
<!DOCTYPE html>
<html lang="zh-Hans">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="google-site-verification" content="9GY-OrjvdT8TkXuLJFSJcJqolHfXKJ5NVYKRUv8mCRM">
  
    <meta name="keywords" content="Redis,">
  

  
    <meta name="description" content="钟宇鹏的博客">
  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" type="image/x-icon" href="/logo.png">
  <title>Redis(转载) [ DO IT ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/simple.css">
    
  
</head>


<body>
  <nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed">
  <ul class="pure-menu-list float-r clearfix">
    
      <!-- <li class="pure-menu-item toc-menu pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main-post" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
      </li> -->
      <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
        <ul class="pure-menu-children">
        
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
          
          
      </ul>
      </li>
    
  </ul>
  <a class="pure-menu-heading" href="/">
      <h1 class="title">DO IT</h1>
      <!-- <span>钟宇鹏的博客</span> -->
  </a>
  <!-- 
  <img class="logo" id="logo" src="/logo.png" alt="logo">
   -->
</nav>


  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <article class="post" id="post">
  <header class="post-header text-center">
    <h1 class="title">
      Redis(转载)
    </h1>
    
    <time class="time" datetime="2017-07-01T16:00:00.000Z">
      2017-07-02
    </time>
     |
    <span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
    <hr>
  </header>
  <div class="post-content">
    <h2 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么"></a>redis是什么</h2><p>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。</p>
<h2 id="学会安装redis"><a href="#学会安装redis" class="headerlink" title="学会安装redis"></a>学会安装redis</h2><p>从redis.io下载最新版redis-X.Y.Z.tar.gz后解压，然后进入redis-X.Y.Z文件夹后直接make即可，安装非常简单。</p>
<p>make成功后会在src文件夹下产生一些二进制可执行文件，包括redis-server、redis-cli等等：<br>代码如下:<br>$ find . -type f -executable<br>./redis-benchmark //用于进行redis性能测试的工具<br>./redis-check-dump //用于修复出问题的dump.rdb文件<br>./redis-cli //redis的客户端<br>./redis-server //redis的服务端<br>./redis-check-aof //用于修复出问题的AOF文件<br>./redis-sentinel //用于集群管理</p>
<h2 id="学会启动redis"><a href="#学会启动redis" class="headerlink" title="学会启动redis"></a>学会启动redis</h2><p>启动redis非常简单，直接./redis-server就可以启动服务端了，还可以用下面的方法指定要加载的配置文件：<br>代码如下:<br>./redis-server ../redis.conf</p>
<p>默认情况下，redis-server会以非daemon的方式来运行，且默认服务端口为6379。</p>
<h2 id="redis数据结构-–-简介"><a href="#redis数据结构-–-简介" class="headerlink" title="redis数据结构 – 简介"></a>redis数据结构 – 简介</h2><p>redis是一种高级的key:value存储系统，其中value支持五种数据类型：</p>
<p>1.字符串（strings）</p>
<p>2.字符串列表（lists）</p>
<p>3.字符串集合（sets）</p>
<p>4.有序字符串集合（sorted sets）</p>
<p>5.哈希（hashes）</p>
<p>而关于key，有几个点要提醒大家：</p>
<p>1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；<br>2.key也不要太短，太短的话，key的可读性会降低；<br>3.在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</p>
<h2 id="redis数据结构-–-strings"><a href="#redis数据结构-–-strings" class="headerlink" title="redis数据结构 – strings"></a>redis数据结构 – strings</h2><p>有人说，如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么，redis就和memcache非常非常的像了。这说明strings类型是一个很基础的数据类型，也是任何存储系统都必备的数据类型。</p>
<p> 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set mystr &quot;hello world!&quot; //设置字符串类型</span><br><span class="line">get mystr //读取字符串类型</span><br></pre></td></tr></table></figure>
<p>字符串类型的用法就是这么简单，因为是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储。</p>
<p>另外，我们还可以通过字符串类型进行数值操作：<br>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set mynum &quot;2&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr mynum</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>
<p>看，在遇到数值操作时，redis会将字符串类型转换成数值。</p>
<p></p><p style="color:red">由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果。</p>假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。不少网站都利用redis的这个特性来实现业务上的统计计数需求。<p></p>
<h2 id="redis数据结构-–-lists"><a href="#redis数据结构-–-lists" class="headerlink" title="redis数据结构 – lists"></a>redis数据结构 – lists</h2><p>redis的另一个重要的数据结构叫做lists，翻译成中文叫做“列表”。</p>
<p>首先要明确一点，redis中的lists在底层实现上并不是数组，而是链表，也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。</p>
<p>虽然lists有这样的优势，但同样有其弊端，那就是，链表型lists的元素定位会比较慢，而数组型lists的元素定位就会快得多。</p>
<p>lists的常用操作包括LPUSH、RPUSH、LRANGE等。我们可以用LPUSH在lists的左侧插入一个新元素，用RPUSH在lists的右侧插入一个新元素，用LRANGE命令从lists中指定一个范围来提取元素。</p>
<p>应用场景：</p>
<p>1.我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序。<br>2.利用LRANGE还可以很方便的实现分页的功能。<br>3.在博客系统中，每片博文的评论也可以存入一个单独的list中。</p>
<h2 id="redis数据结构-–-集合（set）"><a href="#redis数据结构-–-集合（set）" class="headerlink" title="redis数据结构 – 集合（set）"></a>redis数据结构 – 集合（set）</h2><p>redis的集合，是一种无序的集合，集合中的元素没有先后顺序。</p>
<p>集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。</p>
<p>对于集合的使用，也有一些常见的方式，比如，QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。</p>
<h2 id="redis数据结构-–-有序集合-sort-set"><a href="#redis数据结构-–-有序集合-sort-set" class="headerlink" title="redis数据结构 – 有序集合(sort-set)"></a>redis数据结构 – 有序集合(sort-set)</h2><p>redis不但提供了无需集合（sets），还很体贴的提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。</p>
<p>很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等</p>
<h2 id="redis数据结构-–-哈希"><a href="#redis数据结构-–-哈希" class="headerlink" title="redis数据结构 – 哈希"></a>redis数据结构 – 哈希</h2><p>最后要给大家介绍的是hashes，即哈希。哈希是从redis-2.0.0版本之后才有的数据结构。</p>
<p>hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HMSET user:001 username antirez password P1pp0 age 34 </span><br><span class="line">OK</span><br><span class="line">//列出哈希的内容</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:001 </span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;antirez&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;P1pp0&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;34&quot;</span><br><span class="line">//更改哈希中的某一个值</span><br><span class="line">127.0.0.1:6379&gt; HSET user:001 password 12345 </span><br><span class="line">(integer) 0</span><br><span class="line">//再次列出哈希的内容</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:001 </span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;antirez&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;12345&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;34&quot;</span><br></pre></td></tr></table></figure>
<h2 id="聊聊redis持久化-–-两种方式"><a href="#聊聊redis持久化-–-两种方式" class="headerlink" title="聊聊redis持久化 – 两种方式"></a>聊聊redis持久化 – 两种方式</h2><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p>
<p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</p>
<p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p>
<p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p>
<p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p>
<h2 id="聊聊redis持久化-–-RDB"><a href="#聊聊redis持久化-–-RDB" class="headerlink" title="聊聊redis持久化 – RDB"></a>聊聊redis持久化 – RDB</h2><p>RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。</p>
<p>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</p>
<p>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</p>
<p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p>
<p>虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</p>
<h2 id="聊聊redis持久化-–-AOF"><a href="#聊聊redis持久化-–-AOF" class="headerlink" title="聊聊redis持久化 – AOF"></a>聊聊redis持久化 – AOF</h2><p>AOF，英文是Append Only File，即只允许追加不允许改写的文件。</p>
<p>如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。</p>
<p>我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</p>
<p>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</p>
<p>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。</p>
<p>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</p>
<p>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。</p>
<p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p>
<p>虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p>
<p>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</p>
<p>如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</p>
<p>1.备份被写坏的AOF文件<br>2.运行redis-check-aof –fix进行修复<br>3.用diff -u来看下两个文件的差异，确认问题点<br>4.重启redis，加载修复后的AOF文件</p>
<h2 id="聊聊redis持久化-–-AOF重写"><a href="#聊聊redis持久化-–-AOF重写" class="headerlink" title="聊聊redis持久化 – AOF重写"></a>聊聊redis持久化 – AOF重写</h2><p>在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p>
<p>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p>
<p>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p>
<p>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</p>
<h2 id="聊聊redis持久化-–-如何选择RDB和AOF"><a href="#聊聊redis持久化-–-如何选择RDB和AOF" class="headerlink" title="聊聊redis持久化 – 如何选择RDB和AOF"></a>聊聊redis持久化 – 如何选择RDB和AOF</h2><p>对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。</p>
<h2 id="聊聊主从-–-用法"><a href="#聊聊主从-–-用法" class="headerlink" title="聊聊主从 – 用法"></a>聊聊主从 – 用法</h2><p>像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。</p>
<p>主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。</p>
<p>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。</p>
<p>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</p>
<p>在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</p>
<h2 id="聊聊主从-–-同步原理"><a href="#聊聊主从-–-同步原理" class="headerlink" title="聊聊主从 – 同步原理"></a>聊聊主从 – 同步原理</h2><p>从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。</p>
<p>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</p>
<p>另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。</p>
<p>主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把“希望同步的主服务器ID”和“希望请求的数据的偏移位置（replication offset）”发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查“请求的偏移位置”是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。</p>
<p>增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。</p>
<h2 id="聊聊redis的事务处理"><a href="#聊聊redis的事务处理" class="headerlink" title="聊聊redis的事务处理"></a>聊聊redis的事务处理</h2><p>在聊redis事务处理之前，要先和大家介绍四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。</p>
<p>1.MULTI用来组装一个事务；</p>
<p>2.EXEC用来执行一个事务；</p>
<p>3.DISCARD用来取消一个事务；</p>
<p>4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。</p>
<p>我们来看一个MULTI和EXEC的例子：<br>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; MULTI //标记事务开始</span><br><span class="line">OK</span><br><span class="line">redis&gt; INCR user_id //多条命令按顺序入队</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC //执行</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 2</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) PONG</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们看到了QUEUED的字样，这表示我们在用MULTI组装事务时，每一个命令都会进入到内存队列中缓存起来，如果出现QUEUED则表示我们这个命令成功插入了缓存队列，在将来执行EXEC时，这些被QUEUED的命令都会被组装成一个事务来执行。</p>
<p>对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，我们可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。</p>
<p>有关事务，大家经常会遇到的是两类错误：</p>
<p>1.调用EXEC之前的错误<br>2.调用EXEC之后的错误</p>
<p>“调用EXEC之前的错误”，有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，redis会忽略那些入队失败的命令，只执行那些入队成功的命令）。我们来看一个这样的例子：<br>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; haha //一个明显错误的指令</span><br><span class="line">(error) ERR unknown command &apos;haha&apos;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">//redis无情的拒绝了事务的执行，原因是“之前出现了错误”</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>
<p>而对于“调用EXEC之后的错误”，redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。我们也来看一个例子：</p>
<p> 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 23</span><br><span class="line">QUEUED</span><br><span class="line">//age不是集合，所以如下是一条明显错误的指令</span><br><span class="line">127.0.0.1:6379&gt; sadd age 15 </span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set age 29</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec //执行事务时，redis不会理睬第2条指令执行错误</span><br><span class="line">1) OK</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">&quot;29&quot; //可以看出第3条指令被成功执行了</span><br></pre></td></tr></table></figure>
<p>好了，我们来说说最后一个指令“WATCH”，这是一个很好用的指令，它可以帮我们实现类似于“乐观锁”的效果，即CAS（check and set）。</p>
<p>WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。<br>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set age 23</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch age //开始监视age</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 24 //在EXEC之前，age的值被修改了</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 25</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec //触发EXEC</span><br><span class="line">(nil) //事务无法被执行</span><br></pre></td></tr></table></figure>
<h2 id="教你看懂redis配置-–-简介"><a href="#教你看懂redis配置-–-简介" class="headerlink" title="教你看懂redis配置 – 简介"></a>教你看懂redis配置 – 简介</h2><p>我们可以在启动redis-server时指定应该加载的配置文件，方法如下：<br>代码如下:</p>
<p>$ ./redis-server /path/to/redis.conf<br>接下来，我们就来讲解下redis配置文件的各个配置项的含义，注意，本文是基于redis-2.8.4版本进行讲解的。</p>
<p>redis官方提供的redis.conf文件，足有700+行，其中100多行为有效配置行，另外的600多行为注释说明。</p>
<p>在配置文件的开头部分，首先明确了一些度量单位：<br>代码如下:</p>
<h1 id="1k-gt-1000-bytes"><a href="#1k-gt-1000-bytes" class="headerlink" title="1k =&gt; 1000 bytes"></a>1k =&gt; 1000 bytes</h1><h1 id="1kb-gt-1024-bytes"><a href="#1kb-gt-1024-bytes" class="headerlink" title="1kb =&gt; 1024 bytes"></a>1kb =&gt; 1024 bytes</h1><h1 id="1m-gt-1000000-bytes"><a href="#1m-gt-1000000-bytes" class="headerlink" title="1m =&gt; 1000000 bytes"></a>1m =&gt; 1000000 bytes</h1><h1 id="1mb-gt-1024-1024-bytes"><a href="#1mb-gt-1024-1024-bytes" class="headerlink" title="1mb =&gt; 1024*1024 bytes"></a>1mb =&gt; 1024*1024 bytes</h1><h1 id="1g-gt-1000000000-bytes"><a href="#1g-gt-1000000000-bytes" class="headerlink" title="1g =&gt; 1000000000 bytes"></a>1g =&gt; 1000000000 bytes</h1><h1 id="1gb-gt-102410241024-bytes"><a href="#1gb-gt-102410241024-bytes" class="headerlink" title="1gb =&gt; 102410241024 bytes"></a>1gb =&gt; 1024<em>1024</em>1024 bytes</h1><p>可以看出，redis配置中对单位的大小写不敏感，1GB、1Gb和1gB都是相同的。由此也说明，redis只支持bytes，不支持bit单位。</p>
<p>redis支持“主配置文件中引入外部配置文件”，很像C/C++中的include指令，比如：<br> 代码如下:</p>
<p>include /path/to/other.conf<br>如果你看过redis的配置文件，会发现还是很有条理的。redis配置文件被分成了几大块区域，它们分别是：</p>
<p>1.通用（general）<br>2.快照（snapshotting）<br>3.复制（replication）<br>4.安全（security）<br>5.限制（limits)<br>6.追加模式（append only mode)<br>7.LUA脚本（lua scripting)<br>8.慢日志（slow log)<br>9.事件通知（event notification）</p>
<h2 id="教你看懂redis配置-通用"><a href="#教你看懂redis配置-通用" class="headerlink" title="教你看懂redis配置 -通用"></a>教你看懂redis配置 -通用</h2><h2 id="教你看懂redis配置-–-快照"><a href="#教你看懂redis配置-–-快照" class="headerlink" title="教你看懂redis配置 – 快照"></a>教你看懂redis配置 – 快照</h2><h2 id="教你看懂redis配置-–-复制"><a href="#教你看懂redis配置-–-复制" class="headerlink" title="教你看懂redis配置 – 复制"></a>教你看懂redis配置 – 复制</h2><h2 id="教你看懂redis配置-–-安全"><a href="#教你看懂redis配置-–-安全" class="headerlink" title="教你看懂redis配置 – 安全"></a>教你看懂redis配置 – 安全</h2><h2 id="教你看懂redis配置-限制"><a href="#教你看懂redis配置-限制" class="headerlink" title="教你看懂redis配置 -限制"></a>教你看懂redis配置 -限制</h2><h2 id="教你看懂redis配置-–-追加模式"><a href="#教你看懂redis配置-–-追加模式" class="headerlink" title="教你看懂redis配置 – 追加模式"></a>教你看懂redis配置 – 追加模式</h2><h2 id="教你看懂redis配置-–-LUA脚本"><a href="#教你看懂redis配置-–-LUA脚本" class="headerlink" title="教你看懂redis配置 – LUA脚本"></a>教你看懂redis配置 – LUA脚本</h2><h2 id="教你看懂redis配置-–-慢日志"><a href="#教你看懂redis配置-–-慢日志" class="headerlink" title="教你看懂redis配置 – 慢日志"></a>教你看懂redis配置 – 慢日志</h2><h2 id="教你看懂redis配置-–-事件通知"><a href="#教你看懂redis配置-–-事件通知" class="headerlink" title="教你看懂redis配置 – 事件通知"></a>教你看懂redis配置 – 事件通知</h2><h2 id="教你看懂redis配置-–-高级配置"><a href="#教你看懂redis配置-–-高级配置" class="headerlink" title="教你看懂redis配置 – 高级配置"></a>教你看懂redis配置 – 高级配置</h2><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/wyy123/p/6078593.html" target="_blank" rel="noopener">参考博文</a></p>

  </div>
  <div class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>
  </div>
</article>
  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2017/03/08/mysql/2017-03-08-Locking/" rel="next" title="乐观锁，悲观锁">
          乐观锁，悲观锁
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2017/07/05/life/2017-7-5-Journey/" rel="prev" title="旅行">
            旅行
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis是什么"><span class="toc-text">redis是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学会安装redis"><span class="toc-text">学会安装redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学会启动redis"><span class="toc-text">学会启动redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis数据结构-–-简介"><span class="toc-text">redis数据结构 – 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis数据结构-–-strings"><span class="toc-text">redis数据结构 – strings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis数据结构-–-lists"><span class="toc-text">redis数据结构 – lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis数据结构-–-集合（set）"><span class="toc-text">redis数据结构 – 集合（set）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis数据结构-–-有序集合-sort-set"><span class="toc-text">redis数据结构 – 有序集合(sort-set)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis数据结构-–-哈希"><span class="toc-text">redis数据结构 – 哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聊聊redis持久化-–-两种方式"><span class="toc-text">聊聊redis持久化 – 两种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聊聊redis持久化-–-RDB"><span class="toc-text">聊聊redis持久化 – RDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聊聊redis持久化-–-AOF"><span class="toc-text">聊聊redis持久化 – AOF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聊聊redis持久化-–-AOF重写"><span class="toc-text">聊聊redis持久化 – AOF重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聊聊redis持久化-–-如何选择RDB和AOF"><span class="toc-text">聊聊redis持久化 – 如何选择RDB和AOF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聊聊主从-–-用法"><span class="toc-text">聊聊主从 – 用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聊聊主从-–-同步原理"><span class="toc-text">聊聊主从 – 同步原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聊聊redis的事务处理"><span class="toc-text">聊聊redis的事务处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-–-简介"><span class="toc-text">教你看懂redis配置 – 简介</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#1k-gt-1000-bytes"><span class="toc-text">1k =&gt; 1000 bytes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1kb-gt-1024-bytes"><span class="toc-text">1kb =&gt; 1024 bytes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1m-gt-1000000-bytes"><span class="toc-text">1m =&gt; 1000000 bytes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1mb-gt-1024-1024-bytes"><span class="toc-text">1mb =&gt; 1024*1024 bytes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1g-gt-1000000000-bytes"><span class="toc-text">1g =&gt; 1000000000 bytes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1gb-gt-102410241024-bytes"><span class="toc-text">1gb =&gt; 102410241024 bytes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-通用"><span class="toc-text">教你看懂redis配置 -通用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-–-快照"><span class="toc-text">教你看懂redis配置 – 快照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-–-复制"><span class="toc-text">教你看懂redis配置 – 复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-–-安全"><span class="toc-text">教你看懂redis配置 – 安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-限制"><span class="toc-text">教你看懂redis配置 -限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-–-追加模式"><span class="toc-text">教你看懂redis配置 – 追加模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-–-LUA脚本"><span class="toc-text">教你看懂redis配置 – LUA脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-–-慢日志"><span class="toc-text">教你看懂redis配置 – 慢日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-–-事件通知"><span class="toc-text">教你看懂redis配置 – 事件通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#教你看懂redis配置-–-高级配置"><span class="toc-text">教你看懂redis配置 – 高级配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考博文"><span class="toc-text">参考博文</span></a></li></ol>
  </li></div>



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

    </div>

    

  </div>

  <footer class="footer text-center">
    <div id="bottom-inner">

      <a href="http://programer.group" target="_blank">主站</a> |
      <a href="http://zhongyp.me">DO IT</a> |
      <a href="https://github.com/zhongyp" target="_blank">GitHub</a> |
      <a href="http://hexo.io" target="_blank">Hexo</a> |
      <a href="https://github.com/zhongyp/hexo-theme-simple" target="_blank">Theme simple</a> |
      <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank">Base on theme microb</a> |
      <a><span id="busuanzi_container_site_pv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></a> |
      <a><span id="busuanzi_container_site_pv">本站访问量<span id="busuanzi_value_site_pv"></span>次</span></a>
    </div>
  </footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     *
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }

    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      // var menu = document.getElementById('menu-main-post');
      // if (menu) {
      //   var toc = document.getElementById('toc');
      //   if (toc) {
      //     menu.onclick = function() {
      //       if (toc) {
      //         if (toc.style.display == 'block') {
      //           toc.style.display = 'none';
      //         } else {
      //           toc.style.display = 'block';
      //         }
      //       }
      //     };
      //   } else {
      //     menu.style.display = 'none';
      //   }
      // }
    }

  })(window, document);
</script>


  



</body>
</html>
