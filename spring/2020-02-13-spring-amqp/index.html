
<!DOCTYPE html>
<html lang="zh-Hans">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="google-site-verification" content="9GY-OrjvdT8TkXuLJFSJcJqolHfXKJ5NVYKRUv8mCRM">
  
    <meta name="keywords" content="笔记,RabbitMQ,Spring AMQP,Spring AMQP">
  

  
    <meta name="description" content="钟宇鹏的博客,钟宇鹏,个人博客">
  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" type="image/x-icon" href="/logo.png">
  
    <title>Spring AMQP</title>
  
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/pure.min.css">
    
      <link rel="stylesheet" href="/css/simple.css">
    
  
</head>


<body>
  <nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed">
  <ul class="pure-menu-list float-r clearfix">
    
      <!-- <li class="pure-menu-item toc-menu pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main-post" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
      </li> -->
      <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
        <ul class="pure-menu-children">
        
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/photographer" class="pure-menu-link">摄影</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
          
          
      </ul>
      </li>
    
  </ul>
  <a class="pure-menu-heading" href="/">
      <h1 class="title">zhongyp&#39;blog</h1>
      <!-- <span>钟宇鹏的博客</span> -->
  </a>
  <!-- 
  <img class="logo" id="logo" src="/logo.png" alt="logo">
   -->
</nav>


  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <article class="post" id="post">
  <header class="post-header text-center">
    <h1 class="title">
      Spring AMQP
    </h1>
    
    <time class="time" datetime="2020-02-12T16:00:00.000Z">
      2020-02-13
    </time>
     |
    <span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
    <hr>
  </header>
  <div class="post-content">
    <h2 id="1-ConnectionFactory"><a href="#1-ConnectionFactory" class="headerlink" title="1. ConnectionFactory"></a>1. ConnectionFactory</h2><p>工厂类的一些属性：</p>
<p>Connection and Channel Listeners用来监听Connection和Channel相关的事件（创建、关闭、终止)。</p>
<p>Channel关闭事件日志策略。</p>
<p>运行时缓存属性配置。在运行时动态的修改连接属性，比如，channel缓存大小、事务channel缓存大小。</p>
<p>RabbitMQ 自动的连接和拓扑恢复。</p>
<p>添加自定义客户端连接属性。<br><code>connectionFactory.getRabbitConnectionFactory().getClientProperties().put(&quot;thing1&quot;, &quot;thing2&quot;);</code></p>
<h3 id="1-1-CachingConnectionFactory"><a href="#1-1-CachingConnectionFactory" class="headerlink" title="1.1 CachingConnectionFactory"></a>1.1 CachingConnectionFactory</h3><p>CachingConnectionFactory有两种缓存模式：Connection和Channel。</p>
<p>CachingConnectionFactory是一个Connection工厂实现类（当缓存模式是<code>CachingConnectionFactory.CacheMode.CHANNEL</code>（默认）时，返回所有<code>createConnection()</code>调用都返回相同的Connection，忽略对<code>Connection.close()</code>的调用并缓存<code>Channel</code>）。<br>默认情况下，只缓存25个Channel，并根据需要创建和处理其他请求的Channel。在高并发情况下考虑提高<code>channelCacheSize</code>的值。<code>channelCacheSize</code>不限制channel的创建数量，如果需要限制，可以使用<code>channelCheckoutTimeout</code>，当此 <code>channelCheckoutTimeout</code> 大于零时，channelCacheSize将成为可以在连接上创建的 channel 数量的限制。如果达到限制，则调用线程将阻塞，直到 channel 可用或达到此超时，在这种情况下抛出AmqpTimeoutException。</p>
<p>当缓存模式是<code>CachingConnectionFactory.CacheMode.CONNECTION</code>时，每个<code>createConnection()</code>都会使用一个新的（缓存的）Connection；连接将根据<code>connectionCacheSize</code>的值缓存。在这种模式下，Connections和Channels都会被缓存。<code>connectionLimit</code>可以用来限制创建Connection的数量，当数量到达时可以使用<code>channelCheckoutTimeLimit</code>等待缓存中的连接空闲，如果超时，将抛出<code>AmqpTimeoutException</code>。</p>
<p>当使用比较大数量的Connection时，应该考虑在<code>CachingConnectionFactory</code>设置自定义的<code>executor</code>。<code>executor</code>的线程池应不受限制，或应针对预期用途进行适当设置（通常一个线程一个连接）。如果在每个Connection创建多个Channel，线程池的大小影响并发。因此，可变（或简单缓存）线程池执行程序将是最合适的。</p>
<p><code>CachingConnectionFactory.CacheMode.CONNECTION</code>模式和Rabbit Admin自动声明的队列不兼容。</p>
<p>CachingConnectionFactory要求显式关闭从其Connection获得的所有Channel。通常，代码都需要显式的关闭所有的Channel。但是，对于此ConnectionFactory，必须使用显式关闭才能真正使Channel重用。如果有空间（channelCacheSize），Channel.close（）会将通道返回到缓存，否则物理上关闭该通道。</p>
<h3 id="1-2-SimpleRoutingConnectionFactory"><a href="#1-2-SimpleRoutingConnectionFactory" class="headerlink" title="1.2 SimpleRoutingConnectionFactory"></a>1.2 SimpleRoutingConnectionFactory</h3><p>对多个ConnectionFactory进行管理。</p>
<ol>
<li>SimpleResourceHolder绑定lookupKey</li>
<li>RabbitTemplate表达式支持</li>
</ol>
<h2 id="2-AmqpTemplate"><a href="#2-AmqpTemplate" class="headerlink" title="2. AmqpTemplate"></a>2. AmqpTemplate</h2><h3 id="2-1-添加重试机制"><a href="#2-1-添加重试机制" class="headerlink" title="2.1 添加重试机制"></a>2.1 添加重试机制</h3><p>第一种方式是在rabbitTemplate中注入RetryTemplate，这种方式如果使用RecoveryCallback则只能在重试上下文中使用lastThrowable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public AmqpTemplate rabbitTemplate() &#123;</span><br><span class="line">    RabbitTemplate template = new RabbitTemplate(connectionFactory());</span><br><span class="line">    RetryTemplate retryTemplate = new RetryTemplate();</span><br><span class="line">    ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();</span><br><span class="line">    backOffPolicy.setInitialInterval(500);</span><br><span class="line">    backOffPolicy.setMultiplier(10.0);</span><br><span class="line">    backOffPolicy.setMaxInterval(10000);</span><br><span class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</span><br><span class="line">    template.setRetryTemplate(retryTemplate);</span><br><span class="line">    return template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方式是直接使用retryTemplate进行重试，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">retryTemplate.execute(</span><br><span class="line">    new RetryCallback&lt;Object, Exception&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object doWithRetry(RetryContext context) throws Exception &#123;</span><br><span class="line">            context.setAttribute(&quot;message&quot;, message);</span><br><span class="line">            return rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, new RecoveryCallback&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object recover(RetryContext context) throws Exception &#123;</span><br><span class="line">            Object message = context.getAttribute(&quot;message&quot;);</span><br><span class="line">            Throwable t = context.getLastThrowable();</span><br><span class="line">            // Do something with message</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式你可以在上下文中获取属性信息。</p>
<h3 id="2-2-怎样确认异步消息的成功和失败"><a href="#2-2-怎样确认异步消息的成功和失败" class="headerlink" title="2.2 怎样确认异步消息的成功和失败"></a>2.2 怎样确认异步消息的成功和失败</h3><p>默认情况下，rabbitmq将会删除不能被路由的消息，对于成功的消息，会返回一个异步的确认信息。<br>考虑如下两种情况：</p>
<ul>
<li>发送消息没有匹配的队列</li>
<li>发送消息没有匹配exchange</li>
</ul>
<p>第一种情况可以使用消息返回处理；第二种情况消息被删除，不会返回消息，channel关闭并抛出异常。这种情况你可以注册ChannelListener。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">this.connectionFactory.addConnectionListener(new ConnectionListener() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Connection connection) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    // signal中包含reson信息</span><br><span class="line">    public void onShutDown(ShutdownSignalException signal) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-发送消息确认与返回"><a href="#2-3-发送消息确认与返回" class="headerlink" title="2.3 发送消息确认与返回"></a>2.3 发送消息确认与返回</h3><h4 id="2-3-1-消息返回"><a href="#2-3-1-消息返回" class="headerlink" title="2.3.1 消息返回"></a>2.3.1 消息返回</h4><p>消息返回必须设置<code>mandatory</code>属性，或者发送消息时针对特定消息设置<code>mandatory-expression</code>属性。</p>
<p>消息返回可以通过rabbitTemplate设置返回回调。</p>
<p><code>rabbitTemplate.setReturnCallback(ReturnCallback callback)</code></p>
<p><strong><em> 注意：一个rabbitTemplate实例仅支持一个ReturnCallback。</em></strong></p>
<h4 id="2-3-2-消息确认"><a href="#2-3-2-消息确认" class="headerlink" title="2.3.2 消息确认"></a>2.3.2 消息确认</h4><p>消息确认需要设置<code>publisherConfirms</code>属性。</p>
<p>消息确认同样可以设置<code>ConfirmCallback</code>，用来处理消息返回确认。</p>
<p>值得特别注意的是使用消息确认时，需要等到最后一个消息确认完成时再关闭channel。</p>
<p>因为当connectfactory的channelCacheSize满了时，框架会在保持5秒channel后关闭channel，有可能导致没有足够的时间确认和消息返回。<br>当仅使用返回时，channel保持5秒开启。</p>
<p>只要返回回调在60秒或更短时间内执行，就可以保证在确认之前仍接收到返回的消息。确认在返回回调退出后或60秒后（以先到者为准）进行传递。</p>
<p>自从2.1版本开始，开始使用<code>CorrelationData</code>,而不是ConfirmCallback。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData cd1 = new CorrelationData();</span><br><span class="line">this.templateWithConfirmsEnabled.convertAndSend(&quot;exchange&quot;, queue.getName(), &quot;foo&quot;, cd1);</span><br><span class="line">assertTrue(cd1.getFuture().get(10, TimeUnit.SECONDS).isAck());</span><br></pre></td></tr></table></figure>
<p>另外，当同时启用确认和返回，<code>CorrelationData</code>由返回消息组成。它保证在使用将来设置ack之前发生这种情况。</p>
<h3 id="2-4-一种更简单的等待发布者确认的机制"><a href="#2-4-一种更简单的等待发布者确认的机制" class="headerlink" title="2.4 一种更简单的等待发布者确认的机制"></a>2.4 一种更简单的等待发布者确认的机制</h3><p>有时可能希望更好地控制通道的使用，并确保在同一通道上执行全部操作。</p>
<p>从2.0版本，提供了<code>invoke</code>方法，并带有一个<code>OperationCallback</code>。任何操作在callback的范围内及在提供的<code>RabbitOpertions</code>参数中执行都使用相同的<code>Channel</code>，这个channel在结束时关闭（不返回至缓存）。如果<code>Channel</code>是<code>PublisherCallbackChannel</code>，它在所有确认收到后返回至缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface OperationsCallback&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T doInRabbit(RabbitOperations operations);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可能需要这样做的一个示例是，如果您希望在基础Channel上使用waitForConfirms（）方法。如前所述，Spring API以前并未公开此方法，因为通常是对通道进行缓存和共享。<strong><em> RabbitTemplate现在提供了waitForConfirms（long timeout）和waitForConfirmsOrDie（long timeout），它们委托给OperationsCallback范围内使用特定channel。由于明显的原因，不能在该范围之外使用这些方法。</em></strong></p>
<p>如果您只想等待broker确认交付，则可以使用以下示例中显示的技术：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; messages = getMessagesToSend();</span><br><span class="line">Boolean result = this.template.invoke(t -&gt; &#123;</span><br><span class="line">    messages.forEach(m -&gt; t.convertAndSend(ROUTE, m));</span><br><span class="line">    t.waitForConfirmsOrDie(10_000);</span><br><span class="line">    return true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果您希望在OperationsCallback范围内的同一通道上调用RabbitAdmin操作，则必须使用与调用操作相同的RabbitTemplate构造admin。</p>
<p>如果在现有事务的范围内已经执行了template操作，例如，当在事务处理的listener container线程上运行并在事务处理的template上执行操作时，前面的讨论就没有什么意义了。在这种情况下，操作将在该通道上执行，并在线程返回到容器时提交。在这种情况下，不必使用invoke。</p>
<h3 id="2-5-Publisher使用单独的连接"><a href="#2-5-Publisher使用单独的连接" class="headerlink" title="2.5 Publisher使用单独的连接"></a>2.5 Publisher使用单独的连接</h3><p>从2.0.2版本开始，将<code>usePublisherConnection</code>属性设置为true，以便可能的情况下使用与listener容器使用的连接不同的连接。</p>
<p>如果声明的是独占队列，会因为使用不同的连接，导致其中某一个连接获取不到队列<br>通常，不应将RabbitAdmin与具有此设置为 true 的模板一起使用。使用带有连接工厂的RabbitAdmin构造函数;如果使用其他构造函数来获取模板，请确保模板的 property 为 false。这是因为通常使用 admin 来为 listener 容器声明队列;使用 property 设置为 true 的模板意味着将在与 listener 容器使用的连接不同的连接上声明独占队列(例如AnonymousQueue)。在这种情况下，容器不能使用队列。</p>
<h2 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3. 发送消息"></a>3. 发送消息</h2><h3 id="3-1-Message创建API"><a href="#3-1-Message创建API" class="headerlink" title="3.1 Message创建API"></a>3.1 Message创建API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(&quot;123&quot;)</span><br><span class="line">    .setHeader(&quot;bar&quot;, &quot;baz&quot;)</span><br><span class="line">    .build();</span><br><span class="line">Message message = MessageBuilder.withBody(&quot;foo&quot;.getBytes())</span><br><span class="line">    .andProperties(props)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Message message = MessageBuilder.withBody(&quot;foo&quot;.getBytes())</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(&quot;123&quot;)</span><br><span class="line">    .setHeader(&quot;bar&quot;, &quot;baz&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h3 id="3-2-批处理"><a href="#3-2-批处理" class="headerlink" title="3.2 批处理"></a>3.2 批处理</h3><p><code>BatchingRabbitTemplate</code></p>
<p>批量数据保存在 memory 中;未发送的消息可能会在系统故障的 event 中丢失。</p>
<p><code>BatchingRabbitTemplate</code>根据SimpleBatchingStrategy发送消息。它支持将消息发送到单个 exchange/routing key。它有 properties:</p>
<ul>
<li><p>batchSize - 发送前批处理中的消息数</p>
</li>
<li><p>bufferLimit - 批量消息的最大大小;如果超过，将抢占batchSize，并导致发送部分批次</p>
</li>
<li><p>timeout - 一个 time，当没有新的活动向批处理添加消息时，将发送部分批处理</p>
</li>
</ul>
<p>SimpleBatchingStrategy通过在每个嵌入消息之前使用4字节二进制长度来格式化批处理。通过将springBatchFormat message property 设置为lengthHeader4，将其传达给接收系统。</p>
<h2 id="3-3-消费消息"><a href="#3-3-消费消息" class="headerlink" title="3.3 消费消息"></a>3.3 消费消息</h2><h3 id="3-3-1-轮询消费者"><a href="#3-3-1-轮询消费者" class="headerlink" title="3.3.1 轮询消费者"></a>3.3.1 轮询消费者</h3><p>默认情况下，如果没有可用消息，则立即返回null;没有阻挡。从 version 1.5 开始，您现在可以设置receiveTimeout(以毫秒为单位)，接收方法将阻塞，知道最大过期时间。value 小于零意味着无限期地阻塞(或者至少在与 broker 的连接丢失之前)。 Version 1.6 引入了receive方法的变体，允许在每次调用时传递超时时间。</p>
<p>这种轮询操作会为每一个消息创建一个<code>QueueingConsumer</code>。所以不适用于大数据量的环境。</p>
<h3 id="3-3-2-异步消费者"><a href="#3-3-2-异步消费者" class="headerlink" title="3.3.2 异步消费者"></a>3.3.2 异步消费者</h3><h4 id="3-3-2-1-MessageListener"><a href="#3-3-2-1-MessageListener" class="headerlink" title="3.3.2.1 MessageListener"></a>3.3.2.1 MessageListener</h4><p>异步消息接收，涉及专用的回调容器。回调则是我们与消息集成的地方。MessageListener就是这种回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageListener &#123;</span><br><span class="line">    void onMessage(Message message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您的回调逻辑出于任何原因依赖于 AMQP Channel 实例，您可以改为使用ChannelAwareMessageListener。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ChannelAwareMessageListener &#123;</span><br><span class="line">    void onMessage(Message message, Channel channel) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-2-MessageListenerAdapter"><a href="#3-3-2-2-MessageListenerAdapter" class="headerlink" title="3.3.2.2 MessageListenerAdapter"></a>3.3.2.2 MessageListenerAdapter</h4><p>如果您希望在 application 逻辑和消息传递 API 之间保持更严格的分离，则可以依赖 framework 提供的适配器 implementation。这通常被称为“Message-driven POJO”支持。</p>
<p>从 version 2.0 开始，提供了方便的FunctionalInterface：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface ReplyingMessageListener&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">	R handleMessage(T t);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这有助于使用 Java 8 lamdas 方便地配置适配器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new MessageListenerAdapter((ReplyingMessageListener&lt;String, String&gt;) data -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-2-3-消费者优先权"><a href="#3-3-2-3-消费者优先权" class="headerlink" title="3.3.2.3 消费者优先权"></a>3.3.2.3 消费者优先权</h4><p>从RabbitMQ Version 3.2开始，broker 现在支持 consumer 优先级(参见在 RabbitMQ 中使用 Consumer 优先级)。通过在 consumer 上设置x-priority参数来启用此功能。 SimpleMessageListenerContainer现在支持设置 consumer arguments：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">container.setConsumerArguments(Collections.</span><br><span class="line">&lt;String, Object&gt; singletonMap(&quot;x-priority&quot;, Integer.valueOf(10)));</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-2-4-容器监听自动删除队列"><a href="#3-3-2-4-容器监听自动删除队列" class="headerlink" title="3.3.2.4 容器监听自动删除队列"></a>3.3.2.4 容器监听自动删除队列</h4><p>当容器配置为侦听auto-delete queue(s)，或者队列具有x-expires选项或 Broker 上配置了Time-To-Live policy 时，broker 在容器停止时删除队列(最后 consumer 被取消)。在 version 1.3 之前，由于队列丢失，无法重新启动容器;当连接是 closed/opens 时，RabbitAdmin仅自动重新声明队列等，当容器为 stopped/started 时不会发生。</p>
<p>从 version 1.3 开始，容器现在将使用RabbitAdmin在启动期间重新声明任何丢失的队列。</p>
<p>您还可以使用条件声明和auto-startup=”false”一起来管理延迟声明队列，直到容器启动。</p>
<p>在这种情况下，队列和交换由containerAdmin声明，它具有auto-startup=”false”，因此在 context 初始化期间不会声明元素。此外，出于同样的原因，容器未启动。稍后启动容器时，它会使用 reference containerAdmin来声明元素。</p>
<h4 id="3-3-2-5-批处理消息"><a href="#3-3-2-5-批处理消息" class="headerlink" title="3.3.2.5 批处理消息"></a>3.3.2.5 批处理消息</h4><p>批处理的消息（由生产者创建）由侦听器容器自动分批处理（使用springBatchFormat消息头）。拒绝批次中的任何消息都会导致整个批次被拒绝。有关批处理的更多信息，请参见批处理。</p>
<p>设置容器属性ConsumerBatchEnabled以启用此功能。 deBatchingEnabled也必须为true，以便容器负责处理这两种类型的批次。当ConsumerBatchEnabled为true时，实现BatchMessageListener或ChannelAwareBatchMessageListener。有关将此功能与@RabbitListener一起使用的信息，请参阅带有批处理的@RabbitListener。</p>
<h4 id="3-3-2-6-消费者事件"><a href="#3-3-2-6-消费者事件" class="headerlink" title="3.3.2.6 消费者事件"></a>3.3.2.6 消费者事件</h4><p>每当侦听器（消费者）遇到某种类型的故障时，容器就会发布应用程序事件。事件ListenerContainerConsumerFailedEvent具有以下属性：</p>
<ul>
<li>container: 消费者遇到问题的侦听器容器。</li>
<li>reason: 失败的文字原因。</li>
<li>fatal: 指示失败是否致命的布尔值。对于非致命异常，容器将根据recoveryInterval或recoveryBackoff（对于SimpleMessageListenerContainer）或monitorInterval（对于DirectMessageListenerContainer）尝试重新启动消费者。</li>
<li>throwable: 被捕获的Throwable。</li>
</ul>
<p>如果消费者由于默认情况下不专门使用其队列以及发布事件而失败，那么将发出WARN日志。要更改此日志记录行为，请在SimpleMessageListenerContainer实例的ExclusiveConsumerExceptionLogger属性中提供自定义的ConditionalExceptionLogger。另请参阅记录通道关闭事件。</p>
<p>致命错误始终记录在ERROR级别。这是不可修改的。</p>
<p>在容器生命周期的各个阶段还发布了其他一些事件：</p>
<ul>
<li><p>AsyncConsumerStartedEvent：启动消费者时。</p>
</li>
<li><p>AsyncConsumerRestartedEvent：消费者在发生故障后重新启动时-仅SimpleMessageListenerContainer。</p>
</li>
<li><p>AsyncConsumerTerminatedEvent：消费者正常停止时。</p>
</li>
<li><p>AsyncConsumerStoppedEvent：消费者停止时-仅SimpleMessageListenerContainer。</p>
</li>
<li><p>ConsumeOkEvent：当从Broker接收到一个consumerOk时，包含队列名称和consumerTag</p>
</li>
<li><p>ListenerContainerIdleEvent：请参阅检测空闲的异步消费者。</p>
</li>
</ul>
<h4 id="3-3-2-7-消费者标签"><a href="#3-3-2-7-消费者标签" class="headerlink" title="3.3.2.7 消费者标签"></a>3.3.2.7 消费者标签</h4><p>默认情况下，消费者标签由broker提供。你可以使用ConsumerTagStrategy实现自己的命名策略。</p>
<h4 id="3-3-2-8-注解驱动的侦听器端点"><a href="#3-3-2-8-注解驱动的侦听器端点" class="headerlink" title="3.3.2.8 注解驱动的侦听器端点"></a>3.3.2.8 注解驱动的侦听器端点</h4><p>异步接收消息的最简单方法是使用带注释的侦听器端点基础结构。简而言之，它使您可以将托管bean的方法公开为Rabbit侦听器端点。以下示例显示了如何使用@RabbitListener批注：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">    public void processOrder(String data) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种方式，绑定了已经存在的队列。除了上述的方式，你还可以使用自动声明队列的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">  @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue(value = &quot;myQueue&quot;, durable = &quot;true&quot;),</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.exch&quot;, ignoreDeclarationExceptions = &quot;true&quot;),</span><br><span class="line">        key = &quot;orderRoutingKey&quot;)</span><br><span class="line">  )</span><br><span class="line">  public void processOrder(Order order) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue,</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.exch&quot;),</span><br><span class="line">        key = &quot;invoiceRoutingKey&quot;)</span><br><span class="line">  )</span><br><span class="line">  public void processInvoice(Invoice invoice) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @RabbitListener(queuesToDeclare = @Queue(name = &quot;$&#123;my.queue&#125;&quot;, durable = &quot;true&quot;))</span><br><span class="line">  public String handleWithSimpleDeclare(String data) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个示例中，队列myQueue与交换（如果需要）一起自动（持久）声明，并与路由键绑定到交换。在第二个示例中，声明并绑定了一个匿名（专有的，自动删除）队列。可以提供多个QueueBinding条目，让侦听器侦听多个队列。在第三个示例中，如有必要，将声明一个具有从属性my.queue检索到的名称的队列，并使用该队列名称作为路由键将其默认绑定到默认交换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue(value = &quot;auto.headers&quot;, autoDelete = &quot;true&quot;,</span><br><span class="line">                        arguments = @Argument(name = &quot;x-message-ttl&quot;, value = &quot;10000&quot;,</span><br><span class="line">                                                type = &quot;java.lang.Integer&quot;)),</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.headers&quot;, type = ExchangeTypes.HEADERS, autoDelete = &quot;true&quot;),</span><br><span class="line">        arguments = &#123;</span><br><span class="line">                @Argument(name = &quot;x-match&quot;, value = &quot;all&quot;),</span><br><span class="line">                @Argument(name = &quot;thing1&quot;, value = &quot;somevalue&quot;),</span><br><span class="line">                @Argument(name = &quot;thing2&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">)</span><br><span class="line">public String handleWithHeadersExchange(String foo) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@RabbitListener属性参数：</p>
<ul>
<li>String id</li>
<li>String containerFactory</li>
<li>String[] queues</li>
<li>Queue[] queuesToDeclare</li>
<li>boolean exclusive</li>
<li>String priority</li>
<li>String admin</li>
<li>QueueBinding[] bindings<ul>
<li>Queue value</li>
<li>Exchange exchange</li>
<li>String[] key // routingKey</li>
<li>String ignoreDeclarationExceptions</li>
<li>Argument[] arguments</li>
<li>String declare // 如果admin存在，需要声明此属性</li>
<li>String[] admins</li>
</ul>
</li>
<li>String group // 如果存在Listener容器，则可以将容器的beanName赋予此属性</li>
<li>String returnExceptions // 设置为true时，设置为true会导致Listener抛出的异常使用正常的<code>replyto/SendTo</code>语义发送给发送者，设置false时，将异常抛出到Listener容器并执行正常的重试/死信处理。</li>
<li>String errorHandler //如果Listener容器出现异常，则处理异常</li>
<li>String concurrency</li>
<li>String autoStartup // 延迟创建队列，交换器</li>
</ul>
<h4 id="3-3-2-9-创建自己的监听注解-元注解"><a href="#3-3-2-9-创建自己的监听注解-元注解" class="headerlink" title="3.3.2.9 创建自己的监听注解(元注解)"></a>3.3.2.9 创建自己的监听注解(元注解)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue,</span><br><span class="line">        exchange = @Exchange(value = &quot;metaFanout&quot;, type = ExchangeTypes.FANOUT)))</span><br><span class="line">public @interface MyAnonFanoutListener &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MetaListener &#123;</span><br><span class="line"></span><br><span class="line">    @MyAnonFanoutListener</span><br><span class="line">    public void handle1(String foo) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @MyAnonFanoutListener</span><br><span class="line">    public void handle2(String foo) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.2.3 版本开始，支持@AliasFor以允许在元注释的注释上覆盖属性。而且，用户注释现在可以是@Repeatable的，从而允许为一个方法创建多个容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">static class MetaAnnotationTestBean &#123;</span><br><span class="line"></span><br><span class="line">    @MyListener(&quot;queue1&quot;)</span><br><span class="line">    @MyListener(&quot;queue2&quot;)</span><br><span class="line">    public void handleIt(String body) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Repeatable(MyListeners.class)</span><br><span class="line">static @interface MyListener &#123;</span><br><span class="line"></span><br><span class="line">    @AliasFor(annotation = RabbitListener.class, attribute = &quot;queues&quot;)</span><br><span class="line">    String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">static @interface MyListeners &#123;</span><br><span class="line"></span><br><span class="line">    MyListener[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-10-启用侦听器端点注释"><a href="#3-3-2-10-启用侦听器端点注释" class="headerlink" title="3.3.2.10 启用侦听器端点注释"></a>3.3.2.10 启用侦听器端点注释</h4><p>要启用对@RabbitListener批注的支持，可以将@EnableRabbit添加到您的@Configuration类之一。以下示例显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        factory.setConcurrentConsumers(3);</span><br><span class="line">        factory.setMaxConcurrentConsumers(10);</span><br><span class="line">        factory.setContainerCustomizer(container -&gt; /* customize the container */);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从2.0版开始，DirectMessageListenerContainerFactory也可用。它创建DirectMessageListenerContainer实例。</p>
<p>从2.2.2版开始，您可以提供ContainerCustomizer实现（如上所示）。创建和配置容器后，可以使用该方法进一步配置容器。例如，您可以使用它来设置容器工厂未公开的属性。</p>
<p>默认情况下，底层将查找名为RabbitListenerContainerFactory的bean作为工厂的源，以用于创建消息侦听器容器。在这种情况下，忽略了RabbitMQ底层设置，可以使用三个线程的核心池大小和十个线程的最大池大小来调用processOrder方法。</p>
<p>您可以定制用于每个注释的侦听器容器工厂，也可以通过实现RabbitListenerConfigurer接口来配置显式默认值。仅当至少一个端点在没有特定容器工厂的情况下注册时，才需要使用默认值。有关完整的详细信息和示例，请参见Javadoc。</p>
<p>容器工厂提供了添加MessagePostProcessor实例的方法，这些实例在接收消息之后（调用侦听器之前）和发送回复之前应用。</p>
<p>从版本2.0.6开始，可以将RetryTemplate和RecoveryCallback添加到侦听器容器工厂。发送回复时使用。重试用尽时将调用RecoveryCallback。您可以使用SendRetryContextAccessor从上下文中获取信息。以下示例显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">factory.setRetryTemplate(retryTemplate);</span><br><span class="line">factory.setReplyRecoveryCallback(ctx -&gt; &#123;</span><br><span class="line">    Message failed = SendRetryContextAccessor.getMessage(ctx);</span><br><span class="line">    Address replyTo = SendRetryContextAccessor.getAddress(ctx);</span><br><span class="line">    Throwable t = ctx.getLastThrowable();</span><br><span class="line">    ...</span><br><span class="line">    return null;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从2.0版开始，@RabbitListener批注具有并发属性。它支持SpEL表达式（＃{…}）和属性占位符（$ {…}）。其含义和允许的值取决于容器类型，如下所示：</p>
<ul>
<li><p>对于DirectMessageListenerContainer，该值必须是单个整数值，该值设置容器上的consumersPerQueue属性。</p>
</li>
<li><p>对于SimpleRabbitListenerContainer，该值可以是一个单个整数值，该值在容器上设置了concurrentConsumers属性，也可以具有m-n的形式，其中m是parallelConsumers属性，n是maxConcurrentConsumers属性。</p>
</li>
</ul>
<p>无论哪种情况，此设置都将覆盖出厂设置。以前，如果您有需要不同并发性的侦听器，则必须定义不同的容器工厂。</p>
<p>该注释还允许通过autoStartup和executor（自2.2起）注释属性覆盖工厂的autoStartup和taskExecutor属性。为每个执行程序使用不同的执行程序可能有助于在日志和线程转储中标识与每个侦听器关联的线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(id = &quot;manual.acks.1&quot;, queues = &quot;manual.acks.1&quot;, ackMode = &quot;MANUAL&quot;)</span><br><span class="line">public void manual1(String in, Channel channel,</span><br><span class="line">    @Header(AmqpHeaders.DELIVERY_TAG) long tag) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    channel.basicAck(tag, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-2-11-带注释方法的消息转换"><a href="#3-3-2-11-带注释方法的消息转换" class="headerlink" title="3.3.2.11 带注释方法的消息转换"></a>3.3.2.11 带注释方法的消息转换</h4><p>调用侦听器之前，管道中有两个转换步骤。第一步使用MessageConverter将传入的Spring AMQP消息转换为Spring消息。调用目标方法时，如有必要，消息将转换为方法参数类型。</p>
<p>第一步的默认MessageConverter是Spring AMQP SimpleMessageConverter，它处理到String和java.io.Serializable对象的转换。所有其他的都保留为byte []。在下面的讨论中，我们称其为“消息转换器”。</p>
<p>第二步的默认转换器是GenericMessageConverter，它委派给转换服务（DefaultFormattingConversionService的实例）。在下面的讨论中，我们将其称为“方法参数转换器”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    ...</span><br><span class="line">    factory.setMessageConverter(new Jackson2JsonMessageConverter());</span><br><span class="line">    ...</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在1.6之前的版本中，必须在消息头中提供用于转换JSON的类型信息，或者需要自定义ClassMapper。从版本1.6开始，如果没有类型信息标头，则可以从目标方法参数中推断类型。</p>
<p>自定义消息转换器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() &#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();</span><br><span class="line">        factory.setMessageConverter(new GenericMessageConverter(myConversionService()));</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConversionService myConversionService() &#123;</span><br><span class="line">        DefaultConversionService conv = new DefaultConversionService();</span><br><span class="line">        conv.addConverter(mySpecialConverter());</span><br><span class="line">        return conv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-2-12-程序化端点注册"><a href="#3-3-2-12-程序化端点注册" class="headerlink" title="3.3.2.12 程序化端点注册"></a>3.3.2.12 程序化端点注册</h4><p>RabbitListenerEndpoint提供了Rabbit端点的模型，并负责为该模型配置容器。除了RabbitListener批注检测到的端点之外，基础结构还允许您以编程方式配置端点。以下示例显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();</span><br><span class="line">        endpoint.setQueueNames(&quot;anotherQueue&quot;);</span><br><span class="line">        endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">            // processing</span><br><span class="line">        &#125;);</span><br><span class="line">        registrar.registerEndpoint(endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，我们使用了SimpleRabbitListenerEndpoint，它提供了实际的MessageListener来调用，但是您也可以构建自己的端点变体来描述自定义调用机制。</p>
<p>应该注意的是，您也可以完全跳过@RabbitListener的使用，并通过RabbitListenerConfigurer以编程方式注册端点。</p>
<h4 id="3-3-2-13-带注释的端点方法签名"><a href="#3-3-2-13-带注释的端点方法签名" class="headerlink" title="3.3.2.13 带注释的端点方法签名"></a>3.3.2.13 带注释的端点方法签名</h4><p>到目前为止，我们已经在端点中注入了一个简单的String，但实际上它可以具有非常灵活的方法签名。以下示例将其重写为使用自定义标头注入Order：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">    public void processOrder(Order order, @Header(&quot;order_type&quot;) String orderType) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下列表显示了可以在侦听器端点中注入的主要元素：</p>
<ul>
<li><p>原始的org.springframework.amqp.core.Message。</p>
</li>
<li><p>接收消息的com.rabbitmq.client.Channel。</p>
</li>
<li><p>代表传入的AMQP消息的org.springframework.messaging.Message。请注意，此消息同时包含自定义标头和标准标头（由AmqpHeaders定义）。</p>
</li>
</ul>
<p>例如，如果我们想在处理订单之前确保其有效，则可以使用@Valid注释有效负载并配置必要的验证器，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() &#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();</span><br><span class="line">        factory.setValidator(myValidator());</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-2-14-监听多个队列"><a href="#3-3-2-14-监听多个队列" class="headerlink" title="3.3.2.14 监听多个队列"></a>3.3.2.14 监听多个队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &#123; &quot;queue1&quot;, &quot;queue2&quot; &#125; )</span><br><span class="line">    public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;#&#123;&apos;$&#123;property.with.comma.delimited.queue.names&#125;&apos;.split(&apos;,&apos;)&#125;&quot; )</span><br><span class="line">    public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-15-回复管理"><a href="#3-3-2-15-回复管理" class="headerlink" title="3.3.2.15 回复管理"></a>3.3.2.15 回复管理</h4><p>MessageListenerAdapter中的现有支持已经使您的方法具有非空返回类型。在这种情况下，调用的结果将封装在一条消息中，该消息发送到原始消息的ReplyToAddress标头中指定的地址或侦听器上配置的默认地址。您可以使用消息传递抽象的@SendTo批注设置该默认地址。</p>
<p>假设我们的processOrder方法现在应该返回一个OrderStatus，我们可以如下编写它以自动发送回复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(destination = &quot;myQueue&quot;)</span><br><span class="line">@SendTo(&quot;status&quot;)</span><br><span class="line">public OrderStatus processOrder(Order order) &#123;</span><br><span class="line">    // order processing</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要以与传输无关的方式设置其他标头，则可以返回一条Message，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RabbitListener(destination = &quot;myQueue&quot;)</span><br><span class="line">@SendTo(&quot;status&quot;)</span><br><span class="line">public Message&lt;OrderStatus&gt; processOrder(Order order) &#123;</span><br><span class="line">    // order processing</span><br><span class="line">    return MessageBuilder</span><br><span class="line">        .withPayload(status)</span><br><span class="line">        .setHeader(&quot;code&quot;, 1234)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者，可以在beforeSendReplyMessagePostProcessors容器工厂属性中使用MessagePostProcessor添加更多标头。从版本2.2.3开始，在答复消息中可以使用被调用的bean/方法，可以在消息后处理器中使用它来将信息传达回调用方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">factory.setBeforeSendReplyPostProcessors(msg -&gt; &#123;</span><br><span class="line">    msg.getMessageProperties().setHeader(&quot;calledBean&quot;,</span><br><span class="line">            msg.getMessageProperties().getTargetBean().getClass().getSimpleName());</span><br><span class="line">    msg.getMessageProperties().setHeader(&quot;calledMethod&quot;,</span><br><span class="line">            msg.getMessageProperties().getTargetMethod().getName());</span><br><span class="line">    return m;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从版本2.2.5开始，您可以配置ReplyPostProcessor在发送回复消息之前对其进行修改；在为相关请求设置了relatedId标头之后，将调用此方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;test.header&quot;, group = &quot;testGroup&quot;, replyPostProcessor = &quot;echoCustomHeader&quot;)</span><br><span class="line">public String capitalizeWithHeader(String in) &#123;</span><br><span class="line">    return in.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public ReplyPostProcessor echoCustomHeader() &#123;</span><br><span class="line">    return (req, resp) -&gt; &#123;</span><br><span class="line">        resp.getMessageProperties().setHeader(&quot;myHeader&quot;, req.getMessageProperties().getHeader(&quot;myHeader&quot;));</span><br><span class="line">        return resp;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@SendTo值被假定为跟随exchange / routingKey模式的回复交换和routingKey对，其中这些部分之一可以省略。有效值如下：</p>
<p>something1 / thing2：replyTo交换和routingKey。 something1 /：replyTo交换和默认（空）routingKey。 something2或/ thing2：replyTo routingKey和默认（空）交换。 /或为空：replyTo默认交换和默认routingKey。</p>
<p>此外，您可以使用不带值属性的@SendTo。这种情况下等于一个空的sendTo模式。仅当入站邮件没有ReplyToAddress属性时才使用@SendTo。</p>
<p>从版本1.5开始，@SendTo值可以是bean初始化SpEL表达式，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;test.sendTo.spel&quot;)</span><br><span class="line">@SendTo(&quot;#&#123;spelReplyTo&#125;&quot;)</span><br><span class="line">public String capitalizeWithSendToSpel(String foo) &#123;</span><br><span class="line">    return foo.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@Bean</span><br><span class="line">public String spelReplyTo() &#123;</span><br><span class="line">    return &quot;test.sendTo.reply.spel&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于动态回复路由，消息发送者应包括reply_to消息属性或使用备用运行时SpEL表达式（在下一个示例之后进行描述）。</p>
<p>从版本1.6开始，@SendTo可以是SpEL表达式，在运行时将根据请求和答复对它进行评估，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;test.sendTo.spel&quot;)</span><br><span class="line">@SendTo(&quot;!&#123;&apos;some.reply.queue.with.&apos; + result.queueName&#125;&quot;)</span><br><span class="line">public Bar capitalizeWithSendToSpel(Foo foo) &#123;</span><br><span class="line">    return processTheFooAndReturnABar(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpEL表达式的运行时性质由！{…}分隔符指示。表达式的评估上下文#root对象具有三个属性：</p>
<ul>
<li><p>request：o.s.amqp.core.Message请求对象。</p>
</li>
<li><p>来源：转换后的o.s.messaging.Message &lt;？&gt;。</p>
</li>
<li><p>结果：方法结果。</p>
</li>
</ul>
<p>上下文具有一个map属性访问器，一个标准类型转换器和一个bean解析器，该解析器允许引用上下文中的其他bean（例如@ someBeanName.determineReplyQ（request，result））。</p>
<p>总而言之，＃{…}在初始化期间被初始化一次，其中#root对象是应用程序上下文。 Bean由其名称引用。在运行时为每条消息评估！{…}，根对象具有前面列出的属性。 Bean的名称以@开头。</p>
<p>从2.1版开始，还支持简单的属性占位符（例如$ {some.reply.to}）。对于早期版本，可以将以下内容用作替代方法，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;foo&quot;)</span><br><span class="line">@SendTo(&quot;#&#123;environment[&apos;my.send.to&apos;]&#125;&quot;)</span><br><span class="line">public String listen(Message in) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-16-多方法侦听器"><a href="#3-3-2-16-多方法侦听器" class="headerlink" title="3.3.2.16 多方法侦听器"></a>3.3.2.16 多方法侦听器</h4><p>从1.5.0版开始，您可以在类级别指定@RabbitListener注释。与新的@RabbitHandler批注一起，这使单个侦听器可以根据传入消息的有效负载类型调用不同的方法。最好用一个例子来描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(id=&quot;multi&quot;, queues = &quot;someQueue&quot;)</span><br><span class="line">@SendTo(&quot;my.reply.queue&quot;)</span><br><span class="line">public class MultiListenerBean &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public String thing2(Thing2 thing2) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public String cat(Cat cat) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public String hat(@Header(&quot;amqp_receivedRoutingKey&quot;) String rk, @Payload Hat hat) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler(isDefault = true)</span><br><span class="line">    public String defaultMethod(Object object) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Repeatable @RabbitListener<br>从版本1.6开始，@RabbitListener批注标记为@Repeatable。这意味着注释可以多次出现在相同的注释元素（方法或类）上。在这种情况下，将为每个注释创建一个单独的侦听器容器，每个注释容器都调用相同的侦听器@Bean。可重复的注释可以与Java 8或更高版本一起使用。使用Java 7或更早版本时，可以通过使用@RabbitListeners“容器”注释和@RabbitListener注释数组来达到相同的效果。</p>
<h4 id="3-3-2-17-代理-RabbitListener和泛型"><a href="#3-3-2-17-代理-RabbitListener和泛型" class="headerlink" title="3.3.2.17 代理@RabbitListener和泛型"></a>3.3.2.17 代理@RabbitListener和泛型</h4><p>如果要代理您的服务（例如，对于@Transactional），则在接口具有通用参数时，应牢记一些注意事项。考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface TxService&lt;P&gt; &#123;</span><br><span class="line"></span><br><span class="line">   String handle(P payload, String header);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class TxServiceImpl implements TxService&lt;Foo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @RabbitListener(...)</span><br><span class="line">    public String handle(Foo foo, String rk) &#123;</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用通用接口和特定实现，您将不得不切换到CGLIB目标类代理，因为接口句柄方法的实际实现是桥接方法。在事务管理的情况下，通过使用注释选项来配置CGLIB的使用：@EnableTransactionManagement（proxyTargetClass = true）。在这种情况下，必须在实现中的目标方法上声明所有注释，如以下示例所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static class TxServiceImpl implements TxService&lt;Foo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Transactional</span><br><span class="line">    @RabbitListener(...)</span><br><span class="line">    public String handle(@Payload Foo foo, @Header(&quot;amqp_receivedRoutingKey&quot;) String rk) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-2-18-处理异常"><a href="#3-3-2-18-处理异常" class="headerlink" title="3.3.2.18 处理异常"></a>3.3.2.18 处理异常</h4><p>默认情况下，如果带注释的侦听器方法引发异常，则将其引发到容器中，并根据容器和代理的配置，将消息重新排队并重新传递，丢弃或路由到死信交换。什么也没有退还给发送者。</p>
<p>从2.0版开始，@RabbitListener批注具有两个新属性：errorHandler和returnExceptions。</p>
<p>这些默认情况下未配置。</p>
<p>您可以使用errorHandler来提供RabbitListenerErrorHandler实现的bean名称。此功能接口有一种方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface RabbitListenerErrorHandler &#123;</span><br><span class="line"></span><br><span class="line">    Object handleError(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt; message,</span><br><span class="line">              ListenerExecutionFailedException exception) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，您可以访问从容器接收的原始消息，由消息转换器生成的spring-messaging Message &lt;？&gt;对象以及由侦听器引发的异常（包装在ListenerExecutionFailedException中）。错误处理程序可以返回某些结果（作为答复发送），也可以引发原始异常或新异常（根据returnExceptions设置，将其抛出到容器中或返回给发送者）。</p>
<p>returnExceptions属性为true时，会将异常返回给发送方。异常包装在RemoteInvocationResult对象中。在发送方，有一个可用的RemoteInvocationAwareMessageConverterAdapter，如果将其配置到RabbitTemplate中，则会重新引发服务器端异常，并包装在AmqpRemoteException中。服务器异常的堆栈跟踪是通过合并服务器和客户端堆栈跟踪来综合的。</p>
<p>该机制通常仅适用于使用Java序列化的默认SimpleMessageConverter。异常通常不是“杰克逊友好的”，并且不能序列化为JSON。如果使用JSON，请考虑在引发异常时使用errorHandler返回其他一些Jackson友好的Error对象。</p>
<p>在版本2.1中，此接口从软件包o.s.amqp.rabbit.listener移至o.s.amqp.rabbit.listener.api。</p>
<p>从版本2.1.7开始，通道在消息头中可用。使用AcknowledgeMode.MANUAL时，这允许您确认或拒绝失败的消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object handleError(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt; message,</span><br><span class="line">          ListenerExecutionFailedException exception) &#123;</span><br><span class="line">              ...</span><br><span class="line">              message.getHeaders().get(AmqpHeaders.CHANNEL, Channel.class)</span><br><span class="line">                  .basicReject(message.getHeaders().get(AmqpHeaders.DELIVERY_TAG, Long.class),</span><br><span class="line">                               true);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-2-19-容器管理"><a href="#3-3-2-19-容器管理" class="headerlink" title="3.3.2.19 容器管理"></a>3.3.2.19 容器管理</h4><p>为注释创建的容器未在应用程序上下文中注册。您可以通过调用RabbitListenerEndpointRegistry bean上的getListenerContainers（）获得所有容器的集合。然后，您可以遍历此集合，例如，停止或启动所有容器，或在注册表本身上调用Lifecycle方法，这将在每个容器上调用操作。</p>
<p>您还可以通过使用单个容器的ID来获取对单个容器的引用，例如，使用上面的代码段创建的容器，使用getListenerContainer（String id）-例如，registry.getListenerContainer（“ multi”）。</p>
<p>从1.5.2版开始，您可以使用getListenerContainerIds（）获得已注册容器的ID值。</p>
<p>从1.5版开始，您现在可以将组分配给RabbitListener端点上的容器。这提供了一种获取对容器子集的引用的机制。添加组属性会导致将Collection 类型的Bean注册到具有组名的上下文中。</p>
<h4 id="3-3-2-20-批量接收消息-RabbitmqListener"><a href="#3-3-2-20-批量接收消息-RabbitmqListener" class="headerlink" title="3.3.2.20 批量接收消息 @RabbitmqListener"></a>3.3.2.20 批量接收消息 @RabbitmqListener</h4><p>当接收到一批消息时，通常由容器执行分批处理，并且一次仅用一条消息来调用侦听器。从2.2版开始，您可以将侦听器容器工厂和侦听器配置为在一个调用中接收整个批次，只需设置工厂的batchListener属性，并将方法有效负载参数设为List：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory());</span><br><span class="line">    factory.setBatchListener(true);</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.1&quot;)</span><br><span class="line">public void listen1(List&lt;Thing&gt; in) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.2&quot;)</span><br><span class="line">public void listen2(List&lt;Message&lt;Thing&gt;&gt; in) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将batchListener属性设置为true会自动关闭工厂创建的容器中的deBatchingEnabled容器属性（除非ConsumerBatchEnabled为true，请参见下文）。实际上，分批处理已从容器移动到侦听器适配器，并且适配器创建了传递到侦听器的列表。</p>
<p>启用批处理的工厂不能与多方法侦听器一起使用。</p>
<p>同样从2.2版开始。一次接收批处理的消息时，最后一条消息包含设置为true的布尔标头。可以通过将@Header（AmqpHeaders.LAST_IN_BATCH）布尔值last`参数添加到您的侦听器方法中来获取此标头。头是从MessageProperties.isLastInBatch（）映射的。此外，AmqpHeaders.BATCH_SIZE填充有每个消息片段中的批处理大小。</p>
<p>此外，新属性consumerBatchEnabled已添加到SimpleMessageListenerContainer。如果为真，则容器将创建一批消息，最大为batchSize；如果receiveTimeout过去了，但没有新消息到达，则将分批交付。如果收到生产者创建的批次，则将其分批并添加到消费者方批次；因此，实际传递的消息数可能超过batchSize，该大小代表从代理接收到的消息数。当ConsumerBatchEnabled为true时，deBatchingEnabled必须为true；否则为false。集装箱工厂将执行此要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory consumerBatchContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">    factory.setConsumerTagStrategy(consumerTagStrategy());</span><br><span class="line">    factory.setBatchListener(true); // configures a BatchMessageListenerAdapter</span><br><span class="line">    factory.setBatchSize(2);</span><br><span class="line">    factory.setConsumerBatchEnabled(true);</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当将consumerBatchEnabled与@RabbitListener一起使用时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;batch.1&quot;, containerFactory = &quot;consumerBatchContainerFactory&quot;)</span><br><span class="line">public void consumerBatch1(List&lt;Message&gt; amqpMessages) &#123;</span><br><span class="line">    this.amqpMessagesReceived = amqpMessages;</span><br><span class="line">    this.batch1Latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.2&quot;, containerFactory = &quot;consumerBatchContainerFactory&quot;)</span><br><span class="line">public void consumerBatch2(List&lt;org.springframework.messaging.Message&lt;Invoice&gt;&gt; messages) &#123;</span><br><span class="line">    this.messagingMessagesReceived = messages;</span><br><span class="line">    this.batch2Latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.3&quot;, containerFactory = &quot;consumerBatchContainerFactory&quot;)</span><br><span class="line">public void consumerBatch3(List&lt;Invoice&gt; strings) &#123;</span><br><span class="line">    this.batch3Strings = strings;</span><br><span class="line">    this.batch3Latch.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>第一个是使用未转换的原始org.springframework.amqp.core.Message调用的。</p>
</li>
<li><p>第二个是通过org.springframework.messaging.Message &lt;？&gt;调用的，其中包含转换后的有效负载和映射的标头/属性。</p>
</li>
<li><p>第三个调用是使用转换后的有效负载进行的，而无法访问标头/属性。</p>
</li>
</ul>
<p>您还可以添加一个通道参数，该参数通常在使用手动确认模式时使用。这对于第三个示例不是很有用，因为您无权访问delivery_tag属性。</p>
<h4 id="3-3-2-21-使用容器工厂"><a href="#3-3-2-21-使用容器工厂" class="headerlink" title="3.3.2.21 使用容器工厂"></a>3.3.2.21 使用容器工厂</h4><p>引入了侦听器容器工厂以支持@RabbitListener并向RabbitListenerEndpointRegistry注册容器，如“编程端点注册”中所述。</p>
<p>从2.1版开始，它们可用于创建任何侦听器容器-甚至是没有侦听器的容器（例如在Spring Integration中使用的容器）。当然，必须在启动容器之前添加侦听器。</p>
<p>有两种创建此类容器的方法：</p>
<ul>
<li><p>使用SimpleRabbitListenerEndpoint</p>
</li>
<li><p>创建后添加侦听器</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer factoryCreatedContainerSimpleListener(</span><br><span class="line">        SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) &#123;</span><br><span class="line">    SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();</span><br><span class="line">    endpoint.setQueueNames(&quot;queue.1&quot;);</span><br><span class="line">    endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    return rabbitListenerContainerFactory.createListenerContainer(endpoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer factoryCreatedContainerNoListener(</span><br><span class="line">        SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = rabbitListenerContainerFactory.createListenerContainer();</span><br><span class="line">    container.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    container.setQueueNames(&quot;test.no.listener.yet&quot;);</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论哪种情况，侦听器也可以是ChannelAwareMessageListener，因为它现在是MessageListener的子接口。</p>
<p>如果您希望创建多个具有相似属性的容器或使用预先配置的容器工厂（例如，Spring Boot自动配置提供的容器或同时使用两者），则这些技术很有用。</p>
<p>用这种方法创建的容器是普通的@Bean实例，并且未在RabbitListenerEndpointRegistry中注册。</p>
<h4 id="3-3-2-22-异步-RabbitListener返回类型"><a href="#3-3-2-22-异步-RabbitListener返回类型" class="headerlink" title="3.3.2.22 异步@RabbitListener返回类型"></a>3.3.2.22 异步@RabbitListener返回类型</h4><p>从2.1版开始，可以使用异步返回类型ListenableFuture &lt;？&gt;和Mono &lt;？&gt;指定@RabbitListener（和@RabbitHandler）方法，从而使答复以异步方式发送。</p>
<p>必须使用AcknowledgeMode.MANUAL配置侦听器容器工厂，以便消费者线程不会确认该消息。相反，异步完成将在异步操作完成时确认或拒绝消息。当异步结果有错误完成时，是否重新排队消息取决于抛出的异常类型，容器配置和容器错误处理程序。默认情况下，除非容器的defaultRequeueRejected属性设置为false（默认情况下为true），否则将重新排队该消息。如果异步结果是通过AmqpRejectAndDontRequeueException完成的，则不会重新排队该消息。如果容器的defaultRequeueRejected属性为false，则可以通过将Future的异常设置为InstantRequeueException来覆盖该值，然后将消息重新排队。如果在侦听器方法中发生了一些阻止创建异步结果对象的异常，则您必须捕获该异常并返回适当的返回对象，该对象将导致消息被确认或重新排队。</p>
<h4 id="3-3-2-23-线程和异步消费者"><a href="#3-3-2-23-线程和异步消费者" class="headerlink" title="3.3.2.23 线程和异步消费者"></a>3.3.2.23 线程和异步消费者</h4><p>当RabbitMQ Client传递新消息时，使用SimpleMessageListenerContainer中配置的TaskExecutor的线程来调用MessageListener。如果未配置，则使用SimpleAsyncTaskExecutor。如果使用池执行器，则需要确保池大小足以处理配置的并发。使用DirectMessageListenerContainer，可以直接在RabbitMQ客户端线程上调用MessageListener。在这种情况下，taskExecutor用于监视消费者的任务。</p>
<p>使用默认的SimpleAsyncTaskExecutor时，对于在其上调用侦听器的线程，在threadNamePrefix中使用侦听器容器beanName。这对于日志分析很有用。我们通常建议始终在日志记录附加程序配置中包括线程名称。通过容器上的taskExecutor属性专门提供TaskExecutor时，将按原样使用它，而无需进行修改。建议您使用类似的技术来命名由自定义TaskExecutor bean定义创建的线程，以帮助在日志消息中标识线程。</p>
<p>创建连接时，在CachingConnectionFactory中配置的Executor将传递到RabbitMQ Client中，并且其线程用于将新消息传递到侦听器容器。如果未配置，则客户端使用内部线程池执行程序，该执行程序的池大小为5。</p>
<p>使用DirectMessageListenerContainer，您需要确保连接工厂配置有任务执行程序，该任务执行程序具有足够的线程来支持使用该工厂的所有侦听器容器之间的所需并发。默认池大小只有五个。<br>RabbitMQ客户端使用ThreadFactory创建用于低级I / O（套接字）操作的线程。要修改此工厂，您需要配置基础RabbitMQ ConnectionFactory，如配置基础客户端连接工厂中所述。</p>
<h4 id="3-3-2-24-选择一个容器"><a href="#3-3-2-24-选择一个容器" class="headerlink" title="3.3.2.24 选择一个容器"></a>3.3.2.24 选择一个容器</h4><p>2.0版引入了DirectMessageListenerContainer（DMLC）。以前，只有SimpleMessageListenerContainer（SMLC）可用。 SMLC为每个消费者使用内部队列和专用线程。如果将一个容器配置为侦听多个队列，则使用相同的消费者线程来处理所有队列。并发是由并发消费和其他属性控制的。当消息从RabbitMQ客户端到达时，客户端线程将它们通过队列传递给使用方线程。之所以需要这种架构，是因为在RabbitMQ客户端的早期版本中，无法同时进行多个交付。较新版本的客户端具有修订的线程模型，现在可以支持并发。这允许引入DMLC，现在可以在RabbitMQ客户端线程上直接调用侦听器。因此，它的体系结构实际上比SMLC“简单”。但是，这种方法存在一些局限性，并且DMLC无法使用SMLC的某些功能。另外，并发由consumersPerQueue（和客户端库的线程池）控制。 parallelConsumers和关联的属性不适用于此容器。</p>
<p>以下功能可用于SMLC，但不可用于DMLC：</p>
<ul>
<li><p>batchSize：使用SMLC，您可以将其设置为控制在一个事务中传递多少消息或减少确认的数量，但是在失败后可能导致重复传递的数量增加。 （DMLC确实具有messagesPerAck，可用于减少确认，与batchSize和SMLC相同，但不能与事务一起使用-—每条消息都在单独的事务中传递和确认）。</p>
</li>
<li><p>ConsumerBatchEnabled：在消费者中批量处理离散消息；有关更多信息，请参见消息侦听器容器配置。</p>
</li>
<li><p>maxConcurrentConsumers和消费者缩放间隔或触发器-DMLC中没有自动缩放。但是，它确实允许您以编程方式更改consumersPerQueue属性，并相应地调整消费者。</p>
</li>
</ul>
<p>但是，DMLC比SMLC具有以下优点：</p>
<ul>
<li><p>在运行时添加和删除队列更加有效。使用SMLC，将重新启动整个消费者线程（取消并重新创建所有消费者）。使用DMLC，不会取消未受影响的消费者。</p>
</li>
<li><p>避免在RabbitMQ客户端线程和消费者线程之间进行上下文切换。</p>
</li>
<li><p>线程在消费者之间共享，而不是在SMLC中为每个消费者使用专用线程。但是，请参阅“线程和异步消费者”中有关连接工厂配置的重要说明。</p>
</li>
</ul>
<p>有关哪些配置属性适用于每个容器的信息，请参见消息侦听器容器配置。</p>
<h4 id="3-3-2-25-检测空闲的异步消费者"><a href="#3-3-2-25-检测空闲的异步消费者" class="headerlink" title="3.3.2.25 检测空闲的异步消费者"></a>3.3.2.25 检测空闲的异步消费者</h4><p>尽管效率很高，但异步消费者的一个问题是检测它们何时处于空闲状态—如果一段时间内没有消息到达，用户可能希望采取某些措施。</p>
<p>从1.6版开始，现在可以将侦听器容器配置为在一段时间没有消息传递的情况下发布ListenerContainerIdleEvent。当容器处于空闲状态时，每隔idleEventInterval毫秒发布一次事件。</p>
<p>要配置此功能，请在容器上设置idleEventInterval。以下示例显示了如何使用XML和Java（对于SimpleMessageListenerContainer和SimpleRabbitListenerContainerFactory）执行此操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">    ...</span><br><span class="line">    container.setIdleEventInterval(60000L);</span><br><span class="line">    ...</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">    factory.setIdleEventInterval(60000L);</span><br><span class="line">    ...</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-2-26-消费事件"><a href="#3-3-2-26-消费事件" class="headerlink" title="3.3.2.26 消费事件"></a>3.3.2.26 消费事件</h4><p>您可以通过实现ApplicationListener来捕获空闲事件-可以是常规侦听器，也可以是仅侦听仅接收此特定事件的侦听器。您还可以使用Spring Framework 4.2中引入的@EventListener。</p>
<p>以下示例将@RabbitListener和@EventListener组合到一个类中。您需要了解应用程序侦听器会获取所有容器的事件，因此，如果您要基于哪个容器处于空闲状态采取特定的操作，则可能需要检查侦听器ID。您也可以为此使用@EventListener条件。</p>
<p>事件具有四个属性：</p>
<ul>
<li><p>来源：侦听器容器实例</p>
</li>
<li><p>id：侦听器ID（或容器bean名称）</p>
</li>
<li><p>idleTime：事件发布时容器空闲的时间</p>
</li>
<li><p>queueNames：容器侦听的队列的名称</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Listener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(id=&quot;someId&quot;, queues=&quot;#&#123;queue.name&#125;&quot;)</span><br><span class="line">    public String listen(String foo) &#123;</span><br><span class="line">        return foo.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @EventListener(condition = &quot;event.listenerId == &apos;someId&apos;&quot;)</span><br><span class="line">    public void onApplicationEvent(ListenerContainerIdleEvent event) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件侦听器查看所有容器的事件。因此，在前面的示例中，我们根据侦听器ID缩小了接收到的事件的范围。</p>
<p>如果希望使用idle事件停止列表器容器，则不应在调用侦听器的线程上调用container.stop（）。这样做总是会导致延迟和不必要的日志消息。相反，您应该将事件移交给另一个线程，然后该线程可以停止容器。</p>
<h4 id="3-3-2-27-监视侦听器性能"><a href="#3-3-2-27-监视侦听器性能" class="headerlink" title="3.3.2.27 监视侦听器性能"></a>3.3.2.27 监视侦听器性能</h4><p>从2.2版开始，如果在类路径上检测到Micrometer且应用程序上下文中存在MeterRegistry，则侦听器容器将自动为侦听器创建和更新Micrometer Timer。可以通过将容器属性micrometerEnabled设置为false来禁用计时器。</p>
<p>维护两个计时器-一个用于成功调用侦听器，另一个用于失败。使用简单的MessageListener，每个配置的队列都有一对计时器。</p>
<p>这些计时器名为spring.rabbitmq.listener，具有以下标记：</p>
<ul>
<li><p>listenerId ：（侦听器ID或容器Bean名称）</p>
</li>
<li><p>queue ：（当consumerBatchEnabled为true时，一个简单侦听器的队列名称或已配置队列名称的列表-因为批处理可能包含来自多个队列的消息）</p>
</li>
<li><p>结果：成功或失败</p>
</li>
<li><p>异常：无或ListenerExecutionFailedException</p>
</li>
</ul>
<p>您可以使用micrometerTags容器属性添加其他标签。</p>
<h3 id="3-3-3-容器和broker命名的队列"><a href="#3-3-3-容器和broker命名的队列" class="headerlink" title="3.3.3 容器和broker命名的队列"></a>3.3.3 容器和broker命名的队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    return new Queue(&quot;&quot;, false, true, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer container() &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(cf());</span><br><span class="line">    container.setQueues(queue());</span><br><span class="line">    container.setMessageListener(m -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    container.setMissingQueuesFatal(false);</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重置连接并建立新连接后，新队列将获得新名称。由于在容器重启和重新声明队列之间存在竞争状态，因此将容器的missingQueuesFatal属性设置为false很重要，因为容器可能最初会尝试重新连接到旧队列。</p>
<h3 id="3-3-4-消息转换器"><a href="#3-3-4-消息转换器" class="headerlink" title="3.3.4 消息转换器"></a>3.3.4 消息转换器</h3><p>通常不建议依赖Java序列化。 JSON（JavaScript对象表示法）是一种更通用，更灵活且可跨不同语言和平台移植的替代方法。可以在任何RabbitTemplate实例上配置该转换器，以覆盖其对SimpleMessageConverter默认值的用法。 Jackson2JsonMessageConverter使用com.fasterxml.jackson 2.x库。以下示例配置了Jackson2JsonMessageConverter：</p>
<p>Jackson2JsonMessageConverter默认情况下使用DefaultClassMapper。类型信息将添加到MessageProperties（并从中检索）。如果入站邮件在MessageProperties中不包含类型信息，但是您知道期望的类型，则可以使用defaultType属性配置静态类型，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Jackson2JsonMessageConverter jsonMessageConverter() &#123;</span><br><span class="line">    Jackson2JsonMessageConverter jsonConverter = new Jackson2JsonMessageConverter();</span><br><span class="line">    jsonConverter.setClassMapper(classMapper());</span><br><span class="line">    return jsonConverter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public DefaultClassMapper classMapper() &#123;</span><br><span class="line">    DefaultClassMapper classMapper = new DefaultClassMapper();</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = new HashMap&lt;&gt;();</span><br><span class="line">    idClassMapping.put(&quot;thing1&quot;, Thing1.class);</span><br><span class="line">    idClassMapping.put(&quot;thing2&quot;, Thing2.class);</span><br><span class="line">    classMapper.setIdClassMapping(idClassMapping);</span><br><span class="line">    return classMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据发送系统添加到标头的类型信息，将入站消息转换为对象。</p>
<p>在1.6之前的版本中，如果不存在类型信息，则转换将失败。从版本1.6开始，如果缺少类型信息，则转换器将使用Jackson的默认值（通常是地图）来转换JSON。</p>
<p>同样，从版本1.6开始，当您使用@RabbitListener批注（在方法上）时，推断的类型信息将添加到MessageProperties。这使转换器可以转换为目标方法的参数类型。仅当存在一个没有注释的参数或带有@Payload注释的单个参数时，这才适用。在分析期间，将忽略Message类型的参数。</p>
<p>默认情况下，推断的类型信息将覆盖发送系统创建的入站TypeId和相关标头。这使接收系统可以自动转换为其他域对象。仅当参数类型是具体的（不是抽象或接口）或来自java.util包时才适用。在所有其他情况下，将使用TypeId和相关标头。在某些情况下，您可能希望覆盖默认行为并始终使用TypeId信息。例如，假设您有一个@RabbitListener，它带有Thing1参数，但消息中包含Thing2，它是Thing1的子类（具体）。推断的类型将不正确。要处理这种情况，请将Jackson2JsonMessageConverter的TypePrecedence属性设置为TYPE_ID，而不是默认的INFERRED。 （该属性实际上位于转换器的DefaultJackson2JavaTypeMapper上，但为方便起见，在转换器上提供了一个setter。）如果注入自定义类型映射器，则应改为在映射器上设置该属性。</p>
<p>从Message转换时，传入的MessageProperties.getContentType（）必须与JSON兼容（使用contentType.contains（“ json”）进行检查）。从2.2版开始，如果没有contentType属性，或者它具有默认值application / octet-stream，则假定为application / json。要恢复到以前的行为（返回未转换的字节[]），请将转换器的假定的SupportedContentType属性设置为false。如果不支持内容类型，则发出WARN日志消息“无法转换内容类型为[…]的传入消息”，并且按原样以字节[]形式返回message.getBody（）。因此，为了满足消费者方面的Jackson2JsonMessageConverter要求，生产者必须添加contentType消息属性，例如，作为application / json或text / x-json或通过使用Jackson2JsonMessageConverter自动设置标头。下面的清单显示了许多转换器调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(@Payload Thing1 thing1, @Header(&quot;amqp_consumerQueue&quot;) String queue) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, o.s.amqp.core.Message message) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, o.s.messaging.Message&lt;Foo&gt; message) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, String bar) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, o.s.messaging.Message&lt;?&gt; message) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>在上述清单的前四种情况下，转换器尝试转换为Thing1类型。第五个示例无效，因为我们无法确定哪个参数应接收消息有效负载。在第六个示例中，由于通用类型为通配符类型，因此应用了Jackson的默认值。</p>
<p>但是，您可以创建一个自定义转换器，并使用targetMethod消息属性来确定将JSON转换为哪种类型。</p>
<p>仅当在方法级别声明@RabbitListener批注时，才能实现此类型推断。对于类级别的@RabbitListener，转换后的类型用于选择要调用的@RabbitHandler方法。因此，基础结构提供了targetObject消息属性，您可以在自定义转换器中使用该属性来确定类型。</p>
<p>从1.6.11版本开始，Jackson2JsonMessageConverter以及DefaultJackson2JavaTypeMapper（DefaultClassMapper）提供了TrustedPackages选项来克服序列化小工具漏洞。默认情况下，为了实现向后兼容，Jackson2JsonMessageConverter信任所有软件包，即使用*作为选项。</p>
<h4 id="3-3-5-1-使用Spring-Data-映射接口"><a href="#3-3-5-1-使用Spring-Data-映射接口" class="headerlink" title="3.3.5.1 使用Spring Data 映射接口"></a>3.3.5.1 使用Spring Data 映射接口</h4><p>从2.2版开始，您可以将JSON转换为Spring Data Projection接口，而不是具体类型。这允许非常选择性和低耦合的数据绑定，包括从JSON文档中的多个位置查找值。例如，可以将以下接口定义为消息有效负载类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface SomeSample &#123;</span><br><span class="line"></span><br><span class="line">  @JsonPath(&#123; &quot;$.username&quot;, &quot;$.user.name&quot; &#125;)</span><br><span class="line">  String getUsername();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;projection&quot;)</span><br><span class="line">public void projection(SomeSample in) &#123;</span><br><span class="line">    String username = in.getUsername();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，访问器方法将用于在接收到的JSON文档中查找属性名称作为字段。 @JsonPath表达式允许自定义值查找，甚至定义多个JSON路径表达式，以便从多个位置查找值，直到表达式返回实际值为止。</p>
<p>要启用此功能，请在消息转换器上将useProjectionForInterfaces设置为true。您还必须将spring-data：spring-data-commons和com.jayway.jsonpath：json-path添加到类路径。</p>
<p>当用作@RabbitListener方法的参数时，接口类型将像往常一样自动传递给转换器。</p>
<h4 id="3-3-5-2-使用RabbitTemplate从消息转换"><a href="#3-3-5-2-使用RabbitTemplate从消息转换" class="headerlink" title="3.3.5.2 使用RabbitTemplate从消息转换"></a>3.3.5.2 使用RabbitTemplate从消息转换</h4><p>如前所述，类型信息在消息头中传送，以帮助从消息转换时的转换器。在大多数情况下，这可以正常工作。但是，使用泛型类型时，它只能转换简单对象和已知的“容器”对象（列表，数组和映射）。从2.0版开始，Jackson2JsonMessageConverter实现了SmartMessageConverter，它可以与带有ParameterizedTypeReference参数的新RabbitTemplate方法一起使用。这允许转换复杂的泛型类型，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thing1&lt;Thing2&lt;Cat, Hat&gt;&gt; thing1 =</span><br><span class="line">    rabbitTemplate.receiveAndConvert(new ParameterizedTypeReference&lt;Thing1&lt;Thing2&lt;Cat, Hat&gt;&gt;&gt;() &#123; &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-3-MarshallingMessageConverter"><a href="#3-3-5-3-MarshallingMessageConverter" class="headerlink" title="3.3.5.3 MarshallingMessageConverter"></a>3.3.5.3 MarshallingMessageConverter</h4><p>另一个选项是MarshallingMessageConverter。它委托Spring OXM库实现Marshaller和Unmarshaller策略接口的实现。您可以在此处阅读有关该库的更多信息。就配置而言，最常见的是仅提供构造函数参数，因为Marshaller的大多数实现也实现了Unmarshaller。以下示例显示如何配置MarshallingMessageConverter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.amqp.rabbit.core.RabbitTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;rabbitConnectionFactory&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;messageConverter&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.springframework.amqp.support.converter.MarshallingMessageConverter&quot;&gt;</span><br><span class="line">            &lt;constructor-arg ref=&quot;someImplemenationOfMarshallerAndUnmarshaller&quot;/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-4-Jackson2XmlMessageConverter"><a href="#3-3-5-4-Jackson2XmlMessageConverter" class="headerlink" title="3.3.5.4 Jackson2XmlMessageConverter"></a>3.3.5.4 Jackson2XmlMessageConverter</h4><p>此类在版本2.1中引入，可用于在XML之间来回转换消息。</p>
<p>Jackson2XmlMessageConverter和Jackson2JsonMessageConverter具有相同的基类：AbstractJackson2MessageConverter。</p>
<p>引入AbstractJackson2MessageConverter类以替换已删除的类：AbstractJsonMessageConverter。</p>
<p>Jackson2XmlMessageConverter使用com.fasterxml.jackson 2.x库。</p>
<p>您可以使用它与Jackson2JsonMessageConverter相同的方式使用它，但是它支持XML而不是JSON。以下示例配置了Jackson2JsonMessageConverter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;xmlConverterWithDefaultType&quot;</span><br><span class="line">        class=&quot;org.springframework.amqp.support.converter.Jackson2XmlMessageConverter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;classMapper&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.springframework.amqp.support.converter.DefaultClassMapper&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;defaultType&quot; value=&quot;foo.PurchaseOrder&quot;/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-5-ContentTypeDelegatingMessageConverter"><a href="#3-3-5-5-ContentTypeDelegatingMessageConverter" class="headerlink" title="3.3.5.5 ContentTypeDelegatingMessageConverter"></a>3.3.5.5 ContentTypeDelegatingMessageConverter</h4><p>此类在版本1.4.2中引入，并允许基于MessageProperties中的内容类型属性委派到特定的MessageConverter。默认情况下，如果没有contentType属性或没有与配置的转换器匹配的值，它将委派给SimpleMessageConverter。以下示例配置ContentTypeDelegatingMessageConverter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;contentTypeConverter&quot; class=&quot;ContentTypeDelegatingMessageConverter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;delegates&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;application/json&quot; value-ref=&quot;jsonMessageConverter&quot; /&gt;</span><br><span class="line">            &lt;entry key=&quot;application/xml&quot; value-ref=&quot;xmlMessageConverter&quot; /&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-6-Java-反序列化"><a href="#3-3-5-6-Java-反序列化" class="headerlink" title="3.3.5.6 Java 反序列化"></a>3.3.5.6 Java 反序列化</h4><p>从不受信任的来源反序列化Java对象时，可能存在一个漏洞。</p>
<p>如果您接受内容类型为application / x-java-serialized-object的不受信任来源的消息，则应考虑配置允许反序列化哪些包和类。当它配置为隐式或通过配置使用DefaultDeserializer时，这对SimpleMessageConverter和SerializerMessageConverter均适用。</p>
<p>默认情况下，白名单为空，这意味着所有类都将反序列化。</p>
<p>您可以设置模式列表，例如thing1。，thing1.thing2.Cat或.MySafeClass。</p>
<p>顺序检查模式，直到找到匹配项。如果不匹配，则抛出SecurityException。</p>
<p>您可以使用这些转换器上的whiteListPatterns属性设置模式。</p>
<h4 id="3-3-5-7-消息属性转换"><a href="#3-3-5-7-消息属性转换" class="headerlink" title="3.3.5.7 消息属性转换"></a>3.3.5.7 消息属性转换</h4><p>MessagePropertiesConverter策略接口用于在Rabbit Client BasicProperties和Spring AMQP MessageProperties之间进行转换。默认实现（DefaultMessagePropertiesConverter）通常可以满足大多数目的，但是您可以根据需要实现自己的实现。当大小不大于1024字节时，默认属性转换器将LongString类型的BasicProperties元素转换为String实例。较大的LongString实例不会转换（请参阅下一段）。可以使用构造函数参数来覆盖此限制。</p>
<p>从1.6版开始，长于长字符串限制（默认值：1024）的标头现在默认情况下由DefaultMessagePropertiesConverter保留为LongString实例。您可以通过getBytes []，toString（）或getStream（）方法访问内容。</p>
<p>以前，DefaultMessagePropertiesConverter将此类标头“转换”为DataInputStream（实际上它只是引用了LongString实例的DataInputStream）。在输出时，未转换此标头（通过在流上调用toString（）转换为String除外，例如java.io.DataInputStream@1d057a39）。</p>
<p>现在，大型输入LongString标头现在也可以在输出中正确“转换”（默认情况下）。</p>
<p>提供了一个新的构造函数，使您可以配置转换器以像以前一样工作。以下清单显示了Javadoc注释和方法声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Construct an instance where LongStrings will be returned</span><br><span class="line"> * unconverted or as a java.io.DataInputStream when longer than this limit.</span><br><span class="line"> * Use this constructor with &apos;true&apos; to restore pre-1.6 behavior.</span><br><span class="line"> * @param longStringLimit the limit.</span><br><span class="line"> * @param convertLongLongStrings LongString when false,</span><br><span class="line"> * DataInputStream when true.</span><br><span class="line"> * @since 1.6</span><br><span class="line"> */</span><br><span class="line">public DefaultMessagePropertiesConverter(int longStringLimit, boolean convertLongLongStrings) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>同样从1.6版开始，已将一个名为correlationIdString的新属性添加到MessageProperties。以前，在RabbitMQ客户端使用的BasicProperties之间来回转换时，执行了不必要的byte [] &lt;→String转换，因为MessageProperties.correlationId是byte []，但是BasicProperties使用String。 （最终，RabbitMQ客户端使用UTF-8将String转换为字节以放入协议消息中）。</p>
<p>为了提供最大的向后兼容性，已将一个名为correlationIdPolicy的新属性添加到DefaultMessagePropertiesConverter。这需要一个DefaultMessagePropertiesConverter.CorrelationIdPolicy枚举参数。默认情况下，它设置为BYTES，它复制了以前的行为。</p>
<p>对于入站消息：</p>
<ul>
<li><p>STRING：仅映射relatedIdString属性</p>
</li>
<li><p>BYTES：仅关联ID属性被映射</p>
</li>
<li><p>BOTH：映射两个属性</p>
</li>
</ul>
<p>对于出站消息：</p>
<ul>
<li><p>STRING：仅映射relatedIdString属性</p>
</li>
<li><p>BYTES：仅关联ID属性被映射</p>
</li>
<li><p>BOTH：都考虑了这两个属性，其中String属性优先</p>
</li>
</ul>
<p>同样从1.6版开始，入站deliveryMode属性不再映射到MessageProperties.deliveryMode。而是将其映射到MessageProperties.receivedDeliveryMode。此外，入站userId属性不再映射到MessageProperties.userId。而是将其映射到MessageProperties.receivedUserId。如果将同一MessageProperties对象用于出站消息，则这些更改是为了避免这些属性的意外传播。</p>
<p>从2.2版开始，DefaultMessagePropertiesConverter使用getName（）而不是toString（）转换类型为Class &lt;？&gt;类型的任何自定义headers。这避免了使用应用程序必须从toString（）表示形式中解析类名称的麻烦。对于滚动升级，您可能需要更改消费者以了解两种格式，直到所有生产者都升级为止。</p>
<h3 id="3-3-6-修改消息-压缩等"><a href="#3-3-6-修改消息-压缩等" class="headerlink" title="3.3.6 修改消息-压缩等"></a>3.3.6 修改消息-压缩等</h3><p>存在许多扩展点。它们使您可以在将消息发送到RabbitMQ之前或在收到消息之后立即对其进行一些处理。</p>
<p>在消息转换器中可以看到，这样的扩展点之一是在AmqpTemplate convertAndReceive操作中，您可以在其中提供MessagePostProcessor。例如，在转换POJO之后，MessagePostProcessor允许您在Message上设置自定义标头或属性。</p>
<p>从版本1.4.2开始，已将其他扩展点添加到RabbitTemplate中-setBeforePublishPostPostors（）和setAfterReceivePostProcessors（）。第一个使后处理器能够在发送到RabbitMQ之前立即运行。使用批处理（请参阅批处理）时，将在组装批处理之后以及发送批处理之前调用此方法。收到消息后立即调用第二个。</p>
<p>这些扩展点用于压缩等功能，并为此提供了多个MessagePostProcessor实现。 GZipPostProcessor，ZipPostProcessor和DeflaterPostProcessor在发送前先压缩消息，而GUnzipPostProcessor，UnzipPostProcessor和InflaterPostProcessor则对收到的消息进行解压缩。</p>
<p>从版本2.1.5开始，可以使用copyProperties = true选项配置GZipPostProcessor，以复制原始消息属性。默认情况下，出于性能原因，将重用这些属性，并使用压缩内容编码和可选的MessageProperties.SPRING_AUTO_DECOMPRESS header对其进行修改。如果您保留对原始出站消息的引用，则其属性也会更改。因此，如果您的应用程序使用这些消息后处理器保留了出站消息的副本，请考虑打开copyProperties选项。<br>类似地，SimpleMessageListenerContainer也具有setAfterReceivePostProcessors（）方法，该方法允许在容器接收到消息之后执行解压缩。</p>
<p>从版本2.1.4开始，将addBeforePublishPostPostors（）和addAfterReceivePostProcessors（）添加到RabbitTemplate中，以允许将新的后处理器分别追加到发布前和接收后处理器的列表中。还提供了删除后处理器的方法。同样，AbstractMessageListenerContainer还添加了addAfterReceivePostProcessors（）和removeAfterReceivePostProcessor（）方法。有关更多详细信息，请参见RabbitTemplate和AbstractMessageListenerContainer的Javadoc。</p>
<h3 id="3-3-7-请求和回复消息"><a href="#3-3-7-请求和回复消息" class="headerlink" title="3.3.7 请求和回复消息"></a>3.3.7 请求和回复消息</h3><p>AmqpTemplate还提供了各种sendAndReceive方法，它们接受与前面针对单向发送操作（交换，routingKey和Message）所述的相同参数选项。这些方法对于请求-答复方案非常有用，因为它们在发送之前处理必需的答复属性的配置，并且可以在为此目的内部创建的排他队列上侦听答复消息。</p>
<p>将MessageConverter应用于请求和答复时，也可以使用类似的请求-答复方法。这些方法被称为convertSendAndReceive。有关更多详细信息，请参见AmqpTemplate的Javadoc。</p>
<p>从1.5.0版开始，每个sendAndReceive方法变体都有一个采用CorrelationData的重载版本。与正确配置的连接工厂一起，这可以使发布者收到操作的发送方确认。有关更多信息，请参见发布者确认和退货以及RabbitOperations的Javadoc。</p>
<p>从2.0版开始，这些方法有一些变体（convertSendAndReceiveAsType），它们带有一个附加的ParameterizedTypeReference参数来转换复杂的返回类型。模板必须配置有SmartMessageConverter。有关更多信息，请参见使用RabbitTemplate从消息转换。</p>
<p>从2.1版开始，您可以使用noLocalReplyConsumer选项配置RabbitTemplate来控制用于回复消费者的noLocal标志。默认情况下为false。</p>
<h4 id="3-3-7-1-回复超时"><a href="#3-3-7-1-回复超时" class="headerlink" title="3.3.7.1 回复超时"></a>3.3.7.1 回复超时</h4><p>默认情况下，发送和接收方法在五秒钟后超时并返回null。您可以通过设置replyTimeout属性来修改此行为。从版本1.5开始，如果将强制属性设置为true（或对于特定消息，则强制表达式的计算结果为true），如果无法将消息传递到队列，则会引发AmqpMessageReturnedException。此异常具有returnMessage，replyCode和replyText属性，以及用于发送的exchange和routingKey。</p>
<p>此功能使用发布者的退货。您可以通过在CachingConnectionFactory上将PublisherReturns设置为true来启用它（请参阅发布者确认和返回）。另外，您一定不能在RabbitTemplate中注册自己的ReturnCallback。<br>从版本2.1.2开始，添加了replyTimedOut方法，使超时可以通知子类，以便它们可以清除任何保留的状态。</p>
<p>从2.0.11和2.1.3版本开始，使用默认的DirectReplyToMessageListenerContainer时，可以通过设置模板的replyErrorHandler属性来添加错误处理程序。对于任何失败的传递，都会调用此错误处理程序，例如延迟答复和收到的没有相关标头的消息。传入的异常是ListenerExecutionFailedException，它具有failMessage属性。</p>
<h4 id="3-3-7-2-RabbitMQ直接回复"><a href="#3-3-7-2-RabbitMQ直接回复" class="headerlink" title="3.3.7.2 RabbitMQ直接回复"></a>3.3.7.2 RabbitMQ直接回复</h4><p>从3.4.0版本开始，RabbitMQ服务器支持直接回复。这消除了固定答复队列的主要原因（以避免为每个请求创建临时队列）。从Spring AMQP版本1.4.1开始，默认情况下使用直接回复（如果服务器支持），而不是创建临时回复队列。如果没有提供replyQueue（或者设置了名为amq.rabbitmq.reply-to的名称），RabbitTemplate会自动检测是否支持直接回复，然后使用直接回复还是使用临时回复队列。使用直接答复时，不需要答复侦听器，并且不应对其进行配置。<br>命名队列（amq.rabbitmq.reply-to除外）仍支持回复侦听器，从而允许控制回复并发等等。</p>
<p>从1.6版开始，如果您希望为每个答复使用一个临时的，排他的，自动删除队列，请将useTemporaryReplyQueues属性设置为true。如果设置了ReplyAddress，则将忽略此属性。</p>
<p>您可以通过将RabbitTemplate子类化并覆盖useDirectReplyTo（）来检查其他条件，从而更改指示是否使用直接答复的条件。发送第一个请求时，该方法仅被调用一次。</p>
<p>在2.0版之前，RabbitTemplate为每个请求创建一个新消费者，并在收到答复（或超时）时取消该消费者。现在，该模板改为使用DirectReplyToMessageListenerContainer，让消费者重新使用。模板仍然负责将回复相关联，因此没有延迟回复发送给其他发件人的危险。如果要还原为以前的行为，请将useDirectReplyToContainer（使用XML配置时直接回复到容器）属性设置为false。</p>
<p>AsyncRabbitTemplate没有此类选项。使用直接回复时，它始终使用DirectReplyToContainer进行回复。</p>
<h4 id="3-3-7-3-消息与回复队列的关联"><a href="#3-3-7-3-消息与回复队列的关联" class="headerlink" title="3.3.7.3 消息与回复队列的关联"></a>3.3.7.3 消息与回复队列的关联</h4><p>使用固定答复队列（amq.rabbitmq.reply-to除外）时，必须提供相关数据，以便将答复与请求相关。请参阅RabbitMQ远程过程调用（RPC）。默认情况下，标准的correlationId属性用于保存相关数据。但是，如果希望使用自定义属性来保存关联数据，则可以在上设置correlation-key属性。将该属性显式设置为correlationId与省略该属性相同。客户端和服务器必须将相同的标头用于关联数据。</p>
<p>Spring AMQP 1.1版对此数据使用了一个名为spring_reply_correlation的自定义属性。如果您希望使用当前版本恢复到此行为（可能是为了保持与使用1.1的其他应用程序的兼容性），则必须将属性设置为spring_reply_correlation。<br>默认情况下，模板会生成自己的关联ID（忽略任何用户提供的值）。如果您希望使用自己的关联ID，请将RabbitTemplate实例的userCorrelationId属性设置为true。</p>
<p>相关ID必须唯一，以避免针对请求返回错误回复的可能性。</p>
<h4 id="3-3-7-4-回复侦听容器"><a href="#3-3-7-4-回复侦听容器" class="headerlink" title="3.3.7.4 回复侦听容器"></a>3.3.7.4 回复侦听容器</h4><p>当使用3.4.0之前的RabbitMQ版本时，每个答复都会使用一个新的临时队列。但是，可以在模板上配置单个答复队列，这样可以提高效率，还可以在该队列上设置参数。但是，在这种情况下，您还必须提供一个子元素。此元素为答复队列提供一个侦听器容器，其中模板为侦听器。元素上允许上允许的所有消息侦听器容器配置属性，但从模板的配置继承的connection-factory和message-converter除外。</p>
<p>如果您运行应用程序的多个实例或使用多个RabbitTemplate实例，则必须为每个实例使用唯一的答复队列。 RabbitMQ无法从队列中选择消息，因此，如果它们都使用相同的队列，则每个实例都将争夺答复，而不一定会收到自己的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:template id=&quot;amqpTemplate&quot;</span><br><span class="line">        connection-factory=&quot;connectionFactory&quot;</span><br><span class="line">        reply-queue=&quot;replies&quot;</span><br><span class="line">        reply-address=&quot;replyEx/routeReply&quot;&gt;</span><br><span class="line">    &lt;rabbit:reply-listener/&gt;</span><br><span class="line">&lt;/rabbit:template&gt;</span><br></pre></td></tr></table></figure>
<p>容器和模板共享连接工厂时，它们不共享通道。因此，请求和答复不在同一事务中执行（如果是事务性的）。<br>在1.5.0之前的版本中，reply-address属性不可用。始终使用默认交换和答复队列名称作为路由关键字来路由答复。这仍然是默认设置，但是您现在可以指定新的reply-address属性。回复地址可以包含格式为 / 的地址，并且回复被路由到指定的交换机，并被路由到与路由键绑定的队列。回复地址优先于回复队列。当仅使用回复地址时，必须将配置为单独的组件。回复地址和回复队列（或上的queues属性）必须在逻辑上引用同一队列。</p>
<p>通过这种配置，SimpleListenerContainer用于接收答复，其中RabbitTemplate为MessageListener。如上例所示，当使用命名空间元素定义模板时，解析器将模板中的容器和连线定义为侦听器。</p>
<p>当模板不使用固定的ReplyQueue时（或使用直接答复者-参见RabbitMQ直接答复者），则不需要侦听器容器。使用RabbitMQ 3.4.0或更高版本时，首选直接答复机制。</p>
<p>如果将RabbitTemplate定义为或使用@Configuration类将其定义为@Bean，或者在以编程方式创建模板时，则需要自己定义并连接答复侦听器容器。如果您无法执行此操作，则模板将永远不会收到答复，并最终超时并返回null作为对sendAndReceive方法的调用的答复。</p>
<p>从1.5版开始，RabbitTemplate会检测它是否已配置为MessageListener来接收回复。否则，尝试发送和接收带有回复地址的消息失败，并出现IllegalStateException（因为从未收到回复）。</p>
<p>此外，如果使用简单的ReplyAddress（队列名称），则回复侦听器容器将验证它正在侦听具有相同名称的队列。如果回复地址是交换和路由密钥，并且写入了调试日志消息，则无法执行此检查。</p>
<p>自己连接回复侦听器和模板时，务必确保模板的ReplyAddress和容器的队列（或queueNames）属性引用相同的队列。该模板将回复地址插入到出站邮件的ReplyTo属性中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;amqpTemplate&quot; class=&quot;org.springframework.amqp.rabbit.core.RabbitTemplate&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;exchange&quot; value=&quot;foo.exchange&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;routingKey&quot; value=&quot;foo&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;replyQueue&quot; ref=&quot;replyQ&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;replyTimeout&quot; value=&quot;600000&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;useDirectReplyToContainer&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean class=&quot;org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;queues&quot; ref=&quot;replyQ&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;messageListener&quot; ref=&quot;amqpTemplate&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;replyQ&quot; name=&quot;my.reply.queue&quot; /&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RabbitTemplate amqpTemplate() &#123;</span><br><span class="line">   RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());</span><br><span class="line">   rabbitTemplate.setMessageConverter(msgConv());</span><br><span class="line">   rabbitTemplate.setReplyAddress(replyQueue().getName());</span><br><span class="line">   rabbitTemplate.setReplyTimeout(60000);</span><br><span class="line">   rabbitTemplate.setUseDirectReplyToContainer(false);</span><br><span class="line">   return rabbitTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer replyListenerContainer() &#123;</span><br><span class="line">   SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</span><br><span class="line">   container.setConnectionFactory(connectionFactory());</span><br><span class="line">   container.setQueues(replyQueue());</span><br><span class="line">   container.setMessageListener(amqpTemplate());</span><br><span class="line">   return container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue replyQueue() &#123;</span><br><span class="line">   return new Queue(&quot;my.reply.queue&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此测试用例中，显示了一个RabbitTemplate的完整示例，该示例连接了固定的答复队列以及处理请求并返回答复的“远程”侦听器容器。</p>
<p>当回复超时（replyTimeout）时，sendAndReceive（）方法将返回null。</p>
<p>在1.3.6版之前，仅记录对超时消息的最新答复。现在，如果收到延迟答复，则拒绝该答复（模板将引发AmqpRejectAndDontRequeueException）。如果将答复队列配置为将拒绝的邮件发送到死信交换，则可以检索答复以进行以后的分析。为此，请使用与回复队列名称相同的路由键将队列绑定到已配置的死信交换。</p>
<p>有关配置无效字母的更多信息，请参见RabbitMQ无效字母文档。您还可以查看FixedReplyQueueDeadLetterTests测试用例的示例。</p>
<h4 id="3-3-7-5-AsyncRabbitTemplate"><a href="#3-3-7-5-AsyncRabbitTemplate" class="headerlink" title="3.3.7.5 AsyncRabbitTemplate"></a>3.3.7.5 AsyncRabbitTemplate</h4><p>1.6版引入了AsyncRabbitTemplate。这具有与AmqpTemplate上相似的sendAndReceive（和convertSendAndReceive）方法。但是，它们不是阻塞而是返回一个ListenableFuture。</p>
<p>sendAndReceive方法返回RabbitMessageFuture。 convertSendAndReceive方法返回RabbitConverterFuture。</p>
<p>您可以稍后通过将来调用get（）来同步检索结果，也可以注册一个与结果异步调用的回调。下面的清单显示了两种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private AsyncRabbitTemplate template;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public void doSomeWorkAndGetResultLater() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ListenableFuture&lt;String&gt; future = this.template.convertSendAndReceive(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">    // do some more work</span><br><span class="line"></span><br><span class="line">    String reply = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        reply = future.get();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ExecutionException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doSomeWorkAndGetResultAsync() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    RabbitConverterFuture&lt;String&gt; future = this.template.convertSendAndReceive(&quot;foo&quot;);</span><br><span class="line">    future.addCallback(new ListenableFutureCallback&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(String result) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(Throwable ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果设置了mandatory，并且消息无法传递，则将来会引发ExecutionException，其原因是AmqpMessageReturnedException，该异常封装了返回的消息和有关返回的信息。</p>
<p>如果设置了enableConfirms，则future将具有一个名为Confirm的属性，该属性本身是一个ListenableFuture ，其中true表示成功发布。如果确认未来为假，RabbitFuture具有另一个名为nackCause的属性，其中包含失败的原因（如果有）。</p>
<p>如果在回复后收到确认，则发布者确认将被丢弃，因为回复表示成功发布。<br>您可以在模板上设置receiveTimeout属性以使答复超时（默认为30000-30秒）。如果发生超时，则将来会通过AmqpReplyTimeoutException完成。</p>
<p>该模板实现SmartLifecycle。在有挂起的答复时停止模板会导致挂起的Future实例被取消。</p>
<p>从2.0版开始，异步模板现在支持直接答复而不是配置的答复队列。要启用此功能，请使用以下构造函数之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public AsyncRabbitTemplate(ConnectionFactory connectionFactory, String exchange, String routingKey)</span><br><span class="line"></span><br><span class="line">public AsyncRabbitTemplate(RabbitTemplate template)</span><br></pre></td></tr></table></figure>
<p>请参阅RabbitMQ直接答复以将直接答复与同步RabbitTemplate一起使用。</p>
<p>2.0版引入了这些方法的变体（convertSendAndReceiveAsType），这些变体采用附加的ParameterizedTypeReference参数来转换复杂的返回类型。您必须使用SmartMessageConverter配置基础RabbitTemplate。有关更多信息，请参见使用RabbitTemplate从消息转换。</p>
<h4 id="3-3-7-6-Spring-Remoting-with-AMQP"><a href="#3-3-7-6-Spring-Remoting-with-AMQP" class="headerlink" title="3.3.7.6 Spring Remoting with AMQP"></a>3.3.7.6 Spring Remoting with AMQP</h4><p>Spring框架具有常规的远程处理功能，允许使用各种传输方式的远程过程调用（RPC）。 Spring-AMQP通过客户端上的AmqpProxyFactoryBean和服务器上的AmqpInvokerServiceExporter支持类似的机制。这提供了基于AMQP的RPC。在客户端，如前所述使用RabbitTemplate。在服务器端，调用程序（配置为MessageListener）接收消息，调用配置的服务，并使用入站消息的ReplyTo信息返回答复。</p>
<p>您可以将客户端工厂bean注入任何bean（通过使用其serviceInterface）。然后，客户端可以调用代理上的方法，从而通过AMQP进行远程执行。</p>
<p>对于默认的MessageConverter实例，方法参数和返回值必须是Serializable实例。<br>在服务器端，AmqpInvokerServiceExporter同时具有AmqpTemplate和MessageConverter属性。当前，未使用模板的MessageConverter。如果需要提供自定义消息转换器，则应通过设置messageConverter属性来提供它。在客户端，您可以向AmqpTemplate添加自定义消息转换器，该转换器通过使用其amqpTemplate属性提供给AmqpProxyFactoryBean。</p>
<p>以下清单显示了示例客户端和服务器配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;client&quot;</span><br><span class="line">	class=&quot;org.springframework.amqp.remoting.client.AmqpProxyFactoryBean&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;amqpTemplate&quot; ref=&quot;template&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;serviceInterface&quot; value=&quot;foo.ServiceInterface&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:template id=&quot;template&quot; connection-factory=&quot;connectionFactory&quot; reply-timeout=&quot;2000&quot;</span><br><span class="line">	routing-key=&quot;remoting.binding&quot; exchange=&quot;remoting.exchange&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:admin connection-factory=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue name=&quot;remoting.queue&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:direct-exchange name=&quot;remoting.exchange&quot;&gt;</span><br><span class="line">	&lt;rabbit:bindings&gt;</span><br><span class="line">		&lt;rabbit:binding queue=&quot;remoting.queue&quot; key=&quot;remoting.binding&quot; /&gt;</span><br><span class="line">	&lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:direct-exchange&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;listener&quot;</span><br><span class="line">	class=&quot;org.springframework.amqp.remoting.service.AmqpInvokerServiceExporter&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;serviceInterface&quot; value=&quot;foo.ServiceInterface&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;service&quot; ref=&quot;service&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;amqpTemplate&quot; ref=&quot;template&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;service&quot; class=&quot;foo.ServiceImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:template id=&quot;template&quot; connection-factory=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue name=&quot;remoting.queue&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot;&gt;</span><br><span class="line">	&lt;rabbit:listener ref=&quot;listener&quot; queue-names=&quot;remoting.queue&quot; /&gt;</span><br><span class="line">&lt;/rabbit:listener-container&gt;</span><br></pre></td></tr></table></figure>
<p>AmqpInvokerServiceExporter只能处理格式正确的消息，例如从AmqpProxyFactoryBean发送的消息。如果收到无法解释的消息，则会发送序列化的RuntimeException作为答复。如果邮件没有replyToAddress属性，则如果未配置死信交换，则邮件将被拒绝并永久丢失。</p>
<p>默认情况下，如果无法传递请求消息，则调用线程最终超时，并引发RemoteProxyFailureException。默认情况下，超时为五秒。您可以通过在RabbitTemplate上设置ReplyTimeout属性来修改该持续时间。从版本1.5开始，将强制性属性设置为true并在连接工厂上启用返回（请参见发布者确认和返回），调用线程将引发AmqpMessageReturnedException。有关更多信息，请参见回复超时。</p>
<h3 id="3-3-8-配置Broker"><a href="#3-3-8-配置Broker" class="headerlink" title="3.3.8 配置Broker"></a>3.3.8 配置Broker</h3><p>AMQP规范描述了如何使用协议在代理上配置队列，交换和绑定。这些操作（可从0.8规范及更高版本移植）在org.springframework.amqp.core软件包的AmqpAdmin界面中。该类的RabbitMQ实现是RabbitAdmin，位于org.springframework.amqp.rabbit.core包中。</p>
<p>AmqpAdmin界面基于使用Spring AMQP域抽象，并在以下列表中显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface AmqpAdmin &#123;</span><br><span class="line"></span><br><span class="line">    // Exchange Operations</span><br><span class="line"></span><br><span class="line">    void declareExchange(Exchange exchange);</span><br><span class="line"></span><br><span class="line">    void deleteExchange(String exchangeName);</span><br><span class="line"></span><br><span class="line">    // Queue Operations</span><br><span class="line"></span><br><span class="line">    Queue declareQueue();</span><br><span class="line"></span><br><span class="line">    String declareQueue(Queue queue);</span><br><span class="line"></span><br><span class="line">    void deleteQueue(String queueName);</span><br><span class="line"></span><br><span class="line">    void deleteQueue(String queueName, boolean unused, boolean empty);</span><br><span class="line"></span><br><span class="line">    void purgeQueue(String queueName, boolean noWait);</span><br><span class="line"></span><br><span class="line">    // Binding Operations</span><br><span class="line"></span><br><span class="line">    void declareBinding(Binding binding);</span><br><span class="line"></span><br><span class="line">    void removeBinding(Binding binding);</span><br><span class="line"></span><br><span class="line">    Properties getQueueProperties(String queueName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getQueueProperties（）方法返回有关队列的一些有限信息（消息计数和消费者计数）。返回的属性的键在RabbitTemplate中可以作为常量使用（QUEUE_NAME，QUEUE_MESSAGE_COUNT和QUEUE_CONSUMER_COUNT）。 RabbitMQ REST API在QueueInfo对象中提供了更多信息。</p>
<p>no-argclarifyQueue（）方法使用自动生成的名称定义代理上的队列。此自动生成的队列的其他属性是Exclusive = true，autoDelete = true和持久= false。</p>
<p>defineQueue（Queue queue）方法接受一个Queue对象，并返回已声明队列的名称。如果提供的Queue的name属性为空字符串，则代理将使用生成的名称声明队列。该名称将返回给呼叫者。该名称也被添加到队列的actualName属性中。您只能通过直接调用RabbitAdmin来以编程方式使用此功能。在应用程序上下文中以声明方式定义队列时，当管理员使用自动声明时，可以将name属性设置为“”（空字符串）。然后，代理创建名称。从2.1版开始，侦听器容器可以使用这种类型的队列。有关更多信息，请参见以容器和代理命名的队列。</p>
<p>这与AnonymousQueue相反，在AnonymousQueue中，框架生成唯一（UUID）名称，并将持久性设置为false和Exclusive，将autoDelete设置为true。名称属性为空（或缺少）的始终会创建一个AnonymousQueue。</p>
<p>请参阅AnonymousQueue以了解为什么AnonymousQueue优先于代理生成的队列名称，以及如何控制名称格式。从版本2.1开始，默认情况下，匿名队列使用参数x-queue-master-locator声明为本地客户端声明。这样可以确保在与应用程序连接的节点上声明队列。声明性队列必须具有固定的名称，因为它们可能在上下文中的其他地方被引用，例如在以下示例中所示的侦听器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:listener-container&gt;</span><br><span class="line">    &lt;rabbit:listener ref=&quot;listener&quot; queue-names=&quot;#&#123;someQueue.name&#125;&quot; /&gt;</span><br><span class="line">&lt;/rabbit:listener-container&gt;</span><br></pre></td></tr></table></figure>
<p>该接口的RabbitMQ实现是RabbitAdmin，当使用Spring XML进行配置时，它类似于以下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:admin id=&quot;amqpAdmin&quot; connection-factory=&quot;connectionFactory&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>当CachingConnectionFactory缓存模式为CHANNEL（默认）时，RabbitAdmin实现将自动延迟声明在同一ApplicationContext中声明的队列，交换和绑定。一旦向代理打开连接，便声明这些组件。有一些名称空间功能使此操作非常方便。例如，在Stocks示例应用程序中，我们具有以下功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;tradeQueue&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;marketDataQueue&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;fanout-exchange name=&quot;broadcast.responses&quot;</span><br><span class="line">                 xmlns=&quot;http://www.springframework.org/schema/rabbit&quot;&gt;</span><br><span class="line">    &lt;bindings&gt;</span><br><span class="line">        &lt;binding queue=&quot;tradeQueue&quot;/&gt;</span><br><span class="line">    &lt;/bindings&gt;</span><br><span class="line">&lt;/fanout-exchange&gt;</span><br><span class="line"></span><br><span class="line">&lt;topic-exchange name=&quot;app.stock.marketdata&quot;</span><br><span class="line">                xmlns=&quot;http://www.springframework.org/schema/rabbit&quot;&gt;</span><br><span class="line">    &lt;bindings&gt;</span><br><span class="line">        &lt;binding queue=&quot;marketDataQueue&quot; pattern=&quot;$&#123;stocks.quote.pattern&#125;&quot;/&gt;</span><br><span class="line">    &lt;/bindings&gt;</span><br><span class="line">&lt;/topic-exchange&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，我们使用匿名队列（实际上，在内部，只是具有由框架而不是由代理生成的名称的队列），并通过ID引用它们。我们还可以使用显式名称声明队列，这些队列还用作上下文中其bean定义的标识符。以下示例使用明确的名称配置队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;stocks.trade.queue&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>您可以提供id和name属性。这使您可以通过独立于队列名称的ID来引用队列（例如，在绑定中）。它还允许使用标准的Spring功能（例如队列名的属性占位符和SpEL表达式）。当您使用名称作为Bean标识符时，这些功能不可用。</p>
<p>默认情况下，当发生任何异常时，RabbitAdmin将立即停止处理所有声明。这可能会导致下游问题，例如侦听器容器无法初始化，因为未声明另一个队列（在错误的一个之后定义）。</p>
<p>可以通过在RabbitAdmin实例上将ignore-declaration-exceptions属性设置为true来修改此行为。该选项指示RabbitAdmin记录异常并继续声明其他元素。使用Java配置RabbitAdmin时，此属性称为ignoreDeclarationExceptions。这是适用于所有元素的全局设置。队列，交换和绑定具有类似的属性，仅适用于那些元素。</p>
<p>在1.6版之前的版本中，仅当通道上发生IOException时（例如，当前属性与所需属性不匹配时），此属性才生效。现在，此属性对任何异常（包括TimeoutException和其他异常）都生效。</p>
<p>另外，任何声明异常都会导致产生一个DeclarationExceptionEvent，这是一个ApplicationEvent，可以由上下文中的任何ApplicationListener消费。该事件包含对admin，已声明的元素和Throwable的引用。</p>
<h4 id="3-3-8-1-Header-交换器"><a href="#3-3-8-1-Header-交换器" class="headerlink" title="3.3.8.1 Header 交换器"></a>3.3.8.1 Header 交换器</h4><p>从版本1.3开始，您可以配置HeadersExchange以匹配多个Header。您也可以指定是否必须匹配任何Header。以下示例显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:headers-exchange name=&quot;headers-test&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding queue=&quot;bucket&quot;&gt;</span><br><span class="line">            &lt;rabbit:binding-arguments&gt;</span><br><span class="line">                &lt;entry key=&quot;foo&quot; value=&quot;bar&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;baz&quot; value=&quot;qux&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;x-match&quot; value=&quot;all&quot;/&gt;</span><br><span class="line">            &lt;/rabbit:binding-arguments&gt;</span><br><span class="line">        &lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:headers-exchange&gt;</span><br></pre></td></tr></table></figure>
<p>从版本1.6开始，您可以使用内部标志（默认为false）配置Exchange，并且可以通过RabbitAdmin在Broker上正确配置这样的Exchange（如果应用程序上下文中存在Exchange）。如果内部标志适用于交换，则RabbitMQ不允许客户端使用交换。这对于无用信交换或交换对交换绑定很有用，在这种情况下，您不希望发行人直接使用交换。</p>
<p>要查看如何使用Java配置AMQP基础结构，请查看Stock示例应用程序，其中有@Configuration类AbstractStockRabbitConfiguration，该类又具有RabbitClientConfiguration和RabbitServerConfiguration子类。以下清单显示了AbstractStockRabbitConfiguration的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public abstract class AbstractStockAppRabbitConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConnectionFactory connectionFactory() &#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory =</span><br><span class="line">            new CachingConnectionFactory(&quot;localhost&quot;);</span><br><span class="line">        connectionFactory.setUsername(&quot;guest&quot;);</span><br><span class="line">        connectionFactory.setPassword(&quot;guest&quot;);</span><br><span class="line">        return connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitTemplate rabbitTemplate() &#123;</span><br><span class="line">        RabbitTemplate template = new RabbitTemplate(connectionFactory());</span><br><span class="line">        template.setMessageConverter(jsonMessageConverter());</span><br><span class="line">        configureRabbitTemplate(template);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MessageConverter jsonMessageConverter() &#123;</span><br><span class="line">        return new Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TopicExchange marketDataExchange() &#123;</span><br><span class="line">        return new TopicExchange(&quot;app.stock.marketdata&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // additional code omitted for brevity</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端通过AmqpAdmin上的clarifyQueue（）方法声明另一个队列。它使用属性文件中外部化的路由模式将该队列绑定到市场数据交换。</p>
<h4 id="3-3-8-2-Builder-API"><a href="#3-3-8-2-Builder-API" class="headerlink" title="3.3.8.2 Builder API"></a>3.3.8.2 Builder API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> @Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    return QueueBuilder.nonDurable(&quot;foo&quot;)</span><br><span class="line">        .autoDelete()</span><br><span class="line">        .exclusive()</span><br><span class="line">        .withArgument(&quot;foo&quot;, &quot;bar&quot;)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Exchange exchange() &#123;</span><br><span class="line">  return ExchangeBuilder.directExchange(&quot;foo&quot;)</span><br><span class="line">      .autoDelete()</span><br><span class="line">      .internal()</span><br><span class="line">      .withArgument(&quot;foo&quot;, &quot;bar&quot;)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-8-3-声明交换、队列、绑定的集合"><a href="#3-3-8-3-声明交换、队列、绑定的集合" class="headerlink" title="3.3.8.3 声明交换、队列、绑定的集合"></a>3.3.8.3 声明交换、队列、绑定的集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public static class Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConnectionFactory cf() &#123;</span><br><span class="line">        return new CachingConnectionFactory(&quot;localhost&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitAdmin admin(ConnectionFactory cf) &#123;</span><br><span class="line">        return new RabbitAdmin(cf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange e1() &#123;</span><br><span class="line">    	return new DirectExchange(&quot;e1&quot;, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue q1() &#123;</span><br><span class="line">    	return new Queue(&quot;q1&quot;, false, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Binding b1() &#123;</span><br><span class="line">    	return BindingBuilder.bind(q1()).to(e1()).with(&quot;k1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables es() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new DirectExchange(&quot;e2&quot;, false, true),</span><br><span class="line">                new DirectExchange(&quot;e3&quot;, false, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables qs() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new Queue(&quot;q2&quot;, false, false, true),</span><br><span class="line">                new Queue(&quot;q3&quot;, false, false, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">    public Declarables prototypes() &#123;</span><br><span class="line">        return new Declarables(new Queue(this.prototypeQueueName, false, false, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables bs() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new Binding(&quot;q2&quot;, DestinationType.QUEUE, &quot;e2&quot;, &quot;k2&quot;, null),</span><br><span class="line">                new Binding(&quot;q3&quot;, DestinationType.QUEUE, &quot;e3&quot;, &quot;k3&quot;, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables ds() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new DirectExchange(&quot;e4&quot;, false, true),</span><br><span class="line">                new Queue(&quot;q4&quot;, false, false, true),</span><br><span class="line">                new Binding(&quot;q4&quot;, DestinationType.QUEUE, &quot;e4&quot;, &quot;k4&quot;, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.2版将getDeclarablesByType方法添加到了Declarables中。例如，在声明一个或多个侦听器容器bean时，这可以方便使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public SimpleMessageListenerContainer container(ConnectionFactory connectionFactory,</span><br><span class="line">        Declarables mixedDeclarables, MessageListener listener) &#123;</span><br><span class="line"></span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">    container.setQueues(mixedDeclarables.getDeclarablesByType(Queue.class).toArray(new Queue[0]));</span><br><span class="line">    container.setMessageListener(listener);</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-8-4-条件声明"><a href="#3-3-8-4-条件声明" class="headerlink" title="3.3.8.4 条件声明"></a>3.3.8.4 条件声明</h4><p>默认情况下，所有队列，交换和绑定都由应用程序上下文中的所有RabbitAdmin实例声明（假设它们具有auto-startup =“ true”）。</p>
<p>从版本2.1.9开始，RabbitAdmin具有新的属性explicitDeclarationsOnly（默认情况下为false）。当将此设置为true时，管理员将仅声明显式配置为由该RabbitAdmin声明的Bean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RabbitAdmin admin1() &#123;</span><br><span class="line">    return new RabbitAdmin(cf1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RabbitAdmin admin2() &#123;</span><br><span class="line">    return new RabbitAdmin(cf2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    Queue queue = new Queue(&quot;foo&quot;);</span><br><span class="line">    queue.setAdminsThatShouldDeclare(admin1());</span><br><span class="line">    return queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Exchange exchange() &#123;</span><br><span class="line">    DirectExchange exchange = new DirectExchange(&quot;bar&quot;);</span><br><span class="line">    exchange.setAdminsThatShouldDeclare(admin1());</span><br><span class="line">    return exchange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Binding binding() &#123;</span><br><span class="line">    Binding binding = new Binding(&quot;foo&quot;, DestinationType.QUEUE, exchange().getName(), &quot;foo&quot;, null);</span><br><span class="line">    binding.setAdminsThatShouldDeclare(admin1());</span><br><span class="line">    return binding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-8-5-关于id和name属性的注释"><a href="#3-3-8-5-关于id和name属性的注释" class="headerlink" title="3.3.8.5 关于id和name属性的注释"></a>3.3.8.5 关于id和name属性的注释</h4><p>和元素上的name属性反映代理中实体的名称。对于队列，如果省略名称，则会创建一个匿名队列（请参阅AnonymousQueue）。</p>
<p>在2.0之前的版本中，该名称也被注册为Bean名称别名（类似于元素上的名称）。</p>
<p>这导致了两个问题：</p>
<ul>
<li><p>它阻止了队列的声明和相同名称的交换。</p>
</li>
<li><p>如果别名包含SpEL表达式（＃{…}），则无法解析。</p>
</li>
</ul>
<p>从2.0版开始，如果您同时使用id和name属性声明这些元素之一，则该名称不再声明为Bean名称别名。如果要声明队列并使用相同的名称进行交换，则必须提供一个ID。</p>
<p>如果元素只有name属性，则没有任何变化。仍然可以使用名称Bean来引用该Bean，例如在绑定声明中。但是，如果名称包含SpEL，您仍然无法引用它-您必须提供ID以供参考。</p>
<h4 id="3-3-8-6-AnonymousQueue"><a href="#3-3-8-6-AnonymousQueue" class="headerlink" title="3.3.8.6 AnonymousQueue"></a>3.3.8.6 AnonymousQueue</h4><p>通常，当您需要一个唯一命名的排他性自动删除队列时，建议您使用AnonymousQueue而不是broker定义的队列名称（使用“”作为队列名称会导致代理生成队列名称）。</p>
<p>这是因为：</p>
<p>建立与broker的连接时，实际上会声明队列。在创建和将bean连接在一起很长时间之后。使用队列的Bean需要知道其名称。实际上，启动应用程序时，broker甚至可能没有运行。</p>
<p>如果与broker的连接由于某种原因而丢失，则管理员将用相同的名称重新声明AnonymousQueue。如果使用broker声明的队列，则队列名称将更改。</p>
<p>您可以控制AnonymousQueue实例使用的队列名称的格式。</p>
<p>默认情况下，队列名称以spring.gen-为前缀，后跟UUID的base64表示形式，例如：spring.gen-MRBv9sqISkuCiPfOYfpo4g。</p>
<p>您可以在构造函数参数中提供AnonymousQueue.NamingStrategy实现。以下示例显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue anon1() &#123;</span><br><span class="line">    return new AnonymousQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue anon2() &#123;</span><br><span class="line">    return new AnonymousQueue(new AnonymousQueue.Base64UrlNamingStrategy(&quot;something-&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue anon3() &#123;</span><br><span class="line">    return new AnonymousQueue(AnonymousQueue.UUIDNamingStrategy.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个bean生成一个队列名称，该队列名称以spring.gen-为前缀，后跟UUID的base64表示形式-例如：spring.gen-MRBv9sqISkuCiPfOYfpo4g。第二个bean生成一个以某些东西为前缀的队列名称，后跟UUID的base64表示形式。第三个bean仅通过使用UUID（不进行base64转换）来生成名称，例如f20c818a-006b-4416-bf91-643590fedb0e。</p>
<p>base64编码使用RFC 4648中的“ ​​URL和文件名安全字母”。尾随的填充字符（=）被删除。</p>
<p>您可以提供自己的命名策略，从而可以在队列名称中包括其他信息（例如应用程序名称或客户端主机）。</p>
<p>使用XML配置时，可以指定命名策略。 naming-strategy属性存在于实现AnonymousQueue.NamingStrategy的bean引用的元素上。以下示例显示如何以各种方式指定命名策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue id=&quot;uuidAnon&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;springAnon&quot; naming-strategy=&quot;uuidNamer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;customAnon&quot; naming-strategy=&quot;customNamer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;uuidNamer&quot; class=&quot;org.springframework.amqp.core.AnonymousQueue.UUIDNamingStrategy&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;customNamer&quot; class=&quot;org.springframework.amqp.core.AnonymousQueue.Base64UrlNamingStrategy&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;custom.gen-&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>第一个示例创建名称，例如spring.gen-MRBv9sqISkuCiPfOYfpo4g。第二个示例使用UUID的字符串表示形式创建名称。第三个示例创建名称，例如custom.gen-MRBv9sqISkuCiPfOYfpo4g。</p>
<p>您还可以提供自己的命名策略bean。</p>
<p>从版本2.1开始，默认情况下，匿名队列使用参数x-queue-master-locator声明为本地客户端声明。这样可以确保在与应用程序连接的节点上声明队列。构造实例后，可以通过调用queue.setMasterLocator（null）恢复到以前的行为。</p>
<h3 id="3-3-9-Broker事件监听"><a href="#3-3-9-Broker事件监听" class="headerlink" title="3.3.9 Broker事件监听"></a>3.3.9 Broker事件监听</h3><p>启用事件交换插件后，如果将类型为BrokerEventListener的bean添加到应用程序上下文中，它将发布选定的代理事件作为BrokerEvent实例，可以通过常规的Spring ApplicationListener或@EventListener方法使用它。代理将事件发布到主题交换amq.rabbitmq.event，每种事件类型具有不同的路由键。侦听器使用事件密钥，该事件密钥用于将AnonymousQueue绑定到交换，因此侦听器仅接收选定的事件。由于这是一个主题交换，因此可以使用通配符（以及显式请求特定事件），如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public BrokerEventListener eventListener() &#123;</span><br><span class="line">    return new BrokerEventListener(connectionFactory(), &quot;user.deleted&quot;, &quot;channel.#&quot;, &quot;queue.#&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用正常的Spring技术进一步缩小单个事件侦听器中接收到的事件的范围，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@EventListener(condition = &quot;event.eventType == &apos;queue.created&apos;&quot;)</span><br><span class="line">public void listener(BrokerEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-10-延迟消息交换器"><a href="#3-3-10-延迟消息交换器" class="headerlink" title="3.3.10 延迟消息交换器"></a>3.3.10 延迟消息交换器</h3><p>该插件目前被标记为实验性，但已经可用了一年多的时间（在撰写本文时）。如果需要更改插件，我们计划在可行的情况下尽快添加对此类更改的支持。因此，Spring AMQP中的这种支持也应视为试验性的。此功能已通过RabbitMQ 3.6.0和插件的0.0.1版进行了测试。</p>
<p>要使用RabbitAdmin将交换声明为延迟，可以将交换bean的delay属性设置为true。 RabbitAdmin使用交换类型（直接，扇出等）来设置x-delayed-type参数，并使用x-delayed-message类型声明交换。</p>
<p>使用XML配置交换bean时，delayed属性（默认值：false）也可用。以下示例显示了如何使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:topic-exchange name=&quot;topic&quot; delayed=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>要发送延迟的消息，可以通过MessageProperties设置x-delay标头，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties properties = new MessageProperties();</span><br><span class="line">properties.setDelay(15000);</span><br><span class="line">template.send(exchange, routingKey,</span><br><span class="line">MessageBuilder.withBody(&quot;foo&quot;.getBytes()).andProperties(properties).build());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(exchange, routingKey, &quot;foo&quot;, new MessagePostProcessor() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">        message.getMessageProperties().setDelay(15000);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>若要检查消息是否延迟，请在MessageProperties上使用getReceivedDelay（）方法。这是一个单独的属性，可以避免意外传播到由输入消息生成的输出消息。</p>
<h3 id="3-3-11-RabbitMQ-Rest-API"><a href="#3-3-11-RabbitMQ-Rest-API" class="headerlink" title="3.3.11 RabbitMQ Rest API"></a>3.3.11 RabbitMQ Rest API</h3><p>启用管理插件后，RabbitMQ服务器将公开REST API来监视和配置代理。现在提供了API的Java绑定。 com.rabbitmq.http.client.Client是一个标准的，即时的并且因此是阻塞的API。它基于Spring Web模块及其RestTemplate实现。另一方面，com.rabbitmq.http.client.ReactorNettyClient是基于Reactor Netty项目的反应性，非阻塞实现。</p>
<p>跳相关性（com.rabbitmq：http-client）现在也是可选的。</p>
<p>有关更多信息，请参见其Javadoc。</p>
<h3 id="3-3-12-异常处理"><a href="#3-3-12-异常处理" class="headerlink" title="3.3.12 异常处理"></a>3.3.12 异常处理</h3><p>RabbitMQ Java客户端的许多操作都可能引发已检查的异常。例如，在很多情况下，可能会抛出IOException实例。 RabbitTemplate，SimpleMessageListenerContainer和其他Spring AMQP组件捕获这些异常，并将它们转换为AmqpException层次结构中的异常之一。这些在“ org.springframework.amqp”包中定义，AmqpException是层次结构的基础。</p>
<p>当侦听器引发异常时，它将包装在ListenerExecutionFailedException中。通常，消息被代理拒绝并重新排队。将defaultRequeueRejected设置为false会导致消息被丢弃（或路由到无效信件交换）。如消息侦听器和异步案例中所述，侦听器可以引发AmqpRejectAndDontRequeueException（或InstantRequeueAmqpException）来有条件地控制此行为。</p>
<p>但是，存在一类错误，侦听器无法控制该行为。当遇到无法转换的消息（例如，无效的content_encoding标头）时，在消息到达用户代码之前会引发一些异常。将defaultRequeueRejected设置为true（默认值）（或引发InstantRequeueAmqpException），此类消息将一遍又一遍地传递。在版本1.3.2之前，用户需要编写自定义ErrorHandler（如异常处理中所述），以避免这种情况。</p>
<p>从1.3.2版开始，默认的ErrorHandler现在是ConditionalRejectingErrorHandler，它拒绝（并且不重新排队）由于不可恢复的错误而失败的消息。具体来说，它拒绝失败并出现以下错误的消息：</p>
<p>o.s.amqp … MessageConversionException：使用MessageConverter转换传入消息有效负载时可以抛出此异常。</p>
<p>o.s.messaging … MessageConversionException：如果映射到@RabbitListener方法时需要额外的转换，则转换服务可以抛出该异常。</p>
<p>o.s.messaging … MethodArgumentNotValidException：如果在侦听器中使用了验证（例如@Valid），则可以引发此异常。</p>
<p>o.s.messaging … MethodArgumentTypeMismatchException：如果将入站消息转换为与目标方法不正确的类型，则可以引发该异常。例如，将该参数声明为Message ，但收到Message 。</p>
<p>java.lang.NoSuchMethodException：在版本1.6.3中添加。</p>
<p>java.lang.ClassCastException：在版本1.6.3中添加。</p>
<p>您可以使用FatalExceptionStrategy配置此错误处理程序的实例，以便用户可以提供自己的条件消息拒绝规则-例如，从Spring Retry（消息侦听器和异步案例）到BinaryExceptionClassifier的委托实现。另外，ListenerExecutionFailedException现在具有您可以在决策中使用的failedMessage属性。如果FatalExceptionStrategy.isFatal（）方法返回true，则错误处理程序将引发AmqpRejectAndDontRequeueException。当确定异常为致命时，默认的FatalExceptionStrategy会记录一条警告消息。</p>
<p>从1.6.3版开始，将用户异常添加到致命列表的便捷方法是子类ConditionalRejectingErrorHandler.DefaultExceptionStrategy并重写isUserCauseFatal（Throwable cause）方法以为致命异常返回true。</p>
<p>处理DLQ消息的常见模式是在这些消息以及其他DLQ配置上设置生存时间，以使这些消息过期并路由回主队列以重试。这种技术的问题在于，导致致命异常的消息会永远循环。从2.1版开始，ConditionalRejectingErrorHandler在消息上检测到x-death标头，该标头导致引发致命异常。该消息已记录并被丢弃。您可以通过将ConditionalRejectingErrorHandler上的rejectFatalsWithXDeath属性设置为false来还原为以前的行为。</p>
<p>从版本2.1.9开始，即使容器确认模式为MANUAL，默认情况下，具有这些致命异常的消息也将被拒绝并且不重新排队。这些异常通常在调用侦听器之前发生，因此侦听器没有机会确认或拒绝消息，因此消息以未确认状态保留在队列中。若要还原为以前的行为，请将ConditionalRejectingErrorHandler的rejectManual属性设置为false。</p>
<h3 id="3-3-13-事务"><a href="#3-3-13-事务" class="headerlink" title="3.3.13 事务"></a>3.3.13 事务</h3><p>Spring Rabbit框架支持同步和异步用例中的自动事务管理，具有许多不同的语义，可以通过声明方式选择这些语义，这是Spring事务的现有用户所熟悉的。这使许多（如果不是大多数）常见的消息传递模式易于实现。</p>
<p>有两种方法可以向框架发出所需的事务语义。在RabbitTemplate和SimpleMessageListenerContainer中，都有一个标志channelTransacted，如果为true，则告诉框架使用事务性通道并以提交或回滚（取决于结果）结束所有操作（发送或接收），但有例外表示回滚。另一个信号是使用Spring的PlatformTransactionManager实现之一提供外部事务，作为正在进行的操作的上下文。如果在框架发送或接收消息时已经有事务在进行中，并且channelTransacted标志为true，则将消息事务的提交或回滚推迟到当前事务结束为止。如果channelTransacted标志为false，则没有事务语义适用于消息传递操作（它是自动确认的）。</p>
<p>channelTransacted标志是配置时间设置。创建AMQP组件时，通常在应用程序启动时声明和处理一次。原则上，外部事务是动态的，因为系统在运行时响应当前线程状态。但是，实际上，当将事务以声明方式分层到应用程序时，它通常也是配置设置。</p>
<p>对于RabbitTemplate的同步用例，外部事务由调用方根据喜好以声明性或强制性方式提供（通常的Spring事务模型）。以下示例显示了一种声明性方法（通常首选，因为它是非侵入性的），其中已使用channelTransacted = true配置模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    String incoming = rabbitTemplate.receiveAndConvert();</span><br><span class="line">    // do some more database processing...</span><br><span class="line">    String outgoing = processInDatabaseAndExtractReply(incoming);</span><br><span class="line">    rabbitTemplate.convertAndSend(outgoing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，在标记为@Transactional的方法内，String有效负载作为消息正文被接收，转换和发送。如果数据库处理失败并发生异常，则将传入消息返回给代理，并且不发送传出消息。这适用于在交易方法链内使用RabbitTemplate进行的任何操作（例如，除非直接操纵Channel尽早提交交易）。</p>
<p>对于带有SimpleMessageListenerContainer的异步用例，如果需要外部事务，则容器在设置侦听器时必须请求它。为了表明需要外部事务，在配置容器时，用户向容器提供PlatformTransactionManager的实现。以下示例显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ExampleExternalTransactionAmqpConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleMessageListenerContainer messageListenerContainer() &#123;</span><br><span class="line">        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">        container.setTransactionManager(transactionManager());</span><br><span class="line">        container.setChannelTransacted(true);</span><br><span class="line">        container.setQueueName(&quot;some.queue&quot;);</span><br><span class="line">        container.setMessageListener(exampleListener());</span><br><span class="line">        return container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，添加了事务管理器作为从另一个bean定义（未显示）注入的依赖项，并且channelTransacted标志也设置为true。效果是，如果侦听器因异常而失败，则事务将回滚，并且消息也将返回给代理。重要的是，如果事务提交失败（例如，由于数据库约束错误或连接性问题），则AMQP事务也会回滚，并将消息返回给代理。这有时被称为“尽力而为第一阶段提交”，并且是可靠消息传递的非常强大的模式。如果在前面的示例中将channelTransacted标志设置为false（默认值），则仍将为侦听器提供外部事务，但是所有消息传递操作将被自动确认，因此效果是即使在服务器上也提交消息传递操作。业务运营的回滚。</p>
<h4 id="3-3-13-1-条件退回"><a href="#3-3-13-1-条件退回" class="headerlink" title="3.3.13.1 条件退回"></a>3.3.13.1 条件退回</h4><p>在1.6.6版之前，使用外部事务管理器（例如JDBC）在容器的transactionAttribute中添加回滚规则无效。异常总是回滚事务。</p>
<p>另外，在容器的建议链中使用事务建议时，条件回滚并不是很有用，因为所有侦听器异常都包装在ListenerExecutionFailedException中。</p>
<p>第一个问题已得到纠正，现在可以正确应用规则。此外，现在提供了ListenerFailedRuleBasedTransactionAttribute。它是RuleBasedTransactionAttribute的子类，唯一的区别是它知道ListenerExecutionFailedException并将该异常的原因用于规则。该交易属性可以直接在容器中使用，也可以通过交易建议使用。</p>
<p>以下示例使用此规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public AbstractMessageListenerContainer container() &#123;</span><br><span class="line">    ...</span><br><span class="line">    container.setTransactionManager(transactionManager);</span><br><span class="line">    RuleBasedTransactionAttribute transactionAttribute =</span><br><span class="line">        new ListenerFailedRuleBasedTransactionAttribute();</span><br><span class="line">    transactionAttribute.setRollbackRules(Collections.singletonList(</span><br><span class="line">        new NoRollbackRuleAttribute(DontRollBackException.class)));</span><br><span class="line">    container.setTransactionAttribute(transactionAttribute);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-13-2-关于回滚收到消息的注意事项"><a href="#3-3-13-2-关于回滚收到消息的注意事项" class="headerlink" title="3.3.13.2 关于回滚收到消息的注意事项"></a>3.3.13.2 关于回滚收到消息的注意事项</h4><p>AMQP事务仅适用于发送给代理的消息和确认。因此，当发生Spring事务的回滚并且已经收到消息时，Spring AMQP不仅必须回滚该事务，而且还必须手动拒绝该消息（有点小问题，但这不是规范所称的）。拒绝消息时采取的操作与事务无关，并且取决于defaultRequeueRejected属性（默认值：true）。有关拒绝失败消息的更多信息，请参见消息侦听器和异步案例。</p>
<p>有关RabbitMQ事务及其限制的更多信息，请参见RabbitMQ Broker Semantics。</p>
<p>在RabbitMQ 2.7.0之前，此类消息（以及通道关闭或中止时未确认的消息）在Rabbit代理上进入队列的后面。从2.7.0版本开始，被拒绝的消息以与JMS回滚消息类似的方式进入队列的最前面。<br>以前，本地事务之间和提供TransactionManager时，事务回滚时的消息重新排队不一致。在前一种情况下，将应用常规的重新排队逻辑（AmqpRejectAndDontRequeueException或defaultRequeueRejected = false）（请参阅消息侦听器和异步情况）。使用事务管理器，该消息将在回滚时无条件重新排队。从版本2.0开始，行为是一致的，并且在两种情况下均采用常规的重新排队逻辑。要恢复以前的行为，可以将容器的alwaysRequeueWithTxManagerRollback属性设置为true。请参阅消息侦听器容器配置。</p>
<h4 id="3-3-13-3-使用RabbitTransactionManager"><a href="#3-3-13-3-使用RabbitTransactionManager" class="headerlink" title="3.3.13.3 使用RabbitTransactionManager"></a>3.3.13.3 使用RabbitTransactionManager</h4><p>RabbitTransactionManager是在外部事务中执行并与外部事务同步的Rabbit操作的替代方法。该事务管理器是PlatformTransactionManager接口的实现，应与单个Rabbit ConnectionFactory一起使用。</p>
<p>此策略不能提供XA事务，例如，以便在消息传递和数据库访问之间共享事务。<br>需要应用程序代码才能通过ConnectionFactoryUtils.getTransactionalResourceHolder（ConnectionFactory，boolean）（而不是带有后续通道创建的标准Connection.createChannel（））来检索事务型Rabbit资源。使用Spring AMQP的RabbitTemplate时，它将自动检测线程绑定的Channel并自动参与其事务。</p>
<p>使用Java配置，可以使用以下bean来设置新的RabbitTransactionManager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RabbitTransactionManager rabbitTransactionManager() &#123;</span><br><span class="line">    return new RabbitTransactionManager(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您喜欢XML配置，则可以在XML Application Context文件中声明以下bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;rabbitTxManager&quot;</span><br><span class="line">      class=&quot;org.springframework.amqp.rabbit.transaction.RabbitTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-14-消息监听容器配置"><a href="#3-3-14-消息监听容器配置" class="headerlink" title="3.3.14 消息监听容器配置"></a>3.3.14 消息监听容器配置</h3><p>用于配置与事务和服务质量相关的SimpleMessageListenerContainer（SMLC）和DirectMessageListenerContainer（DMLC）的选项很多，它们中的一些相互交互。适用于SMLC或DMLC的属性由相应列中的复选标记指示。请参阅选择容器，以获取帮助您确定哪个容器适合您的应用程序的信息。</p>
<p>下表显示了使用命名空间配置时的容器属性名称及其等效属性名称（在括号中）。该元素上的type属性可以是简单的（默认），也可以直接指定SMLC或DMLC。命名空间未公开某些属性。这些由属性的N / A表示。</p>
<h3 id="3-3-15-监听并发"><a href="#3-3-15-监听并发" class="headerlink" title="3.3.15 监听并发"></a>3.3.15 监听并发</h3><h4 id="3-3-15-1-SimpleMessageListenerContainer"><a href="#3-3-15-1-SimpleMessageListenerContainer" class="headerlink" title="3.3.15.1 SimpleMessageListenerContainer"></a>3.3.15.1 SimpleMessageListenerContainer</h4><p>默认情况下，侦听器容器启动一个消费者，该消费者从队列中接收消息。</p>
<p>检查上一节中的表时，您可以看到许多控制并发性的属性。最简单的是currentsconsumers，它创建并发处理消息的（固定）数量的消费者。</p>
<p>在1.3.0版之前，这是唯一可用的设置，必须停止容器并再次启动容器才能更改设置。</p>
<p>从1.3.0版开始，您现在可以动态调整parallelConsumers属性。如果在容器运行时更​​改了容器，则会根据需要添加或删除消费者，以适应新设置。</p>
<p>另外，添加了一个名为maxConcurrentConsumers的新属性，并且该容器根据工作负载动态调整了并发性。这与四个附加属性一起工作：ContinuousActiveTrigger，startConsumerMinInterval，continuousIdleTrigger和stopConsumerMinInterval。</p>
<hr>
<p>使用默认设置，增加使用方的算法如下：</p>
<p>如果尚未达到maxConcurrentConsumers且现有消费者处于连续十个周期的活动状态，并且自启动最后一个消费者以来至少经过了10秒钟，则将启动一个新消费者。如果消费者以batchSize * receiveTimeout毫秒接收至少一条消息，则认为该消费者是活动的。</p>
<hr>
<hr>
<p>在默认设置下，减少使用方的算法如下：</p>
<p>如果运行的并发消费者数量超过了，并且消费者检测到十个连续超时（空闲），并且最后一个消费者至少在60秒前停止，则该消费者将停止。超时取决于receiveTimeout和batchSize属性。如果消费者未接收到batchSize * receiveTimeout毫秒中的消息，则被视为空闲。因此，在默认超时（一秒）和batchSize为4的情况下，在40秒的空闲时间后考虑停止消费者（四个超时对应于一个空闲检测）。</p>
<hr>
<p>实际上，只有在整个容器闲置一段时间后才可以停止使用。这是因为broker在所有活跃的消费者中共享其工作。<br>每个消费者都使用一个通道，而不管配置的队列数量如何。</p>
<p>从2.0版开始，可以使用并发属性（例如2-4）设置parallelConsumers和maxConcurrentConsumers属性。</p>
<h4 id="3-3-15-2-使用-DirectMessageListenerContainer"><a href="#3-3-15-2-使用-DirectMessageListenerContainer" class="headerlink" title="3.3.15.2 使用 DirectMessageListenerContainer"></a>3.3.15.2 使用 DirectMessageListenerContainer</h4><p>使用此容器，并发性基于配置的队列和consumersPerQueue。每个队列的每个消费者都使用一个单独的通道，并发性由Rabbit客户端库控制。默认情况下，在编写本文时，它使用DEFAULT_NUM_THREADS = Runtime.getRuntime().availableProcessors()* 2个线程的池。</p>
<p>您可以配置taskExecutor以提供所需的最大并发性。</p>
<h3 id="3-3-16-排他消费者"><a href="#3-3-16-排他消费者" class="headerlink" title="3.3.16 排他消费者"></a>3.3.16 排他消费者</h3><p>从版本1.3开始，您可以使用单个独占消费者配置侦听器容器。这样可以防止其他容器从队列中使用，直到当前使用方被取消为止。这样的容器的并发性必须为1。</p>
<h3 id="3-3-17-监听容器队列"><a href="#3-3-17-监听容器队列" class="headerlink" title="3.3.17 监听容器队列"></a>3.3.17 监听容器队列</h3><p>1.3版引入了许多改进，用于处理侦听器容器中的多个队列。</p>
<p>必须将容器配置为侦听至少一个队列。以前也是如此，但是现在可以在运行时添加和删除队列。处理完任何预提取的消息后，容器将回收（取消并重新创建）消费者。有关addQueues，addQueueNames，removeQueues和removeQueueNames方法，请参见Javadoc。删除队列时，必须至少保留一个队列。</p>
<p>现在，如果消费者的任何队列可用，便会启动。以前，如果没有任何队列，容器将停止。现在，只有在没有可用队列的情况下才是这种情况。如果不是所有队列都可用，则容器会尝试每60秒被动声明（并消耗）丢失的队列。</p>
<p>同样，如果消费者从代理收到取消通知（例如，如果删除队列），则该消费者尝试恢复，并且恢复的消费者继续处理来自任何其他已配置队列的消息。以前，取消一个队列会取消整个消费者，最终，由于缺少队列，容器将停止。</p>
<p>如果要永久删除队列，则应在删除队列之前或之后更新容器，以避免将来尝试从中使用该容器。</p>
<h3 id="3-3-18-弹性：从错误和broker失败中恢复"><a href="#3-3-18-弹性：从错误和broker失败中恢复" class="headerlink" title="3.3.18 弹性：从错误和broker失败中恢复"></a>3.3.18 弹性：从错误和broker失败中恢复</h3><p>Spring AMQP提供的一些关键（也是最流行的）高级功能与协议错误或代理失败时的恢复和自动重新连接有关。我们已经在本指南中看到了所有相关组件，但是应该有助于将它们放在一起，并分别指出功能和恢复方案。</p>
<p>主要重新连接功能由CachingConnectionFactory本身启用。使用RabbitAdmin自动声明功能通常也很有益。另外，如果您关心保证传递，则可能还需要使用RabbitMessage和SimpleMessageListenerContainer中的channelTransacted标志以及SimpleMessageListenerContainer中的AcknowledgeMode.AUTO（如果您自己进行确认，则使用手册）。</p>
<h4 id="3-3-18-1-自动声明交换，队列和绑定"><a href="#3-3-18-1-自动声明交换，队列和绑定" class="headerlink" title="3.3.18.1 自动声明交换，队列和绑定"></a>3.3.18.1 自动声明交换，队列和绑定</h4><p>RabbitAdmin组件可以在启动时声明交换，队列和绑定。它通过ConnectionListener懒惰地执行此操作。因此，如果broker在启动时不存在，则没有关系。第一次使用Connection（例如，通过发送消息）时，将触发侦听器并应用管理功能。在侦听器中执行自动声明的另一个好处是，如果由于任何原因（例如，代理死亡，网络故障等）而断开连接，则在重新建立连接时会再次应用它们。</p>
<p>以这种方式声明的队列必须具有固定的名称-由AnonymousQueue实例的框架明确声明或生成。匿名队列是非持久的，排他的和自动删除的。<br>仅当CachingConnectionFactory缓存模式为CHANNEL（默认）时，才执行自动声明。存在此限制是因为排他队列和自动删除队列绑定到该连接。<br>从版本2.2.2开始，RabbitAdmin将检测类型为DeclarationCustomizer的bean，并在实际处理声明之前应用该函数。例如，这对于在框架内具有一流支持之前设置新参数（属性）很有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DeclarableCustomizer customizer() &#123;</span><br><span class="line">    return dec -&gt; &#123;</span><br><span class="line">        if (dec instanceof Queue &amp;&amp; ((Queue) dec).getName().equals(&quot;my.queue&quot;)) &#123;</span><br><span class="line">            dec.addArgument(&quot;some.new.queue.argument&quot;, true);</span><br><span class="line">        &#125;</span><br><span class="line">        return dec;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在不直接访问Declarable bean定义的项目中，它也很有用。</p>
<h4 id="3-3-18-2-同步操作失败和重试选项"><a href="#3-3-18-2-同步操作失败和重试选项" class="headerlink" title="3.3.18.2 同步操作失败和重试选项"></a>3.3.18.2 同步操作失败和重试选项</h4><p>如果您在使用RabbitTemplate时（例如）在同步序列中失去了与代理的连接，则Spring AMQP会引发AmqpException（通常但并非总是AmqpIOException）。我们不会试图掩盖存在问题的事实，因此您必须能够捕获并响应异常。如果您怀疑连接丢失（不是您的错），最简单的方法是再次尝试该操作。您可以手动执行此操作，也可以查看使用Spring Retry处理（命令式或声明式）重试。</p>
<p>Spring Retry提供了几个AOP拦截器，并提供了很大的灵活性来指定重试的参数（尝试次数，异常类型，退避算法等）。 Spring AMQP还为AMQP用例提供了一些方便的工厂bean，以方便的形式创建Spring Retry拦截器，并提供了可用于实现自定义恢复逻辑的强类型回调接口。有关更多详细信息，请参见Javadoc和StatefulRetryOperationsInterceptor和StatelessRetryOperationsInterceptor的属性。如果没有事务或在重试回调中启动了事务，则无状态重试是合适的。请注意，无状态重试比有状态重试更易于配置和分析，但是如果存在正在进行的事务必须回滚或肯定要回滚，则通常不适合使用。在事务中间断开连接应具有与回滚相同的效果。因此，对于在事务从堆栈开始的更高位置进行重新连接而言，有状态重试通常是最佳选择。有状态重试需要一种机制来唯一标识消息。最简单的方法是让发件人在MessageId消息属性中放置一个唯一值。提供的消息转换器提供了执行此操作的选项：您可以将createMessageIds设置为true。否则，您可以将MessageKeyGenerator实现注入到拦截器中。密钥生成器必须为每个消息返回唯一的密钥。在2.0版之前的版本中，提供了MissingMessageIdAdvice。它使没有messageId属性的消息仅被重试一次（忽略重试设置）。不再提供此建议，因为与spring-retry 1.2版一起，其功能已内置在拦截器和消息侦听器容器中。</p>
<p>为了向后兼容，默认情况下（在重试一次之后），具有空消息ID的消息被认为对消费者是致命的（消费者已停止）。若要复制MissingMessageIdAdvice提供的功能，可以在侦听器容器上将statefulRetryFatalWithNullMessageId属性设置为false。使用该设置，消费者继续运行，并且邮件被拒绝（在重试一次之后）。它被丢弃或路由到死信队列（如果已配置）。<br>从1.3版开始，提供了一个构建器API，以帮助使用Java（在@Configuration类中）组装这些拦截器。以下示例显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public StatefulRetryOperationsInterceptor interceptor() &#123;</span><br><span class="line">	return RetryInterceptorBuilder.stateful()</span><br><span class="line">			.maxAttempts(5)</span><br><span class="line">			.backOffOptions(1000, 2.0, 10000) // initialInterval, multiplier, maxInterval</span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能以这种方式配置重试功能的子集。更多高级功能将需要将RetryTemplate配置为Spring bean。有关可用策略及其配置的完整信息，请参见Spring Retry Javadoc。</p>
<h4 id="3-3-18-3-使用批处理侦听器重试"><a href="#3-3-18-3-使用批处理侦听器重试" class="headerlink" title="3.3.18.3 使用批处理侦听器重试"></a>3.3.18.3 使用批处理侦听器重试</h4><p>不建议使用批处理侦听器配置重试，除非该批处理由生产者在单个记录中创建。有关消费者和生产者创建的批次的信息，请参阅批次消息。对于用户创建的批处理，框架不知道该批处理中的哪个消息导致了故障，因此无法在重试用完后进行恢复。对于生产者创建的批次，由于只有一条消息实际上是失败的，因此可以恢复整个消息。应用程序可能希望通过设置抛出的异常的index属性来通知自定义恢复程序在批次中发生故障的位置。</p>
<p>批处理侦听器的重试恢复器必须实现MessageBatchRecoverer。</p>
<h4 id="3-3-18-4-消息侦听器和异步情况"><a href="#3-3-18-4-消息侦听器和异步情况" class="headerlink" title="3.3.18.4 消息侦听器和异步情况"></a>3.3.18.4 消息侦听器和异步情况</h4><p>如果MessageListener因业务异常而失败，则由消息侦听器容器处理该异常，然后该容器将返回侦听另一条消息。如果故障是由断开的连接（不是业务异常）引起的，则必须取消并重新启动为侦听器收集消息的消费者。 SimpleMessageListenerContainer无缝处理此问题，并留下一条日志说正在重新启动侦听器。实际上，它无限循环，试图重新启动消费者。只有当消费者表现得很糟糕时，它才会放弃。副作用是，如果在容器启动时代理关闭，则它将继续尝试直到可以建立连接为止。</p>
<p>与协议错误和连接断开相反，业务异常处理可能需要更多考虑和一些自定义配置，尤其是在使用事务或容器确认的情况下。在2.8.x之前，RabbitMQ没有死信行为的定义。因此，默认情况下，由于业务异常而被拒绝或回滚的消息可以无限地重新发送。为了限制客户端的重传次数，一种选择是侦听器建议链中的StatefulRetryOperationsInterceptor。拦截器可以具有实现自定义死信操作的恢复回调-适用于您的特定环境的任何回调。</p>
<p>另一种选择是将容器的defaultRequeueRejected属性设置为false。这将导致所有失败的消息被丢弃。当使用RabbitMQ 2.8.x或更高版本时，这也有助于将消息传递给死信交换。</p>
<p>或者，可以引发AmqpRejectAndDontRequeueException。这样做可以防止消息重新排队，而不管defaultRequeueRejected属性的设置如何。</p>
<p>从2.1版开始，引入了InstantRequeueAmqpException以执行完全相反的逻辑：无​​论defaultRequeueRejected属性如何设置，都会重新排队消息。</p>
<p>通常，将两种技术结合使用。您可以将通知链中的StatefulRetryOperationsInterceptor与抛出AmqpRejectAndDontRequeueException的MessageRecoverer一起使用。当所有重试用尽后，将调用MessageRecover。 RejectAndDontRequeueRecoverer正是这样做的。默认的MessageRecoverer使用错误的消息并发出WARN消息。</p>
<p>从1.3版开始，提供了新的RepublishMessageRecoverer，以允许在重试用尽后发布失败的消息。</p>
<p>当恢复者使用了最后的例外时，该消息将被确认，并且不会发送到死信交换处（如果有的话）。</p>
<p>在消费者方使用RepublishMessageRecoverer时，接收到的消息在receiveDeliveryMode消息属性中具有deliveryMode。在这种情况下，deliveryMode为null。这意味着代理上的NON_PERSISTENT交付模式。从2.0版开始，您可以为deliveryMode配置RepublishMessageRecoverer，以将其设置为要重新发布的消息（如果为null）。默认情况下，它使用MessageProperties的默认值-MessageDeliveryMode.PERSISTENT。<br>以下示例显示如何将RepublishMessageRecoverer设置为恢复器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">RetryOperationsInterceptor interceptor() &#123;</span><br><span class="line">	return RetryInterceptorBuilder.stateless()</span><br><span class="line">			.maxAttempts(5)</span><br><span class="line">			.recoverer(new RepublishMessageRecoverer(amqpTemplate(), &quot;something&quot;, &quot;somethingelse&quot;))</span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RepublishMessageRecoverer在消息头中发布消息以及其他信息，例如异常消息，堆栈跟踪，原始交换和路由键。可以通过创建子类并覆盖AdditionalHeaders（）来添加其他标头。也可以在additionalHeaders（）中更改deliveryMode（或任何其他属性），如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RepublishMessageRecoverer recoverer = new RepublishMessageRecoverer(amqpTemplate, &quot;error&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    protected Map&lt;? extends String, ? extends Object&gt; additionalHeaders(Message message, Throwable cause) &#123;</span><br><span class="line">        message.getMessageProperties()</span><br><span class="line">            .setDeliveryMode(message.getMessageProperties().getReceivedDeliveryMode());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从2.0.5版开始，如果堆栈跟踪太大，则可能会被截断；这是因为所有标头都必须放在一个框架中。默认情况下，如果堆栈跟踪将导致少于20,000字节（“余量”）可用于其他标头，则它将被截断。如果您需要更多或更少的空间放置其他标头，则可以通过设置恢复程序的frameMaxHeadroom属性进行调整。从版本2.1.13、2.2.3开始，此计算中包括异常消息，并且使用以下算法将最大化堆栈跟踪量：</p>
<p>如果仅堆栈跟踪将超出限制，则异常消息标头将被截断为97个字节加……且堆栈跟踪也将被截断。</p>
<p>如果堆栈跟踪很小，则消息将被截断（加……）以适合可用字节（但是堆栈跟踪本身内的消息将被截断为97字节加…）。</p>
<p>每当发生任何截断时，都会记录原始异常以保留完整的信息。</p>
<p>从2.1版开始，添加了InstantRequeueMessageRecoverer以引发InstantRequeueAmqpException，该异常通知侦听器容器重新排队当前失败的消息。</p>
<h4 id="3-3-18-5-Spring重试的异常分类"><a href="#3-3-18-5-Spring重试的异常分类" class="headerlink" title="3.3.18.5 Spring重试的异常分类"></a>3.3.18.5 Spring重试的异常分类</h4><p>Spring Retry在确定哪些异常可以调用重试方面具有很大的灵活性。默认配置将重试所有异常。鉴于用户异常被包装在ListenerExecutionFailedException中，我们需要确保分类检查异常原因。默认分类器仅查看顶级异常。</p>
<p>从Spring Retry 1.0.3开始，BinaryExceptionClassifier具有一个名为traverseCauses的属性（默认值：false）。为true时，它将遍历异常原因，直到找到匹配项或没有原因为止。</p>
<p>要使用此分类器进行重试，可以使用通过构造函数创建的SimpleRetryPolicy，该构造函数采用最大尝试次数，异常映射实例和布尔值（traverseCauses），然后将此策略注入RetryTemplate。</p>
<h3 id="3-3-19-Debugging"><a href="#3-3-19-Debugging" class="headerlink" title="3.3.19 Debugging"></a>3.3.19 Debugging</h3><p>Spring AMQP提供了广泛的日志记录，尤其是在DEBUG级别。</p>
<p>如果要监视应用程序和代理之间的AMQP协议，可以使用诸如WireShark之​​类的工具，该工具具有用于解码协议的插件。另外，RabbitMQ Java客户端带有一个非常有用的类，称为Tracer。默认情况下，作为主服务器运行时，它将侦听端口5673并连接到本地主机上的端口5672。您可以运行它并更改连接工厂配置以连接到本地主机上的端口5673。它在控制台上显示解码的协议。有关更多信息，请参考Tracer Javadoc。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>从2.2版开始，回调是在连接工厂的执行程序线程之一上调用的，在之前的版本中回调直接在amqp-client连接I / O线程上调用；如果执行某些RPC操作（例如打开新通道），则会死锁，因为I / O线程阻塞了等待结果，但是结果需要由I / O线程本身处理。对于那些版本，有必要将工作（例如发送消息）移交给回调中的另一个线程。由于框架现在将回调调用移交给了执行程序，因此不再需要此操作。</p>

  </div>
  <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
            <strong>本文作者： </strong>zhongyp</li>
          <li class="post-copyright-link">
            <strong>本文链接：</strong>
            <a href="http://blog.programer.group/spring/2020-02-13-spring-amqp/" title="使用simple主题并开始写作">http://blog.programer.group/spring/2020-02-13-spring-amqp/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
        </ul>

  </div>
  <div class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-AMQP/">Spring AMQP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
  </div>
  
<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script src="/js/md5.min.js"></script>
    <script>
        var gitalk = new Gitalk({
            clientID: "94db00fd8803b1da40de",
            clientSecret: "34b513c63a3e941ea4b2df972635d9fa19cf3364",
            accessToken: "a25c2320388186bc7accf5faff34062b18131873",
            repo: "comment",
            owner: "zhongyp",
            admin: "zhongyp",
            id: location.pathname,
            perPage: 50,
            distractionFreeMode: "false"
        })

        gitalk.render('gitalk-container')
    </script>
</section>


</article>
  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/java/2019-12-25-java8-stream/" rel="next" title="Java 8 Stream">
          Java 8 Stream
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/middleware/2020-02-21-rabbitmq/" rel="prev" title="RabbitMQ 学习随笔">
            RabbitMQ 学习随笔
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ConnectionFactory"><span class="toc-text">1. ConnectionFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-CachingConnectionFactory"><span class="toc-text">1.1 CachingConnectionFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-SimpleRoutingConnectionFactory"><span class="toc-text">1.2 SimpleRoutingConnectionFactory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AmqpTemplate"><span class="toc-text">2. AmqpTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-添加重试机制"><span class="toc-text">2.1 添加重试机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-怎样确认异步消息的成功和失败"><span class="toc-text">2.2 怎样确认异步消息的成功和失败</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-发送消息确认与返回"><span class="toc-text">2.3 发送消息确认与返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-消息返回"><span class="toc-text">2.3.1 消息返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-消息确认"><span class="toc-text">2.3.2 消息确认</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-一种更简单的等待发布者确认的机制"><span class="toc-text">2.4 一种更简单的等待发布者确认的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Publisher使用单独的连接"><span class="toc-text">2.5 Publisher使用单独的连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-发送消息"><span class="toc-text">3. 发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Message创建API"><span class="toc-text">3.1 Message创建API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-批处理"><span class="toc-text">3.2 批处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-消费消息"><span class="toc-text">3.3 消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-轮询消费者"><span class="toc-text">3.3.1 轮询消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-异步消费者"><span class="toc-text">3.3.2 异步消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-1-MessageListener"><span class="toc-text">3.3.2.1 MessageListener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-2-MessageListenerAdapter"><span class="toc-text">3.3.2.2 MessageListenerAdapter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-3-消费者优先权"><span class="toc-text">3.3.2.3 消费者优先权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-4-容器监听自动删除队列"><span class="toc-text">3.3.2.4 容器监听自动删除队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-5-批处理消息"><span class="toc-text">3.3.2.5 批处理消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-6-消费者事件"><span class="toc-text">3.3.2.6 消费者事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-7-消费者标签"><span class="toc-text">3.3.2.7 消费者标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-8-注解驱动的侦听器端点"><span class="toc-text">3.3.2.8 注解驱动的侦听器端点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-9-创建自己的监听注解-元注解"><span class="toc-text">3.3.2.9 创建自己的监听注解(元注解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-10-启用侦听器端点注释"><span class="toc-text">3.3.2.10 启用侦听器端点注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-11-带注释方法的消息转换"><span class="toc-text">3.3.2.11 带注释方法的消息转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-12-程序化端点注册"><span class="toc-text">3.3.2.12 程序化端点注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-13-带注释的端点方法签名"><span class="toc-text">3.3.2.13 带注释的端点方法签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-14-监听多个队列"><span class="toc-text">3.3.2.14 监听多个队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-15-回复管理"><span class="toc-text">3.3.2.15 回复管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-16-多方法侦听器"><span class="toc-text">3.3.2.16 多方法侦听器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-17-代理-RabbitListener和泛型"><span class="toc-text">3.3.2.17 代理@RabbitListener和泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-18-处理异常"><span class="toc-text">3.3.2.18 处理异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-19-容器管理"><span class="toc-text">3.3.2.19 容器管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-20-批量接收消息-RabbitmqListener"><span class="toc-text">3.3.2.20 批量接收消息 @RabbitmqListener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-21-使用容器工厂"><span class="toc-text">3.3.2.21 使用容器工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-22-异步-RabbitListener返回类型"><span class="toc-text">3.3.2.22 异步@RabbitListener返回类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-23-线程和异步消费者"><span class="toc-text">3.3.2.23 线程和异步消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-24-选择一个容器"><span class="toc-text">3.3.2.24 选择一个容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-25-检测空闲的异步消费者"><span class="toc-text">3.3.2.25 检测空闲的异步消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-26-消费事件"><span class="toc-text">3.3.2.26 消费事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-27-监视侦听器性能"><span class="toc-text">3.3.2.27 监视侦听器性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-容器和broker命名的队列"><span class="toc-text">3.3.3 容器和broker命名的队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-消息转换器"><span class="toc-text">3.3.4 消息转换器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-1-使用Spring-Data-映射接口"><span class="toc-text">3.3.5.1 使用Spring Data 映射接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-2-使用RabbitTemplate从消息转换"><span class="toc-text">3.3.5.2 使用RabbitTemplate从消息转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-3-MarshallingMessageConverter"><span class="toc-text">3.3.5.3 MarshallingMessageConverter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-4-Jackson2XmlMessageConverter"><span class="toc-text">3.3.5.4 Jackson2XmlMessageConverter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-5-ContentTypeDelegatingMessageConverter"><span class="toc-text">3.3.5.5 ContentTypeDelegatingMessageConverter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-6-Java-反序列化"><span class="toc-text">3.3.5.6 Java 反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-7-消息属性转换"><span class="toc-text">3.3.5.7 消息属性转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-6-修改消息-压缩等"><span class="toc-text">3.3.6 修改消息-压缩等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-7-请求和回复消息"><span class="toc-text">3.3.7 请求和回复消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-1-回复超时"><span class="toc-text">3.3.7.1 回复超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-2-RabbitMQ直接回复"><span class="toc-text">3.3.7.2 RabbitMQ直接回复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-3-消息与回复队列的关联"><span class="toc-text">3.3.7.3 消息与回复队列的关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-4-回复侦听容器"><span class="toc-text">3.3.7.4 回复侦听容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-5-AsyncRabbitTemplate"><span class="toc-text">3.3.7.5 AsyncRabbitTemplate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-6-Spring-Remoting-with-AMQP"><span class="toc-text">3.3.7.6 Spring Remoting with AMQP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-8-配置Broker"><span class="toc-text">3.3.8 配置Broker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-8-1-Header-交换器"><span class="toc-text">3.3.8.1 Header 交换器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-8-2-Builder-API"><span class="toc-text">3.3.8.2 Builder API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-8-3-声明交换、队列、绑定的集合"><span class="toc-text">3.3.8.3 声明交换、队列、绑定的集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-8-4-条件声明"><span class="toc-text">3.3.8.4 条件声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-8-5-关于id和name属性的注释"><span class="toc-text">3.3.8.5 关于id和name属性的注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-8-6-AnonymousQueue"><span class="toc-text">3.3.8.6 AnonymousQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-9-Broker事件监听"><span class="toc-text">3.3.9 Broker事件监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-10-延迟消息交换器"><span class="toc-text">3.3.10 延迟消息交换器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-11-RabbitMQ-Rest-API"><span class="toc-text">3.3.11 RabbitMQ Rest API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-12-异常处理"><span class="toc-text">3.3.12 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-13-事务"><span class="toc-text">3.3.13 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-13-1-条件退回"><span class="toc-text">3.3.13.1 条件退回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-13-2-关于回滚收到消息的注意事项"><span class="toc-text">3.3.13.2 关于回滚收到消息的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-13-3-使用RabbitTransactionManager"><span class="toc-text">3.3.13.3 使用RabbitTransactionManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-14-消息监听容器配置"><span class="toc-text">3.3.14 消息监听容器配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-15-监听并发"><span class="toc-text">3.3.15 监听并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-15-1-SimpleMessageListenerContainer"><span class="toc-text">3.3.15.1 SimpleMessageListenerContainer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-15-2-使用-DirectMessageListenerContainer"><span class="toc-text">3.3.15.2 使用 DirectMessageListenerContainer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-16-排他消费者"><span class="toc-text">3.3.16 排他消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-17-监听容器队列"><span class="toc-text">3.3.17 监听容器队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-18-弹性：从错误和broker失败中恢复"><span class="toc-text">3.3.18 弹性：从错误和broker失败中恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-18-1-自动声明交换，队列和绑定"><span class="toc-text">3.3.18.1 自动声明交换，队列和绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-18-2-同步操作失败和重试选项"><span class="toc-text">3.3.18.2 同步操作失败和重试选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-18-3-使用批处理侦听器重试"><span class="toc-text">3.3.18.3 使用批处理侦听器重试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-18-4-消息侦听器和异步情况"><span class="toc-text">3.3.18.4 消息侦听器和异步情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-18-5-Spring重试的异常分类"><span class="toc-text">3.3.18.5 Spring重试的异常分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-19-Debugging"><span class="toc-text">3.3.19 Debugging</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a></li></ol>
  </div>



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

    </div>

    

  </div>

  <footer class="footer text-center">
    <div id="bottom-inner">

      <a href="https://tuchong.com/16028574/" target="_blank">我的摄影</a> |
      <a href="http://zhongyp.me">DO IT</a> |
      <a href="https://github.com/zhongyp" target="_blank">GitHub</a> |
      <a href="http://hexo.io" target="_blank">Hexo</a> |
      <a href="https://github.com/zhongyp/hexo-theme-simple" target="_blank">Theme simple</a> |
      <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank">Base on theme microb</a> |
      <a><span id="busuanzi_container_site_pv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></a> |
      <a><span id="busuanzi_container_site_pv">本站访问量<span id="busuanzi_value_site_pv"></span>次</span></a>
    </div>
  </footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     *
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }

    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      // var menu = document.getElementById('menu-main-post');
      // if (menu) {
      //   var toc = document.getElementById('toc');
      //   if (toc) {
      //     menu.onclick = function() {
      //       if (toc) {
      //         if (toc.style.display == 'block') {
      //           toc.style.display = 'none';
      //         } else {
      //           toc.style.display = 'block';
      //         }
      //       }
      //     };
      //   } else {
      //     menu.style.display = 'none';
      //   }
      // }
    }

  })(window, document);
</script>


  



</body>
</html>
