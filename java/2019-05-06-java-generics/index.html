
<!DOCTYPE html>
<html lang="zh-Hans">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="google-site-verification" content="9GY-OrjvdT8TkXuLJFSJcJqolHfXKJ5NVYKRUv8mCRM">
  
    <meta name="keywords" content="Java,Java 泛型">
  

  
    <meta name="description" content="钟宇鹏的博客,钟宇鹏,个人博客">
  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" type="image/x-icon" href="/logo.png">
  <title>Java 泛型 [ zhongyp&#39;blog ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/pure.min.css">
    
      <link rel="stylesheet" href="/css/simple.css">
    
  
</head>


<body>
  <nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed">
  <ul class="pure-menu-list float-r clearfix">
    
      <!-- <li class="pure-menu-item toc-menu pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main-post" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
      </li> -->
      <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
        <ul class="pure-menu-children">
        
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
          
          
      </ul>
      </li>
    
  </ul>
  <a class="pure-menu-heading" href="/">
      <h1 class="title">zhongyp&#39;blog</h1>
      <!-- <span>钟宇鹏的博客</span> -->
  </a>
  <!-- 
  <img class="logo" id="logo" src="/logo.png" alt="logo">
   -->
</nav>


  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <article class="post" id="post">
  <header class="post-header text-center">
    <h1 class="title">
      Java 泛型
    </h1>
    
    <time class="time" datetime="2019-05-05T16:00:00.000Z">
      2019-05-06
    </time>
     |
    <span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
    <hr>
  </header>
  <div class="post-content">
    <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote>
<p><strong>其他参数术语：</strong><br>参数化的类型(parameterized type)：<code>List&lt;String&gt;</code><br>实际类型参数(type arguments)：<code>String</code><br>泛型(generic type)：<code>List&lt;E&gt;</code><br>形式类型参数(formal parameter types)：<code>E</code><br>无限制通配符类型(unbounded wildcards)：<code>List&lt;?&gt;</code><br>原生态类型(raw type)：<code>List</code><br>有限制类型参数(bounded type parameter)：<code>&lt;E extends Number&gt;</code><br>递归类型限制(recursive type restriction)：<code>&lt;T extends Comparable&lt;T&gt;&gt;</code><br>有限制通配符类型(bounded wildcards)：<code>List&lt;? extends Number&gt;</code><br>泛型方法(generic method)：<code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code><br>类型令牌(type token)：<code>String.class</code></p>
<p>– 摘自《Effective Java》</p>
</blockquote>
<p>Java集合有个缺点：集合对元素类型没有任何限制，这样就会引发一些问题，例如：创建一个只保存Dog对象的集合，但是程序也能将Cat对象放进去。由于把对象放进集合时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此去除集合元素后通常还需要进行强制类型转换。</p>
<p>为了解决上述问题，从JDK1.5之后，Java引入了“参数化类型（parameterized type）”的概念，Java的参数化类型被称为泛型（Generic）。</p>
<p>所谓泛型：就是允许在定义类、接口时指定类型形参（type parameters），这个类型形参将在声明变量、创建对象时确定。泛型的作用就是在编译时保证类型安全。</p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>定义泛型接口、类示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义接口时指定一个类型形参</span><br><span class="line">public interface List&lt;E&gt;&#123;</span><br><span class="line">    //在接口里，E可以作为类型使用</span><br><span class="line">    void add(E x);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    E asList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：</em></strong></p>
<ul>
<li>包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参(type arguments)，从而可以动态生成无数多个逻辑上的子类，但这种子类在物理上并不存在。</li>
<li>当创建泛型声明的自定义类，为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明。例如：为<code>Apple&lt;T&gt;</code>类定义构造器，其构造器名依然是<code>Apple</code>，而不是<code>Apple&lt;T&gt;</code>，但调用构造器时可以使用<code>Apple&lt;T&gt;</code>，此时T应该为实参类型。</li>
</ul>
<h3 id="2-1-从泛型类派生子类"><a href="#2-1-从泛型类派生子类" class="headerlink" title="2.1 从泛型类派生子类"></a>2.1 从泛型类派生子类</h3><p>当创建子类使用泛型接口或类时，不能再包含类型形参。如下代码时错误的：<br><code>public class A extends Apple&lt;T&gt;{}</code><br>正确方式如下：<br><code>public class A extends Apple&lt;String&gt;{}</code></p>
<p>类的静态变量和方法在所有的实例间共享，所以在静态方法、静态初始化或者静态变量的声明和初始化中不允许使用类型形参。原因见<a href="#4-3-不能声明静态字段的类型为类型参数">4.3 不能声明静态字段的类型为类型参数</a></p>
<p>由于系统对于泛型类或接口并不会生成真正的泛型类或接口（即逻辑上的子类，并不是生成真正的子类），所以instanceof运算符后不能使用泛型类。（具体原因见<a href="#4-4-不能使用参数化类型强制类型转换或者instanceof">4.4 不能使用参数化类型强制类型转换或者instanceof</a>）如下的代码时错误的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = new ArrayList&lt;String&gt;();</span><br><span class="line">if(cs instanceof List&lt;String&gt;)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-类型通配符"><a href="#2-2-类型通配符" class="headerlink" title="2.2 类型通配符"></a>2.2 类型通配符</h3><p>类型通配符既可以在方法签名中定义形参的类型，也可以用于定义变量的类型。使用通配符比显式声明通配符声明类型形参更加清晰准确，所以在可能的情况下，使用通配符更好。</p>
<h4 id="2-2-1-不受约束的通配符"><a href="#2-2-1-不受约束的通配符" class="headerlink" title="2.2.1 不受约束的通配符"></a>2.2.1 不受约束的通配符</h4><p>通配符可用于各种情况：作为参数，字段或局部变量的类型;有时作为返回类型（虽然更好的编程实践更具体）。通配符从不用作泛型方法调用，泛型类实例创建或超类型的类型参数。</p>
<p>如果满足下面的条件任意一个，就可以使用不受约束通配符：</p>
<ul>
<li>如果你正在编写可以<strong>使用Object类中提供的方法实现</strong>的方法。</li>
<li>当代码使用在泛型类中不依赖类型参数方法时。例如：List.size 或者 List.clear。 事实上，Class&lt;?&gt;经常被使用，因为Class<t>中的大多数方法不依赖T。</t></li>
</ul>
<p>使用通配符时，不能将元素放入未知类型的集合中。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aaa&quot;);//这行代码引起编译时错误。因为不知道list的类型，所以不能往里面放任何元素，除了null。</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-上限通配符"><a href="#2-2-2-上限通配符" class="headerlink" title="2.2.2 上限通配符"></a>2.2.2 上限通配符</h4><p>使用<code>? extend type</code>表示所有type泛型类的子类（包含type本身）。</p>
<h4 id="2-2-3-下限通配符"><a href="#2-2-3-下限通配符" class="headerlink" title="2.2.3 下限通配符"></a>2.2.3 下限通配符</h4><p>使用<code>? super type</code>表示所有type泛型类的父类（包含type本身）。<del>只能用于泛型方法（有待验证）。</del></p>
<h4 id="2-2-4-通配符捕获和Helper方法"><a href="#2-2-4-通配符捕获和Helper方法" class="headerlink" title="2.2.4 通配符捕获和Helper方法"></a>2.2.4 通配符捕获和Helper方法</h4><p>在一些情况下，编译器会推断一个通配符的类型。例如，一个列表可以被定义为<code>List&lt;?&gt;</code>，当评估一个表达式时，编译器会从代码中推断一个特定类型。此方案称为通配符捕获。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardError &#123;</span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.set(0, i.get(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>i.set</code>方法编译异常，类型参数<code>List&lt;?&gt;</code>为不确定类型参数，所以<code>i.get(0)</code>获取的类型参数不确定，因此<code>i.set</code>方法不能将未知类型放入<code>i</code>中。（其中i.set默认是i.set(Integer,Object)，因为不确定i.get(0)的类型，所以产生编译问题）解决方案如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardFixed &#123;</span><br><span class="line"></span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // Helper method created so that the wildcard can be captured</span><br><span class="line">    // through type inference.</span><br><span class="line">    private &lt;T&gt; void fooHelper(List&lt;T&gt; l) &#123;</span><br><span class="line">        l.set(0, l.get(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-通配符和子类型"><a href="#2-2-5-通配符和子类型" class="headerlink" title="2.2.5 通配符和子类型"></a>2.2.5 通配符和子类型</h4><p>如泛型，继承和子类型中所述，泛型类或接口仅仅因为它们的类型不同而无关。但是，您可以使用通配符在泛型类或接口之间创建关系。下图是Number和Integer之间的继承关系：<br><img src="/media/article/15579245029350.jpg" alt=""></p>
<h3 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c)&#123;</span><br><span class="line">    for(T o:a)&#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面示例中，定义了一个泛型方法，该泛型方法中定义了一个T类型形参，这个T类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型形参不同的是，方法声明中定义的形参只能在该方法里使用，而接口、类声明中的定义的类型形参则可以在整个接口、类中使用。<br>与类、接口中使用泛型参数不同的是，方法中的泛型参数无需显式传入实际类型参数，根据实参推断类型形参的值。如果编译器不能推断你希望它拥有的类型，可以通过一个显示的类型参数（explicit type parameter）来告诉它要使用哪种类型。<br>泛型方法的用法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,S&gt; 返回值类型 方法名（形参列表）&#123;</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong><em>提示：</em></strong><br>如果某个方法中一个形参（a）的类型或返回值类型依赖于另一个形参（b）的类型，则形参（b）的类型声明不应该使用通配符，因为形参（a）、或返回值与该形参（b）的类型，如果形参（b）的类型无法确定，程序无法定义形参（a）的类型。在这种情况下，<strong><em>只能考虑使用在方法签名中声明类型形参</em></strong>。</p>
</blockquote>
<p>类型通配符与显式声明类型形参区别：</p>
<ul>
<li>类型通配符即可在方法签名中定义形参的类型，也可以用于定义变量的类型。但泛型方法中类型形参必须在对应方法中显式声明。</li>
<li><strong><em>泛型方法允许类型形参用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系。如果没有这样的依赖关系，不应该使用泛型方法。</em></strong></li>
</ul>
<h3 id="2-4-泛型使用准则"><a href="#2-4-泛型使用准则" class="headerlink" title="2.4 泛型使用准则"></a>2.4 泛型使用准则</h3><blockquote>
<p>“in”变量：in变量向代码提供数据。想象复制方法有两个参数：<code>copy(src, dest)</code>。<code>src</code>参数提供复制数据，因此时”in”参数。<br>“out”变量：out变量保存数据以供其他地方使用。在复制的例子中，<code>copy(src, dest)</code>，<code>dest</code>参数接受数据，因此时”out”参数。</p>
</blockquote>
<ul>
<li>使用<code>extends</code>关键字定义带有上限通配符的“in”变量。</li>
<li>使用<code>super</code>关键字定义带有下限通配符的“out”变量。</li>
<li>在可以使用Object类中定义的方法访问“in”变量的情况下，使用无界通配符。</li>
<li>在代码需要作为“in”和“out”变量访问的情况下，不要使用通配符。</li>
</ul>
<h2 id="3-泛型的擦除与转换"><a href="#3-泛型的擦除与转换" class="headerlink" title="3. 泛型的擦除与转换"></a>3. 泛型的擦除与转换</h2><p>泛型被引入Java语言，以便在编译时提供更严格的类型检查并支持通用编程（向上兼容）。为了实现泛型，Java编译器将类型擦除应用于：</p>
<ul>
<li>使用边界替换所有在泛型中的类型参数或者如果类型参数是无界的则使用<code>Object</code>替换。因此生成的字节码只包含通用的类，接口和方法。</li>
<li>如果必要，插入类型强制转换来保证类型安全。</li>
<li>生成桥接方法以保留扩展泛型类型中的多态性。</li>
</ul>
<p>对于以上3点，1和3可能在<a href="#3-1-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E6%93%A6%E9%99%A4">3.1</a>和<a href="#3-2-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E6%A1%A5%E6%96%B9%E6%B3%95">3.2</a>中会详细说明，但是第二点可能不是那么清楚，如果有必要，类型擦除时，会进行强制类型转换。一般这种情况包括：</p>
<ul>
<li>方法的返回类型是类型参数；</li>
<li>在访问数据域时，域的类型是一个类型参数。</li>
</ul>
<p>例如：<br>项目中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println(list1.get(0));</span><br></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list1 = new ArrayList();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println((String)list1.get(0));</span><br></pre></td></tr></table></figure></p>
<p>字节码，字节码命令请参阅<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Chapter 6. The Java Virtual Machine Instruction Set</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">       0: new           #3                  // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #4                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #5                  // String Hell</span><br><span class="line">      11: invokeinterface #6,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      16: pop</span><br><span class="line">      17: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: iconst_0</span><br><span class="line">      22: invokeinterface #8,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">      27: checkcast     #9                  // class java/lang/String 强制类型转换校验是否为String类型</span><br><span class="line">      30: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      33: return</span><br></pre></td></tr></table></figure></p>
<p>上面的例子说明，编译器在擦除泛型代码时，确实保留了List<string>的相关信息，但是你无法找到列表对象本身的T=String，参阅自<a href="https://stackoverflow.com/questions/339699/java-generics-type-erasure-when-and-what-happens/339708#339708" target="_blank" rel="noopener">Java generics type erasure: when and what happens?</a>Jon Skeet的answer。</string></p>
<p>详细了解请参阅<a href="https://stackoverflow.com/questions/55084504/insert-type-casts-if-necessary-to-preserve-type-safety" target="_blank" rel="noopener">Insert type casts if necessary to preserve type safety</a></p>
<h3 id="3-1-泛型方法的擦除"><a href="#3-1-泛型方法的擦除" class="headerlink" title="3.1 泛型方法的擦除"></a>3.1 泛型方法的擦除</h3><p>Java编译器也会擦除泛型方法中的类型参数。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static &lt;T&gt; int count(T[] anArray, T elem)&#123;</span><br><span class="line"></span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(T e : anArray)&#123;</span><br><span class="line">        if(e.equals(elem))&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为T是无限制的，所以Java编译器会使用Object代替它，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int count(Object[] anArray, Object elem) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (Object e : anArray)</span><br><span class="line">        if (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-类型擦除的影响和桥方法"><a href="#3-2-类型擦除的影响和桥方法" class="headerlink" title="3.2 类型擦除的影响和桥方法"></a>3.2 类型擦除的影响和桥方法</h3><p>在编译扩展参数化类或实现参数化接口的类或接口时，编译器可能需要创建一个称为桥接方法的合成方法，作为类型擦除过程的一部分。您通常不需要担心桥接方法，但如果出现在堆栈跟踪中，您可能会感到困惑。</p>
<p>生成桥接方法以保留扩展泛型类型中的多态性。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T data;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = mn;            // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);     </span><br><span class="line">Integer x = mn.data;    // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p>
<p>类型擦除后, 代码变成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);</span><br><span class="line">Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p>
<p>代码执行逻辑如下：</p>
<p><code>n.setData(&quot;Hello&quot;)</code>使得MyNode类对象中的<code>setData(Object)</code>被执行。<br>在<code>setData(Object)</code>方法体内，对象的数据字段引用被分配为String。<br>通过mn引用的相同对象数据字段，可以访问、且期望是Interger类型。<br>尝试分配String到Integer造成ClassCastException。</p>
<p>类型擦除后代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    public Object data;</span><br><span class="line"></span><br><span class="line">    public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类型擦除之后，方法签名不匹配。 Node方法变为setData（Object），MyNode方法变为setData（Integer）。因此，MyNode setData方法不会覆盖Node setData方法。 为了解决这个问题并在类型擦除后保留泛型类型的多态性，Java编译器会生成一个桥接方法，以确保子类型按预期工作。对于MyNode类，编译器为setData生成以下桥接方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    // Bridge method generated by the compiler</span><br><span class="line">    //</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>桥接方法与类型擦除后的Node类的setData方法具有相同的方法签名，委托给原始的setData方法(桥接方法在字节码中可见，<code>javap -c class</code>)。</p>
<h3 id="3-3-不可具体化类型"><a href="#3-3-不可具体化类型" class="headerlink" title="3.3 不可具体化类型"></a>3.3 不可具体化类型</h3><p>可具体化类型是在运行时类型信息完全可用的一种类型。包括基本类型，非泛型类型，原始类型，无界的通配符调用。唯一可具体化参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<br>不可具体化类型是类型信息在编译时通过类型擦除被删除————调用未定义为无界通配符的泛型类型。不可具体化的类型在运行时不是所有信息都可用。不可具体化类型的示例是<code>List &lt;String&gt;</code>和<code>List &lt;Number&gt;</code>; JVM无法在运行时区分这些类型。如<a href="#4-泛型的限制">4 泛型的限制</a>中所示，在某些情况下，不能使用不可具体化的类型：例如，在<code>instanceof</code>表达式的实例中，或作为数组中的元素。</p>
<h3 id="3-4-堆污染"><a href="#3-4-堆污染" class="headerlink" title="3.4 堆污染"></a>3.4 堆污染</h3><p>堆污染发生在当参数化类型的变量引用不是该参数化类型的对象时。如果程序执行某些操作，在编译时产生未经检查的警告，则会出现这种情况。如果在编译时（在编译时类型检查规则的限制内）或在运行时，一个包含参数化类型操作的正确性不能被验证，则会生成未经检查的警告。例如，在混合原始类型和参数化类型时，或者在执行未经检查的强制转换时，会发生堆污染。</p>
<p>在通常情况下，当所有代码在相同时间被编译，编译器为潜在的堆污染产生一个未经检查警告来引起你的注意。如果你分开编译代码的各个部分，很难检查出堆污染的潜在风险。如果你确保你的代码编译没有警告，则不会有堆污染可以发生。</p>
<h3 id="3-5-使用不可具体化形参的可变参数方法的潜在漏洞"><a href="#3-5-使用不可具体化形参的可变参数方法的潜在漏洞" class="headerlink" title="3.5 使用不可具体化形参的可变参数方法的潜在漏洞"></a>3.5 使用不可具体化形参的可变参数方法的潜在漏洞</h3><p>包含可变输入参数泛型方法可以造成堆污染。<br>考虑如下class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBuilder &#123;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) &#123;</span><br><span class="line">    for (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void faultyMethod(List&lt;String&gt;... l) &#123;</span><br><span class="line">    Object[] objectArray = l;     // Valid</span><br><span class="line">    objectArray[0] = Arrays.asList(42);</span><br><span class="line">    String s = l[0].get(0);       // ClassCastException thrown here</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下例子，<code>HeapPollutionExample</code>使用<code>ArrayBuilder</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HeapPollutionExample &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stringListA = new ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; stringListB = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.addToList(stringListA, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;);</span><br><span class="line">    ArrayBuilder.addToList(stringListB, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listOfStringLists =</span><br><span class="line">      new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    ArrayBuilder.addToList(listOfStringLists,</span><br><span class="line">      stringListA, stringListB);</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当编译时，如下<code>ArrayBuilder.addToList</code>方法的定义将产生warning：<br><code>warning: [varargs] Possible heap pollution from parameterized vararg type T</code><br>当编译器遇到一个可变参数方法，它转换可变形参为数组。然而，Java编程语言不允许参数化类型数组的创建。在<code>ArrrayBuilder.addToList</code>方法中，编译器转换可变形参<code>T...</code>要素为<code>T[]</code>要素。因为类型擦除，编译器转换可变形参为<code>Object[]</code>要素。所以，有堆污染的可能性。<br>如下声明分配可变形参给对象数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray = l;</span><br></pre></td></tr></table></figure></p>
<p>这种声明可能引起堆污染。可以将与可变形参<code>l</code>的参数化类型匹配的值分配给变量objectArray，因此可以分配给<code>l</code>。然而，在此声明中，编译器不能生成一个未经检查警告。编译器早已在转换可变形参<code>List&lt;String&gt;...l</code> 到形参<code>List[] l</code>时生成警告。这个声明是有效的；<code>l</code>变量的类型是<code>List[]</code>，是<code>Object[]</code>的子类型。</p>
<p>因此，如果将任何类型的List对象分配给objectArray数组的任何数组组件，编译器不会发出警告或错误，如下所示：<br><code>ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</code><br>在运行时，JVM在以下语句中抛出<code>ClassCastException</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ClassCastException thrown here</span><br><span class="line">String s = l[0].get(0);</span><br></pre></td></tr></table></figure></p>
<p>存储在变量<code>l</code>的第一个数组组件中的对象具有<code>List&lt;Integer&gt;</code>类型，但此语句需要一个<code>List &lt;String&gt;</code>类型的对象。</p>
<h3 id="3-6-使用不可具体化的形参防止可变参数方法发出警告"><a href="#3-6-使用不可具体化的形参防止可变参数方法发出警告" class="headerlink" title="3.6 使用不可具体化的形参防止可变参数方法发出警告"></a>3.6 使用不可具体化的形参防止可变参数方法发出警告</h3><p>如果声明具有参数化类型参数的可变参数方法，并确保方法体不会因可变参数形参处理不当而抛出<code>ClassCastException</code>或其他类似异常，你可以通过给静态和非构造方法声明添加如下的注解防止编译器给这些可变参数方法生成警告：<br><code>@SafeVarargs</code><br><code>@SafeVarargs</code>注解是方法约定的记录部分;这个注释断言该方法的实现不会不正确地处理可变形参。<br> 尽管不太可取，但通过在方法声明中添加以下内容来消除此类警告也是可以的：<br><code>@SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})</code><br>但是，此方法不会消除从方法的调用点生成的警告。如果您不熟悉<code>@SuppressWarnings</code>语法，请参阅注释。</p>
<h2 id="4-泛型的限制"><a href="#4-泛型的限制" class="headerlink" title="4 泛型的限制"></a>4 泛型的限制</h2><h3 id="4-1-不能使用基本类型实例化通用类型"><a href="#4-1-不能使用基本类型实例化通用类型" class="headerlink" title="4.1 不能使用基本类型实例化通用类型"></a>4.1 不能使用基本类型实例化通用类型</h3><p>考虑如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public Pair(K key, V value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当创建一个<code>Pair</code>对象，你不能为类型参数<code>K</code>或者<code>V</code>替换成基本类型：<br><code>Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);  // compile-time error</code><br>你仅可以为类型参数<code>K</code>或者<code>V</code>替换非基本类型：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);</code><br>Java编译器自动装箱<code>8</code>为<code>Integer.valueOf(8)</code>和<code>a</code>为<code>Character(&#39;a&#39;)</code>：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character(&#39;a&#39;));</code></p>
<h3 id="4-2-不能创建类型参数实例"><a href="#4-2-不能创建类型参数实例" class="headerlink" title="4.2 不能创建类型参数实例"></a>4.2 不能创建类型参数实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">    E elem = new E();  // compile-time error</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一种解决方案，你可以创建一个类型参数对象通过反射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">    E elem = cls.newInstance();   // OK</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以调用<code>append</code>方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = new ArrayList&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-3-不能声明静态字段的类型为类型参数"><a href="#4-3-不能声明静态字段的类型为类型参数" class="headerlink" title="4.3 不能声明静态字段的类型为类型参数"></a>4.3 不能声明静态字段的类型为类型参数</h3><p>类的静态字段是类等级变量，被当前类的所有非静态对象共享。因此，类型参数的静态字段是不允许的。考虑如下类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MobileDevice&lt;T&gt; &#123;</span><br><span class="line">    private static T os;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果类型参数的静态字段被允许，如下的代码将会混乱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MobileDevice&lt;Smartphone&gt; phone = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;Pager&gt; pager = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;TabletPC&gt; pc = new MobileDevice&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>因为静态字段<code>os</code>被<code>phone</code>,<code>pager</code>和<code>pc</code>共享，什么是<code>os</code>的真实类型？在相同的时间它不可能是<code>Smartphone</code>，<code>Pager</code>，和<code>TablePc</code>。因此你不能创建类型参数静态字段。</p>
<h3 id="4-4-不能使用参数化类型强制类型转换或者instanceof"><a href="#4-4-不能使用参数化类型强制类型转换或者instanceof" class="headerlink" title="4.4 不能使用参数化类型强制类型转换或者instanceof"></a>4.4 不能使用参数化类型强制类型转换或者<code>instanceof</code></h3><p>因为Java编译器在泛型代码中擦除所有类型参数，您无法验证在运行时使用泛型类型的参数化类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传递到<code>rtti</code>方法的参数化类型集合是：<br><code>S = { ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, ... }</code><br>运行时不保持对类型参数的跟踪，因此它不能告诉<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>之间的不同。你最多是使用无限通配符来验证列表是否为ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;?&gt;) &#123;  // OK; instanceof requires a reifiable type</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，你不能强制转换参数化类型，除非它通过无限制通配符参数化。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  // compile-time error</span><br></pre></td></tr></table></figure></p>
<p>但是，在一些情况下，编译器知道类型参数总是有效的，允许强制类型转换。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  // OK</span><br></pre></td></tr></table></figure></p>
<h3 id="4-5-不能创建参数化类型的数组"><a href="#4-5-不能创建参数化类型的数组" class="headerlink" title="4.5 不能创建参数化类型的数组"></a>4.5 不能创建参数化类型的数组</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</span><br></pre></td></tr></table></figure></p>
<p>如下代码说明在不同类型插入列表是发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] strings = new String[2];</span><br><span class="line">strings[0] = &quot;hi&quot;;   // OK</span><br><span class="line">strings[1] = 100;    // An ArrayStoreException is thrown.</span><br></pre></td></tr></table></figure></p>
<p>如果你使用泛型列表尝试相同的事情，将会有如下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&apos;s allowed</span><br><span class="line">stringLists[0] = new ArrayList&lt;String&gt;();   // OK</span><br><span class="line">stringLists[1] = new ArrayList&lt;Integer&gt;();  // An ArrayStoreException should be thrown,</span><br><span class="line">                                            // but the runtime can&apos;t detect it.</span><br></pre></td></tr></table></figure></p>
<p> 如果参数化列表数组是允许的，之前的代码将失败抛出<code>ArrayStoreException</code>。</p>
<h3 id="4-6-不能创建、捕获或者抛出参数化类型对象"><a href="#4-6-不能创建、捕获或者抛出参数化类型对象" class="headerlink" title="4.6 不能创建、捕获或者抛出参数化类型对象"></a>4.6 不能创建、捕获或者抛出参数化类型对象</h3><p>泛型类也不能直接或间接继承自Throwable。原因是因为在编译期和运行时都必须知道异常的确切类型。例如如下类将不编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Extends Throwable indirectly</span><br><span class="line">class MathException&lt;T&gt; extends Exception &#123; /* ... */ &#125;    // compile-time error</span><br><span class="line"></span><br><span class="line">// Extends Throwable directly</span><br><span class="line">class QueueFullException&lt;T&gt; extends Throwable &#123; /* ... */ // compile-time error</span><br></pre></td></tr></table></figure></p>
<p>一个方法不能捕获一个类型参数的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (J job : jobs)</span><br><span class="line">            // ...</span><br><span class="line">    &#125; catch (T e) &#123;   // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，你可以在一个<code>throws</code>子句中使用类型参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parser&lt;T extends Exception&gt; &#123;</span><br><span class="line">    public void parse(File file) throws T &#123;     // OK</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出上述泛化的代码。</p>
<h3 id="4-7-不能重载形式类型参数擦除后相同原始类型的方法"><a href="#4-7-不能重载形式类型参数擦除后相同原始类型的方法" class="headerlink" title="4.7 不能重载形式类型参数擦除后相同原始类型的方法"></a>4.7 不能重载形式类型参数擦除后相同原始类型的方法</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public void print(Set&lt;String&gt; strSet) &#123; &#125;</span><br><span class="line">    public void print(Set&lt;Integer&gt; intSet) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重载将共享相同的类文件表示，并将生成编译时错误。</p>
<h2 id="5-泛型与数组"><a href="#5-泛型与数组" class="headerlink" title="5. 泛型与数组"></a>5. 泛型与数组</h2><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p>
<p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型<code>Sub[]</code>就是<code>Super[]</code>的子类型。<br>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</p>
<p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p>
<p>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</p>
<p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p>
<h2 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h2><p>如果以上都看完了，可以访问<a href="https://docs.oracle.com/javase/tutorial/java/generics/QandE/generics-questions.html" target="_blank" rel="noopener">Questions</a>试试自己是否真的懂了。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a><br><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">Effective Java</a><br><a href="https://docs.oracle.com/javase/tutorial/java/generics/" target="_blank" rel="noopener">Java Document Generic</a><br><a href="http://www.jiangjun.name/thinking-in-java/chapter15" target="_blank" rel="noopener">第十五章 泛型</a></p>

  </div>
  <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
            <strong>本文作者： </strong>zhongyp</li>
          <li class="post-copyright-link">
            <strong>本文链接：</strong>
            <a href="https://zhongyp.me/java/2019-05-06-java-generics/" title="使用simple主题并开始写作">https://zhongyp.me/java/2019-05-06-java-generics/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
        </ul>

  </div>
  <div class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="zhongyp.github.io/tags/Java/">Java</a></li></ul>
  </div>
</article>
  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="zhongyp.github.io/java/2019-05-02-effective-java/" rel="next" title="Effective Java">
          Effective Java
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="zhongyp.github.io/java/2019-05-19-javadoc-guide/" rel="prev" title="How to Write Doc Comments for the Javadoc Tool">
            How to Write Doc Comments for the Javadoc Tool
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-概念"><span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-使用"><span class="toc-text">2. 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-从泛型类派生子类"><span class="toc-text">2.1 从泛型类派生子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-类型通配符"><span class="toc-text">2.2 类型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-不受约束的通配符"><span class="toc-text">2.2.1 不受约束的通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-上限通配符"><span class="toc-text">2.2.2 上限通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-下限通配符"><span class="toc-text">2.2.3 下限通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-通配符捕获和Helper方法"><span class="toc-text">2.2.4 通配符捕获和Helper方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-通配符和子类型"><span class="toc-text">2.2.5 通配符和子类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-泛型方法"><span class="toc-text">2.3 泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-泛型使用准则"><span class="toc-text">2.4 泛型使用准则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-泛型的擦除与转换"><span class="toc-text">3. 泛型的擦除与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-泛型方法的擦除"><span class="toc-text">3.1 泛型方法的擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-类型擦除的影响和桥方法"><span class="toc-text">3.2 类型擦除的影响和桥方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-不可具体化类型"><span class="toc-text">3.3 不可具体化类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-堆污染"><span class="toc-text">3.4 堆污染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-使用不可具体化形参的可变参数方法的潜在漏洞"><span class="toc-text">3.5 使用不可具体化形参的可变参数方法的潜在漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-使用不可具体化的形参防止可变参数方法发出警告"><span class="toc-text">3.6 使用不可具体化的形参防止可变参数方法发出警告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-泛型的限制"><span class="toc-text">4 泛型的限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-不能使用基本类型实例化通用类型"><span class="toc-text">4.1 不能使用基本类型实例化通用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-不能创建类型参数实例"><span class="toc-text">4.2 不能创建类型参数实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-不能声明静态字段的类型为类型参数"><span class="toc-text">4.3 不能声明静态字段的类型为类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-不能使用参数化类型强制类型转换或者instanceof"><span class="toc-text">4.4 不能使用参数化类型强制类型转换或者instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-不能创建参数化类型的数组"><span class="toc-text">4.5 不能创建参数化类型的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-不能创建、捕获或者抛出参数化类型对象"><span class="toc-text">4.6 不能创建、捕获或者抛出参数化类型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-不能重载形式类型参数擦除后相同原始类型的方法"><span class="toc-text">4.7 不能重载形式类型参数擦除后相同原始类型的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-泛型与数组"><span class="toc-text">5. 泛型与数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIPs"><span class="toc-text">TIPs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用"><span class="toc-text">引用</span></a></li></ol>
  </div>



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

    </div>

    

  </div>

  <footer class="footer text-center">
    <div id="bottom-inner">

      <a href="http://programer.group" target="_blank">主站</a> |
      <a href="http://zhongyp.me">DO IT</a> |
      <a href="https://github.com/zhongyp" target="_blank">GitHub</a> |
      <a href="http://hexo.io" target="_blank">Hexo</a> |
      <a href="https://github.com/zhongyp/hexo-theme-simple" target="_blank">Theme simple</a> |
      <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank">Base on theme microb</a> |
      <a><span id="busuanzi_container_site_pv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></a> |
      <a><span id="busuanzi_container_site_pv">本站访问量<span id="busuanzi_value_site_pv"></span>次</span></a>
    </div>
  </footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     *
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }

    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      // var menu = document.getElementById('menu-main-post');
      // if (menu) {
      //   var toc = document.getElementById('toc');
      //   if (toc) {
      //     menu.onclick = function() {
      //       if (toc) {
      //         if (toc.style.display == 'block') {
      //           toc.style.display = 'none';
      //         } else {
      //           toc.style.display = 'block';
      //         }
      //       }
      //     };
      //   } else {
      //     menu.style.display = 'none';
      //   }
      // }
    }

  })(window, document);
</script>


  



</body>
</html>
