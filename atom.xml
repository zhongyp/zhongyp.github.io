<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhongyp&#39;blog</title>
  
  <subtitle>钟宇鹏的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhongyp.me/"/>
  <updated>2019-10-12T13:02:30.637Z</updated>
  <id>https://zhongyp.me/</id>
  
  <author>
    <name>zhongyp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK动态代理浅析</title>
    <link href="https://zhongyp.me/java/2019-10-04-jdk-proxy/"/>
    <id>https://zhongyp.me/java/2019-10-04-jdk-proxy/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-12T13:02:30.637Z</updated>
    
    <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><h2 id="1-使用JDK动态代理"><a href="#1-使用JDK动态代理" class="headerlink" title="1. 使用JDK动态代理"></a>1. 使用JDK动态代理</h2><p>JDK动态代理使用起来很简单，如下：</p><p>TestService是一个业务接口，接口中有个test方法， TestServiceImpl是TestService的实现类。<br>InvocationHandler是JDK动态代理的调用代理方法处理接口，我们JDK使用动态代理时需要实现这个接口，在这个接口的处理方法中编写处理逻辑，你想怎样控制目标方法的访问都可以在这个方法中实现。然后调用Proxy类的静态方法newProxyInstance方法即可获得到代理类实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        TestServiceImpl testService = new TestServiceImpl();</span><br><span class="line">        // 声明自己的处理类</span><br><span class="line">        MyInvokeHandler myInvokeHandler = new MyInvokeHandler(testService);</span><br><span class="line">        // 第一次生成代理类</span><br><span class="line">        TestService proxy = (TestService) Proxy.newProxyInstance(TestService.class.getClassLoader(),new Class[]&#123;TestService.class&#125;,myInvokeHandler);</span><br><span class="line">        // 代理类调用接口方法</span><br><span class="line">        proxy.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestServiceImpl implements TestService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;我要开始测试啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyInvokeHandler implements InvocationHandler&#123;</span><br><span class="line">    Object obj;</span><br><span class="line">    public MyInvokeHandler(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        //在反射调用之前，可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        method.invoke(obj,args);</span><br><span class="line">        //在反射调用之后，也可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface TestService&#123;</span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java通过<code>Proxy</code>类和<code>InvocationHandler</code>接口生成动态代理类<code>$Proxy0</code>。<code>Proxy</code>类是JDK生成动态代理的核心类，包含了JDK动态代理生成代理类的大部分逻辑。</p><!--![java-proxy](/media/article/java-proxy.001.png)--><h2 id="2-Java动态代理源码解析"><a href="#2-Java动态代理源码解析" class="headerlink" title="2. Java动态代理源码解析"></a>2. Java动态代理源码解析</h2><blockquote><p>Class对象每个类只有一个（同一个类加载器的情况下），该Class对象在类加载阶段生成，存储在内存中，非Java虚拟机堆，是该类对外访问的唯一入口。<a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-12.html#jls-12.4" target="_blank" rel="noopener">Java Language Specification 12.4</a></p></blockquote><p>Java生成动态代理类的核心方法是：ProxyClassFactory的<code>Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>。</p><p>参数：<code>ClassLoader loader</code>接口类加载器，<code>Class&lt;?&gt;[] interfaces</code>接口类的Class。</p><p>下面代码主要作用就是通过遍历接口数组，校验接口数组中的数据是否合法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 遍历接口类的Class数组</span><br><span class="line">  for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">      </span><br><span class="line">      Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          // 反射获得接口类Class对象</span><br><span class="line">          interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      // 校验是否是同一个类加载器，如果是不同的类加载器，生成的接口Class对象是不同的</span><br><span class="line">      if (interfaceClass != intf) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // Java动态代理仅支持接口代理</span><br><span class="line">      if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 使用Set来验证传入的接口数组中是否存在相同的接口</span><br><span class="line">      if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>下面这么多代码是为了给下面生成的代理类找到一个合理的包名和类名，如果接口数组中有非public属性的接口，如果此接口的包名不为null，则使用这个接口的包名，否则使用默认的<code>com.sun.proxy</code>包名，类名则是“上述包名+$Proxy+自增数字”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String proxyPkg = null;     </span><br><span class="line">int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">    int flags = intf.getModifiers();</span><br><span class="line">    if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">        accessFlags = Modifier.FINAL;</span><br><span class="line">        String name = intf.getName();</span><br><span class="line">        int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">        String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            proxyPkg = pkg;</span><br><span class="line">        &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (proxyPkg == null) &#123;</span><br><span class="line">    // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">    proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用自增数字区分不同的类</span><br><span class="line">long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br></pre></td></tr></table></figure><p>下面就是整个动态代理最核心的代码。生成代理类class文件的字节码，根据这个文件的字节码生成代理类的Class对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成字节数组，这个字节数组是生成的Class文件的字节数组，将这个字节流输出到class文件，就是上面的$Proxy0代理类。  </span><br><span class="line">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line"> proxyName, interfaces, accessFlags);</span><br><span class="line">try &#123;</span><br><span class="line"> // 通过刚才生成的代理类文件，生成代理类的Class对象。</span><br><span class="line"> return defineClass0(loader, proxyName,</span><br><span class="line">                     proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">&#125; catch (ClassFormatError e) &#123;</span><br><span class="line"> throw new IllegalArgumentException(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码仅仅是生成动态代理类的逻辑，不是JDK Proxy生成动态代理类实例的流程。</p><p>建议下面跟着源码一点点看如下的流程图。</p><p><img src="/media/article/weakcache.png" alt="weakcache"></p><p>第一个结构图是WeakCache的缓存结构图，WeakCache是Proxy的一个实例，每次去创建代理时，都会先去访问WeakCache，WeakCache中没有才会去创建。WeakCache采用两级缓存机制，第一层使用classloader生成的弱引用key，map实例valueMap的value在ConcurrentHashMap map中，valueMap是ConcurrentHasshMap， valueMap中使用接口数组（创建代理类传入的接口数组参数）生成的subKey，这个subKey不是弱引用，valueMap的value即可能是WeakCache.Factory实例，也可能是实现Supplier接口和继承WeakReference类的CacheValue实例。CacheValue用于封装动态生成的代理类的Class对象，WeakCache.Factory中包含生成动态代理类字节码和Class对象的逻辑，这个逻辑就是上面源码分析中的apply方法。<br>第二个是流程图，使用Proxy.newProxyInnstance生成动态代理类时，读取缓存的流程，结合着结构图和代码，应该可以理解JDK Proxy的整个缓存存储结构及读取流程。</p><p>生成的<code>$Proxy0</code>代理类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zhongyp.advanced.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">// 这个地方有两个接口，是因为我之前做测试的时候多加了一个TestService1接口。</span><br><span class="line">final class $Proxy0 extends Proxy implements TestService, TestService1 &#123;</span><br><span class="line"></span><br><span class="line">    // TestSerivce，TestService1两个接口总共就4个方法，test()，test1()，test3()，test4()，这里有7个方法，其中三个是hashCode，toString，equals。</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    private static Method m6;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m5;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 接口中的所有方法都会在代理类中生成，然后将代理类中的方法对象与方法名匹配放到InvocaotionHandler实现类实例的方法参数中</span><br><span class="line">    public final void test() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test3() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m4, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test4() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m6, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test1() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m5, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 动态代理在初始化是会初始化所有的方法对象</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m3 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test&quot;);</span><br><span class="line">            m4 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test3&quot;);</span><br><span class="line">            m6 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test4&quot;);</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m5 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test1&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于JDK动态代理的调用很简单，上面是我们上面的例子输出的动态代理类反编译的代码，我们看到接口中的每个方法<code>super.h.invoke(this, m5, (Object[])null)</code>，super就是Proxy，h是Proxy中的InvocationnHandler实例，InvocationHandler实例反射调用你的方法。InvocationHandler是在生成动态代理类的class对象后，创建动态代理类实例作为构造参数传进去的，所以虽然当前接口参数相同时，可能返回同一个动态代理类Class对象，但是只要InvocationHandler不同，他们就是不同的实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">    super(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/jdk-proxy-invoke.png" alt="jdk-proxy-invoke"></p><p>优点：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比cglib更加可靠。</li><li>平滑进行JDK版本升级，而字节码类库通常需要进行更新来保证在新版Java上能够使用。</li><li>代码实现简单。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>为什么JDK动态代理仅支持实现接口类的动态代理？</li></ol><p>这个问题我觉得可以从JDK做动态代理的初衷来说，JDK动态代理类是在运行时实现指定的接口列表的类，这个是JDK在设计实现动态代理最初就已经确定了的，所以可以看到在生成代理类的过程中，基本上就把接口类当作一个已知条件在使用，包括在定义缓存使用的subKey，代理类包名的生成规则中，反射获取Method对象等等地方，所以不存在为什么只支持实现接口类，而是JDK动态代理类的设计就是这样子的。</p><ol start="2"><li>为什么WeakCache采用两级缓存接口？</li></ol><p>这个问题我们可以从两个缓存的不同点来看，第一层缓存map是一个弱引用key，非弱引用valueMap，第二层缓存valueMap使用的是非弱引用subKey，弱引用CacheValue。我们都知道弱引用只要有垃圾回收时就会被回收，主要是为了防止缓存太多导致服务频繁的FullGC，所以第一层的作用就是当垃圾回收时，将缓存的valueMap全部清空。还有一个原因是第一层缓存使用的是classloader生成的key，所以map其实缓存的是所有当前同一个classloader生成的代理类的class对象。再说第二层缓存，第二层缓存使用的是创建代理类时传入的接口数组生成的subKey，这个是为了区分实现不同接口的动态代理类Class对象，如果说两个类都实现了同一个接口，那岂不是获取的同样的Class对象，这么说也是对的，区别在于实现的InvocationHandler接口的子类h不同，而这个h才是生成代理类实例的最终区别。第二层缓存为什么CacheValue使用弱引用，原因在于第一层缓存虽然key时弱引用，但是value不是，所以垃圾回收时只会回收key，不会回收value，value只会在下一次调用Proxy.newProxyInstance方法时才会去清空无效key的value。所以为了value能及时清空，所以CacheValue也使用了弱引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文承接自&lt;a href=&quot;/java/2019-09-09-java-proxy/&quot;&gt;动态代理浅析&lt;/a&gt;这篇文章，对代理没有什么概念的同学建议先读下这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;1-使用JDK动态代理&quot;&gt;&lt;a href=&quot;#1-使用JDK动态代理&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB浅析</title>
    <link href="https://zhongyp.me/java/2019-10-04-cglib/"/>
    <id>https://zhongyp.me/java/2019-10-04-cglib/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-17T03:38:50.630Z</updated>
    
    <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><p>本文打算从这几个方面来理解cglib怎样生成动态代理类的：</p><ol><li><a href="#1-使用Cglib动态代理">怎样使用cglib？</a></li><li><a href="#2-CGLIB原理解析">cglib怎样生成/缓存动态代理类实例的？</a></li><li><a href="#3-CGLIB代理类调用方法原理解析">cglib生成的动态代理类怎样调用的，过程是怎样的，这样有什么好处？</a></li><li>常见问题<a href="#FAQ">FAQ</a></li></ol><h2 id="1-使用Cglib动态代理"><a href="#1-使用Cglib动态代理" class="headerlink" title="1. 使用Cglib动态代理"></a>1. 使用Cglib动态代理</h2><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">LogInterceptor logInterceptor = new LogInterceptor();</span><br><span class="line">// 设置超类，cglib是通过继承来实现的</span><br><span class="line">enhancer.setSuperclass(UserDao.class);</span><br><span class="line">enhancer.setCallback(logInterceptor);</span><br><span class="line">/**</span><br><span class="line"> * 如果是实现指定接口</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// enhancer.setInterfaces(new Class[]&#123;Dao.class&#125;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果使用createClass方法返回值为代理类的Class对象，需要设置CallbackType参数，这个参数用来验证当使用create方法时，CallbackType和callback都不为空时，两者类型必须相等。</span><br><span class="line"> * create方法返回的是代理类实例</span><br><span class="line"> * enhancer.setCallbackType(LogInterceptor.class);</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 创建代理类</span><br><span class="line">Dao dao = (Dao)enhancer.create();</span><br><span class="line">dao.select();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">//        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">//        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao implements Dao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-CGLIB生成动态代理类的原理解析"><a href="#2-CGLIB生成动态代理类的原理解析" class="headerlink" title="2. CGLIB生成动态代理类的原理解析"></a>2. CGLIB生成动态代理类的原理解析</h2><p>cglib动态代理如果没有特殊设置也会缓存已生成的动态代理类的Class对象。cglib比JDK proxy更复杂一点。cglib封装了3层。</p><p><img src="/media/article/cglib-cache.png" alt="cglib-cache"></p><p>上图是cglib缓存动态代理类的Class对象的结构，建议先理解下存储结构再看下面的内容会更容易。</p><p>下图是cglib动态代理生成代理类实例的代码大致流程：<a href="/media/article/cglib-processor.png">点击看大图</a></p><p><img src="/media/article/cglib-processor.png"></p><p>cglib动态代理基于ASM技术，使用<a href="/java/2019-10-06-asm/">ASM</a>技术的部分就是图中标红的模块。</p><p>这里贴出的是cglib获取/生成动态代理类实例的源码流程，可以参考着上面的缓存结构了解cglib的生成及缓存的流程。</p><p>方法调用流程：</p><p><img src="/media/article/cglib-method-invoke.png" alt="cglib-invoke-method"></p><p>下面是一些比较核心的一些代码解析：</p><p>AbstractGenerator中的create(key)方法，key=KeyFactory.newInstance()。KeyFactory也是动态生成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 参数key是Enhancer.KeyFactory(superclassname)的实例，这个KeyFactory类也是cglib动态生成的，当你new Enhancer()时，Enhancer会动态的生成该实例对象，superclassname就是上面的UserDAO。</span><br><span class="line">protected Object create(Object key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ClassLoader loader = this.getClassLoader();</span><br><span class="line">        // CACHE时WeakHashMap 第一层缓存的容器</span><br><span class="line">        Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        // 第一层缓存 key是classLoader</span><br><span class="line">        AbstractClassGenerator.ClassLoaderData data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">        if (data == null) &#123;</span><br><span class="line">            Class var5 = AbstractClassGenerator.class;</span><br><span class="line">            // 加锁意义在于CACHE时静态变量，属于该类，不是该实例对象，所以线程安全需要加锁。</span><br><span class="line">            synchronized(AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">                if (data == null) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; newCache = new WeakHashMap(cache);</span><br><span class="line">                    // 创建第二层缓存容器</span><br><span class="line">                    data = new AbstractClassGenerator.ClassLoaderData(loader);</span><br><span class="line">                    // 将第二层缓存容器放入第一层容器内，key为classloader</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.key = key;</span><br><span class="line">        // 使用ClassLoaderData data获取Enhancer.EnhancerFactoryData对象，Enhancer.EnhancerFactoryData对象中是代理类的Class对象，也可以直接获取KeyFactory的Class对象</span><br><span class="line">        Object obj = data.get(this, this.getUseCache());</span><br><span class="line">        // firstInstance主要是针对KeyFactory生成的Class对象，例如接口方法生成的MethodWraper的代理类Class对象，nextInstance针对Enhancer实例生成的Enhancer.EnhancerFactoryData实例，实例中存储着真正的代理类的Class对象，如果生成的代理类中有接口方法，生成代理类时，会生成接口方法的MethodWrapper的代理类实例。</span><br><span class="line">        return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);</span><br><span class="line">    &#125; catch (Error | RuntimeException var9) &#123;</span><br><span class="line">        throw var9;</span><br><span class="line">    &#125; catch (Exception var10) &#123;</span><br><span class="line">        throw new CodeGenerationException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ClassLoaderData的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoaderData(ClassLoader classLoader) &#123;</span><br><span class="line">  if (classLoader == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;classLoader == null is not yet supported&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // 首先你用弱引用封装classLoader，垃圾回收时可以直接回收</span><br><span class="line">      this.classLoader = new WeakReference(classLoader);</span><br><span class="line">      Function&lt;AbstractClassGenerator, Object&gt; load = new Function&lt;AbstractClassGenerator, Object&gt;() &#123;</span><br><span class="line">          public Object apply(AbstractClassGenerator gen) &#123;</span><br><span class="line">              Class klass = gen.generate(ClassLoaderData.this);</span><br><span class="line">              // 这里需要注意gen是Enhancer子类实例，还是KeyFactory$Genertor实例，两者的包装方式完全不一样，使用的数据结构也不一样。Enhancer使用EnhancerFactoryData，KeyFactory$Genertor使用LoadingCache</span><br><span class="line">              return gen.wrapCachedClass(klass);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      // this.generatedClasses的key是KeyFactory根据superclassName生成的key实例，将load放入LoadingCache，等下如果LoadingCache的map获取代理类为null，需要回调这个load重新生成代理类</span><br><span class="line">      this.generatedClasses = new LoadingCache(GET_KEY, load);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LoadingCache中的核心方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// key是Enhancer实例，或者是KeyFactory$Generator实例</span><br><span class="line">public V get(K key) &#123;</span><br><span class="line">   KK cacheKey = this.keyMapper.apply(key);</span><br><span class="line">   Object v = this.map.get(cacheKey);</span><br><span class="line">   return v != null &amp;&amp; !(v instanceof FutureTask) ? v : this.createEntry(key, cacheKey, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected V createEntry(final K key, KK cacheKey, Object v) &#123;</span><br><span class="line">   boolean creator = false;</span><br><span class="line">   FutureTask task;</span><br><span class="line">   Object result;</span><br><span class="line">   if (v != null) &#123;</span><br><span class="line">       task = (FutureTask)v;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       task = new FutureTask(new Callable&lt;V&gt;() &#123;</span><br><span class="line">           public V call() throws Exception &#123;</span><br><span class="line">               // 回调AbstractGenerator.ClassLoaderData构造器中的load</span><br><span class="line">               return LoadingCache.this.loader.apply(key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 获取map中的value，如果是Enhancer.EnhancerFactoryData就直接返回，如果不是，继续往下获取Class对象</span><br><span class="line">       result = this.map.putIfAbsent(cacheKey, task);</span><br><span class="line">       // 如果等于null，需要重新生成</span><br><span class="line">       if (result == null) &#123;</span><br><span class="line">           creator = true;</span><br><span class="line">           task.run();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (!(result instanceof FutureTask)) &#123;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           task = (FutureTask)result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">       result = task.get();</span><br><span class="line">   &#125; catch (InterruptedException var9) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Interrupted while loading cache item&quot;, var9);</span><br><span class="line">   &#125; catch (ExecutionException var10) &#123;</span><br><span class="line">       Throwable cause = var10.getCause();</span><br><span class="line">       if (cause instanceof RuntimeException) &#123;</span><br><span class="line">           throw (RuntimeException)cause;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       throw new IllegalStateException(&quot;Unable to load cache item&quot;, cause);</span><br><span class="line">   &#125;</span><br><span class="line">   // 新建的Class对象或者Enhancer.EnhancerFactoryData需要存起来</span><br><span class="line">   if (creator) &#123;</span><br><span class="line">       this.map.put(cacheKey, result);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Enhancer中的操作class字节码的ASM技术：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public void generateClass(ClassVisitor v) throws Exception &#123;</span><br><span class="line">   Class sc = this.superclass == null ? Object.class : this.superclass;</span><br><span class="line">   if (TypeUtils.isFinal(sc.getModifiers())) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Cannot subclass final class &quot; + sc.getName());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">       this.filterConstructors(sc, constructors);</span><br><span class="line">       List actualMethods = new ArrayList();</span><br><span class="line">       List interfaceMethods = new ArrayList();</span><br><span class="line">       final Set forcePublic = new HashSet();</span><br><span class="line">       // 将接口中的方法获取放入到forcePublic中，获取的其实是KeyFactory生成的MethodWrapper实例 select,&#125;, void</span><br><span class="line">       // actualMethods是一个包含所有方法的数组，值类似public void com.zhongyp.advanced.proxy.cglib.UserDao.update()</span><br><span class="line">       getMethods(sc, this.interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line">       // 获取到所有的方法及访问标识</span><br><span class="line">       List methods = CollectionUtils.transform(actualMethods, new Transformer() &#123;</span><br><span class="line">           public Object transform(Object value) &#123;</span><br><span class="line">               Method method = (Method)value;</span><br><span class="line">               int modifiers = 16 | method.getModifiers() &amp; -1025 &amp; -257 &amp; -33;</span><br><span class="line">               if (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                   // 如果接口中有相同的方法，</span><br><span class="line">                   modifiers = modifiers &amp; -5 | 1;</span><br><span class="line">               &#125;</span><br><span class="line">               return ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 下面就是ASM的操作逻辑了</span><br><span class="line">       ClassEmitter e = new ClassEmitter(v);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), Type.getType(sc), this.useFactory ? TypeUtils.add(TypeUtils.getTypes(this.interfaces), FACTORY) : TypeUtils.getTypes(this.interfaces), &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), (Type)null, new Type[]&#123;FACTORY&#125;, &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line">       e.declare_field(2, &quot;CGLIB$BOUND&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       e.declare_field(9, &quot;CGLIB$FACTORY_DATA&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (!this.interceptDuringConstruction) &#123;</span><br><span class="line">           e.declare_field(2, &quot;CGLIB$CONSTRUCTED&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(26, &quot;CGLIB$THREAD_CALLBACKS&quot;, THREAD_LOCAL, (Object)null);</span><br><span class="line">       e.declare_field(26, &quot;CGLIB$STATIC_CALLBACKS&quot;, CALLBACK_ARRAY, (Object)null);</span><br><span class="line">       if (this.serialVersionUID != null) &#123;</span><br><span class="line">           e.declare_field(26, &quot;serialVersionUID&quot;, Type.LONG_TYPE, this.serialVersionUID);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for(int i = 0; i &lt; this.callbackTypes.length; ++i) &#123;</span><br><span class="line">           e.declare_field(2, getCallbackField(i), this.callbackTypes[i], (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(10, &quot;CGLIB$CALLBACK_FILTER&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           this.emitMethods(e, methods, actualMethods);</span><br><span class="line">           this.emitConstructors(e, constructorInfo);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.emitDefaultConstructor(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       this.emitSetThreadCallbacks(e);</span><br><span class="line">       this.emitSetStaticCallbacks(e);</span><br><span class="line">       this.emitBindCallbacks(e);</span><br><span class="line">       if (this.useFactory || this.currentData != null) &#123;</span><br><span class="line">           int[] keys = this.getCallbackKeys();</span><br><span class="line">           this.emitNewInstanceCallbacks(e);</span><br><span class="line">           this.emitNewInstanceCallback(e);</span><br><span class="line">           this.emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">           this.emitGetCallback(e, keys);</span><br><span class="line">           this.emitSetCallback(e, keys);</span><br><span class="line">           this.emitGetCallbacks(e);</span><br><span class="line">           this.emitSetCallbacks(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.end_class();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-CGLIB代理类调用方法原理解析"><a href="#3-CGLIB代理类调用方法原理解析" class="headerlink" title="3. CGLIB代理类调用方法原理解析"></a>3. CGLIB代理类调用方法原理解析</h2><p>使用<code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;./&quot;)</code>可以输出生成的代理类的class文件，CGLIB调用方法使用的是FastClass机制，这种机制不需要反射即可调用目标方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zhongyp.advanced.proxy.cglib;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import org.springframework.cglib.core.ReflectUtils;</span><br><span class="line">import org.springframework.cglib.core.Signature;</span><br><span class="line">import org.springframework.cglib.proxy.Callback;</span><br><span class="line">import org.springframework.cglib.proxy.Factory;</span><br><span class="line">import org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line">import org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">public class UserDao$$EnhancerByCGLIB$$c00e2e9b extends UserDao implements Factory &#123;</span><br><span class="line">    private boolean CGLIB$BOUND;</span><br><span class="line">    public static Object CGLIB$FACTORY_DATA;</span><br><span class="line">    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    private static final Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    private MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    private static Object CGLIB$CALLBACK_FILTER;</span><br><span class="line">    private static final Method CGLIB$update$0$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$update$0$Proxy;</span><br><span class="line">    private static final Object[] CGLIB$emptyArgs;</span><br><span class="line">    private static final Method CGLIB$select$1$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$select$1$Proxy;</span><br><span class="line">    private static final Method CGLIB$equals$2$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$equals$2$Proxy;</span><br><span class="line">    private static final Method CGLIB$toString$3$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$toString$3$Proxy;</span><br><span class="line">    private static final Method CGLIB$hashCode$4$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$hashCode$4$Proxy;</span><br><span class="line">    private static final Method CGLIB$clone$5$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$clone$5$Proxy;</span><br><span class="line"></span><br><span class="line">    static void CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = new ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = new Object[0];</span><br><span class="line">        // 获取代理类的Class对象</span><br><span class="line">        Class var0 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao$$EnhancerByCGLIB$$c00e2e9b&quot;);</span><br><span class="line">        Class var1;</span><br><span class="line">        // 获取所有的方法对象</span><br><span class="line">        Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;update&quot;, &quot;()V&quot;, &quot;select&quot;, &quot;()V&quot;&#125;, (var1 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao&quot;)).getDeclaredMethods());</span><br><span class="line">        CGLIB$update$0$Method = var10000[0];</span><br><span class="line">        CGLIB$update$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;update&quot;, &quot;CGLIB$update$0&quot;);</span><br><span class="line">        CGLIB$select$1$Method = var10000[1];</span><br><span class="line">        CGLIB$select$1$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;select&quot;, &quot;CGLIB$select$1&quot;);</span><br><span class="line">        var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;&#125;, (var1 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods());</span><br><span class="line">        CGLIB$equals$2$Method = var10000[0];</span><br><span class="line">        CGLIB$equals$2$Proxy = MethodProxy.create(var1, var0, &quot;(Ljava/lang/Object;)Z&quot;, &quot;equals&quot;, &quot;CGLIB$equals$2&quot;);</span><br><span class="line">        CGLIB$toString$3$Method = var10000[1];</span><br><span class="line">        CGLIB$toString$3$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/String;&quot;, &quot;toString&quot;, &quot;CGLIB$toString$3&quot;);</span><br><span class="line">        CGLIB$hashCode$4$Method = var10000[2];</span><br><span class="line">        CGLIB$hashCode$4$Proxy = MethodProxy.create(var1, var0, &quot;()I&quot;, &quot;hashCode&quot;, &quot;CGLIB$hashCode$4&quot;);</span><br><span class="line">        CGLIB$clone$5$Method = var10000[3];</span><br><span class="line">        CGLIB$clone$5$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/Object;&quot;, &quot;clone&quot;, &quot;CGLIB$clone$5&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void CGLIB$update$0() &#123;</span><br><span class="line">        super.update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void update() &#123;</span><br><span class="line">        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (var10000 != null) &#123;</span><br><span class="line">            var10000.intercept(this, CGLIB$update$0$Method, CGLIB$emptyArgs, CGLIB$update$0$Proxy);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void CGLIB$select$1() &#123;</span><br><span class="line">        super.select();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void select() &#123;</span><br><span class="line">        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (var10000 != null) &#123;</span><br><span class="line">            var10000.intercept(this, CGLIB$select$1$Method, CGLIB$emptyArgs, CGLIB$select$1$Proxy);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.select();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final boolean CGLIB$equals$2(Object var1) &#123;</span><br><span class="line">        return super.equals(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) &#123;</span><br><span class="line">        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (var10000 != null) &#123;</span><br><span class="line">            Object var2 = var10000.intercept(this, CGLIB$equals$2$Method, new Object[]&#123;var1&#125;, CGLIB$equals$2$Proxy);</span><br><span class="line">            return var2 == null ? false : (Boolean)var2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.equals(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String CGLIB$toString$3() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() &#123;</span><br><span class="line">        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var10000 != null ? (String)var10000.intercept(this, CGLIB$toString$3$Method, CGLIB$emptyArgs, CGLIB$toString$3$Proxy) : super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int CGLIB$hashCode$4() &#123;</span><br><span class="line">        return super.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (var10000 != null) &#123;</span><br><span class="line">            Object var1 = var10000.intercept(this, CGLIB$hashCode$4$Method, CGLIB$emptyArgs, CGLIB$hashCode$4$Proxy);</span><br><span class="line">            return var1 == null ? 0 : ((Number)var1).intValue();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Object CGLIB$clone$5() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var10000 != null ? var10000.intercept(this, CGLIB$clone$5$Method, CGLIB$emptyArgs, CGLIB$clone$5$Proxy) : super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MethodProxy CGLIB$findMethodProxy(Signature var0) &#123;</span><br><span class="line">        String var10000 = var0.toString();</span><br><span class="line">        switch(var10000.hashCode()) &#123;</span><br><span class="line">        case -1949253108:</span><br><span class="line">            if (var10000.equals(&quot;update()V&quot;)) &#123;</span><br><span class="line">                return CGLIB$update$0$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case -1716030215:</span><br><span class="line">            if (var10000.equals(&quot;select()V&quot;)) &#123;</span><br><span class="line">                return CGLIB$select$1$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case -508378822:</span><br><span class="line">            if (var10000.equals(&quot;clone()Ljava/lang/Object;&quot;)) &#123;</span><br><span class="line">                return CGLIB$clone$5$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1826985398:</span><br><span class="line">            if (var10000.equals(&quot;equals(Ljava/lang/Object;)Z&quot;)) &#123;</span><br><span class="line">                return CGLIB$equals$2$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1913648695:</span><br><span class="line">            if (var10000.equals(&quot;toString()Ljava/lang/String;&quot;)) &#123;</span><br><span class="line">                return CGLIB$toString$3$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1984935277:</span><br><span class="line">            if (var10000.equals(&quot;hashCode()I&quot;)) &#123;</span><br><span class="line">                return CGLIB$hashCode$4$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UserDao$$EnhancerByCGLIB$$c00e2e9b() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        UserDao$$EnhancerByCGLIB$$c00e2e9b var1 = (UserDao$$EnhancerByCGLIB$$c00e2e9b)var0;</span><br><span class="line">        if (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = true;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            if (var10000 == null) &#123;</span><br><span class="line">                var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">                if (CGLIB$STATIC_CALLBACKS == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newInstance(Callback[] var1) &#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var1);</span><br><span class="line">        UserDao$$EnhancerByCGLIB$$c00e2e9b var10000 = new UserDao$$EnhancerByCGLIB$$c00e2e9b();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);</span><br><span class="line">        return var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newInstance(Callback var1) &#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(new Callback[]&#123;var1&#125;);</span><br><span class="line">        UserDao$$EnhancerByCGLIB$$c00e2e9b var10000 = new UserDao$$EnhancerByCGLIB$$c00e2e9b();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);</span><br><span class="line">        return var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) &#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var3);</span><br><span class="line">        UserDao$$EnhancerByCGLIB$$c00e2e9b var10000 = new UserDao$$EnhancerByCGLIB$$c00e2e9b;</span><br><span class="line">        switch(var1.length) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            var10000.&lt;init&gt;();</span><br><span class="line">            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);</span><br><span class="line">            return var10000;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;Constructor not found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Callback getCallback(int var1) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">        MethodInterceptor var10000;</span><br><span class="line">        switch(var1) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            var10000 = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCallback(int var1, Callback var2) &#123;</span><br><span class="line">        switch(var1) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            this.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;</span><br><span class="line">        default:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">        return new Callback[]&#123;this.CGLIB$CALLBACK_0&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCallbacks(Callback[] var1) &#123;</span><br><span class="line">        this.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似cglib动态代理就没有这种限制。</li><li>只操作我们关心的类，不必为其他相关类增加工作量。</li><li>高性能，高性能体现方法的调用上，cglib的方法调用为FastClass机制，JDK Proxy为反射调用。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>cglib针对final方法怎么处理的呢？</li><li>CGLib动态代理是通过字节码底层继承要代理类来实现，如果被代理类被final关键字所修饰，那么代理会失败么？</li><li>cglib到底比JDk Proxy快在哪里？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文承接自&lt;a href=&quot;/java/2019-09-09-java-proxy/&quot;&gt;动态代理浅析&lt;/a&gt;这篇文章，对代理没有什么概念的同学建议先读下这篇文章。&lt;/p&gt;
&lt;p&gt;本文打算从这几个方面来理解cglib怎样生成动态代理类的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://zhongyp.me/java/2019-10-04-reflection/"/>
    <id>https://zhongyp.me/java/2019-10-04-reflection/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-12T02:22:06.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-反射"><a href="#1-反射" class="headerlink" title="1. 反射"></a>1. 反射</h2><p>Java 动态代理中除了字节码增强技术外，最主要的就是Java的反射机制。</p><blockquote><p>Reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible. –引用自<a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a><br>译：反射通常在程序需要检查或者修改在JVM虚拟机中的应用的运行时行为的能力时被使用。 这是比较高级的特性，仅仅应该被掌握该编程语言基础知识的开发者使用。考虑到这一警告，反射是一种强大的技术，可以使应用程序执行原本不可能的操作。</p></blockquote><p>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p><p>反射接口API：</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>反射调用慢在哪里？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-反射&quot;&gt;&lt;a href=&quot;#1-反射&quot; class=&quot;headerlink&quot; title=&quot;1. 反射&quot;&gt;&lt;/a&gt;1. 反射&lt;/h2&gt;&lt;p&gt;Java 动态代理中除了字节码增强技术外，最主要的就是Java的反射机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Re
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AspectJ</title>
    <link href="https://zhongyp.me/java/2019-10-04-aspectj/"/>
    <id>https://zhongyp.me/java/2019-10-04-aspectj/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-09T08:59:33.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-1-3-AspectJ"><a href="#3-1-3-AspectJ" class="headerlink" title="3.1.3 AspectJ"></a>3.1.3 AspectJ</h3><p>AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言。当然，AspectJ需要使用额外的编译器。</p><p>AspectJ可以通过多种方式实现，包括源码织入或字节码织入，并且可以直接在虚拟机（VM）中实现。在所有情况下，AspectJ程序都将成为在Java VM中运行的有效Java程序。受切面影响的类与不受影响的类具有二进制兼容性（以保持与不受影响的原始文件编译的类兼容）。支持多种实现方式使该语言可以随着技术的变化而发展，并且与Java兼容可确保平台可用性。<br>AspectJ采用编译期织入和类加载期织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<br>使用AspectJ LTW有两个主要步骤，第一，通过JVM的-javaagent参数设置LTW的织入器类包，以代理JVM默认的类加载器；第二，LTW织入器需要一个aop.xml文件，在该文件中指定切面类和需要进行切面织入的目标类。</p><p>设置-javaagent JVM参数的方法:<br>(1)在Eclipse下的设置:<br>运行类-&gt;右键单击-&gt;Run As-&gt;Run…，可以在弹出的Run设置窗口设置该类的各项运行属性，切换到Arguments Tab页，在VM arguments中通过-javaagent指定AspectJ 织入器类包。-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar<br>(2)在Tomcat下的设置<br>打开&lt;Tomcat_Home&gt;\bin\catalina.bat，在该批处理文件头部添加以下的设置：<br>set JAVA_OPTS=-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;3-1-3-AspectJ&quot;&gt;&lt;a href=&quot;#3-1-3-AspectJ&quot; class=&quot;headerlink&quot; title=&quot;3.1.3 AspectJ&quot;&gt;&lt;/a&gt;3.1.3 AspectJ&lt;/h3&gt;&lt;p&gt;AspectJ是目前实现AOP框架中最成熟，功能最丰
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>知识结构图</title>
    <link href="https://zhongyp.me/java/2019-09-29-knowledge-structure/"/>
    <id>https://zhongyp.me/java/2019-09-29-knowledge-structure/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2019-09-29T01:51:10.571Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/article/knowledge-structure.png" alt="knowledge-structure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/article/knowledge-structure.png&quot; alt=&quot;knowledge-structure&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>闲谈Java引用</title>
    <link href="https://zhongyp.me/java/2019-09-15-reference/"/>
    <id>https://zhongyp.me/java/2019-09-15-reference/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-23T11:33:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。</p><h2 id="1-强引用-StrongReference"><a href="#1-强引用-StrongReference" class="headerlink" title="1. 强引用(StrongReference)"></a>1. 强引用(StrongReference)</h2><p>Java中最常见的引用方式。当一个对象被一个或者一个以上的引用变量引用时，它处于激活状态，不可能被系统垃圾回收机制回收。</p><h2 id="2-软引用-SoftReference"><a href="#2-软引用-SoftReference" class="headerlink" title="2. 软引用(SoftReference)"></a>2. 软引用(SoftReference)</h2><p>软引用需要通过SoftRefrence类来实现，当一个对象只具有软引用时，可能被垃圾回收机制回收。当系统内存空间足够时，它不会被系统回收，当系统内存空间不够时，系统将会回收。</p><p>和弱引用的区别仅仅在于垃圾回收时， 是否根据空间大小回收的区别。</p><p>何时回收软引用的对象？</p><p>从1.3.1开始软可达对象将在最后被引用之后存活一段时间。默认值是堆中每MB空闲空间一秒的生存时间。这个值可以使用<code>-XX:SoftRefLRUPolicyMSPerMB</code>调整。<br>Java Hotspot服务端虚拟机使用最大可能的堆大小计算剩余可用空间。<br>Java Hotspot客户端虚拟机使用当前堆大小计算空闲空间。<br>这就意味着对于服务端虚拟机总体趋势是增长堆而不是清理软引用，因此在垃圾回收时<code>-Xmx</code>对软引用的回收有重要的影响。<br>相反，客户端虚拟机将很大趋势去清理软引用而不是增长堆。</p><p>上述行为对于1.3.1到Java SE 6版本的Java HotSpot VM都是正确的。但是，此行为不是VM规范的一部分，并且在将来的版本中可能会更改。同样，不保证-XX：SoftRefLRUPolicyMSPerMB标志在任何给定的发行版中均不存在。</p><p>在1.3.1版之前，Java HotSpot VM会在发现软引用时清除它们。</p><p>当我定期打开-verbose：gc时，我得到了很多完整的GC，已经调整了堆并且没有什么区别，这是怎么回事？</p><p>如果您使用的是RMI，则可能会遇到分布式GC。另外，某些应用程序添加了显式GC的思想，即它将使它们的应用程序更快。幸运的是，您可以在1.3及更高版本中使用命令行选项禁用此功能。尝试将-XX：+ DisableExplicitGC与-verbose：gc一起使用，看看是否有帮助。</p><h2 id="3-虚引用-PhantomReference"><a href="#3-虚引用-PhantomReference" class="headerlink" title="3. 虚引用(PhantomReference)"></a>3. 虚引用(PhantomReference)</h2><p>虚引用通过PhantomReference实现，虚引用类似于完全没有引用，虚引用对对象本身没有太大的影响。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列(ReferenceQueue)联合使用。</p><p>举例来说就是，如果垃圾回收时，发现一个实例对象除了虚引用外没有任何其他的引用，将会把这个引用放到<br><code>java.lang.ref.Reference.pending</code>队列里，GC完成时，通知ReferenceHandler这个守护线程做一些后续处理（如释放内存等等操作）。</p><h2 id="4-弱引用-WeakReference"><a href="#4-弱引用-WeakReference" class="headerlink" title="4. 弱引用(WeakReference)"></a>4. 弱引用(WeakReference)</h2><p>弱引用通过WeakReference类实现，对只有弱引用的对象而言，当系统垃圾回收机制运行时，不管内存是否足够，总会回收该对象所占用的内存。</p><h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue referenceQueue = new ReferenceQueue();</span><br><span class="line">WeakReference weakReference = new WeakReference(new TestEntity(), referenceQueue);</span><br><span class="line">((TestEntity) weakReference.get()).test();</span><br></pre></td></tr></table></figure><p>ReferenceQueue的作用是为了查看哪些WeakReference和SoftReferece被回收了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p><p><a href="https://www.jianshu.com/p/e66930caca9c" target="_blank" rel="noopener">Java PhantomReference详解</a></p><p><a href="oracle.com/technetwork/java/hotspotfaq-138619.html#gc_softrefs">Frequently Asked Questions About the Java HotSpot VM</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。&lt;/p&gt;
&lt;h2 id=&quot;1-强引用-StrongReference&quot;&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机知识点架构图</title>
    <link href="https://zhongyp.me/jvm/2019-09-08-jvm-structure/"/>
    <id>https://zhongyp.me/jvm/2019-09-08-jvm-structure/</id>
    <published>2019-09-07T16:00:00.000Z</published>
    <updated>2019-09-08T12:59:18.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/article/jvm-structure.png" alt="jvm-structure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/article/jvm-structure.png&quot; alt=&quot;jvm-structure&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhongyp.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>动态代理浅析</title>
    <link href="https://zhongyp.me/java/2019-09-09-java-proxy/"/>
    <id>https://zhongyp.me/java/2019-09-09-java-proxy/</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2019-10-09T12:25:46.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是动态代理？"><a href="#1-什么是动态代理？" class="headerlink" title="1. 什么是动态代理？"></a>1. 什么是动态代理？</h2><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问，而不是增强目标对象的功能。</p><blockquote><p>访问控制包括同步，身份验证，远程访问（RPC），惰性实例化（休眠，Mybatis），AOP（事务）。</p></blockquote><p><img src="/media/article/proxy-invoke-method.png" alt="代理方法调用"></p><p>实现代理的技术有很多，如 CGLIB(ASM)、AspectJ、Javassist、JDK Proxy等。</p><ul><li>ASM: 针对<strong><em>运行时</em></strong>动态生成和转换类（class）的Java语言工具，旨在处理已编译的Java类（class）。<a href="/java/2019-10-04-cglib/">CGLIB浅析</a></li><li>AspectJ: AspectJ采用<strong><em>编译时</em></strong>织入和<strong><em>类加载时</em></strong>织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<a href="/java/2019-10-04-aspectj/">AspectJ</a></li><li>Javassist: Javassist在Java中是一个用来编辑字节码的扩展包，它允许Java程序在<strong><em>运行时</em></strong>定义一个新类或者在JVM<strong><em>加载class文件时</em></strong>修改class文件。<br><a href="/java/2019-09-04-javassist/">Javassist</a></li><li>JDK Proxy: JDK动态代理类是在<strong><em>运行时</em></strong>实现指定的接口列表的类，该类实例上的其中一个接口进行的方法调用时，将被通过统一的接口进行编码并调用到另一个对象。因此，动态代理类可用于为接口列表创建类型安全的代理对象，而无需诸如在编译时使用编译工具预生成代理类。动态代理类实例的代理方法调用将在该代理类实例中的处理程序中通过java.lang.reflect.Method对象进行调用，该对象标识了所调用的方法和包含参数的Object类型数组，翻译自<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a>。详情<a href="/java/2019-10-04-jdk-proxy/">《JDK 动态代理浅析》</a></li></ul><p>在Java语言中，从构建代理类的时期上来看，有三种：编译时、类加载时和运行时。从方式上来说有两种，一种是静态代理，一种是动态代理。<br>动态代理则是一种方便<strong><em>运行时</em></strong>动态构建代理、动态处理代理方法调用的机制。例如ASM，Javassist，Java Proxy。</p><p><strong><em>编译时</em></strong>和<strong><em>类加载时</em></strong>构建代理类则属于静态代理。例如AspectJ。</p><h2 id="2-常用代理方式"><a href="#2-常用代理方式" class="headerlink" title="2. 常用代理方式"></a>2. 常用代理方式</h2><p>由于篇幅问题，本文进行了拆分，详细了解常用的代理方式的原理，请点击下方链接。</p><p><a href="/java/2019-10-04-jdk-proxy/">JDK proxy</a></p><p><a href="/java/2019-10-04-cglib/">CGLIB浅析</a></p><p><a href="/java/2019-10-04-aspectj/">AspectJ</a></p><p><a href="/java/2019-09-04-javassist/">Javassist</a></p><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h2><p><img src="/media/article/15688575046625.png" alt="jclasslib"><br>图片引用自<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">《美团技术团队》-字节码增强技术探索</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>1.Java生成动态代理的时候，使用WeakCache缓存已经生成的动态代理工厂，疑问点在于，为什么缓存的key使用的是<a href="/java/2019-09-15-reference/">弱引用</a>？</p><p>答: 类中的静态变量，当它持有一个指向一个对象的引用时，它就作为GC Root，第一类被列为GC Root的元素就是静态成员变量。因此若缓存不再需要时，使用强引用会让GC进行标记分析时认为从GC Root可达，不太会去标记这块内存，反之能够有效地标记这些缓存，从而提高内存回收效率。引用自<a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a></p><p>个人分析: 既然缓存代理工厂类，为什么不使用SoftReference，这样只有内存空间不够时才会进行回收。这样可以最大限度的缓存生成的代理工厂？<br>如果使用SoftReference，当服务使用动态代理较多时，可能会导致频繁的FullGC。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html" target="_blank" rel="noopener">Java动态代理机制分析及扩展，第1部分</a><br><a href="https://www.cnblogs.com/whirly/p/10154887.html" target="_blank" rel="noopener">Java 动态代理详解</a><br><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a><br><a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a><br><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a><br><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是动态代理？&quot;&gt;&lt;a href=&quot;#1-什么是动态代理？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是动态代理？&quot;&gt;&lt;/a&gt;1. 什么是动态代理？&lt;/h2&gt;&lt;p&gt;代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>了解ASM</title>
    <link href="https://zhongyp.me/java/2019-10-06-asm/"/>
    <id>https://zhongyp.me/java/2019-10-06-asm/</id>
    <published>2019-09-05T16:00:00.000Z</published>
    <updated>2019-10-11T09:04:37.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h2><blockquote><p><strong><a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a>技术是个啥？</strong><br>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br>ASM是一个通用的Java字节码操作和分析框架。它可以直接以二进制形式用于修改现有类或动态生成类。 ASM提供了一些常见的字节码转换和分析算法，可以从中构建定制的复杂转换和代码分析工具。 ASM提供与其他Java字节码框架类似的功能，但侧重于性能。因为它的设计和实现是尽可能的小和尽可能快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中使用）。<br>ASM应用广泛：OpenJDK lambda call sites，<a href="http://hg.openjdk.java.net/jdk8/jdk8/nashorn/file/096dc407d310/src/jdk/nashorn/internal/codegen/ClassEmitter.java" target="_blank" rel="noopener">Nashorn compiler</a><br>CGLIB，以动态生成代理类（用于其他项目，例如Mockito和EasyMock），Gradle，在运行时生成一些类。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ASM&quot;&gt;&lt;a href=&quot;#ASM&quot; class=&quot;headerlink&quot; title=&quot;ASM&quot;&gt;&lt;/a&gt;ASM&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://asm.ow2.io/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Javassist</title>
    <link href="https://zhongyp.me/java/2019-09-04-javassist/"/>
    <id>https://zhongyp.me/java/2019-09-04-javassist/</id>
    <published>2019-09-03T16:00:00.000Z</published>
    <updated>2019-10-09T10:43:47.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-1-4-Javassist"><a href="#3-1-4-Javassist" class="headerlink" title="3.1.4 Javassist"></a>3.1.4 Javassist</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;3-1-4-Javassist&quot;&gt;&lt;a href=&quot;#3-1-4-Javassist&quot; class=&quot;headerlink&quot; title=&quot;3.1.4 Javassist&quot;&gt;&lt;/a&gt;3.1.4 Javassist&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机类加载机制</title>
    <link href="https://zhongyp.me/jvm/2019-08-18-jvm-classloading/"/>
    <id>https://zhongyp.me/jvm/2019-08-18-jvm-classloading/</id>
    <published>2019-08-17T16:00:00.000Z</published>
    <updated>2019-09-10T08:44:34.872Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p></blockquote><p>Java 虚拟机动态的加载，连接，初始化类或者接口。</p><p>加载是一个通过特殊符号查找类或者接口类型的二进制文件，同时使用二进制文件创建类或者接口的过程。</p><p>连接是一个加载类或者接口并结合它变为Java虚拟机的运行时状态的过程，以便于它可以被Java虚拟机执行。</p><p>一个类或者接口的初始化由执行类或者接口的初始化方法<code>&lt;clinit&gt;</code>组成(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener">§2.9</a>)。</p><p>下图是类或者接口动态加载、连接、初始化的过程：</p><p><img src="/media/article/jvm-classloading.png" alt="jvm-classloading"></p><p>图片摘自<a href="">深入理解Java虚拟机</a></p><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h2><p>加载阶段：</p><ul><li><ol><li>通过一个类的全限定名来获取定义此类二进制字节流。</li></ol></li><li><ol start="2"><li>将这个字节流代表的静态存储结构转换为方法区的运行时数据结构(运行时数据结构详见第四小节<a href="#4-运行时常量池"></a>)。</li></ol></li><li><ol start="3"><li>在<strong><em>内存(Class对象比较特殊，它虽然是对象，但是存储在方法区中)</em></strong>生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol></li></ul><p>对于数组类本身不通过类加载器创建，它由Java虚拟机直接创建。数组类型却由类加载器创建，创建过程遵循以下规则：</p><ul><li>如果数组组件类型是引用类型，则数组被标记为组件类型定义的类加载器定义。否则，数组被标记为引导类加载器定义。</li><li>如果数组的组件类型不是引用类型，Java虚拟机将会把数组标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认是public。</li></ul><p>加载和连接阶段是交叉进行的。</p><h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h2><p>如果需要连接类或接口涉及验证和准备该类或接口，直接超类，直接超接口及其元素类型（如果它是数组类型）。类或接口中符号引用的解析是连接的可选部分。</p><p>只要维护了以下所有属性，此规范允许实现灵活性，以便何时发生连接活动（以及由于递归，加载）。</p><ul><li><p>类或接口在连接之前已完全加载。</p></li><li><p>在初始化之前，类或接口已完全验证并准备好。</p></li></ul><p>在连接期间检测到的错误被抛出到程序中的某个点，程序可能会直接或间接地需要连接到错误中涉及的类或接口。</p><p>例如，Java虚拟机实现可以选择在使用它时分别解析类或接口中的每个符号引用，或者在验证类时立即解析它们。这意味着在一些实现中，在初始化类或接口之后，解析过程可以继续。无论采用哪种策略，在解析期间检测到的任何错误都必须抛出到程序中（直接或间接）使用对类或接口的符号引用的位置。</p><p>因为连接涉及新数据结构的分配，所以它可能会失败OutOfMemoryError。</p><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>验证阶段会完成4个阶段的验证动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置类变量<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。进行内存分配的仅包括<strong><em>类变量[static变量]</em></strong>，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><h3 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic，这些虚拟机指令对运行时常量池进行符号引用，执行任何这些指令都需要解析其符号引用。</p><p>解析是从运行时常量池中的符号引用动态确定具体值的过程。</p><p>对出现在invokedynamic指令的相同的符号引用被解析一次并不意味着被任何其他invokedynamic指令认为已解析。</p><p>对于上述提到的所有指令，如果其中一个指令对符号引用进行了解析，则意味着任何非invokedynamic指令认为这个符号引用已经解析。</p><p>如果在解析符号引用期间发生错误，则必须在程序中(直接或间接)使用符号引用时的某一点抛出IncompatibleClassChangeError(或子类)的实例。</p><p>如果Java虚拟机尝试解析符号引用失败，抛出的错误是LinkageError(或子类)的实例，后续尝试解析引用始终失败，并且和初始解析尝试而引发的错误相同。</p><p>在执行指令之前，不得解析特定invokedynamic指令对调用site说明符的符号引用。</p><p>在<code>invokedynamic</code>指令解析失败的情况下，后续解析尝试不会重新执行引导方法。</p><p>上述某些指令在解析符号引用时需要额外的连接检查。例如，为了使getfield指令成功解析对其运行的字段的符号引用，它不仅必须完成第<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2" target="_blank" rel="noopener">5.4.3.2</a>节中给出的字段解析步骤，还要检查字段是否为静态。如果它是静态字段，则必须抛出链接异常。</p><p>值得注意的是，为了使<code>invokedynamic</code>指令成功解析对调用site说明符的符号引用，其中指定的引导方法必须正常完成并返回合适的调用站点对象。如果引导方法突然完成或返回不合适的调用站点对象，则必须抛出连接异常。</p><p>连接由特定执行特定Java虚拟机指令检查生成的异常在该指令的描述中给出，并且在本解析的一般性讨论中未涉及。请注意，此类异常虽然被描述为Java虚拟机指令执行而非解析的一部分，但仍然被视为解析失败。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h2><p>一个类的加载过程中加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，解析阶段则不一定。解析可以在初始化完成后再开始，这时为了支持Java的运行时绑定。</p><p>Java虚拟机没有进行强制约束什么时候加载，只是严格规范了5中情况必须对类进行”初始化”。</p><ul><li>遇到new、getstatic、putstatic或invokestatic这4条指令时，如果类没有进行初始化，则需要先触发其初始化。4条指令的常见场景是:使用new 关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)、以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7及以上版本的动态语言(详细了解 <a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a>)支持时，如果一个java.lang.incoke.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。</li></ul><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有 <strong><em>类变量的赋值动作</em></strong>和<strong><em>静态语句块(static{}块)中的语句</em></strong>合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语义块之前的变量，定义在它之后的变量，可以赋值，但是不能访问。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test()&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>不需要执行其父接口的<code>&lt;clinit&gt;()</code>方法。<br>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待。</p></blockquote><h2 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4. 运行时常量池"></a>4. 运行时常量池</h2><p>Java虚拟机维护每种类型常量池，这是一种运行时数据结构，它服务于常规编程语言实现的符号表的许多目的。</p><p>类或接口的二进制表示形式中的constant_pool表用于在创建类或接口对象时构造运行时常量池。运行时常量池中的所有引用最初都是符号引用。运行时常量池中的符号引用是从类或接口的二进制表示中的结构派生的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">String str = &quot;str&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">// 基本类型</span><br><span class="line">int i = 1;</span><br><span class="line"></span><br><span class="line">// 基本类型数组</span><br><span class="line">int[] arrayI = new int[3];</span><br><span class="line"></span><br><span class="line">// 引用类型数组</span><br><span class="line">A [] arrayA = new A[3];</span><br><span class="line"></span><br><span class="line">// 引用类型</span><br><span class="line">A a = new A();</span><br><span class="line"></span><br><span class="line">// 引用方法</span><br><span class="line">a.test();</span><br><span class="line"></span><br><span class="line">// 接口声明</span><br><span class="line">C c = new B();</span><br><span class="line"></span><br><span class="line">// 接口方法</span><br><span class="line">c.test();</span><br><span class="line"></span><br><span class="line">// lambda</span><br><span class="line">Runnable x = ()-&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p><code>javap -v</code>编译如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #13.#42        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #25            // str</span><br><span class="line">   #3 = Fieldref           #43.#44        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #45.#46        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #47            // com/zhongyp/test/A</span><br><span class="line">   #6 = Methodref          #5.#42         // com/zhongyp/test/A.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #7 = Methodref          #5.#48         // com/zhongyp/test/A.test:()V</span><br><span class="line">   #8 = Class              #49            // com/zhongyp/test/B</span><br><span class="line">   #9 = Methodref          #8.#42         // com/zhongyp/test/B.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #10 = InterfaceMethodref #50.#48        // com/zhongyp/test/C.test:()V</span><br><span class="line">  #11 = InvokeDynamic      #0:#55         // #0:run:()Ljava/lang/Runnable;</span><br><span class="line">  #12 = Class              #56            // com/zhongyp/test/Test</span><br><span class="line">  #13 = Class              #57            // java/lang/Object</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               LocalVariableTable</span><br><span class="line">  #19 = Utf8               this</span><br><span class="line">  #20 = Utf8               Lcom/zhongyp/test/Test;</span><br><span class="line">  #21 = Utf8               main</span><br><span class="line">  #22 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               args</span><br><span class="line">  #24 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               str</span><br><span class="line">  #26 = Utf8               Ljava/lang/String;</span><br><span class="line">  #27 = Utf8               i</span><br><span class="line">  #28 = Utf8               I</span><br><span class="line">  #29 = Utf8               arrayI</span><br><span class="line">  #30 = Utf8               [I</span><br><span class="line">  #31 = Utf8               arrayA</span><br><span class="line">  #32 = Utf8               [Lcom/zhongyp/test/A;</span><br><span class="line">  #33 = Utf8               a</span><br><span class="line">  #34 = Utf8               Lcom/zhongyp/test/A;</span><br><span class="line">  #35 = Utf8               c</span><br><span class="line">  #36 = Utf8               Lcom/zhongyp/test/C;</span><br><span class="line">  #37 = Utf8               x</span><br><span class="line">  #38 = Utf8               Ljava/lang/Runnable;</span><br><span class="line">  #39 = Utf8               lambda$main$0</span><br><span class="line">  #40 = Utf8               SourceFile</span><br><span class="line">  #41 = Utf8               Test.java</span><br><span class="line">  #42 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #43 = Class              #58            // java/lang/System</span><br><span class="line">  #44 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #45 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #46 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #47 = Utf8               com/zhongyp/test/A</span><br><span class="line">  #48 = NameAndType        #64:#15        // test:()V</span><br><span class="line">  #49 = Utf8               com/zhongyp/test/B</span><br><span class="line">  #50 = Class              #65            // com/zhongyp/test/C</span><br><span class="line">  #51 = Utf8               BootstrapMethods</span><br><span class="line">  #52 = MethodHandle       #6:#66         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #53 = MethodType         #15            //  ()V</span><br><span class="line">  #54 = MethodHandle       #6:#67         // invokestatic com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #55 = NameAndType        #68:#69        // run:()Ljava/lang/Runnable;</span><br><span class="line">  #56 = Utf8               com/zhongyp/test/Test</span><br><span class="line">  #57 = Utf8               java/lang/Object</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #64 = Utf8               test</span><br><span class="line">  #65 = Utf8               com/zhongyp/test/C</span><br><span class="line">  #66 = Methodref          #70.#71        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #67 = Methodref          #12.#72        // com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #68 = Utf8               run</span><br><span class="line">  #69 = Utf8               ()Ljava/lang/Runnable;</span><br><span class="line">  #70 = Class              #73            // java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #71 = NameAndType        #74:#78        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #72 = NameAndType        #39:#15        // lambda$main$0:()V</span><br><span class="line">  #73 = Utf8               java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #74 = Utf8               metafactory</span><br><span class="line">  #75 = Class              #80            // java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #76 = Utf8               Lookup</span><br><span class="line">  #77 = Utf8               InnerClasses</span><br><span class="line">  #78 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #79 = Class              #81            // java/lang/invoke/MethodHandles</span><br><span class="line">  #80 = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #81 = Utf8               java/lang/invoke/MethodHandles</span><br></pre></td></tr></table></figure><h3 id="4-1-CONSTANT-Class-info结构"><a href="#4-1-CONSTANT-Class-info结构" class="headerlink" title="4.1 CONSTANT_Class_info结构"></a>4.1 CONSTANT_Class_info结构</h3><p>对类或接口的符号引用是从类或接口的二进制表示形式中的CONSTANT_Class_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1" target="_blank" rel="noopener">第4.4.1节</a>派生的。这样的引用给出了Class.getName方法返回的表单中的类或接口的名称。</p><p>对于非数组类或接口，名称是类或接口的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>。</p><p>对于n维的数组类，名称以n个出现的ASCII“[”字符开头，后跟元素类型的表示：</p><ul><li><p>如果元素类型是基本类型，则它由相应的字段描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">第4.3.2节</a>表示。</p></li><li><p>否则，如果元素类型是引用类型，则它由ASCII“L”字符后跟元素类型的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>后跟ASCII“;”符号表示。</p></li></ul><h3 id="4-2-CONSTANT-Fieldref-info结构"><a href="#4-2-CONSTANT-Fieldref-info结构" class="headerlink" title="4.2 CONSTANT_Fieldref_info结构"></a>4.2 CONSTANT_Fieldref_info结构</h3><p>对类或接口的字段的符号引用是从类或接口的二进制表示形式中的CONSTANT_Fieldref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了字段的名称和描述符，以及对要在其中找到字段的类或接口的符号引用。</p><h3 id="4-3-CONSTANT-Methodref-info结构"><a href="#4-3-CONSTANT-Methodref-info结构" class="headerlink" title="4.3 CONSTANT_Methodref_info结构"></a>4.3 CONSTANT_Methodref_info结构</h3><p>对类的方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_Methodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了方法的名称和描述符，以及对要在其中找到方法的类的符号引用。</p><h3 id="4-4-CONSTANT-InterfaceMethodref-info"><a href="#4-4-CONSTANT-InterfaceMethodref-info" class="headerlink" title="4.4 CONSTANT_InterfaceMethodref_info"></a>4.4 CONSTANT_InterfaceMethodref_info</h3><p>对接口方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_InterfaceMethodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了接口方法的名称和描述符，以及对要在其中找到方法的接口的符号引用。</p><h3 id="4-5-CONSTANT-MethodHandle-info结构"><a href="#4-5-CONSTANT-MethodHandle-info结构" class="headerlink" title="4.5 CONSTANT_MethodHandle_info结构"></a>4.5 CONSTANT_MethodHandle_info结构</h3><p>方法句柄的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodHandle_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.8" target="_blank" rel="noopener">第4.4.8节</a>派生的。这样的引用根据方法句柄的类型给出了类或接口的字段，类的方法或接口的方法的符号引用。</p><h3 id="4-6-CONSTANT-MethodType-info结构"><a href="#4-6-CONSTANT-MethodType-info结构" class="headerlink" title="4.6 CONSTANT_MethodType_info结构"></a>4.6 CONSTANT_MethodType_info结构</h3><p>方法类型的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodType_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.9" target="_blank" rel="noopener">第4.4.9节</a>派生的。这样的引用给出了方法描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">§4.3.3</a>。</p><h3 id="4-7-CONSTANT-InvokeDynamic-info结构"><a href="#4-7-CONSTANT-InvokeDynamic-info结构" class="headerlink" title="4.7 CONSTANT_InvokeDynamic_info结构"></a>4.7 CONSTANT_InvokeDynamic_info结构</h3><blockquote><h3 id="invokedynamic-instructions"><a href="#invokedynamic-instructions" class="headerlink" title="invokedynamic instructions"></a>invokedynamic instructions</h3><p>A dynamic call site is originally in an unlinked state. In this state, there is no target method for the call site to invoke.<br>动态的调用site起初处在未连接的状态。在这种状态下，调用site没有调用的目标方法。<br>Before the JVM can execute a dynamic call site (an invokedynamic instruction), the call site must first be linked. Linking is accomplished by calling a bootstrap method which is given the static information content of the call site, and which must produce a method handle that gives the behavior of the call site.<br>在JVM可以执行动态调用site（invokedynamic指令）之前，必须首先连接调用site。连接是通过调用一个bootstrap方法来完成的，该方法被赋予了调用站点的静态信息内容，并且必须产生一个方法句柄来给出调用站点的行为。<br>Each invokedynamic instruction statically specifies its own bootstrap method as a constant pool reference. The constant pool reference also specifies the call site’s name and type descriptor, just like invokevirtual and the other invoke instructions.<br>每个invokedynamic指令静态的将它自己的引导方法指定作为一个常量池引用。常量池引用也指定调用site的名称和类型描述，就像invokevirtual和其他的调用描述一样。<br>Linking starts with resolving the constant pool entry for the bootstrap method, and resolving a MethodType object for the type descriptor of the dynamic call site. This resolution process may trigger class loading. It may therefore throw an error if a class fails to load. This error becomes the abnormal termination of the dynamic call site execution. Linkage does not trigger class initialization.<br>连接从解析引导方法的常量池条目开始，并为动态调用site的类型描述符解析MethodType对象。这个解决的进程可能触发类加载。如果一个类加载失败，可能因此抛出一个error。这个error将成为动态调用site执行的异常终止。连接不能触发类的初始化。<br>The bootstrap method is invoked on at least three values:<br>引导方法至少使用3个值调用:</p><ul><li>a MethodHandles.Lookup, a lookup object on the caller class in which dynamic call site occurs</li><li>一个是MethodHandles.Lookup，发生动态调用site的调用类上的一个lookup对象。</li><li>a String, the method name mentioned in the call site</li><li>一个字符创，在调用site中提到的方法名称。</li><li>a MethodType, the resolved type descriptor of the call</li><li>一个MethodType，已解析的调用的类型描述。</li><li>optionally, between 1 and 251 additional static arguments taken from the constant pool。</li><li>可选地，从常量池中获取1到251个额外的静态参数。</li></ul></blockquote><p>对调用站点说明符的符号引用是从类或接口的二进制表示形式中的CONSTANT_InvokeDynamic_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.10" target="_blank" rel="noopener">第4.4.10节</a>派生的。这样的参考给出：</p><ul><li><p>方法句柄的符号引用，它将作为invokedynamic指令的引导方法<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic" target="_blank" rel="noopener">§invokedynamic</a>;</p></li><li><p>一系列符号引用(对类，方法类型和方法句柄)，字符串文字和运行时常量值，它们将作为引导方法的静态参数;</p></li><li><p>方法名称和方法描述符。</p></li></ul><h3 id="4-8-CONSTANT-String-info结构"><a href="#4-8-CONSTANT-String-info结构" class="headerlink" title="4.8 CONSTANT_String_info结构"></a>4.8 CONSTANT_String_info结构</h3><p>此外，某些不是符号引用的运行时值是从constant_pool表中找到的项派生的：</p><p>字符串文字是对类String实例的引用，它是从类或接口的二进制表示形式的CONSTANT_String_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3" target="_blank" rel="noopener">第4.4.3节</a>派生而来的。 CONSTANT_String_info结构给出了构成字符串文字的Unicode代码点序列。</p><p>Java编程语言要求相同的字符串文字[即包含相同代码点序列的文字]必须引用类String的相同实例(JLS§3.10.5)。此外，如果在任何字符串上调用String.intern方法，则结果是对该字符串显示为文字时将返回的同一类实例的引用。因此，以下表达式的值必须为true：</p><p><code>(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</code></p><p>为了派生字符串文字，Java虚拟机检查CONSTANT_String_info结构给出的代码点序列。</p><p>如果先前在类String的实例上调用了String.intern方法，该类包含与CONSTANT_String_info结构给出的Unicode代码点序列相同的Unicode代码点序列，则字符串文字派生的结果是对类String的同一实例的引用。</p><p>否则，将创建一个类String的新实例，其中包含CONSTANT_String_info结构给出的Unicode代码点序列;对该类实例的引用是字符串文字派生的结果。最后，调用新String实例的intern方法。</p><h3 id="4-9-其他结构"><a href="#4-9-其他结构" class="headerlink" title="4.9 其他结构"></a>4.9 其他结构</h3><p>运行时常量值是从类或接口的二进制表示形式中的CONSTANT_Integer_info，CONSTANT_Float_info，CONSTANT_Long_info或CONSTANT_Double_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">第4.4.4节，第4.4.5节</a>派生的。</p><p>请注意，CONSTANT_Float_info结构表示IEEE 754单一格式的值，CONSTANT_Double_info结构表示IEEE 754双格式<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">§4.4.4，§4.4.5</a>中的值。因此，从这些结构导出的运行时常数值必须是可以分别使用IEEE 754单格式和双格式表示的值。</p><p>类或接口的二进制表示的constant_pool表中的其余结构 - CONSTANT_NameAndType_info和CONSTANT_Utf8_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.6" target="_blank" rel="noopener">§4.4.6，§4.4.7</a> - 仅在派生对类，接口，方法，字段的符号引用时间接使用，方法类型和方法句柄，以及派生字符串文字和调用站点说明符时。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a></p><p><a href="">深入理解Java虚拟机</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/package-summary.html#package.description" target="_blank" rel="noopener">Package java.lang.invoke Description</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chapter 5. Loadin
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhongyp.me/tags/JVM/"/>
    
      <category term="翻译" scheme="https://zhongyp.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM官方文档指南</title>
    <link href="https://zhongyp.me/jvm/2019-08-08-offical-document/"/>
    <id>https://zhongyp.me/jvm/2019-08-08-offical-document/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-11T11:01:42.708Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">Java虚拟机规范</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java虚拟机规范&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhongyp.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data Redis的execute和executePipelined的区别</title>
    <link href="https://zhongyp.me/redis/2019-08-06-execute-executePipelined/"/>
    <id>https://zhongyp.me/redis/2019-08-06-execute-executePipelined/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-09-05T06:31:08.333Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring-data-redis 2.0.7.RELEASE</p></blockquote><h2 id="executePipelined方法说明"><a href="#executePipelined方法说明" class="headerlink" title="executePipelined方法说明"></a>executePipelined方法说明</h2><p>executePipelined方法基于Redis的pipelining。关于pipelining官方解释如下: </p><p>A Request/Response server can be implemented so that it is able to process new requests even if the client didn’t already read the old responses. This way it is possible to send multiple commands to the server without waiting for the replies at all, and finally read the replies in a single step.<br>—摘自<a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">Redis Piplining</a></p><p>上面的意思大概是Redis服务器可以实现即使没有读取旧响应的情况下也可以发送新的请求，以这种方式可以发送多个命令到服务器而不用等待回复，最后一次获取全部的回复。这就是Redis Pipelining。</p><p>executePipelined的官方注释:</p><p>Executes the given action object on a pipelined connection, returning the results. Note that the callback cannot return a non-null value as it gets overwritten by the pipeline. This method will use the default serializers to deserialize results.</p><p>上面这句话的意思在一个<strong><em>管道连接</em></strong>中执行给定的动作对象，并返回结果。但是需要注意的是callback不能返回一个非null的值，callback的值将被pipeline覆盖。这个方法将使用默认的序列化和反序列化方式处理结果集。</p><p>例举executePipelined(SessionCallback&lt;?&gt; session, @Nullable RedisSerializer&lt;?&gt; resultSerializer) 方法源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt; executePipelined(SessionCallback&lt;?&gt; session, @Nullable RedisSerializer&lt;?&gt; resultSerializer) &#123;</span><br><span class="line">        Assert.isTrue(this.initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);</span><br><span class="line">        Assert.notNull(session, &quot;Callback object must not be null&quot;);</span><br><span class="line">        RedisConnectionFactory factory = this.getRequiredConnectionFactory();</span><br><span class="line">        // 是否开启事务管理，将当前连接注册到事务管理器</span><br><span class="line">        RedisConnectionUtils.bindConnection(factory, this.enableTransactionSupport);</span><br><span class="line"></span><br><span class="line">        List var4;</span><br><span class="line">        try &#123;</span><br><span class="line">            // this.execute其实就是execute，所以本质上来说，两个方法的区别在于executePipeline方法开启了pipeline</span><br><span class="line">            var4 = (List)this.execute((connection) -&gt; &#123;</span><br><span class="line">                // 开启管道</span><br><span class="line">                connection.openPipeline();</span><br><span class="line">                boolean pipelinedClosed = false;</span><br><span class="line"></span><br><span class="line">                List var7;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 在连接中执行SessionCallback中的动作，并获取结果集</span><br><span class="line">                    Object result = this.executeSession(session);</span><br><span class="line">                    // 如果结果集不为空，抛出InvalidDataAccessApiUsageException</span><br><span class="line">                    if (result != null) &#123;</span><br><span class="line">                        throw new InvalidDataAccessApiUsageException(&quot;Callback cannot return a non-null value as it gets overwritten by the pipeline&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    List&lt;Object&gt; closePipeline = connection.closePipeline();</span><br><span class="line">                    pipelinedClosed = true;</span><br><span class="line">                    // 获取管道返回的结果集并序列化</span><br><span class="line">                    var7 = this.deserializeMixedResults(closePipeline, resultSerializer, this.hashKeySerializer, this.hashValueSerializer);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (!pipelinedClosed) &#123;</span><br><span class="line">                        connection.closePipeline();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                // 返回管道的结果集</span><br><span class="line">                return var7;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码中<code>this.execute((connection)...</code>其实就是execute(RedisCallback&lt;?&gt; session)方法。所以executePipelined方法只是在execute内中开启了pipeline而已。</p><h2 id="execute方法说明"><a href="#execute方法说明" class="headerlink" title="execute方法说明"></a>execute方法说明</h2><p>execute相对于<code>executePipelined(SessionCallback&lt;?&gt; session)</code>比较简单，没有过多的处理，而是直接执行SessionCallback中的动作，官方注释如下:</p><p>Executes a Redis session. Allows multiple operations to be executed in the same session enabling ‘transactional’ capabilities through RedisOperations.multi() and RedisOperations.watch(Collection) operations.</p><p>大概意思是执行一个Redis会话。允许在<strong><em>同一会话</em></strong>中执行多个操作，通过RedisOperations.multi()和RedisOperations.watch(Collection)操作启用“事务”功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public &lt;T&gt; T execute(SessionCallback&lt;T&gt; session) &#123;</span><br><span class="line">        Assert.isTrue(this.initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);</span><br><span class="line">        Assert.notNull(session, &quot;Callback object must not be null&quot;);</span><br><span class="line">        RedisConnectionFactory factory = this.getRequiredConnectionFactory();</span><br><span class="line">        RedisConnectionUtils.bindConnection(factory, this.enableTransactionSupport);</span><br><span class="line"></span><br><span class="line">        Object var3;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 执行SessionCallback并获取执行SessionCallback返回的结果集</span><br><span class="line">            var3 = session.execute(this);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接返回结果集</span><br><span class="line">        return var3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="execute和executePipelined区别"><a href="#execute和executePipelined区别" class="headerlink" title="execute和executePipelined区别"></a>execute和executePipelined区别</h2><p>从上面两段源码示例可以看出，execute和executePipelined的最主要区别是executePipelined开启了pipeline。pipline与execute正常的请求/响应的区别主要在于请求/响应模式上，execute是串行化的命令请求，executePipelined请求与响应则是穿插进行。两者区别如图所示:<br>串行:<br><img src="/media/article/redis-execute.png" alt="redis-execute"></p><p>execute方法是串行的，命令请求发出后，必须得到响应数据，才能发送下一条命令请求。所以在一次Redis会话中，一次会话可能包含多次请求，即多次RTT。</p><p>穿插:</p><p><img src="/media/article/redis-executepipeline.png" alt="redis-executepipeline.png"></p><p>executePipelined是穿插的，可以批量发送命令到服务器，也可以批量获取响应数据。即可能使用一次RTT就能完成批量操作。</p><p>除了网络协议上的区别外，execute和executePipelined都支持事务管理器，支持multi，watch，exec，discard等事务操作，不过execute与executePipelined的这些操作还是有些区别的。</p><p>例如 JedisConnection开启multi:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void multi() &#123;</span><br><span class="line">   if (!this.isQueueing()) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           if (this.isPipelined()) &#123;</span><br><span class="line">               // 如果开启了pipeline，则使用Pipeline内部的multi</span><br><span class="line">               // Pipeline绑定的是client</span><br><span class="line">               this.getRequiredPipeline().multi();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // 没有开启pipeline使用jedis的multi</span><br><span class="line">               // jedis的multi绑定的是connection</span><br><span class="line">               this.transaction = this.jedis.multi();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception var2) &#123;</span><br><span class="line">           throw this.convertJedisAccessException(var2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jedis与Pipeline的命令绑定的对象不一样，前者绑定的是connection，后者绑定client。这和上面提到的请求/响应模式有关。<br>watch，exec，discard等操作也是如此。</p><p>除此之外，executePipelined的SessionCallback是不能有返回值的，executePipelined需要返回Pipleline的返回值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wuxian90/article/details/81322536" target="_blank" rel="noopener">Redis客户端与服务端交互详解</a></p><p><a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">pipelining</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Spring-data-redis 2.0.7.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;executePipelined方法说明&quot;&gt;&lt;a href=&quot;#executePipelined方法说明&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="redis" scheme="https://zhongyp.me/tags/redis/"/>
    
      <category term="FAQ" scheme="https://zhongyp.me/tags/FAQ/"/>
    
  </entry>
  
  <entry>
    <title>Redis 设计与实现</title>
    <link href="https://zhongyp.me/redis/2019-06-21-redis/"/>
    <id>https://zhongyp.me/redis/2019-06-21-redis/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2019-07-19T11:22:00.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据结构与对象"><a href="#1-数据结构与对象" class="headerlink" title="1. 数据结构与对象"></a>1. 数据结构与对象</h2><h3 id="1-1-简单动态字符串（SDS）"><a href="#1-1-简单动态字符串（SDS）" class="headerlink" title="1.1 简单动态字符串（SDS）"></a>1.1 简单动态字符串（SDS）</h3><p>Redis没有使用C语言传统的字符串表示，而是构建了一种简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。Redis只会使用C字符串作为字面量。<br>除了用来保存数据库中的字符串值之外，SDS还被用做缓冲区(buffer): AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是SDS实现的。</p><blockquote><p>在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。</p></blockquote><h4 id="1-1-1-SDS的定义"><a href="#1-1-1-SDS的定义" class="headerlink" title="1.1.1 SDS的定义"></a>1.1.1 SDS的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    // 记录buf数组中已使用字节的数量</span><br><span class="line">    // 等于SDS所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    // 记录buf数组中未使用字节的数量</span><br><span class="line">    int free;</span><br><span class="line">    // 字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/15611092689335.jpg" alt="SDS示例"></p><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。</p><h4 id="1-1-2-与C字符串的区别"><a href="#1-1-2-与C字符串的区别" class="headerlink" title="1.1.2 与C字符串的区别"></a>1.1.2 与C字符串的区别</h4><ol><li>获取字符串长度复杂度：C字符串不记录长度信息，所以获取字符串长度复杂度为O(N)，SDS为O(1)。</li><li>杜绝缓冲区溢出：<code>strcat</code>函数可以将src字符串中的内容拼接到dest字符串的末尾:<br><code>char *strcat(char *dest, const char *src)</code><br>因为C字符创不记录自身的长度，所以<code>strcat</code>假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立，就会产生缓冲区溢出。SDS在执行拼接操作之前检查s的长度是否足够，在发现s目前的空间不足以拼接时，sdscat就会扩展s的空间，然后执行拼接操作。</li><li>减少修改字符串时带来的内存重分配次数：b中说道每次拼接字符串时，C字符串都要对C字符串进行一次内存重分配操作（即：在拼接操作，需要扩展空间大小，否则缓冲区溢出；在截断操作，需要释放多余空间，否则内存泄漏），因为重分配是比较耗时的操作，所以为了避免频繁修改字符串对性能造成的影响，SDS通过未使用空间接触了字符串长度和底层数组长度之间的关联：SDS中，buf的长度不一定是字符数量+1，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</li></ol><blockquote><p>空间预分配</p><ul><li>如果对SDS进行修改之后，SDS的长度小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。</li><li>如果对SDS修改之后，SDS的长度大于1MB，那么程序会分配1MB的未使用空间。</li></ul><p>惰性空间释放</p><ul><li>当 SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录下来，并等待将来使用。同时SDS提供了相应的API，在有需要时，释放SDS未使用的空间，这样就可以避免惰性空间释放策略会造成内存浪费。</li></ul></blockquote><h4 id="1-1-3-二进制安全"><a href="#1-1-3-二进制安全" class="headerlink" title="1.1.3 二进制安全"></a>1.1.3 二进制安全</h4><p>C语言字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符串，所以C字符串只能保存文本数据，不能保存二进制数据。<br>SDS的API都是二进制安全(binary-safe)的。</p><h4 id="1-1-4-兼容部分C字符串的函数"><a href="#1-1-4-兼容部分C字符串的函数" class="headerlink" title="1.1.4 兼容部分C字符串的函数"></a>1.1.4 兼容部分C字符串的函数</h4><p>虽然SDS的API都是二进制安全的，但是API总会将SDS保存的数据的末尾设置为空字符串，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数。</p><h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><p>当一个列表键包含数量比较多的元素，又或者包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区(output buffer)。</p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li><li>带链表长度的计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h3 id="1-3-字典"><a href="#1-3-字典" class="headerlink" title="1.3 字典"></a>1.3 字典</h3><h4 id="1-3-1-结构"><a href="#1-3-1-结构" class="headerlink" title="1.3.1 结构"></a>1.3.1 结构</h4><p>字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair)的抽象数据结构。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><p>字典结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">    // 类型特定函数</span><br><span class="line">    dicType *type;</span><br><span class="line">    </span><br><span class="line">    // 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line">    </span><br><span class="line">    // 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    </span><br><span class="line">    // rehash索引</span><br><span class="line">    // 当rehash不在进行时，值为-1</span><br><span class="line">    in threhash; /* rehashing not in progress if rehashidx == -1 */</span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。<br>pridata属性则保存了需要传给那些类型特定函数的可选参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dicType&#123;</span><br><span class="line"></span><br><span class="line">// 计算哈希值的函数</span><br><span class="line">unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">// 复制键的函数</span><br><span class="line">void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">// 对比键的函数</span><br><span class="line">int (*keyCompare)(void *privdata,const void *key1,const void *key);</span><br><span class="line"></span><br><span class="line">// 销毁键</span><br><span class="line">(*keyDestructor)(void *privdata,void *key);</span><br><span class="line"></span><br><span class="line">// 复制值</span><br><span class="line">void(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">// 销毁值</span><br><span class="line">void(*valDestructor)(void *privdata,void *obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ht属性是一个包含两个项的数组，数组的每项都是dictht哈希表，一般情况下只是用ht[0]，ht[1]只会在对ht[0]哈希表进行rehash时使用。<br>除ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有进行rehash，那么它的值为-1。<br><img src="/media/article/dicht.png" alt="dic"></p><h4 id="1-3-2-哈希算法"><a href="#1-3-2-哈希算法" class="headerlink" title="1.3.2 哈希算法"></a>1.3.2 哈希算法</h4><p>Redis使用的是<a href="http://code.google.com/p/smhasher/" target="_blank" rel="noopener">MurmurHash2</a>算法。</p><ol><li>算出hash值：hash=dict-&gt;type-&gt;hashFunction(key);</li><li>根据hash值计算索引值：index = hash &amp; dict-&gt;ht[x].sizemask;//x是0或1</li></ol><h4 id="1-3-4-键冲突"><a href="#1-3-4-键冲突" class="headerlink" title="1.3.4 键冲突"></a>1.3.4 键冲突</h4><p>Redis的哈希表使用链地址法(separate chaining)来解决冲突，每个哈希表节点都有一个next指针，多个哈希表节点就可以用next指针构成一个单项链表。速度考虑，最新节点添加到表头位置，复杂度O(1)。</p><h4 id="1-3-5-rehash"><a href="#1-3-5-rehash" class="headerlink" title="1.3.5 rehash"></a>1.3.5 rehash</h4><blockquote><p><strong>为什么无论是HashMap还是Redis，扩容/收缩时容量大小都是2的幂？</strong></p><ul><li>减少碰撞次数，比如1111&amp;1110=1110，1110&amp;1110=1110；</li><li>容量*2不至于分配空间过大造成浪费；</li></ul></blockquote><p>Redis对字典的rehash步骤如下：</p><ol><li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量：</li></ol><ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n；</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^2；</li></ul><ol start="2"><li>将保存在ht[0]中的所有键值对rehash到ht[1]上:rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li></ol><p><strong> 哈希表的扩展与收缩 </strong></p><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p><ul><li>服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子=哈希表已保存节点数量/哈希表大小</span><br><span class="line">load_factor = ht[0].used/ht[0].size</span><br></pre></td></tr></table></figure><p>执行BGSAVE或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，大多数操作系统都采用写时复制(copy-on-write)技术优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子。<br>当哈希表的负载因子小于0.1时，程序自动开始执行收缩操作。</p><h4 id="1-3-6-渐进式rehash"><a href="#1-3-6-渐进式rehash" class="headerlink" title="1.3.6 渐进式rehash"></a>1.3.6 渐进式rehash</h4><p>rehash动作不是一次性、集中式的完成，而是分多次、渐进式的完成。<br>渐进式rehash步骤:</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash值ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作完成。</li></ol><p>在渐进式rehash期间，字典的删除、查找、更新等操作会在两个哈希表上进行。如果新加到字典的键值对一律被保存到ht[1]里面。</p><h3 id="1-4-跳跃表"><a href="#1-4-跳跃表" class="headerlink" title="1.4 跳跃表"></a>1.4 跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p><h4 id="1-4-1-结构"><a href="#1-4-1-结构" class="headerlink" title="1.4.1 结构"></a>1.4.1 结构</h4><p><img src="/media/article/skiplist.png" alt="skiplist"><br>上图展示了一个跳跃表示例，左边是zskiplist结构：</p><ul><li>header: 指向跳跃表的表头节点</li><li>tail: 指向跳跃表的结尾节点</li><li>level: 记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length: 记录跳跃表的长度，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>右侧是zskiplistNode结构：</p><ul><li>level: 节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，以此类推。每层两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，跨度则记录了前进指针所指向节点和当前节点的距离。</li><li>backward: 节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>score: 各个节点中的1.0、2.0、和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排序。</li><li>obj: 各个节点中的o1、o2和o3时节点所保存的成员对象。</li></ul><h3 id="1-5-整数集合"><a href="#1-5-整数集合" class="headerlink" title="1.5 整数集合"></a>1.5 整数集合</h3><p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。<br>整数集合是Redis用于保存整数值的集合抽象数据结构，他可以保存集合类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    // 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    // 集合包含的元素</span><br><span class="line">    uint32_t length;</span><br><span class="line">    // 保存元素的数据</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现:整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小从小打到有序的排列，并且数组中不包含任何重复项。</p><h4 id="1-5-1-整数集合升级"><a href="#1-5-1-整数集合升级" class="headerlink" title="1.5.1 整数集合升级"></a>1.5.1 整数集合升级</h4><p>每当我们将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合先进行升级，然后添加到整数集合里面。</p><p>升级步骤：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，放置元素过程中，需要维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><h3 id="1-6-压缩列表"><a href="#1-6-压缩列表" class="headerlink" title="1.6 压缩列表"></a>1.6 压缩列表</h3><p>当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><p>压缩列表是为了节约内存开发的，是由一系列特殊编码的连续内存块组织的顺序(sequential)数据结构。</p><p><img src="/media/article/ziplist.png" alt="ziplist"><br><img src="/media/article/ziplistintroduce.png" alt="ziplistintroduce"></p><p>节点content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><h4 id="1-6-1-连锁更新"><a href="#1-6-1-连锁更新" class="headerlink" title="1.6.1 连锁更新"></a>1.6.1 连锁更新</h4><p>连锁更新最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最快复杂度为O(N)，所以更新的最快复杂度为O(N^2)。</p><h3 id="1-7-快速列表-quicklist"><a href="#1-7-快速列表-quicklist" class="headerlink" title="1.7 快速列表(quicklist)"></a>1.7 快速列表(quicklist)</h3><p>quicklist是一个ziplist的双向链表（双向链表是由多个节点Node组成的）。也就是说quicklist的每个节点都是一个ziplist。ziplist本身也是一个能维持数据项先后顺序的列表（按插入位置），而且是一个各个数据项在内存上前后相邻的列表。<br>结构如下:</p><p><img src="/media/article/quicklist.png" alt="quicklist"><br>图片来自<a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a></p><p>quicklist基于空间和时间的考虑，结合双向链表和ziplist的优点。</p><blockquote><p>双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。<br>ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。<br>摘自<a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau Redis源码剖析–quicklist</a></p></blockquote><h3 id="1-8-对象"><a href="#1-8-对象" class="headerlink" title="1.8 对象"></a>1.8 对象</h3><p>Redis并没有 直接使用SDS、双端链表、字典、压缩列表、整数集合这些数据结构实现键值对数据库，而是基于这些数据结构创建了一个对象系统。对象系统包含：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。<br>Redis的对象系统实现了基于引用计数计数的内存回收机制，当程序 不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外Redis还通过引用计数技术实现了对象共享机制，这种机制在适当情况下，通过让多个数据库键共享同一个对象来节约内存。<br>Redis对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能情况下，空转时长较大的那些键可能会优先被服务器删除。</p><h4 id="1-8-1-对象的类型与编码"><a href="#1-8-1-对象的类型与编码" class="headerlink" title="1.8.1 对象的类型与编码"></a>1.8.1 对象的类型与编码</h4><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，一个对象用作键值对的值。</p><p>Redis中的每个对象都由一个RedisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    </span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    </span><br><span class="line">    // 指向底层实现数据结构的指针</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>type记录了对象的类型：</p><ul><li>REDIS_STRING:字符串对象</li><li>REDIS_LIST:列表对象</li><li>REDIS_HASH:哈希对象</li><li>REDIS_SET:集合对象</li><li>REDIS_ZSET:有序集合对象</li></ul><blockquote><p>字符串键指的是这个数据库键所对应的值得字符串对象<br>列表键指的是数据库键所对应的值为列表对象</p></blockquote><p>ptr指针指向对象的底层实现数据结构，这些数据结构由对象的encoding属性决定。encoding记录对象使用的编码：</p><p><img src="/media/article/encoding-type.png" alt="encoding"><br>除上述列表外，还有一个是REDIS_ENCODING_QUICKLIST编码，快速列表。</p><p>每种类型的对象都至少使用了两种不同编码，下表列出了每种类型的对象可以使用的编码。</p><p><img src="/media/article/type-encoding.png" alt="type-encoding"></p><p>除上述列表外，还有一个是REDIS_LIST对应REDIS_ENCODING_QUICKLIST。</p><h4 id="1-8-2-字符串对象"><a href="#1-8-2-字符串对象" class="headerlink" title="1.8.2 字符串对象"></a>1.8.2 字符串对象</h4><p>字符串对象的编码可以是int、raw或者embstr。<br>如果字符串对象保存的是整数值，将字符串对象的编码设置为int。<br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度大于32字节，字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为raw。<br>raw结构：<br><img src="/media/article/raw.png" alt="raw"><br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度小于32字节，字符串对象将使用embstr编码的方式保存这个字符串值。<br>embstr内存块结构：<br><img src="/media/article/embstr.png" alt="embstr"><br><strong>raw和embstr区别：</strong></p><ul><li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li><li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码字符串对象比起来raw编码的字符串能够更好地利用缓存带来的优势。</li></ul><p>字符串对象保存各类型值得编码方式:</p><p><img src="/media/article/string-type-value.png" alt="string"></p><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。<br>Redis没有为embstr编码的字符串对象编写任何响应的修改程序，所以embstr编码的字符串对象实际上是只读的。</p><p><img src="/media/article/string-order-implement.png" alt="string"></p><h4 id="1-8-3-列表对象"><a href="#1-8-3-列表对象" class="headerlink" title="1.8.3 列表对象"></a>1.8.3 列表对象</h4><p>列表对象的编码可以使ziplist或者linkedlist。<br>ziplist结构如下：<br><img src="/media/article/ziplist-store.png" alt="ziplist"></p><p>linkedlist结构如下：</p><p><img src="/media/article/linkedlist-store.png" alt="linkedlist"></p><p>StringObject结构：</p><p><img src="/media/article/string-obj-store.png" alt="string-object"></p><p>当列表对象满足如下条件时，使用ziplist编码：<br>列表对象保存的所有字符串元素的长度都小于64字节；<br>列表对象保存的元素数量小于512个；</p><p><strong>列表命令的实现：</strong><br><img src="/media/article/list-order-implement.png" alt="list-order"></p><h4 id="1-8-4-哈希对象"><a href="#1-8-4-哈希对象" class="headerlink" title="1.8.4 哈希对象"></a>1.8.4 哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值得压缩列表节点推入到压缩列表表尾：</p><ul><li>因此保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;HSET profile name &quot;Tom&quot;</span><br><span class="line">&gt;HSET profile age 25</span><br><span class="line">&gt;HSET profile career &quot;Programmer&quot;</span><br></pre></td></tr></table></figure></p><p>哈希对象的压缩列表底层实现：</p><p><img src="/media/article/hash-ziplist-implement.png" alt="hash-ziplist-implement"></p><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><p>如果上述例子不是ziplist而是hashtable，则结构如下：</p><p><img src="/media/article/hashtable-implement.png" alt="hashtable-implement"></p><p>如果哈希对象满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值得字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；</li></ul><p><strong>hash命令：</strong></p><p><img src="/media/article/hash-order.png" alt="hash-order"></p><h4 id="1-8-5-集合对象"><a href="#1-8-5-集合对象" class="headerlink" title="1.8.5 集合对象"></a>1.8.5 集合对象</h4><p>集合对象编码可以是intset或者hashtable。</p><p><strong>集合命令：</strong></p><p><img src="/media/article/set-order.png" alt="set-order"><br><img src="/media/article/set-order1.png" alt="set-order"></p><h4 id="1-8-6-有序集合对象"><a href="#1-8-6-有序集合对象" class="headerlink" title="1.8.6 有序集合对象"></a>1.8.6 有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist。</p><p><strong>ziplist的的存储结构：</strong></p><p><img src="/media/article/sorted-set-ziplist.png" alt="sorted-set-ziplist"><br><img src="/media/article/sorted-set-ziplist1.png" alt="sorted-set-ziplist"></p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset&#123;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点保存了一个集合元素:跳跃表节点的Object属性保存了元素的成员，而跳跃表的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，如<code>ZRANK</code>、<code>ZRANGE</code>等命令就是基于跳跃表API来实现的。</p><p>除此之外，zset结构中的dict字典为有序集合创建了一个从成员的分值的映射，字典中的每个键值对都保存了一个集合元素:字典的键保存了元素的成员，而字典的值保存了元素的分值。通过这个字典，程序可以O(1)复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的。</p><p>虽然zset结构同时使用跳跃表和字典来保存有序集合元素，而这两种数据机构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或分值，也不会浪费额外内存。</p><blockquote><p><strong>为什么有序集合需要同时使用跳跃表和字典来实现？</strong><br>如果我们只是用字典来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p></blockquote><p><strong>skiplist结构：</strong></p><p><img src="/media/article/sorted-set-skiplist.png" alt="sorted-set-skiplist"></p><p><strong><em>注意：字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p><strong>命令实现：</strong></p><p><img src="/media/article/sorted-set-order.png" alt="sorted-set-order"></p><h4 id="1-8-7-类型检查与命令多态"><a href="#1-8-7-类型检查与命令多态" class="headerlink" title="1.8.7 类型检查与命令多态"></a>1.8.7 类型检查与命令多态</h4><p>Redis中用于操作键的命令基本上可以分为两种类型。<br>一种可以对任何类型键执行；另一种只能对特定类型的键执行。</p><p>Redis在执行一个类型特定的命令之前，会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。<br>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的:</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需类型，如果是的话执行。</li><li>否则，拒绝执行，返回类型错误。</li></ul><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。如llen：</p><p><img src="/media/article/llen-order.png" alt="llen-order"></p><h4 id="1-8-8-内存回收"><a href="#1-8-8-内存回收" class="headerlink" title="1.8.8 内存回收"></a>1.8.8 内存回收</h4><p>因为C不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数(reference counting)技术实现的内存回收机制。</p><h4 id="1-8-9-对象共享"><a href="#1-8-9-对象共享" class="headerlink" title="1.8.9 对象共享"></a>1.8.9 对象共享</h4><p>Redis对象的引用计数属性还带有对象共享的作用（多个键共享同一个值对象）。<br>这些共享对象不单单只有字符串键可以使用，那些数据结构中嵌套了字符串对象的对象都可以使用这些共享对象。</p><p>Redis只对包含整数值的字符串对象进行共享。</p><h4 id="1-8-10-对象的空转时长"><a href="#1-8-10-对象的空转时长" class="headerlink" title="1.8.10 对象的空转时长"></a>1.8.10 对象的空转时长</h4><p>除了type、encoding、ptr和refcount四个属性外，redisObject结构包含的最后一个属性为lru属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    unsigned lru:22;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>OBJECT IDLETIME命令可以打印出键的空转时长，计算方式：当前时间-lru。</p><h2 id="2-单机数据库实现"><a href="#2-单机数据库实现" class="headerlink" title="2. 单机数据库实现"></a>2. 单机数据库实现</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p><p><strong>数据库结构示例：</strong><br><img src="/media/article/redis-db.png" alt="db"></p><p>redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典成为键空间：</p><p><strong>数据库键空间示例：</strong><br><img src="/media/article/redis-db-keyspace.png" alt="db"></p><p>键空间的键也就是数据库的键，每个键都是一个字符串对象。<br>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。<br>数据库的键空间是一个字典。</p><p><strong> 读写空间时的维护操作</strong></p><ul><li>读取一个键后，服务器会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>读取一个键后，服务器会更新键的LRU时间，可以使用OBJECT idletime <key> 命令查看键key的闲置时间。</key></li><li>如果服务器在读取一个键时发现该键过期，服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果客户端使用watch命令监视了某个键，那么服务器在对被监视的键进行修改后，会将这个键标记为脏(dirty)。</li><li>服务器每次修改一个键后，都会对(dirty)键计数器的值增1，这个计数器会触发服务器的持久化及复制操作。</li><li>如果服务器开启了数据库通知功能，那么对键进行修改之后，服务器将按配置发送响应的数据库通知。</li></ul><h3 id="2-1-过期时间"><a href="#2-1-过期时间" class="headerlink" title="2.1 过期时间"></a>2.1 过期时间</h3><p>Redis有四种不同的命令可以用于设置键的生存时间或过期时间:</p><ul><li><code>EXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl秒。</li><li><code>PEXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl毫秒。</li><li><code>EXPIREAT&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp秒数时间戳。</li><li><code>PEXPIRE&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp毫秒数时间戳。</li></ul><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典:</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><p>PERSIST命令可以移除一个键的过期时间。</p><p>TTL命令以秒级单位返回键的剩余生存时间，PTTL命令以毫秒为单位返回键的剩余生存时间。</p><h3 id="2-2-过期键删除策略"><a href="#2-2-过期键删除策略" class="headerlink" title="2.2 过期键删除策略"></a>2.2 过期键删除策略</h3><p>定时删除: 在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作。<br>惰性删除: 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。<br>定期删除: 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><h4 id="2-2-1-定时删除"><a href="#2-2-1-定时删除" class="headerlink" title="2.2.1 定时删除"></a>2.2.1 定时删除</h4><p>定时删除对内存友好，对CPU时间不友好，在过期键比较多的情况下，删除过期键这一行为可能会占用相同一部分CPU时间。</p><h4 id="2-2-2-惰性删除"><a href="#2-2-2-惰性删除" class="headerlink" title="2.2.2 惰性删除"></a>2.2.2 惰性删除</h4><p>惰性删除策略对CPU友好，对内存不友好。有内存泄漏的风险。</p><h4 id="2-2-3-定期删除"><a href="#2-2-3-定期删除" class="headerlink" title="2.2.3 定期删除"></a>2.2.3 定期删除</h4><p>定期删除操作的难点在于如果确定删除操作的时长和频率。</p><h4 id="2-2-4-Redis的过期删除策略"><a href="#2-2-4-Redis的过期删除策略" class="headerlink" title="2.2.4 Redis的过期删除策略"></a>2.2.4 Redis的过期删除策略</h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略。</p><h4 id="2-2-5-AOF、RDB和复制功能对过期键的处理"><a href="#2-2-5-AOF、RDB和复制功能对过期键的处理" class="headerlink" title="2.2.5 AOF、RDB和复制功能对过期键的处理"></a>2.2.5 AOF、RDB和复制功能对过期键的处理</h4><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件是，程序会对数据库中的键进行检查，已过期的键不会保存到新建的RDB文件中。</p><p><strong>RDB文件载入：</strong></p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模型运行，那么载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过主从服务器在进行数据同步时，从服务器的数据库会被清空。</li></ul><p>AOF重写的过程中，会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><p>当服务器在复制模式下时，从服务器的过期键删除动作有主服务器控制:</p><ul><li>主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告诉从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，及时碰到过期键也不会将过期键删除，而继续像处理未过期的键一样处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令后，才会删除过期键。</li></ul><h4 id="2-2-6-数据库通知"><a href="#2-2-6-数据库通知" class="headerlink" title="2.2.6 数据库通知"></a>2.2.6 数据库通知</h4><p>数据库通知时Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>监听索引为0的键空间key为message所有操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SUBSCRIBE __keyspace@0__:message</span><br></pre></td></tr></table></figure></p><h3 id="2-3-RDB持久化"><a href="#2-3-RDB持久化" class="headerlink" title="2.3 RDB持久化"></a>2.3 RDB持久化</h3><h4 id="2-3-1-RDB文件的创建与载入"><a href="#2-3-1-RDB文件的创建与载入" class="headerlink" title="2.3.1 RDB文件的创建与载入"></a>2.3.1 RDB文件的创建与载入</h4><p>Redis命令可用于生成RDB文件，一个是SAVE，另一个是BGSAVE。<br>SAVE会阻塞Redis服务进程，知道RDB文件创建完毕，阻塞期间，服务器不能处理任何命令请求。<br>BGSAVE命令会派生除一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求。<br>BGSAVE命令正在执行，客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕后执行。<br>BGREWRITEAOF正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</p><blockquote><p>如果开启了AOF持久化功能，服务器会优先使用AOF文件还原数据库状态。<br>只有AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</p></blockquote><h4 id="2-3-2-自动间隔性保存"><a href="#2-3-2-自动间隔性保存" class="headerlink" title="2.3.2 自动间隔性保存"></a>2.3.2 自动间隔性保存</h4><h4 id="2-3-3-RDB文件结构"><a href="#2-3-3-RDB文件结构" class="headerlink" title="2.3.3 RDB文件结构"></a>2.3.3 RDB文件结构</h4><p><img src="/media/article/rdb-structure.png" alt="rdb"></p><p>REDIS部分用来校验是否为RDB文件。<br>db_version长度为4字节，记录RDB文件的版本号。<br>databases部分包含着两个或者任意多个数据库，以及各个数据库中的键值对数据。<br>EOF标志着RDB文件的正文结束。<br>check_sum保存着一个校验和，由REDIS、db_version、databases、EOF计算得出。校验RDB文件是否出错或者损坏。</p><p>database部分保存任意多个非空数据库，如下图所示，每个非空数据库可以保存SELECTDB、db_number、key_value_pairs:</p><p><img src="/media/article/rdb-structure1.png" alt="rdb"><br><img src="/media/article/rdb-database.png" alt="rdb"></p><p>SELEECT表示数据库号码。<br>db_number保存一个数据库号码。<br>key_value_pairs保存数据库中的所有键值对数据。</p><p><img src="/media/article/rdb-file-structure.png" alt="rdb"></p><p>key_values_pairs保存了一个以上的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。<br>不过期时间的键值对由TYPE、key、value组成。<br>TYPE:</p><ul><li>REDIS_RDB_TYPE_STRING</li><li>REDIS_RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_ZIPLIST</li></ul><p>过期时间的键值对在RDB文件中结构:<br><img src="/media/article/rdb-expire-structure.png" alt="rdb"></p><h3 id="2-4-AOF持久化"><a href="#2-4-AOF持久化" class="headerlink" title="2.4 AOF持久化"></a>2.4 AOF持久化</h3><p>AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤。</p><h4 id="2-4-1-命令追加"><a href="#2-4-1-命令追加" class="headerlink" title="2.4.1 命令追加"></a>2.4.1 命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-2-文件写入与同步"><a href="#2-4-2-文件写入与同步" class="headerlink" title="2.4.2 文件写入与同步"></a>2.4.2 文件写入与同步</h4><p>Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def eventLoop():</span><br><span class="line">    while True:</span><br><span class="line">        # 处理文件事件，接收命令请求以及发送命令回复</span><br><span class="line">        # 处理命令请求时可能会有新内容被追加到aof_buf缓冲区中</span><br><span class="line">        processFileEvents()</span><br><span class="line">        </span><br><span class="line">        # 处理时间事件</span><br><span class="line">        processTimeEvents()</span><br><span class="line">        </span><br><span class="line">        # 考虑是否将aof_buf中的内容写入和保存到AOF文件里面</span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定，各个不同值产生的行为如表:<br><img src="/media/article/appendfsycn.png" alt="appendfsync"></p><h4 id="2-4-3-AOF重写"><a href="#2-4-3-AOF重写" class="headerlink" title="2.4.3 AOF重写"></a>2.4.3 AOF重写</h4><p>因为AOF通过保存执行的写命令来记录数据库状态，所以可能造成AOF文件过大。为了解决这个问题，Redis提供了AOF文件重写功能。通过创建一个新的AOF文件替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF通常比旧AOF小得多。<br>重写功能通过读取服务器当前的数据状态来实现的。因为aof——rewirte函数生成的新的AOF只包含还原当前数据库状态所必需的的命令，所以新AOF文件不会浪费任何硬盘空间。</p><p><strong>注意:</strong><br>在实际中，为了避免执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查所包含的元素数量，如果元素数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值。</p><p>aof_rewrite会长时间阻塞，所以Redis将AOF重写程序放到子进程里执行:</p><ul><li>子进程进行AOF重写期间，服务器进程可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>AOF重写期间，客户端命令可能对现有数据库状态修改，造成当前数据库状态和AOF文件不一致的情况。</p><p>为了解决不一致的情况，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令后，它同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>AOF完成重写后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作:</p><ul><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子的覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ul><p>AOF后台重写过程中，只有信号处理函数执行时会对服务器进程造成阻塞，其他时候，AOF不会阻塞父进程。</p><h3 id="2-5-事件"><a href="#2-5-事件" class="headerlink" title="2.5 事件"></a>2.5 事件</h3><p>Redis服务器是一个事件驱动程序:</p><ul><li>文件事件: Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信产生响应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件: Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h4 id="2-5-1-文件事件"><a href="#2-5-1-文件事件" class="headerlink" title="2.5.1 文件事件"></a>2.5.1 文件事件</h4><p>Redis基于Reactor模式开发了自己的网络事件处理器: 这个处理器被称为文件事件处理器:</p><ul><li>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><h4 id="2-5-2-时间事件"><a href="#2-5-2-时间事件" class="headerlink" title="2.5.2 时间事件"></a>2.5.2 时间事件</h4><p>Redis的时间事件分为以下两类:</p><ul><li>定时事件: 让一段程序在指定的时间之后执行一次。</li><li>周期性时间: 让一段程序每隔指定时间执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成:</p><ul><li>id: 服务器为时间事件创建的全局唯一ID。从小到大递增。</li><li>when: 毫秒级精度的UNIX时间戳，记录了时间事件的到达时间。</li><li>timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件: 该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性事件: 当一个时间事件到达之后，服务器会根据事件处理器返回的值，对事件事件的when属性进行更新，这个事件在一段时间之后再次到达，并以这种方式一致更新并运行下去。</li></ul><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行，这些定期操作由redis.c/serverCron函数负责执行，主要工作包括:</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF和RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><h4 id="2-5-3-事件调度与执行"><a href="#2-5-3-事件调度与执行" class="headerlink" title="2.5.3 事件调度与执行"></a>2.5.3 事件调度与执行</h4><p>事件调度和执行由ae.c/aeProcessEvents函数负责。</p><blockquote><p>processFileEvent这个函数并不存在，在实际中，处理已产生文件事件的代码是直接写在aeProcessEvents函数里面。</p></blockquote><p>事件调度和执行规则:</p><ol><li>aeApiPoll函数的最大阻塞时间由到达时间最近当前时间的时间事件决定，这个方法既可以避免服务器对事件事件进行频繁的轮询，也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何事件事件到达，那么服务器将再次等待处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件。</li><li>对文件事件和时间事件的处理都是同步、有序、原子的执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此不管是文件事件的处理器，还是时间事件的处理器，也不会对事件进行抢占，一次不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可的减少程序阻塞时间，并在有需要时主动让出执行权，从而降低造成时间饥饿的可能性。另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li><li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间晚一些。</li></ol><h2 id="3-多机数据库实现"><a href="#3-多机数据库实现" class="headerlink" title="3. 多机数据库实现"></a>3. 多机数据库实现</h2><h3 id="3-1-复制"><a href="#3-1-复制" class="headerlink" title="3.1 复制"></a>3.1 复制</h3><p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制(replicate)另一个服务器。</p><p>Redis复制功能分为同步和命令传播两个操作：</p><ul><li>同步操作用于将服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致的状态。</li></ul><p>Redis复制实现：</p><ol><li>客户端发送命令(此命令是异步的)：<code>&gt;SLAVEOF master-ip master-port</code>。</li><li>1命令在从服务上完成masterhost和masterport属性的设置之后，从服务器返回OK。</li><li>从服务器根据masterhost和masterport建立socket连接。</li><li>发送PING命令，检查socket连接的读写状态，检查主服务器的命令处理，如果主服务器返回非PONG，则断开并重连主服务器。</li><li>从服务器发送身份验证信息。</li><li>发送从服务器的端口信息。</li><li>同步PSYNC。</li><li>最后命令传播。</li></ol><p>Redis复制流程图：</p><p><img src="/media/article/redis-replicate.png" alt="redis-replicate"></p><p>从Redis 2.8版本开始，Redis使用PSYNC代替SYNC命令执行复制操作。<br>PSYNC命令执行：</p><p><img src="/media/article/psync.png" alt="PSYNC"></p><p>PSYNC与SYNC最显著的区别是PSYNC支持部分重同步。</p><h3 id="3-2-Sentinel"><a href="#3-2-Sentinel" class="headerlink" title="3.2 Sentinel"></a>3.2 Sentinel</h3><p>Sentinel是Redis的高可用解决方案。</p><p>启动Sentinel时，执行<code>redis-server /path/sentinel.conf --sentinel</code>或者<code>redis-sentinel /path/sentinel.conf</code>命令即可。</p><p>Sentinel启动时，需要执行以下步骤：</p><ol><li>初始化服务器</li><li>将普通Redis服务器使用的代码替换成Sentinel专用代码</li><li>初始化Sentinel状态</li><li>根据给定配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连向主服务器的网络连接</li></ol><p>Sentinel状态图：<br><img src="/media/article/redis-sentinel-state.png" alt="redis-sentinel-state"></p><h4 id="3-2-1-获取主从、Sentinel的信息"><a href="#3-2-1-获取主从、Sentinel的信息" class="headerlink" title="3.2.1 获取主从、Sentinel的信息"></a>3.2.1 获取主从、Sentinel的信息</h4><p>初始化Sentinel最后一步是创建连向主服务器的网络连接，Sentinel将成为主服务器的客户端。</p><p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络：</p><ul><li>命令连接，这个连接专门向主服务器发送命令，并接收命令回复。</li><li>订阅连接，这个连接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道。 </li></ul><p>Sentinel默认以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，通过INFO获取主服务器的当前信息。<br>Sentinel通过主服务器发现从服务器时，也会建立上述的两个连接，每10秒发送INFO命令，获取从服务器的当前信息。<br>默认情况下，Sentinel每2秒通过命令连接向所有主从服务器发送如下命令：<br><code>PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_id&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;</code>“</p><p>s开头的是sentinel的信息，m开头的是主服务器的信息，如果发送的是从服务器，则m为从服务器正在复制的主服务器的信息。<br>Sentinel与一个主或从服务器建立订阅连接后，Sentinel就会通过订阅连接，向服务器发送以下命令:<br><code>SUBSCRIBE __sentinel__:hello</code></p><p>Sentinel通过频道信息发现一个新的Sentinel时，不仅会为新的Sentinel创建相应的实例结构，还会创建一个连向新Sentinel的命令连接。</p><h4 id="3-2-1-下线状态"><a href="#3-2-1-下线状态" class="headerlink" title="3.2.1 下线状态"></a>3.2.1 下线状态</h4><p>Sentinel每1秒一次的频率向所有与它建立命令连接的实例发送PING命令，判断是否在线。<br>实例在down-after-milliseconds内返回+PONG、-LOADING、-MASTERDOWN以外的回复，Sentinel将修改该实例的flags属性:SRI_S_DOWN标识，标识进入主观下线状态。<br>超时也会被置为主观下线状态。</p><p>当主服务器被判定为主观下线后，为确认是否真的下线了，Sentinel会询问监视此服务器的其他Sentinel，如果从其他Sentinel得到足够数量的已下线判断后，Sentinel将此服务器置为客观下线。</p><p>Redis下线状态及Sentinel领头选举：<br><img src="/media/article/redis-down.png" alt="redis-down"><br>上图中，1. master代表一个主服务器，2. 监视master的sentinel代表其中一个监视master的sentinel(所有监视master的sentinel都会这样去操作，这个地方只是列出来一个作为示例)，3. 监视master的sentinel代表监视master的sentinel的集合。</p><h4 id="3-2-2-故障转移"><a href="#3-2-2-故障转移" class="headerlink" title="3.2.2 故障转移"></a>3.2.2 故障转移</h4><p>故障转移步骤：</p><ul><li><ol><li>在已下线的主服务器的从服务器中，选一个作为主服务器。</li></ol></li><li><ol start="2"><li>让其他没有作为主服务器的从服务器复制新的主服务器。</li></ol></li><li><ol start="3"><li>将已下线的主服务器置为新主服务器的从服务器，当下线的主服务器再上线时，它就会成为新主服务器的从服务器。</li></ol></li></ul><h3 id="3-3-集群"><a href="#3-3-集群" class="headerlink" title="3.3 集群"></a>3.3 集群</h3><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。</p><h4 id="3-3-1-节点"><a href="#3-3-1-节点" class="headerlink" title="3.3.1 节点"></a>3.3.1 节点</h4><p>当一个节点node发送<code>CLUSTER MEET &lt;IP&gt; &lt;PORT&gt;</code>命令，可以让node节点与ip和port所指定的节点进行握手(handshake)，当握手成功后，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。<br>集群数据结构示例:<br><img src="/media/article/redis-cluster.png" alt="cluster"></p><h4 id="3-3-2-槽"><a href="#3-3-2-槽" class="headerlink" title="3.3.2 槽"></a>3.3.2 槽</h4><p>Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为16384个槽(slot)，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理0个或者最多16384个槽。</p><p>如果16384个槽都有节点在处理时，集群处于上线状态(ok)，相反如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态(fail)。</p><p>槽分配命令<code>CLUSTER ADSLOTS &lt;slot&gt; [slot ...]</code>，例如<code>127.0.0.1:6379&gt;cluster addslots 0 1 2 ... 1000</code>将0到1000的槽分配给本地的6379节点负责。</p><p>槽分配后节点的ClusterState结构:</p><p><img src="/media/article/redis-clusterstate.png" alt="clusterstate"></p><p>集群节点数据库存储结构:</p><p><img src="/media/article/redis-clusterstate1.png" alt="clusterstate"></p><p>集群节点保存key对应槽的跳跃表:</p><p><img src="/media/article/redis-slots-to-key.png" alt="clusterstate"></p><h4 id="3-3-3-分片"><a href="#3-3-3-分片" class="headerlink" title="3.3.3 分片"></a>3.3.3 分片</h4><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的减值对也会从源节点被移动到目标节点。</p><p>Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重分配分片所需要的所有命令。</p><p>Redis重分片迁移过程:</p><p><img src="/media/article/redis-migrate.png" alt="migrate"></p><p>迁移过程中，查询key的命令过程如下:</p><p><img src="/media/article/redis-ask.png" alt="redis-ask"></p><p><img src="/media/article/redis-asking.png" alt="redis-asking"></p><h4 id="3-3-4-故障检测"><a href="#3-3-4-故障检测" class="headerlink" title="3.3.4 故障检测"></a>3.3.4 故障检测</h4><p>集群中的每个节点都会定期的向集群中的其他节点发送PING消息，以此来检测对方是否在线。</p><h4 id="3-3-5-消息"><a href="#3-3-5-消息" class="headerlink" title="3.3.5 消息"></a>3.3.5 消息</h4><p>集群中的各个节点通过发送和接收消息(message)来进行通信。消息主要以下五种:</p><ul><li>MEET消息:当发送者接收客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</li><li>PING消息:集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对五个节点中最长时间没有发送过PING消息的节点发送PING消息。</li><li>PONG消息:当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。</li><li>FAIL消息:当一个主节点A判断另一个主节点B进入FAIL状态时，节点A会向集群广播一条关于B的FAIL消息，所有接收到这条消息的节点都会立即将B标记为已下线。</li><li>PUBLISH消息:当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收者都会执行相同的PUBLISH命令。</li></ul><p>Redis集群中的各个节点通过Gossip协议来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG是三种消息实现。三种消息使用相同的消息正文，通过消息头type区分消息。</p><h2 id="4-独立功能的实现"><a href="#4-独立功能的实现" class="headerlink" title="4. 独立功能的实现"></a>4. 独立功能的实现</h2><h3 id="4-1-事务"><a href="#4-1-事务" class="headerlink" title="4.1 事务"></a>4.1 事务</h3><p>Redis 通过MULTI、EXEC、WATCH等命令来说实现事务。<br>事务在执行期间，服务器不会中断事务处理其他请求。</p><h4 id="4-1-1-事务的实现"><a href="#4-1-1-事务的实现" class="headerlink" title="4.1.1 事务的实现"></a>4.1.1 事务的实现</h4><p>一个事务从开始时到结束通常经历3个阶段:</p><ol><li>事务开始: MULTI</li><li>命令入队: <command></li><li>事务执行: EXEC</li></ol><h4 id="4-1-2-WATCH-命令的实现"><a href="#4-1-2-WATCH-命令的实现" class="headerlink" title="4.1.2 WATCH 命令的实现"></a>4.1.2 WATCH 命令的实现</h4><p>WATCH命令是一个乐观锁(optimistic locking)，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少少有一个已经被修改过了，如果是，则拒绝执行事务，并向客户端返回代表事务执行失败的空回复。<br>每个Redis数据库都保存着一个watched_keys字典，这个字典的键时某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。<br>如果有修改命令对数据库键修改过，那么touchWatchKey函数将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，标识该客户端的事务安全性被破坏。</p><p><img src="/media/article/watch-transaction.png" alt="watch"></p><h4 id="4-1-3-事务的ACID性质"><a href="#4-1-3-事务的ACID性质" class="headerlink" title="4.1.3 事务的ACID性质"></a>4.1.3 事务的ACID性质</h4><p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕。</p><p>Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性，从而确保事务的一致性。以下介绍Redis事务可能出错的地方，并说明Redis是如何妥善处理这些错误。</p><ol><li>入队错误：服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被带有入队错误的事务影响。</li><li>执行错误：</li></ol><ul><li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时触发。</li><li>即使在事务的执行过程中发生错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令不会被出错的命令影响。</li></ul><ol start="3"><li>服务器停机：</li></ol><ul><li>如果Redis服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。</li><li>如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，空白的总是一致的。</li><li>如果服务器运行在AOF模式下，那么事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>BGSAVE 是否会存执行BGSAVE命令后客户端请求的命令？</li><li>假如说每秒执行一次AOF持久化，那么Redis从aof缓冲区写入AOF文件时，服务端处理的命令是否会存入缓冲区，是否会进入AOF文件？</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong><em>文中的列表和图片大都引用自<a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a></em></strong></p><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a><br><a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau-Redis源码解析-quicklist</a><br><a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数据结构与对象&quot;&gt;&lt;a href=&quot;#1-数据结构与对象&quot; class=&quot;headerlink&quot; title=&quot;1. 数据结构与对象&quot;&gt;&lt;/a&gt;1. 数据结构与对象&lt;/h2&gt;&lt;h3 id=&quot;1-1-简单动态字符串（SDS）&quot;&gt;&lt;a href=&quot;#1-1-简单动
      
    
    </summary>
    
    
      <category term="redis" scheme="https://zhongyp.me/tags/redis/"/>
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>How to Write Doc Comments for the Javadoc Tool</title>
    <link href="https://zhongyp.me/java/2019-05-19-javadoc-guide/"/>
    <id>https://zhongyp.me/java/2019-05-19-javadoc-guide/</id>
    <published>2019-05-18T16:00:00.000Z</published>
    <updated>2019-05-19T12:28:11.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.oracle.com/technetwork/articles/javase/index-137868.html" target="_blank" rel="noopener">How to Write Doc Comments for the Javadoc Tool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/articles/javase/index-1378
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型</title>
    <link href="https://zhongyp.me/java/2019-05-06-java-generics/"/>
    <id>https://zhongyp.me/java/2019-05-06-java-generics/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-06-05T11:29:39.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote><p><strong>其他参数术语：</strong><br>参数化的类型(parameterized type)：<code>List&lt;String&gt;</code><br>实际类型参数(type arguments)：<code>String</code><br>泛型(generic type)：<code>List&lt;E&gt;</code><br>形式类型参数(formal parameter types)：<code>E</code><br>无限制通配符类型(unbounded wildcards)：<code>List&lt;?&gt;</code><br>原生态类型(raw type)：<code>List</code><br>有限制类型参数(bounded type parameter)：<code>&lt;E extends Number&gt;</code><br>递归类型限制(recursive type restriction)：<code>&lt;T extends Comparable&lt;T&gt;&gt;</code><br>有限制通配符类型(bounded wildcards)：<code>List&lt;? extends Number&gt;</code><br>泛型方法(generic method)：<code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code><br>类型令牌(type token)：<code>String.class</code></p><p>– 摘自《Effective Java》</p></blockquote><p>Java集合有个缺点：集合对元素类型没有任何限制，这样就会引发一些问题，例如：创建一个只保存Dog对象的集合，但是程序也能将Cat对象放进去。由于把对象放进集合时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此去除集合元素后通常还需要进行强制类型转换。</p><p>为了解决上述问题，从JDK1.5之后，Java引入了“参数化类型（parameterized type）”的概念，Java的参数化类型被称为泛型（Generic）。</p><p>所谓泛型：就是允许在定义类、接口时指定类型形参（type parameters），这个类型形参将在声明变量、创建对象时确定。泛型的作用就是在编译时保证类型安全。</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>定义泛型接口、类示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义接口时指定一个类型形参</span><br><span class="line">public interface List&lt;E&gt;&#123;</span><br><span class="line">    //在接口里，E可以作为类型使用</span><br><span class="line">    void add(E x);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    E asList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>注意：</em></strong></p><ul><li>包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参(type arguments)，从而可以动态生成无数多个逻辑上的子类，但这种子类在物理上并不存在。</li><li>当创建泛型声明的自定义类，为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明。例如：为<code>Apple&lt;T&gt;</code>类定义构造器，其构造器名依然是<code>Apple</code>，而不是<code>Apple&lt;T&gt;</code>，但调用构造器时可以使用<code>Apple&lt;T&gt;</code>，此时T应该为实参类型。</li></ul><h3 id="2-1-从泛型类派生子类"><a href="#2-1-从泛型类派生子类" class="headerlink" title="2.1 从泛型类派生子类"></a>2.1 从泛型类派生子类</h3><p>当创建子类使用泛型接口或类时，不能再包含类型形参。如下代码时错误的：<br><code>public class A extends Apple&lt;T&gt;{}</code><br>正确方式如下：<br><code>public class A extends Apple&lt;String&gt;{}</code></p><p>类的静态变量和方法在所有的实例间共享，所以在静态方法、静态初始化或者静态变量的声明和初始化中不允许使用类型形参。原因见<a href="#4-3-不能声明静态字段的类型为类型参数">4.3 不能声明静态字段的类型为类型参数</a></p><p>由于系统对于泛型类或接口并不会生成真正的泛型类或接口（即逻辑上的子类，并不是生成真正的子类），所以instanceof运算符后不能使用泛型类。（具体原因见<a href="#4-4-不能使用参数化类型强制类型转换或者instanceof">4.4 不能使用参数化类型强制类型转换或者instanceof</a>）如下的代码时错误的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = new ArrayList&lt;String&gt;();</span><br><span class="line">if(cs instanceof List&lt;String&gt;)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-类型通配符"><a href="#2-2-类型通配符" class="headerlink" title="2.2 类型通配符"></a>2.2 类型通配符</h3><p>类型通配符既可以在方法签名中定义形参的类型，也可以用于定义变量的类型。使用通配符比显式声明通配符声明类型形参更加清晰准确，所以在可能的情况下，使用通配符更好。</p><h4 id="2-2-1-不受约束的通配符"><a href="#2-2-1-不受约束的通配符" class="headerlink" title="2.2.1 不受约束的通配符"></a>2.2.1 不受约束的通配符</h4><p>通配符可用于各种情况：作为参数，字段或局部变量的类型;有时作为返回类型（虽然更好的编程实践更具体）。通配符从不用作泛型方法调用，泛型类实例创建或超类型的类型参数。</p><p>如果满足下面的条件任意一个，就可以使用不受约束通配符：</p><ul><li>如果你正在编写可以<strong>使用Object类中提供的方法实现</strong>的方法。</li><li>当代码使用在泛型类中不依赖类型参数方法时。例如：List.size 或者 List.clear。 事实上，Class&lt;?&gt;经常被使用，因为Class<t>中的大多数方法不依赖T。</t></li></ul><p>使用通配符时，不能将元素放入未知类型的集合中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aaa&quot;);//这行代码引起编译时错误。因为不知道list的类型，所以不能往里面放任何元素，除了null。</span><br></pre></td></tr></table></figure><h4 id="2-2-2-上限通配符"><a href="#2-2-2-上限通配符" class="headerlink" title="2.2.2 上限通配符"></a>2.2.2 上限通配符</h4><p>使用<code>? extend type</code>表示所有type泛型类的子类（包含type本身）。</p><h4 id="2-2-3-下限通配符"><a href="#2-2-3-下限通配符" class="headerlink" title="2.2.3 下限通配符"></a>2.2.3 下限通配符</h4><p>使用<code>? super type</code>表示所有type泛型类的父类（包含type本身）。<del>只能用于泛型方法（有待验证）。</del></p><h4 id="2-2-4-通配符捕获和Helper方法"><a href="#2-2-4-通配符捕获和Helper方法" class="headerlink" title="2.2.4 通配符捕获和Helper方法"></a>2.2.4 通配符捕获和Helper方法</h4><p>在一些情况下，编译器会推断一个通配符的类型。例如，一个列表可以被定义为<code>List&lt;?&gt;</code>，当评估一个表达式时，编译器会从代码中推断一个特定类型。此方案称为通配符捕获。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardError &#123;</span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.set(0, i.get(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>i.set</code>方法编译异常，类型参数<code>List&lt;?&gt;</code>为不确定类型参数，所以<code>i.get(0)</code>获取的类型参数不确定，因此<code>i.set</code>方法不能将未知类型放入<code>i</code>中。（其中i.set默认是i.set(Integer,Object)，因为不确定i.get(0)的类型，所以产生编译问题）解决方案如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardFixed &#123;</span><br><span class="line"></span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // Helper method created so that the wildcard can be captured</span><br><span class="line">    // through type inference.</span><br><span class="line">    private &lt;T&gt; void fooHelper(List&lt;T&gt; l) &#123;</span><br><span class="line">        l.set(0, l.get(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-通配符和子类型"><a href="#2-2-5-通配符和子类型" class="headerlink" title="2.2.5 通配符和子类型"></a>2.2.5 通配符和子类型</h4><p>如泛型，继承和子类型中所述，泛型类或接口仅仅因为它们的类型不同而无关。但是，您可以使用通配符在泛型类或接口之间创建关系。下图是Number和Integer之间的继承关系：<br><img src="/media/article/15579245029350.jpg" alt=""></p><h3 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c)&#123;</span><br><span class="line">    for(T o:a)&#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面示例中，定义了一个泛型方法，该泛型方法中定义了一个T类型形参，这个T类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型形参不同的是，方法声明中定义的形参只能在该方法里使用，而接口、类声明中的定义的类型形参则可以在整个接口、类中使用。<br>与类、接口中使用泛型参数不同的是，方法中的泛型参数无需显式传入实际类型参数，根据实参推断类型形参的值。如果编译器不能推断你希望它拥有的类型，可以通过一个显示的类型参数（explicit type parameter）来告诉它要使用哪种类型。<br>泛型方法的用法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,S&gt; 返回值类型 方法名（形参列表）&#123;</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><em>提示：</em></strong><br>如果某个方法中一个形参（a）的类型或返回值类型依赖于另一个形参（b）的类型，则形参（b）的类型声明不应该使用通配符，因为形参（a）、或返回值与该形参（b）的类型，如果形参（b）的类型无法确定，程序无法定义形参（a）的类型。在这种情况下，<strong><em>只能考虑使用在方法签名中声明类型形参</em></strong>。</p></blockquote><p>类型通配符与显式声明类型形参区别：</p><ul><li>类型通配符即可在方法签名中定义形参的类型，也可以用于定义变量的类型。但泛型方法中类型形参必须在对应方法中显式声明。</li><li><strong><em>泛型方法允许类型形参用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系。如果没有这样的依赖关系，不应该使用泛型方法。</em></strong></li></ul><h3 id="2-4-泛型使用准则"><a href="#2-4-泛型使用准则" class="headerlink" title="2.4 泛型使用准则"></a>2.4 泛型使用准则</h3><blockquote><p>“in”变量：in变量向代码提供数据。想象复制方法有两个参数：<code>copy(src, dest)</code>。<code>src</code>参数提供复制数据，因此时”in”参数。<br>“out”变量：out变量保存数据以供其他地方使用。在复制的例子中，<code>copy(src, dest)</code>，<code>dest</code>参数接受数据，因此时”out”参数。</p></blockquote><ul><li>使用<code>extends</code>关键字定义带有上限通配符的“in”变量。</li><li>使用<code>super</code>关键字定义带有下限通配符的“out”变量。</li><li>在可以使用Object类中定义的方法访问“in”变量的情况下，使用无界通配符。</li><li>在代码需要作为“in”和“out”变量访问的情况下，不要使用通配符。</li></ul><h2 id="3-泛型的擦除与转换"><a href="#3-泛型的擦除与转换" class="headerlink" title="3. 泛型的擦除与转换"></a>3. 泛型的擦除与转换</h2><p>泛型被引入Java语言，以便在编译时提供更严格的类型检查并支持通用编程（向上兼容）。为了实现泛型，Java编译器将类型擦除应用于：</p><ul><li>使用边界替换所有在泛型中的类型参数或者如果类型参数是无界的则使用<code>Object</code>替换。因此生成的字节码只包含通用的类，接口和方法。</li><li>如果必要，插入类型强制转换来保证类型安全。</li><li>生成桥接方法以保留扩展泛型类型中的多态性。</li></ul><p>对于以上3点，1和3可能在<a href="#3-1-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E6%93%A6%E9%99%A4">3.1</a>和<a href="#3-2-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E6%A1%A5%E6%96%B9%E6%B3%95">3.2</a>中会详细说明，但是第二点可能不是那么清楚，如果有必要，类型擦除时，会进行强制类型转换。一般这种情况包括：</p><ul><li>方法的返回类型是类型参数；</li><li>在访问数据域时，域的类型是一个类型参数。</li></ul><p>例如：<br>项目中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println(list1.get(0));</span><br></pre></td></tr></table></figure></p><p>编译后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list1 = new ArrayList();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println((String)list1.get(0));</span><br></pre></td></tr></table></figure></p><p>字节码，字节码命令请参阅<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Chapter 6. The Java Virtual Machine Instruction Set</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">       0: new           #3                  // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #4                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #5                  // String Hell</span><br><span class="line">      11: invokeinterface #6,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      16: pop</span><br><span class="line">      17: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: iconst_0</span><br><span class="line">      22: invokeinterface #8,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">      27: checkcast     #9                  // class java/lang/String 强制类型转换校验是否为String类型</span><br><span class="line">      30: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      33: return</span><br></pre></td></tr></table></figure></p><p>上面的例子说明，编译器在擦除泛型代码时，确实保留了List<string>的相关信息，但是你无法找到列表对象本身的T=String，参阅自<a href="https://stackoverflow.com/questions/339699/java-generics-type-erasure-when-and-what-happens/339708#339708" target="_blank" rel="noopener">Java generics type erasure: when and what happens?</a>Jon Skeet的answer。</string></p><p>详细了解请参阅<a href="https://stackoverflow.com/questions/55084504/insert-type-casts-if-necessary-to-preserve-type-safety" target="_blank" rel="noopener">Insert type casts if necessary to preserve type safety</a></p><h3 id="3-1-泛型方法的擦除"><a href="#3-1-泛型方法的擦除" class="headerlink" title="3.1 泛型方法的擦除"></a>3.1 泛型方法的擦除</h3><p>Java编译器也会擦除泛型方法中的类型参数。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static &lt;T&gt; int count(T[] anArray, T elem)&#123;</span><br><span class="line"></span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(T e : anArray)&#123;</span><br><span class="line">        if(e.equals(elem))&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为T是无限制的，所以Java编译器会使用Object代替它，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int count(Object[] anArray, Object elem) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (Object e : anArray)</span><br><span class="line">        if (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-类型擦除的影响和桥方法"><a href="#3-2-类型擦除的影响和桥方法" class="headerlink" title="3.2 类型擦除的影响和桥方法"></a>3.2 类型擦除的影响和桥方法</h3><p>在编译扩展参数化类或实现参数化接口的类或接口时，编译器可能需要创建一个称为桥接方法的合成方法，作为类型擦除过程的一部分。您通常不需要担心桥接方法，但如果出现在堆栈跟踪中，您可能会感到困惑。</p><p>生成桥接方法以保留扩展泛型类型中的多态性。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T data;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = mn;            // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);     </span><br><span class="line">Integer x = mn.data;    // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>类型擦除后, 代码变成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);</span><br><span class="line">Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>代码执行逻辑如下：</p><p><code>n.setData(&quot;Hello&quot;)</code>使得MyNode类对象中的<code>setData(Object)</code>被执行。<br>在<code>setData(Object)</code>方法体内，对象的数据字段引用被分配为String。<br>通过mn引用的相同对象数据字段，可以访问、且期望是Interger类型。<br>尝试分配String到Integer造成ClassCastException。</p><p>类型擦除后代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    public Object data;</span><br><span class="line"></span><br><span class="line">    public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类型擦除之后，方法签名不匹配。 Node方法变为setData（Object），MyNode方法变为setData（Integer）。因此，MyNode setData方法不会覆盖Node setData方法。 为了解决这个问题并在类型擦除后保留泛型类型的多态性，Java编译器会生成一个桥接方法，以确保子类型按预期工作。对于MyNode类，编译器为setData生成以下桥接方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    // Bridge method generated by the compiler</span><br><span class="line">    //</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>桥接方法与类型擦除后的Node类的setData方法具有相同的方法签名，委托给原始的setData方法(桥接方法在字节码中可见，<code>javap -c class</code>)。</p><h3 id="3-3-不可具体化类型"><a href="#3-3-不可具体化类型" class="headerlink" title="3.3 不可具体化类型"></a>3.3 不可具体化类型</h3><p>可具体化类型是在运行时类型信息完全可用的一种类型。包括基本类型，非泛型类型，原始类型，无界的通配符调用。唯一可具体化参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<br>不可具体化类型是类型信息在编译时通过类型擦除被删除————调用未定义为无界通配符的泛型类型。不可具体化的类型在运行时不是所有信息都可用。不可具体化类型的示例是<code>List &lt;String&gt;</code>和<code>List &lt;Number&gt;</code>; JVM无法在运行时区分这些类型。如<a href="#4-泛型的限制">4 泛型的限制</a>中所示，在某些情况下，不能使用不可具体化的类型：例如，在<code>instanceof</code>表达式的实例中，或作为数组中的元素。</p><h3 id="3-4-堆污染"><a href="#3-4-堆污染" class="headerlink" title="3.4 堆污染"></a>3.4 堆污染</h3><p>堆污染发生在当参数化类型的变量引用不是该参数化类型的对象时。如果程序执行某些操作，在编译时产生未经检查的警告，则会出现这种情况。如果在编译时（在编译时类型检查规则的限制内）或在运行时，一个包含参数化类型操作的正确性不能被验证，则会生成未经检查的警告。例如，在混合原始类型和参数化类型时，或者在执行未经检查的强制转换时，会发生堆污染。</p><p>在通常情况下，当所有代码在相同时间被编译，编译器为潜在的堆污染产生一个未经检查警告来引起你的注意。如果你分开编译代码的各个部分，很难检查出堆污染的潜在风险。如果你确保你的代码编译没有警告，则不会有堆污染可以发生。</p><h3 id="3-5-使用不可具体化形参的可变参数方法的潜在漏洞"><a href="#3-5-使用不可具体化形参的可变参数方法的潜在漏洞" class="headerlink" title="3.5 使用不可具体化形参的可变参数方法的潜在漏洞"></a>3.5 使用不可具体化形参的可变参数方法的潜在漏洞</h3><p>包含可变输入参数泛型方法可以造成堆污染。<br>考虑如下class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBuilder &#123;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) &#123;</span><br><span class="line">    for (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void faultyMethod(List&lt;String&gt;... l) &#123;</span><br><span class="line">    Object[] objectArray = l;     // Valid</span><br><span class="line">    objectArray[0] = Arrays.asList(42);</span><br><span class="line">    String s = l[0].get(0);       // ClassCastException thrown here</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下例子，<code>HeapPollutionExample</code>使用<code>ArrayBuilder</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HeapPollutionExample &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stringListA = new ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; stringListB = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.addToList(stringListA, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;);</span><br><span class="line">    ArrayBuilder.addToList(stringListB, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listOfStringLists =</span><br><span class="line">      new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    ArrayBuilder.addToList(listOfStringLists,</span><br><span class="line">      stringListA, stringListB);</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译时，如下<code>ArrayBuilder.addToList</code>方法的定义将产生warning：<br><code>warning: [varargs] Possible heap pollution from parameterized vararg type T</code><br>当编译器遇到一个可变参数方法，它转换可变形参为数组。然而，Java编程语言不允许参数化类型数组的创建。在<code>ArrrayBuilder.addToList</code>方法中，编译器转换可变形参<code>T...</code>要素为<code>T[]</code>要素。因为类型擦除，编译器转换可变形参为<code>Object[]</code>要素。所以，有堆污染的可能性。<br>如下声明分配可变形参给对象数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray = l;</span><br></pre></td></tr></table></figure></p><p>这种声明可能引起堆污染。可以将与可变形参<code>l</code>的参数化类型匹配的值分配给变量objectArray，因此可以分配给<code>l</code>。然而，在此声明中，编译器不能生成一个未经检查警告。编译器早已在转换可变形参<code>List&lt;String&gt;...l</code> 到形参<code>List[] l</code>时生成警告。这个声明是有效的；<code>l</code>变量的类型是<code>List[]</code>，是<code>Object[]</code>的子类型。</p><p>因此，如果将任何类型的List对象分配给objectArray数组的任何数组组件，编译器不会发出警告或错误，如下所示：<br><code>ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</code><br>在运行时，JVM在以下语句中抛出<code>ClassCastException</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ClassCastException thrown here</span><br><span class="line">String s = l[0].get(0);</span><br></pre></td></tr></table></figure></p><p>存储在变量<code>l</code>的第一个数组组件中的对象具有<code>List&lt;Integer&gt;</code>类型，但此语句需要一个<code>List &lt;String&gt;</code>类型的对象。</p><h3 id="3-6-使用不可具体化的形参防止可变参数方法发出警告"><a href="#3-6-使用不可具体化的形参防止可变参数方法发出警告" class="headerlink" title="3.6 使用不可具体化的形参防止可变参数方法发出警告"></a>3.6 使用不可具体化的形参防止可变参数方法发出警告</h3><p>如果声明具有参数化类型参数的可变参数方法，并确保方法体不会因可变参数形参处理不当而抛出<code>ClassCastException</code>或其他类似异常，你可以通过给静态和非构造方法声明添加如下的注解防止编译器给这些可变参数方法生成警告：<br><code>@SafeVarargs</code><br><code>@SafeVarargs</code>注解是方法约定的记录部分;这个注释断言该方法的实现不会不正确地处理可变形参。<br> 尽管不太可取，但通过在方法声明中添加以下内容来消除此类警告也是可以的：<br><code>@SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})</code><br>但是，此方法不会消除从方法的调用点生成的警告。如果您不熟悉<code>@SuppressWarnings</code>语法，请参阅注释。</p><h2 id="4-泛型的限制"><a href="#4-泛型的限制" class="headerlink" title="4 泛型的限制"></a>4 泛型的限制</h2><h3 id="4-1-不能使用基本类型实例化通用类型"><a href="#4-1-不能使用基本类型实例化通用类型" class="headerlink" title="4.1 不能使用基本类型实例化通用类型"></a>4.1 不能使用基本类型实例化通用类型</h3><p>考虑如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public Pair(K key, V value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当创建一个<code>Pair</code>对象，你不能为类型参数<code>K</code>或者<code>V</code>替换成基本类型：<br><code>Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);  // compile-time error</code><br>你仅可以为类型参数<code>K</code>或者<code>V</code>替换非基本类型：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);</code><br>Java编译器自动装箱<code>8</code>为<code>Integer.valueOf(8)</code>和<code>a</code>为<code>Character(&#39;a&#39;)</code>：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character(&#39;a&#39;));</code></p><h3 id="4-2-不能创建类型参数实例"><a href="#4-2-不能创建类型参数实例" class="headerlink" title="4.2 不能创建类型参数实例"></a>4.2 不能创建类型参数实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">    E elem = new E();  // compile-time error</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种解决方案，你可以创建一个类型参数对象通过反射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">    E elem = cls.newInstance();   // OK</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以调用<code>append</code>方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = new ArrayList&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure></p><h3 id="4-3-不能声明静态字段的类型为类型参数"><a href="#4-3-不能声明静态字段的类型为类型参数" class="headerlink" title="4.3 不能声明静态字段的类型为类型参数"></a>4.3 不能声明静态字段的类型为类型参数</h3><p>类的静态字段是类等级变量，被当前类的所有非静态对象共享。因此，类型参数的静态字段是不允许的。考虑如下类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MobileDevice&lt;T&gt; &#123;</span><br><span class="line">    private static T os;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类型参数的静态字段被允许，如下的代码将会混乱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MobileDevice&lt;Smartphone&gt; phone = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;Pager&gt; pager = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;TabletPC&gt; pc = new MobileDevice&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>因为静态字段<code>os</code>被<code>phone</code>,<code>pager</code>和<code>pc</code>共享，什么是<code>os</code>的真实类型？在相同的时间它不可能是<code>Smartphone</code>，<code>Pager</code>，和<code>TablePc</code>。因此你不能创建类型参数静态字段。</p><h3 id="4-4-不能使用参数化类型强制类型转换或者instanceof"><a href="#4-4-不能使用参数化类型强制类型转换或者instanceof" class="headerlink" title="4.4 不能使用参数化类型强制类型转换或者instanceof"></a>4.4 不能使用参数化类型强制类型转换或者<code>instanceof</code></h3><p>因为Java编译器在泛型代码中擦除所有类型参数，您无法验证在运行时使用泛型类型的参数化类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>传递到<code>rtti</code>方法的参数化类型集合是：<br><code>S = { ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, ... }</code><br>运行时不保持对类型参数的跟踪，因此它不能告诉<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>之间的不同。你最多是使用无限通配符来验证列表是否为ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;?&gt;) &#123;  // OK; instanceof requires a reifiable type</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通常，你不能强制转换参数化类型，除非它通过无限制通配符参数化。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  // compile-time error</span><br></pre></td></tr></table></figure></p><p>但是，在一些情况下，编译器知道类型参数总是有效的，允许强制类型转换。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  // OK</span><br></pre></td></tr></table></figure></p><h3 id="4-5-不能创建参数化类型的数组"><a href="#4-5-不能创建参数化类型的数组" class="headerlink" title="4.5 不能创建参数化类型的数组"></a>4.5 不能创建参数化类型的数组</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</span><br></pre></td></tr></table></figure></p><p>如下代码说明在不同类型插入列表是发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] strings = new String[2];</span><br><span class="line">strings[0] = &quot;hi&quot;;   // OK</span><br><span class="line">strings[1] = 100;    // An ArrayStoreException is thrown.</span><br></pre></td></tr></table></figure></p><p>如果你使用泛型列表尝试相同的事情，将会有如下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&apos;s allowed</span><br><span class="line">stringLists[0] = new ArrayList&lt;String&gt;();   // OK</span><br><span class="line">stringLists[1] = new ArrayList&lt;Integer&gt;();  // An ArrayStoreException should be thrown,</span><br><span class="line">                                            // but the runtime can&apos;t detect it.</span><br></pre></td></tr></table></figure></p><p> 如果参数化列表数组是允许的，之前的代码将失败抛出<code>ArrayStoreException</code>。</p><h3 id="4-6-不能创建、捕获或者抛出参数化类型对象"><a href="#4-6-不能创建、捕获或者抛出参数化类型对象" class="headerlink" title="4.6 不能创建、捕获或者抛出参数化类型对象"></a>4.6 不能创建、捕获或者抛出参数化类型对象</h3><p>泛型类也不能直接或间接继承自Throwable。原因是因为在编译期和运行时都必须知道异常的确切类型。例如如下类将不编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Extends Throwable indirectly</span><br><span class="line">class MathException&lt;T&gt; extends Exception &#123; /* ... */ &#125;    // compile-time error</span><br><span class="line"></span><br><span class="line">// Extends Throwable directly</span><br><span class="line">class QueueFullException&lt;T&gt; extends Throwable &#123; /* ... */ // compile-time error</span><br></pre></td></tr></table></figure></p><p>一个方法不能捕获一个类型参数的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (J job : jobs)</span><br><span class="line">            // ...</span><br><span class="line">    &#125; catch (T e) &#123;   // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，你可以在一个<code>throws</code>子句中使用类型参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parser&lt;T extends Exception&gt; &#123;</span><br><span class="line">    public void parse(File file) throws T &#123;     // OK</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出上述泛化的代码。</p><h3 id="4-7-不能重载形式类型参数擦除后相同原始类型的方法"><a href="#4-7-不能重载形式类型参数擦除后相同原始类型的方法" class="headerlink" title="4.7 不能重载形式类型参数擦除后相同原始类型的方法"></a>4.7 不能重载形式类型参数擦除后相同原始类型的方法</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public void print(Set&lt;String&gt; strSet) &#123; &#125;</span><br><span class="line">    public void print(Set&lt;Integer&gt; intSet) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重载将共享相同的类文件表示，并将生成编译时错误。</p><h2 id="5-泛型与数组"><a href="#5-泛型与数组" class="headerlink" title="5. 泛型与数组"></a>5. 泛型与数组</h2><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型<code>Sub[]</code>就是<code>Super[]</code>的子类型。<br>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h2 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h2><p>如果以上都看完了，可以访问<a href="https://docs.oracle.com/javase/tutorial/java/generics/QandE/generics-questions.html" target="_blank" rel="noopener">Questions</a>试试自己是否真的懂了。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a><br><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">Effective Java</a><br><a href="https://docs.oracle.com/javase/tutorial/java/generics/" target="_blank" rel="noopener">Java Document Generic</a><br><a href="http://www.jiangjun.name/thinking-in-java/chapter15" target="_blank" rel="noopener">第十五章 泛型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他参数术语：&lt;/strong&gt;&lt;br&gt;参数化的类型(parameterize
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java</title>
    <link href="https://zhongyp.me/java/2019-05-02-effective-java/"/>
    <id>https://zhongyp.me/java/2019-05-02-effective-java/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-06-26T02:44:53.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘自《Effective Java》</p></blockquote><h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><h2 id="一、创建和销毁对象"><a href="#一、创建和销毁对象" class="headerlink" title="一、创建和销毁对象"></a>一、创建和销毁对象</h2><h3 id="1-考虑使用静态工厂方法替代构造器"><a href="#1-考虑使用静态工厂方法替代构造器" class="headerlink" title="1.考虑使用静态工厂方法替代构造器"></a>1.考虑使用静态工厂方法替代构造器</h3><ul><li>静态工厂方法与构造器不同的第一大优势在于，它们有名称，不必和类名相同。</li><li>静态工厂方法与构造器不同的第二大优势在于不必在每次调用他们的时候都创建一个新的对象。</li><li>静态工厂方法与构造器不同的第三大优势在于他们可以返回原类型的任何子类型对象。</li><li>静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们是代码变得更加简洁。</li><li>静态工厂方法的主要缺点在于类如果不含公有的活着受保护的构造器，就不能被子类化。</li><li>静态工厂方法第二个缺点在于它们与其他的静态方法实际上没有任何区别。</li></ul><h3 id="2-遇到多个构造器参数时要考虑用构建器"><a href="#2-遇到多个构造器参数时要考虑用构建器" class="headerlink" title="2.遇到多个构造器参数时要考虑用构建器"></a>2.遇到多个构造器参数时要考虑用构建器</h3><h3 id="3-用私有构造器或着枚举类强化Singleton属性"><a href="#3-用私有构造器或着枚举类强化Singleton属性" class="headerlink" title="3.用私有构造器或着枚举类强化Singleton属性"></a>3.用私有构造器或着枚举类强化Singleton属性</h3><h3 id="4-通过私有构造器强化不可实例化的能力"><a href="#4-通过私有构造器强化不可实例化的能力" class="headerlink" title="4.通过私有构造器强化不可实例化的能力"></a>4.通过私有构造器强化不可实例化的能力</h3><h3 id="5-避免创建不必要的对象"><a href="#5-避免创建不必要的对象" class="headerlink" title="5.避免创建不必要的对象"></a>5.避免创建不必要的对象</h3><h3 id="6-消除过期的对象引用"><a href="#6-消除过期的对象引用" class="headerlink" title="6.消除过期的对象引用"></a>6.消除过期的对象引用</h3><ul><li>只要类是自己管理内存，程序员就应该警惕内存泄露问题。</li><li>内存泄漏的另一个常见来源是缓存。</li><li>内存的第三个常见来源是监听器和其他回调。确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用。</li></ul><h3 id="7-避免使用终结方法"><a href="#7-避免使用终结方法" class="headerlink" title="7.避免使用终结方法"></a>7.避免使用终结方法</h3><ul><li>终结方法（finalizer）通常是不可预测的，也是危险的，一般情况下是不必要的。</li><li>使用终结方法有非常严重的（Severe）性能损失。</li></ul><h2 id="二、对于所有对象都通用的方法"><a href="#二、对于所有对象都通用的方法" class="headerlink" title="二、对于所有对象都通用的方法"></a>二、对于所有对象都通用的方法</h2><h3 id="8-覆盖equals时请遵守通用约定"><a href="#8-覆盖equals时请遵守通用约定" class="headerlink" title="8.覆盖equals时请遵守通用约定"></a>8.覆盖equals时请遵守通用约定</h3><ul><li>类的每个实例本质都是唯一的。</li><li>不关心类是否提供了“逻辑相等（logical equality）“的测试功能。</li><li>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。</li><li>类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用。</li><li>在覆盖equals方法时，必须遵守：<strong>自反性（reflexive）、对称性（symmetric）、传递性（transitive）、一致性（consistent）和对于任何非null的引用，equals(null)必须返回false</strong>。</li></ul><blockquote><p>里氏替换原则（Liskov substitution principle）认为，一个类型的任何重要属性也将适用它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行的很好。</p></blockquote><ul><li>覆盖equals时总要覆盖hashCode。</li><li>不要企图让equals方法过于智能。</li><li>不要将equals声明中的Object对象替换为其他的类型。</li></ul><h3 id="9-覆盖equals总要覆盖hashCode"><a href="#9-覆盖equals总要覆盖hashCode" class="headerlink" title="9.覆盖equals总要覆盖hashCode"></a>9.覆盖equals总要覆盖hashCode</h3><ul><li>在应用程序的执行期间，只要对象的equals方法比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li><li>如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。<strong>（违反第二条）</strong></li><li>如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定产生不同的整数结果。但是程序猿应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列（hash table）的性能。</li></ul><h3 id="10-始终要覆盖toString"><a href="#10-始终要覆盖toString" class="headerlink" title="10.始终要覆盖toString()"></a>10.始终要覆盖toString()</h3><h3 id="11-谨慎覆盖clone"><a href="#11-谨慎覆盖clone" class="headerlink" title="11.谨慎覆盖clone()"></a>11.谨慎覆盖clone()</h3><ul><li>如果专门为了继承而设计的类，覆盖了clone方法，覆盖版本的clone方法就应该模拟Object.clone的行为：他应该声明为protected、抛出CloneNotSupportedException异常，并且该类不应该实现Cloneable接口。</li><li>如果用线程安全的类实现Cloneable接口，要记得它的clone方法必须得到同步。</li><li>任何实现Cloneable接口的类都应该用一个公有的方法覆盖clone，首先调用super.clone，再修正任何需要修正的域。</li><li>另一种实现对象拷贝的好方法是提供一个拷贝构造器(copy constructor)或者拷贝工厂(copy factory)。</li></ul><h3 id="12-考虑实现Comparable接口"><a href="#12-考虑实现Comparable接口" class="headerlink" title="12.考虑实现Comparable接口"></a>12.考虑实现Comparable接口</h3><h2 id="三、类和接口"><a href="#三、类和接口" class="headerlink" title="三、类和接口"></a>三、类和接口</h2><h3 id="13-使类和成员的可访问性最小化"><a href="#13-使类和成员的可访问性最小化" class="headerlink" title="13.使类和成员的可访问性最小化"></a>13.使类和成员的可访问性最小化</h3><ul><li>尽可能的使每个类或者成员不被外界访问。</li><li>实例域绝不能使公有的。</li><li>类具有共有的静态final数组域，或者返回这种域的访问方法，这种几乎总是错误的。</li><li>公有类都不应该包含公有域，除了公有静态final域的特殊情形外。</li><li>确保公有静态final域所引用的对象都是不可变的。</li></ul><h3 id="14-在公有类中使用访问方法而非公有域"><a href="#14-在公有类中使用访问方法而非公有域" class="headerlink" title="14.在公有类中使用访问方法而非公有域"></a>14.在公有类中使用访问方法而非公有域</h3><ul><li>如果类可以在它所在的包的外部进行访问，就提供访问方法。</li><li>如果类是包级私有的，或者私有的嵌套类，直接暴露它的数据域并没有本质的错误。</li></ul><h3 id="15-使可变性最小化"><a href="#15-使可变性最小化" class="headerlink" title="15.使可变性最小化"></a>15.使可变性最小化</h3><p>不可变类只是实例不能被修改的类。每个实例中包含的信息都必须在创建该实例的时候提供，并在对象的整个生命周期固定不变。</p><ul><li>不要提供任何会修改对象状态的方法。</li><li>保证类不被扩展。</li><li>使所有的域都是final的。</li><li>使所有的域都成为私有的。</li><li>确保对于任何可变组件的互斥访问。</li></ul><h3 id="16-复合优先于继承"><a href="#16-复合优先于继承" class="headerlink" title="16.复合优先于继承"></a>16.复合优先于继承</h3><ul><li>与方法调用不同的是，继承打破了封装性。</li></ul><h3 id="17-要么为继承而设计，并提供文档说明，要么就禁止继承。"><a href="#17-要么为继承而设计，并提供文档说明，要么就禁止继承。" class="headerlink" title="17.要么为继承而设计，并提供文档说明，要么就禁止继承。"></a>17.要么为继承而设计，并提供文档说明，要么就禁止继承。</h3><ul><li>构造器绝不能调用可被覆盖的方法。</li><li>无论是clone还是readObject，都不可以调用可覆盖的方法，不管是以直接还是间接的方式。</li></ul><h3 id="18-接口优于抽象类"><a href="#18-接口优于抽象类" class="headerlink" title="18.接口优于抽象类"></a>18.接口优于抽象类</h3><ul><li>现有的类可以很容易被更新，以实现新的接口。</li><li>接口是定义mixin(混合类型)的理想选择。</li><li>接口允许构造非层次结构的类型框架。</li><li>接口使得安全的增强类的功能成为可能。</li><li>通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的优点结合起来。</li></ul><h3 id="19-接口只用于定义类型"><a href="#19-接口只用于定义类型" class="headerlink" title="19.接口只用于定义类型"></a>19.接口只用于定义类型</h3><ul><li>常量接口模式是对接口的不良使用。</li></ul><h3 id="20-类层级优于标签类"><a href="#20-类层级优于标签类" class="headerlink" title="20.类层级优于标签类"></a>20.类层级优于标签类</h3><h3 id="21-用函数对象表示策略"><a href="#21-用函数对象表示策略" class="headerlink" title="21.用函数对象表示策略"></a>21.用函数对象表示策略</h3><p>策略模式</p><h3 id="22-优先考虑静态成员类"><a href="#22-优先考虑静态成员类" class="headerlink" title="22.优先考虑静态成员类"></a>22.优先考虑静态成员类</h3><p>静态类成员：Map中的Entry<br>非静态类成员：Iterator<br>匿名类：无法实例化，无法声明实现接口，扩展类，无法调用任何成员除了从它的超类继承的，必须简洁，常用来作为函数对象，即函数表达式；另一种是创建过程对象（Runable）<br>局部类：声明局部变量的地方都可以声明局部类。</p><p>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中。</p><h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h3 id="23-请不要在新代码中使用原生态类型"><a href="#23-请不要在新代码中使用原生态类型" class="headerlink" title="23.请不要在新代码中使用原生态类型"></a>23.请不要在新代码中使用原生态类型</h3><ul><li>如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。</li><li>泛型有子类化的规则，虽然可以将List<string>传递给List的参数，但是不能将它传给类型List<object>的参数。</object></string></li><li>如果使用像List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<object>这样的参数化类型，则不会。</object></li><li>在类文字中必须使用原生态类型。</li><li>在参数化类型而非无限制通配符类型上使用instanceof操作法是非法的。</li></ul><h3 id="24-消除非受检警告"><a href="#24-消除非受检警告" class="headerlink" title="24.消除非受检警告"></a>24.消除非受检警告</h3><ul><li>尽可能消除每一个非受检警告</li><li>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，只有这种情况下可以用@SuppressWarnings(“unchecked”)注解来禁止这条警告。</li><li>应该在尽可能小的范围内使用SuppressWarnings注解。</li><li>每当使用SuppressWarnings注解，都要增加注释，说明为什么这么做是安全的。</li></ul><h3 id="25-列表优于数组"><a href="#25-列表优于数组" class="headerlink" title="25.列表优于数组"></a>25.列表优于数组</h3><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型。<br><strong>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</strong></p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p><strong>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</strong></p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型时无限制通配符类型，如List&lt;?&gt;和Map&lt;?,?&gt;。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h3 id="26-优先考虑泛型"><a href="#26-优先考虑泛型" class="headerlink" title="26.优先考虑泛型"></a>26.优先考虑泛型</h3><ul><li>不能创建不可具体化的（non-reifiable）类型的数组。解决方案是新建Object数组强制转换为不可具体化类型，确保未受检的转换是安全的，就要尽可能小的范围中禁止警告。</li></ul><h3 id="27-优先考虑泛型方法"><a href="#27-优先考虑泛型方法" class="headerlink" title="27.优先考虑泛型方法"></a>27.优先考虑泛型方法</h3><h3 id="28-利用有限制通配符来提升API的灵活性"><a href="#28-利用有限制通配符来提升API的灵活性" class="headerlink" title="28.利用有限制通配符来提升API的灵活性"></a>28.利用有限制通配符来提升API的灵活性</h3><ul><li>为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。</li><li>如果类型参数只在方法声明中出现一次，就可以用通配符取代它，如果是无限制的类型参数，就用无限制的通配符取代它。</li><li>如果类的用户必须考虑通配符类型，类的API或许就会出错。</li><li>不要用通配符类型作为返回类型，除了为用户提供额外的灵活性之外，它还会强制用户在客户端代码中使用通配符类型。</li></ul><h3 id="29-优先考虑类型安全的异构容器"><a href="#29-优先考虑类型安全的异构容器" class="headerlink" title="29.优先考虑类型安全的异构容器"></a>29.优先考虑类型安全的异构容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Favorites&#123;</span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);</span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不像普通的map，它的<strong>所有键都是不同类型</strong>的，因此Favorites称作类型安全的异构容器（typesafe heterogeneous container）。</p><p>集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数，但是可以通过将类型参数放在键上而不是容器上来避开这一限制。</p><h2 id="五、枚举和注解"><a href="#五、枚举和注解" class="headerlink" title="五、枚举和注解"></a>五、枚举和注解</h2><h3 id="30-用enum代替int常量"><a href="#30-用enum代替int常量" class="headerlink" title="30.用enum代替int常量"></a>30.用enum代替int常量</h3><p>只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。</p><p>如果多个枚举常量同时共享相同的行为，则考虑策略枚举（strategy enum）。</p><h3 id="31-用实例代替序数索引"><a href="#31-用实例代替序数索引" class="headerlink" title="31.用实例代替序数索引"></a>31.用实例代替序数索引</h3><p>永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Ensemble&#123;</span><br><span class="line">    SOLO(1),DUET(2);</span><br><span class="line">    private final int numberOfMusicians;</span><br><span class="line">    Ensemble(int size)&#123;this.numberOfMusicians = size;&#125;</span><br><span class="line">    public int numberOfMusicians()&#123;return numberOfMusicians;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="32-用EnumSet代替位域"><a href="#32-用EnumSet代替位域" class="headerlink" title="32.用EnumSet代替位域"></a>32.用EnumSet代替位域</h3><h3 id="33-用EnumMap代替序数索引"><a href="#33-用EnumMap代替序数索引" class="headerlink" title="33.用EnumMap代替序数索引"></a>33.用EnumMap代替序数索引</h3><h3 id="34-用接口模拟可伸缩的枚举"><a href="#34-用接口模拟可伸缩的枚举" class="headerlink" title="34.用接口模拟可伸缩的枚举"></a>34.用接口模拟可伸缩的枚举</h3><h3 id="35-注解优先于命名模式"><a href="#35-注解优先于命名模式" class="headerlink" title="35.注解优先于命名模式"></a>35.注解优先于命名模式</h3><h3 id="36-坚持使用Override注解"><a href="#36-坚持使用Override注解" class="headerlink" title="36.坚持使用Override注解"></a>36.坚持使用Override注解</h3><h3 id="37-用标记接口定义类型"><a href="#37-用标记接口定义类型" class="headerlink" title="37.用标记接口定义类型"></a>37.用标记接口定义类型</h3><h2 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h2><h3 id="38-检查参数的有效性"><a href="#38-检查参数的有效性" class="headerlink" title="38.检查参数的有效性"></a>38.检查参数的有效性</h3><p>每当编写方法或者构造器时，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显示的检查来实施这些限制。<br>非公有的方法通常应该使用断言（assertion）来检查它们的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(long a[], int offset, int length)&#123;</span><br><span class="line">    assert a != null;</span><br><span class="line">    assert offset &gt;= 0 &amp;&amp; offset &lt;= a.length;</span><br><span class="line">    assert length &gt;= 0 &amp;&amp; length &lt;= a.length - offset;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="39-必要时进行保护性拷贝"><a href="#39-必要时进行保护性拷贝" class="headerlink" title="39.必要时进行保护性拷贝"></a>39.必要时进行保护性拷贝</h3><p>对于构造器的每个可变参数进行保护性拷贝（defensive copy）是必要的。<br>保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    this.start = start;</span><br><span class="line">    this.end = end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中虽然增加约束条件，但是Date在此对象外部还是可以被修改的，因为Date是引用传递，所以为避免这种问题，使用备份对象，而不是使用原始对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    this.start = new Date(start.getTime);</span><br><span class="line">    this.end = new Date(end.getTime);</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。<br>如果类中提供了对其可变内部成员的访问能力，则使它返回可变内部域的保护性拷贝即可。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date start = new Date();</span><br><span class="line">Date end = new Date();</span><br><span class="line">Period p = new Period(start, end);</span><br><span class="line">p.end().setYear(78);//end()方法返回Date对象，Period中提供setYear改变Date属性。</span><br></pre></td></tr></table></figure><p>为了保证传入Period中的start或者end不被改变，只需要修改Period中获取start和end的访问方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Date start()&#123;</span><br><span class="line">    return new Date(start.getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Date end()&#123;</span><br><span class="line"></span><br><span class="line">    return new Date(end.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数的保护性拷贝不仅仅针对不可变类。如果客户端提供的对象是可变的且该对象不允许在你的类对象中变化，就必须对该对象进行保护性拷贝。</p><p>如果拷贝成本受到限制，并且信任它的客户端不会不恰当的修改组件，就可以在文档中声明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。</p><h3 id="40-谨慎设计方法签名"><a href="#40-谨慎设计方法签名" class="headerlink" title="40.谨慎设计方法签名"></a>40.谨慎设计方法签名</h3><p>谨慎的选择方法的名称；<br>不要过于追求提供便利的方法。只有当一项操作被经常用到的时候，才考虑为它提供快捷方式（shorthand）。如果不确定还是不提供快捷为好；<br>避免过长的参数列表；</p><h3 id="41-慎用重载"><a href="#41-慎用重载" class="headerlink" title="41.慎用重载"></a>41.慎用重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionClassifier&#123;</span><br><span class="line"></span><br><span class="line">    public static String classify(Set&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;set&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(List&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;list&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(Collection&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;unknow&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">            new HashSet&lt;String&gt;(),</span><br><span class="line">            new ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">            new HashMap&lt;String, String&gt;().value()</span><br><span class="line">        &#125;;</span><br><span class="line">        for(Collection&lt;?&gt; c : collections)</span><br><span class="line">            System.out.println(classify(c)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果是打印“unknow”三次。</p><h3 id="42-慎用可变参数"><a href="#42-慎用可变参数" class="headerlink" title="42.慎用可变参数"></a>42.慎用可变参数</h3><p>定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用，使用不当，将产生混乱的结果。</p><h3 id="43-返回零长度的数组或者集合，而不是null"><a href="#43-返回零长度的数组或者集合，而不是null" class="headerlink" title="43.返回零长度的数组或者集合，而不是null"></a>43.返回零长度的数组或者集合，而不是null</h3><h3 id="44-为所有导出的API元素编写文档注释"><a href="#44-为所有导出的API元素编写文档注释" class="headerlink" title="44.为所有导出的API元素编写文档注释"></a>44.为所有导出的API元素编写文档注释</h3><h2 id="七、通用程序设计"><a href="#七、通用程序设计" class="headerlink" title="七、通用程序设计"></a>七、通用程序设计</h2><h3 id="45-将局部变量的作用域最小化"><a href="#45-将局部变量的作用域最小化" class="headerlink" title="45.将局部变量的作用域最小化"></a>45.将局部变量的作用域最小化</h3><p>要使用局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。<br>几乎每个局部变量的声明都应该包含一个初始化表达式。</p><h3 id="46-for-each循环优先于传统的for循环"><a href="#46-for-each循环优先于传统的for循环" class="headerlink" title="46.for-each循环优先于传统的for循环"></a>46.for-each循环优先于传统的for循环</h3><p>虽然for-each循环在简洁性和预防bug方面比传统的for循环有优势，且没有性能损失。但是有三种常见情况无法使用for-each:</p><ul><li>过滤： 如果需要遍历集合，并且删除选定的元素，就需要使用显式的迭代器。</li><li>转换： 如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引。</li><li>平行迭代： 如果需要并行的遍历多个集合，就需要显式的控制迭代器或者索引变量。</li></ul><h3 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47.了解和使用类库"></a>47.了解和使用类库</h3><p>每个程序员都应该熟悉java.lang、java.util、java.io中的内容。</p><h3 id="48-如果需要精确的答案，请避免使用float和double"><a href="#48-如果需要精确的答案，请避免使用float和double" class="headerlink" title="48.如果需要精确的答案，请避免使用float和double"></a>48.如果需要精确的答案，请避免使用float和double</h3><p>使用BigDecimal、int或者long进行计算。如果数值防伪不超过9位十进制数字，就可以使用int；如果不超过18位就可以使用long；如果数值超过18位就必须使用BigDecimal。</p><p>BigDecimal缺点：不方便，慢。</p><h3 id="49-基本类型优先于装箱基本类型"><a href="#49-基本类型优先于装箱基本类型" class="headerlink" title="49.基本类型优先于装箱基本类型"></a>49.基本类型优先于装箱基本类型</h3><p>基本类型与装箱基本类型之间主要区别：</p><ul><li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。</li><li>基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值之外，还有非功能值：null。</li><li>基本类型通常比装箱基本类型更节省空间和时间。</li></ul><p>第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型（在代码中不用自己去装箱，如果把基本类型放入集合中，集合会自动把基本类型装箱）。不能放在集合中的原因是：基本类型存放在栈上，集合中的引用则存在堆或方法取上。</p><p>在参数化类型中，必须使用装箱基本类型作为参数，Java不允许使用基本类型，因为Java泛型要求使用的是对象类型，基本类型不是对象类型。</p><h3 id="50-如果其他类型更适合，则尽量避免使用字符串"><a href="#50-如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="50.如果其他类型更适合，则尽量避免使用字符串"></a>50.如果其他类型更适合，则尽量避免使用字符串</h3><p>字符串不适合代替其他的值类型。<br>字符串不适合代替枚举类型。<br>字符串不适合代替聚集类型。<br>字符串也不适合代替能力表。</p><h3 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51.当心字符串连接的性能"></a>51.当心字符串连接的性能</h3><h3 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52.通过接口引用对象"></a>52.通过接口引用对象</h3><p>如果有适合的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。</p><p>如果没有合适的接口存在，完全可以用类而不是接口来引用对象：</p><ul><li>如果具体类没有相关联的接口，不管它是否表示一个值，你都没有别的选择，只有通过它的类来引用它的对象。</li><li>对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架（class-based</li><li>framework），就应该用相关的积累（base class）来引用这个对象，而不是用它的实现类。</li></ul><h3 id="53-接口优先于反射机制"><a href="#53-接口优先于反射机制" class="headerlink" title="53.接口优先于反射机制"></a>53.接口优先于反射机制</h3><p>反射机制：</p><ul><li>丧失了编译时类型检查的好处，包括异常检查。如果程序企图用反射方式调用不存在的活不可访问的方法，在运行时它将会失败，除非采用了特别的预防措施。</li><li>执行反射访问所需的代码非常笨拙和冗长。编写这样的代码非常乏味，阅读起来也很困难。</li><li>性能损失。反射方法调用比普通方法调用慢了许多。</li></ul><p>通常普通应用程序在运行时不应该以反射方式访问对象。<br>对于有些程序，它们必须用到在编译时无法获取的类，但是在编译时存在适当的接口或者超类，通过它们可以引用这个类。如果是这种情况，就可以以反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例。如果适当的构造器不带参数，甚至根本不需要使用<code>java.lang.reflect</code>；<code>Class.newInstance</code>方法就已经提供了所需的功能。</p><h3 id="54-谨慎的使用本地方法"><a href="#54-谨慎的使用本地方法" class="headerlink" title="54.谨慎的使用本地方法"></a>54.谨慎的使用本地方法</h3><h3 id="55-谨慎的优化"><a href="#55-谨慎的优化" class="headerlink" title="55.谨慎的优化"></a>55.谨慎的优化</h3><blockquote><p>很多计算上的过失都被归咎于效率（没有必要达到的效率），而不是任何其他的原因—甚至包括盲目的做傻事。<br>不要取计较效率上的一些小小的得失，在97%的情况下，不成熟的优化才是一切问题的根源。<br>在优化方面，我们应该遵守两条规则：<br>规则1: 不要进行优化。<br>规则2: 还是不要进行优化—也就是说，在你还没有绝对清晰的未优化方案之前，请不要优化。</p></blockquote><p>不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。好的程序体现了信息隐藏的原则：只要有可能，它们就会把设计决策几种在单个模块中，因此，可以改变单个决策，而不会影响到系统的其他部分。</p><p>在设计的过程中考虑性能问题。努力避免限制性能的设计决策。</p><h3 id="56-遵守普遍接受的命名惯例"><a href="#56-遵守普遍接受的命名惯例" class="headerlink" title="56.遵守普遍接受的命名惯例"></a>56.遵守普遍接受的命名惯例</h3><h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><h3 id="57-只针对异常的情况才使用异常"><a href="#57-只针对异常的情况才使用异常" class="headerlink" title="57.只针对异常的情况才使用异常"></a>57.只针对异常的情况才使用异常</h3><p>异常机制的设计初衷是用于不正常的情形，所以很少会有JVM实现试图对它们进行优化，使得与显式的测试一样快速。</p><p>把代码放在try-catch块中反而阻止了现代JVM实现本来可能要执行的某些特定的优化。</p><p>对数组进行遍历的标准模式并不会导致冗余的检查。有些现代的JVM实现会将它们优化掉。</p><h3 id="58-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#58-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="58.对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>58.对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><h3 id="59-避免不必要的使用受检异常"><a href="#59-避免不必要的使用受检异常" class="headerlink" title="59.避免不必要的使用受检异常"></a>59.避免不必要的使用受检异常</h3><h3 id="60-优先使用标准异常"><a href="#60-优先使用标准异常" class="headerlink" title="60.优先使用标准异常"></a>60.优先使用标准异常</h3><p><img src="/media/article/15583547431411.jpg" alt=""></p><h3 id="61-抛出域抽象相对应的异常"><a href="#61-抛出域抽象相对应的异常" class="headerlink" title="61.抛出域抽象相对应的异常"></a>61.抛出域抽象相对应的异常</h3><p>更高层次的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。<br>如果不能阻止或者处理来自低层的异常，一般做法是使用异常转译，除非低层方法碰巧可以保证它抛出的所有异常对高层也合适才可以将异常从低层传播到高层。异常链对高层和低层异常都提供了最佳功能：它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析。</p><h3 id="62-每个方法抛出的异常都要有文档"><a href="#62-每个方法抛出的异常都要有文档" class="headerlink" title="62.每个方法抛出的异常都要有文档"></a>62.每个方法抛出的异常都要有文档</h3><p>始终要单独的声明受检异常，并且利用Javadoc的@throws标记，准确的记录下抛出的每个异常的条件。</p><p>使用Javadoc的@throws标签记录下一个方法可能抛出的每个受检异常，但是不要使用throws关键字将未受检异常包含在方法的声明中。</p><p>如果一个类中的许多方法处于同样的原因而抛出同一个异常，则该类的文档注释中对这个异常建立文档，是可以接受的。</p><h3 id="63-在细节消息中包含能捕获失败的信息"><a href="#63-在细节消息中包含能捕获失败的信息" class="headerlink" title="63.在细节消息中包含能捕获失败的信息"></a>63.在细节消息中包含能捕获失败的信息</h3><p>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。</p><h3 id="64-努力使失败保持原子性"><a href="#64-努力使失败保持原子性" class="headerlink" title="64.努力使失败保持原子性"></a>64.努力使失败保持原子性</h3><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p><h3 id="65-不要忽略异常"><a href="#65-不要忽略异常" class="headerlink" title="65.不要忽略异常"></a>65.不要忽略异常</h3><h2 id="九、并发"><a href="#九、并发" class="headerlink" title="九、并发"></a>九、并发</h2><h3 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66.同步访问共享的可变数据"></a>66.同步访问共享的可变数据</h3><p>Java语言规范保证读或写一个变量是原子的，除非这个变量的类型为long或者double[JLS，17.4.7]。对于这句话不要误解，虽然语言规范保证了线程在读取原子数据的时候，不会看到任意的数值，但是它并不保证一个线程写入的值对于另一个线程将是可见的。为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。</p><h3 id="67-避免过度同步"><a href="#67-避免过度同步" class="headerlink" title="67.避免过度同步"></a>67.避免过度同步</h3><p>为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法，要尽量限制同步区域内部的工作量。</p><h3 id="68-executor和task优先于线程"><a href="#68-executor和task优先于线程" class="headerlink" title="68.executor和task优先于线程"></a>68.executor和task优先于线程</h3><h3 id="69-并发工具优先于wait和notify"><a href="#69-并发工具优先于wait和notify" class="headerlink" title="69.并发工具优先于wait和notify"></a>69.并发工具优先于wait和notify</h3><p>java.util.concurrent中更高级的的工具分成三类：Execcutor Framework、并发集合（Concurrent Collection）以及同步器（Synchronizer）。</p><p>同步器是一些使线程能够等待另一个线程的对象，允许它们协调动作。常用的是CountDownLatch和Semaphore。不常用的是CyclicBarrier和Exchanger。</p><p>对于间歇式的定时，始终应该优先使用System.nanoTime，而不是使用System.currentTimeMills。System.nanoTime更加准确也更加精确，它不受系统的实时时钟的调整所影响。</p><p>如果你在维护使用wait和notify的代码，务必确保始终是利用标准的模式从while循环内部调用wait。一般情况下，你应该优先使用notifyAll，而不是使用notify。如果使用notify，请一定小心，以确保程序的活性。</p><h3 id="70-线程安全性的文档化"><a href="#70-线程安全性的文档化" class="headerlink" title="70.线程安全性的文档化"></a>70.线程安全性的文档化</h3><p>一个类为了可被多个线程安全的使用，必须在文档中清楚的说明它所支持的线程安全级别。</p><ul><li>不可变的（immutable）这个类是不可变的。所以不需要外部同步。例如：String、Long、BigInteger。</li><li>无条件的线程安全（unconditionally thread-safe）这个类的实例是可变的，但是这个类有着足够的内部同步，所以，它的实例可以被并发使用，无需任何外部同步。例如：Random、ConcurrentHashMap。</li><li>有条件的线程安全（conditionally thread-safe）除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。例如：Collections.synchronized包装返回的集合，它们的迭代器（iterator）要求外部同步。</li><li>非线程安全（not thread-safe）这个类的实例是可变的。为了并发地使用它们，客户端必须利用自己选择的外部同步包围每个方法调用。例如：ArrayList、HashMap。</li><li>线程对立（thread-hostile）这个类不能安全的被多个线程并发使用，即使所有的方法调用都被外部同步包围。</li></ul><h3 id="71-慎用延迟初始化"><a href="#71-慎用延迟初始化" class="headerlink" title="71.慎用延迟初始化"></a>71.慎用延迟初始化</h3><p>延迟初始化（lazy initialization）是延迟到需要域的值时才将它初始化的这种行为。<br>大多数的域应该正常地进行初始化，而不是延迟初始化。如果为了达到性能目的，或者为了破坏有害的初始化循环，必须延迟初始化一个域则：<br>对于实例域，就使用双重检查模式（double-check idiom）；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            result = field;</span><br><span class="line">            if(result == null)&#123;</span><br><span class="line">                field = result = computeFieldValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于静态域，则使用lazy initialization holder class idiom；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class FieldHolder&#123;</span><br><span class="line">    static final FieldType field = computeFieldValue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static FieldType getField()&#123;return FieldHolder.field;&#125;</span><br></pre></td></tr></table></figure></p><p>对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式（single-check idiom）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line"></span><br><span class="line">private FieldType getField()&#123;</span><br><span class="line"></span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        field = result = computeFieldValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="72-不要依赖于线程调度器"><a href="#72-不要依赖于线程调度器" class="headerlink" title="72.不要依赖于线程调度器"></a>72.不要依赖于线程调度器</h3><h3 id="73-避免使用线程组"><a href="#73-避免使用线程组" class="headerlink" title="73.避免使用线程组"></a>73.避免使用线程组</h3><p>线程组的初衷是作为一种隔离applet的机制，当然是出于安全的考虑。线程组并没有提供太多有用的功能，而且它们提供的许多功能还都是有缺陷的。</p><h2 id="十、序列化"><a href="#十、序列化" class="headerlink" title="十、序列化"></a>十、序列化</h2><h3 id="74-谨慎的实现Serializable接口"><a href="#74-谨慎的实现Serializable接口" class="headerlink" title="74.谨慎的实现Serializable接口"></a>74.谨慎的实现Serializable接口</h3><p>实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。</p><p>如果接受了默认的序列化形式，并且以后要改变这个类的内部表示法，结果可能导致序列化形式的不兼容。</p><p>第二个代价是，它增加了出现Bug和安全漏洞的可能性。</p><p>实现Serializable第三个代价是，随着类发行新的版本，相关的测试负担也增加了。</p><p>为了继承而设计的类应该尽可能少的趋势线Serializable接口，用户的接口也应该尽可能少的继承Serializable接口。如果违反了这条规则，扩展这个类或者实现该接口的程序员就会背上沉重的负担。然而有些情况下，这条规则确实适合的。例如：如果一个类或者接口存在的目的主要是为了参加到某个框架中，该框架要求所有的参与者都必须实现Serializable接口，那么对于类或者接口来说实现扩展Serializable是有意义的。</p><p>如果一个专门为了继承而设计的类不是可序列化的，就不可能编写出可序列化的子类。特别是，如果超类没有提供可访问的无参构造器，子类也不可能做到序列化。对于未继承而设计的不可序列化的类，你应该提供一个无参构造器。</p><h3 id="75-考虑使用自定义的序列化形式"><a href="#75-考虑使用自定义的序列化形式" class="headerlink" title="75.考虑使用自定义的序列化形式"></a>75.考虑使用自定义的序列化形式</h3><p>如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Name implements Serializable&#123;</span><br><span class="line">    private final String lastName;</span><br><span class="line">    </span><br><span class="line">    private final String firstName;</span><br><span class="line">    </span><br><span class="line">    private final String middleName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使你确定了默认的序列化形式是合适的，通常还必须提供一个readObject方法保证约束关系和安全性。</p><p>当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下4个缺点：</p><ul><li>它使这个类的导出API永远地束缚在该类的内部表示法上。</li><li>它会消耗过多的时间。</li><li>它会消耗过多空间。</li><li>它会引起栈溢出。</li></ul><p>如果所有的实例域都是瞬时的（transient），从技术角度而言，不调用DefaultWriteObject和defaultReadObject也是允许的，但是不推荐这样做。<br>在决定将一个域做成非transient的之前，请一定要确信它的值将是该对象逻辑状态的一部分。<br>如果在读取整个对象状态的任何其他方法上强制任何同步，则也必须在对象序列化上强制这种同步。<br>不管你选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显式的序列版本UID（serial version UID）。</p><h3 id="76-保护性的编写readObject方法"><a href="#76-保护性的编写readObject方法" class="headerlink" title="76.保护性的编写readObject方法"></a>76.保护性的编写readObject方法</h3><p><strong><em>记得回来看反序列化代码</em></strong></p><p>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。保护性拷贝在有效性检查之前进行。</p><p>不要使用writeUnshared和readUnshared方法。</p><p>对于非final的可序列化类，readObject方法不可以调用可被覆盖的方法，无论是直接调用还是间接调用都不可以。如果违反了规则，并覆盖了该方法，被覆盖的方法将在子类的状态被序列化之前先运行，程序很可能失败。</p><p>readObject方法指导：</p><ul><li>对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别。</li><li>对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li><li>如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。</li><li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li></ul><h3 id="77-对于实例控制，枚举类型优先于readResolve"><a href="#77-对于实例控制，枚举类型优先于readResolve" class="headerlink" title="77.对于实例控制，枚举类型优先于readResolve"></a>77.对于实例控制，枚举类型优先于readResolve</h3><p>如果这个类的声明加上了“implements Serializable”的字样，它就不再是一个单例类。无论使用默认的序列化形式，还是自定义的序列化形式，都会返回一个新建的实例，这个新建实例不用于该类初始化时创建的实例。</p><p>readResolve特性允许你用readObject创建的实例代替另一个实例。对于一个正在被序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化后，新建对象上的readResolve方法就会被调用，该方法返回的对象引用将被返回，取代新建对象，指向新建对象的引用不需要再被保留，因此立即成为垃圾回收对象。</p><p>如果readResolve方法忽略被反序列化的对象，只返回该类初始化时创建的实例。如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient的。</p><p>readResolve的可访问性很重要。如果把readResolve方法放在一个final类上，它就应该是私有的。如果吧readResolve方法放在一个非final类上，就必须考虑它的可访问性。</p><p>尽可能的使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控（instance-controlled）的类，就必须提供一个readResolve方法，并确保该类的所有实例域都为基本类型，或者是transient的。</p><h3 id="78-考虑用序列化代理代替序列化实例"><a href="#78-考虑用序列化代理代替序列化实例" class="headerlink" title="78.考虑用序列化代理代替序列化实例"></a>78.考虑用序列化代理代替序列化实例</h3><p>每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。要想文件的带有重要约束条件的对象序列化，这种模式可能是最容易的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;摘自《Effective Java》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Effective-Java&quot;&gt;&lt;a href=&quot;#Effective-Java&quot; class=&quot;headerlink&quot; title=&quot;Effective J
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 枚举类</title>
    <link href="https://zhongyp.me/java/2019-05-01-java-enum/"/>
    <id>https://zhongyp.me/java/2019-05-01-java-enum/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-06-26T02:45:28.470Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java枚举类笔记，摘自《疯狂Java讲义》</p></blockquote><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在早期代码中，可能会直接使用简单的静态常量表示枚举，例如如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final int SEASON_SPRING = 1;</span><br><span class="line">public static final int SEASON_SUMMER = 2;</span><br><span class="line">public static final int SEASON_FALL = 3;</span><br><span class="line">public static final int SEASON_WINTER = 4;</span><br></pre></td></tr></table></figure><p>但是这种方式定义会存在如下问题：</p><ul><li>类型不安全：可能存在SEASON_SPRING + SEASON_FALL。</li><li>没有命名空间：当需要使用季节时，必须在SPRING钱使用SEASON_前缀，否则程序可能与其他类中的静态常量混淆。</li><li>打印输出的意义不明确：当输出某个季节时，实际的输出值时数字。</li></ul><p>JDK1.5 之后新增了enum关键字，用来定义枚举类。枚举类是一种特殊类，有自己的成员变量、方法，可以实现一个或者多个接口，可以定义自己的构造器。一个Java源文件中最多只能定一个public访问权限的枚举类，且该Java源文件必须和该枚举类的类名相同。和普通类区别如下：</p><ul><li>使用enum定义的默认枚举类默认继承了java.lang.Enum类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。</li><li>使用enum定义、<strong>非抽象</strong>的枚举类默认会使用final修饰，因此不能派生子类。</li><li>枚举类的构造器只能使用private访问控制符。</li><li>枚举类所有的实例必须在枚举类的第一行显示列出，否则这个枚举类永远都不能产生实例。</li></ul><p>Java枚举类型基本思想：通过公有的静态final域为每个枚举常量到处实例的类。因为没有可以访问的构造器，枚举类型是真正的final。</p><h3 id="1-枚举类的成员变量、方法和构造器"><a href="#1-枚举类的成员变量、方法和构造器" class="headerlink" title="1. 枚举类的成员变量、方法和构造器"></a>1. 枚举类的成员变量、方法和构造器</h3><p>枚举类也是一种比较特殊的类。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;),FEMALE(&quot;女&quot;);</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看出，枚举类中列出枚举值时，实际上就是调用构造器创建枚举类对象，只是这里不是使用new关键字，也无需显式调用构造器。</p><p>上面<code>MALE(&quot;男&quot;),FEMALE(&quot;女&quot;)</code>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void final Gender MALE = new Gender(&quot;男&quot;)；</span><br><span class="line">public static void final Gender FEMALE = new Gender(&quot;女&quot;)；</span><br></pre></td></tr></table></figure></p><h3 id="2-实现接口的枚举类"><a href="#2-实现接口的枚举类" class="headerlink" title="2. 实现接口的枚举类"></a>2. 实现接口的枚举类</h3><p>接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface GenderDesc&#123;</span><br><span class="line">    void info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;men&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,FEMALE(&quot;女&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;women&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong>并非所有的枚举类都使用final修饰，非抽象的枚举类才默认使用final修饰。对于一个抽象的枚举类，系统默认使用abstract修饰，而不是final。</p><h3 id="3-包含抽象方法的抽象类"><a href="#3-包含抽象方法的抽象类" class="headerlink" title="3. 包含抽象方法的抽象类"></a>3. 包含抽象方法的抽象类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public enum Operation&#123;</span><br><span class="line"></span><br><span class="line">    PLUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x-y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x*y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x/y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    public abstract double eval(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Java枚举类笔记，摘自《疯狂Java讲义》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;枚举类&quot;&gt;&lt;a href=&quot;#枚举类&quot; class=&quot;headerlink&quot; title=&quot;枚举类&quot;&gt;&lt;/a&gt;枚举类&lt;/h2&gt;&lt;p&gt;在早期代码中，可能
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java Serializable</title>
    <link href="https://zhongyp.me/java/2019-04-27-java-serializable/"/>
    <id>https://zhongyp.me/java/2019-04-27-java-serializable/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-06-26T02:46:34.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java序列化笔记，摘自《疯狂Java讲义》</p></blockquote><h2 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h2><h3 id="1-序列化的含义和意义"><a href="#1-序列化的含义和意义" class="headerlink" title="1.序列化的含义和意义"></a>1.序列化的含义和意义</h3><p>对象序列化指将一个Java对象写入IO流中。<br>对象支持序列化则必须让它的类是可序列化的。该类必须实现如下两个接口之一</p><ul><li><code>Serializable</code></li><li><code>Externalizable</code></li></ul><p>建议：JavaBean类都实现Serializable。</p><h3 id="2-使用对象流实现序列化"><a href="#2-使用对象流实现序列化" class="headerlink" title="2.使用对象流实现序列化"></a>2.使用对象流实现序列化</h3><ul><li>反序列化读取的仅仅是Java对象的数据，而不是Java类，因此采用反序列化恢复Java对象时，必须提供该Java对象所属类的class文件，否则将会引发ClassNotFoundException异常。</li><li>反序列化无需通过构造器来初始化Java对象。</li><li>如果使用序列化机制向文件中写入了多个Java对象，使用反序列化机制恢复对象时必须按实际写入顺序读取。</li><li>当一个可序列化类有多个父类时，这些父类要么有无参数构造器，要么也是可序列化的，否则抛出InvalidClassException。</li><li>如果父类时不可序列化的，只带有无参数构造器，则该父类中定义的成员变量值不会序列化到二进制流中。（反序列化时会调用父类的无参构造器，重新实例化父类对象）</li></ul><h3 id="3-对象引用的序列化"><a href="#3-对象引用的序列化" class="headerlink" title="3.对象引用的序列化"></a>3.对象引用的序列化</h3><p>Java序列化机制算法：</p><ul><li>所有保存到磁盘中的对象都有一个序列化编号。</li><li>当程序试图序列化一个对象时，程序将先检查该对象是否已经被序列化过，只有该对象从未被序列化过，系统才会将该对象转换成字节序列并输出。</li><li>如果某个对象已经序列化过，程序将直接输出一个序列化编号，而不是再次重新序列化该对象。</li></ul><p>注：当程序序列化一个可变对象时，只有第一次writeObject()方法输出时才会将该对象转换成字节序列并输出，当再次调用writeObject()方法时，程序只是输出前面的序列化编号，即使后面该对象的实例变量值已被改变，改变的实例变量值也不会被输出。</p><h3 id="4-自定义序列化"><a href="#4-自定义序列化" class="headerlink" title="4.自定义序列化"></a>4.自定义序列化</h3><blockquote><p>当对某个对象进行序列化时，系统会自动把该对象的所有实例变量依次进行序列化，如果某个实例变量引用另一个对象，则被引用的对象也会被序列化；如果被引用的对象实例变量也引用了其他对象，则被引用的对象也会被序列化，这种情况被称为递归序列化。</p></blockquote><h4 id="4-1-transient关键字"><a href="#4-1-transient关键字" class="headerlink" title="4.1 transient关键字"></a>4.1 transient关键字</h4><p>在实例变量前使用transient关键字修饰，可以指定Java序列化时无需理会该实例变量。<br>transient关键字只能用于修饰实例变量，不能用于修饰Java程序中的其他成分。<br>transient关键字修饰实例变量将被完全隔离在序列化机制之外，这样导致在反序列化恢复Java对象时无法取得该实例的变量值。</p><h4 id="4-2-自定义序列化"><a href="#4-2-自定义序列化" class="headerlink" title="4.2 自定义序列化"></a>4.2 自定义序列化</h4><p>在类中提供如下方法，这些方法用以实现自定义序列化。</p><ul><li><code>private void writeObject(java.io.ObjectOutputStream out)throws IOException</code></li><li><code>private void readObject(java.io.ObjectInputStream in)throws IOException,ClassNotFoundException</code></li><li><code>private void readObjectNoData()throws ObjectStreamException</code></li></ul><p>注：writeObject的顺序与readObject的顺序一致，否则不能正常恢复Java对象。</p><p>writeReplace方法由序列化机制调用，只要该方法存在。在序列化某个对象前，先调用该对象writeReplace()方法，如果该方法返回另一个Java对象，则系统转化序列化另一个对象。<br>与writeReplace方法相对的是，readResolve()，这个方法在readObject()后被调用，该方法的返回值将代替原来反序列化的对象，原来的对象被丢弃。<br>readResolve()在序列化单例类和枚举类时尤其有用。所有的单例类和枚举类在实现序列化时都应该提供readResolve方法，这样才能保证反序列化的正常。</p><h3 id="5-自定义序列化机制"><a href="#5-自定义序列化机制" class="headerlink" title="5.自定义序列化机制"></a>5.自定义序列化机制</h3><p>Java除了Serializable，还提供了另一种序列化机制，这种序列化方式完全由程序员决定存储和恢复对象数据。要实现该目标，Java必须实现Externalizable接口，接口中方法如下：</p><ul><li><code>void readExternal(ObjectInput in)</code>：需要实现readExternal方法实现反序列化。</li><li><code>void writeExternal(ObjectOutput out)</code>：需要实现writeExternal方法来保存对象状态。</li></ul><p>两种序列化机制的对比：</p><p>Serializable</p><ul><li>系统自动保存必要信息</li><li>Java内建支持，易于实现，只需实现该接口即可，无需任何代码支持（也可以自定义）</li><li>性能略差</li></ul><p>Externalizable</p><ul><li>程序员决定存储哪些信息</li><li>仅仅提供空方法，必须自定义实现序列化</li><li>性能略高</li></ul><blockquote><p><strong>注意</strong></p><ul><li>对象的类名、属性（基本类型、数组、对其他对象的引用）都会被序列化；方法、static属性、transient属性都不会被序列化。</li><li>实现Serializable接口的类如果需要想让某个属性不被序列化，可在属性前加transient修饰符，而不是加static。</li><li>保证序列化对象的属性的类型也是可序列化的，否则需要使用transient关键字来修饰该属性，要不然，则该类是不可序列化的。</li><li>反序列化对象时必须有序列化对象的class文件。</li></ul></blockquote><h3 id="6-版本"><a href="#6-版本" class="headerlink" title="6.版本"></a>6.版本</h3><p>反序列化Java对象时必须提供该对象的class文件，如果项目升级，Java如何保证两个class文件的兼容性？</p><p>Java序列化机制允许为序列化类提供一个private static final的serialVersionUID属性值，该属性值用于表示该Java类的序列化版本。</p><ul><li>如果修改类时仅仅修改了方法，则反序列化完全不受任何影响，类定义无需修改serialVersionUID的属性值。</li><li>如果修饰类时仅仅修改了静态属性或瞬态属性，则反序化不受任何影响，类定义无需修改serialVersionUID属性值。</li><li>如果修改类时修饰了非静态、非瞬态属性，则可能导致序列化版本不兼容，如果对象流中的对象和新类中包含同名的属性，而属性类型不同，则反序列化失败，类定义应该更新serialVersionUID属性值。如果对象流中对象比新类中包含更多的属性，则多处的属性值被忽略，序列化版本可以兼容，类定义可以不更新serialVersionUID属性值；但反序列化得到的新对象中多处的属性值都是null（引用类型属性）或0（基本类型属性）。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Java序列化笔记，摘自《疯狂Java讲义》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Java-序列化&quot;&gt;&lt;a href=&quot;#Java-序列化&quot; class=&quot;headerlink&quot; title=&quot;Java 序列化&quot;&gt;&lt;/a&gt;Java 
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring Transaction Management</title>
    <link href="https://zhongyp.me/transaction/2019-03-07-spring-transaction-management/"/>
    <id>https://zhongyp.me/transaction/2019-03-07-spring-transaction-management/</id>
    <published>2019-03-06T16:00:00.000Z</published>
    <updated>2019-10-12T06:34:32.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-事务管理"><a href="#Spring-事务管理" class="headerlink" title="Spring 事务管理"></a>Spring 事务管理</h1><p>翻译自<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-motivation" target="_blank" rel="noopener">spring/docs/4.2.x</a></p><p>翻译过程中使用工具：google翻译，欧路词典</p><p>名词解释：<br>JTA：Java Transaction API<br>JPA：Java Persistence API<br>JDO：Java Data Object<br>CMT： Container Managed Transactions<br>JNDI：Java Naming and Directory Interface<br>JMS： Java Message Service<br>JCA： Java EE Connector Architecture</p><h2 id="1-事务管理"><a href="#1-事务管理" class="headerlink" title="1. 事务管理"></a>1. 事务管理</h2><h2 id="1-1-Spring框架事务管理介绍"><a href="#1-1-Spring框架事务管理介绍" class="headerlink" title="1.1 Spring框架事务管理介绍"></a>1.1 Spring框架事务管理介绍</h2><p>全方面的事务支持是使用Spring框架的最引人注目的原因之一。Spring框架为事务管理提供一致性抽象提供了如下好处：</p><ul><li>一致性编程模型横跨不同的事务APIs，例如 JTA，JPA，JDO。</li><li>支持声明式事务管理</li><li>和复杂编程事务APIs（例如JTA）相比，Spring提供更简单的编程事务管理的API。</li><li>与Spring的数据访问抽象有良好的集成。</li></ul><p>下面的部分描述Spring框架的事务value-adds和技术。(这部分也包含对于最好事务管理的实践，应用服务器集成和常见问题解决方案的讨论)</p><ul><li><a href="#1-2-Spring框架事务支持模型的优势">Spring框架事务支持模型的优势</a>描述你为什么会使用Spring框架的事务抽象，而不是选择EJB的容器管理事务或者通过专有的API（例如Hibernate）驱动本地事务。</li><li><a href="#1-3-理解Spring框架事务抽象">理解Spring框架的事务抽象</a>概述核心类和描述怎样配置和怎样从各种类型的数据源中获取数据源。</li><li><a href="#1-4-将资源与事务同步">将资源与事务同步</a>描述应用代码怎样确保资源的创建，复用和正确的清理。</li><li><a href="#1-5-声明式事务管理">声明式事务管理</a>描述支持声明式事务管理。</li><li><a href="#1-6-编程事务管理">编程事务管理</a>包含支持编程事务管理。</li><li><a href="#1-8-事务约束事件">事务约束事件</a>描述你可以怎样在事务中使用应用程序事件。</li></ul><h2 id="1-2-Spring框架事务支持模型的优势"><a href="#1-2-Spring框架事务支持模型的优势" class="headerlink" title="1.2 Spring框架事务支持模型的优势"></a>1.2 Spring框架事务支持模型的优势</h2><p>传统上，Java EE的开发者对于事务管理有两种选择：全局或者本地事务管理，这两种都有很大的局限性。全局和本地事务管理将在下面的两小节中回顾，接着是Spring框架管理支持解决全局和本地事务管理模型局限性的讨论。</p><h3 id="1-2-1-全局事务"><a href="#1-2-1-全局事务" class="headerlink" title="1.2.1 全局事务"></a>1.2.1 全局事务</h3><p>全部事务管理允许你和多个事务资源一块运行，事务资源一般是关系型数据库和消息队列。应用服务器通过JTA管理全局事务，JTA是一个用起来笨重的API（部分是由于它的异常模型决定的）。此外，JTA<code>UserTransaction</code>正常来说需要JNDI引入资源，意味着为了使用JTA你还需要使用JNDI。显然，全局事务的使用将会限制应用代码潜在的复用，同时JTA只能在应用服务器环境中可用。<br>先前，使用全局事务比较好的方式是通过EJB的容器管理事务：CMT是一张声明式事务管理表（对于编程事务管理也同样好用）。EJB CMT删除了关联事务JNDI的查找，尽管EJB自己必须要使用JNDI。它消除了编写Java代码以控制事务的大部分但不是全部的需要。CMT最大的缺陷是捆绑JTA和应用的服务器环境。同时，CMT只有在EJBs里实现业务逻辑才可用，或者至少在一个事务EJB facade之前。通常EJB的负面影响太大以致于这不是一个有吸引力的方案，尤其是面对声明式事务管理的引人注目的备选方案。</p><h3 id="1-2-2-本地事务"><a href="#1-2-2-本地事务" class="headerlink" title="1.2.2 本地事务"></a>1.2.2 本地事务</h3><p>本地事务是特定于资源的，比如一个事务关联一个JDBC连接。本地事务可能使用简单，但是有明显的缺陷：它们不能在多个事务资源上工作。举个例子，使用JDBC连接的管理事务代码不能在全局JTA事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个数据源的正确性。（值得注意的是，大多数应用使用单个事务资源）另一个缺陷是本地事务在编程模型中是侵入式的。</p><h3 id="1-2-3-Spring框架的一致性编程模型"><a href="#1-2-3-Spring框架的一致性编程模型" class="headerlink" title="1.2.3 Spring框架的一致性编程模型"></a>1.2.3 Spring框架的一致性编程模型</h3><p>Spring 解决了全局和本地事务的缺陷。它允许程序员在任何环境中使用一致性编程模型。你写一次代码，它可以在不同环境中的不同事务管理策略中受益。Spring框架提供声明和编程事务管理。大多数用户使用在大多数情况下被推荐使用的声明式事务模型。<br>对于编程式事务管理，开发者将使用Spring 框架的事务抽象，它可以在底层的事务基础设施上运行。对于声明式模型，开发经常写一点或者没有代码去关联事务管理，因此不依赖Spring框架的事务API或者其他的事务API。</p><blockquote><p><b>对于事务管理，你是否需要应用服务器？</b><br>Spring 框架事务管理支持当企业Java应用需要应用服务器时修改传统规则。<br>尤其，你只是需要通过EJBs声明事务而不是需要应用服务器。事实上，<strong>即使你的应用服务器有的JTA能</strong>力，对比EJB CMT，你可能决定使用Spring框架的声明式事务提供更多能力和一个富有成效的编程模型。<br>通常你需要使用应用服务器的JTA能力仅仅因为你的应用需要跨多个资源去处理事务，这种情况对于许多应用是不需要的，许多高端应用使用一个高扩展性的数据库（如：Oracle RAC）代替多个资源。独立事务管理如 Atomikos Transactions 和 JOTM是其他选择。当然，你可能需要其他应用服务器能力，如Java消息服务和JCA。<br>Spring框架给你当需要扩展你的应用去完整加载应用服务器的选择，替代使用EJB CMT或者JTA的唯一方式是使用本地事务（如：JDBC连接）写代码的日子一去不复返了，如果你需要在全局或者CMT中运行该本地事务代码将会面对大量的返工。使用Spring框架，你仅仅需要在配置文件中定义一些bean，而不是需要去修改代码。</p></blockquote><h2 id="1-3-理解Spring框架事务抽象"><a href="#1-3-理解Spring框架事务抽象" class="headerlink" title="1.3 理解Spring框架事务抽象"></a>1.3 理解Spring框架事务抽象</h2><p><strong>spring框架事务抽象的关键是事务策略的概念</strong>，通过<code>org.springframework.transaction.PlatformTransactionManager</code>接口定义事务策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager&#123;</span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition) throws TransactionException;</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个主要是Java的服务提供发现机制，尽管可以从应用代码中以编程方式使用。因为<code>PlatformTransactionManager</code>是一个接口，它可以在被需要是很容易的仿制或者存根。它和类似JNDI的查找策略无关。<br>定义<code>PlatformTransactionManager</code>的接口实现和spring IoC容器中的其他对象（或bean）相同。即使你使用JTA，仅此一项好处也使得Sping框架事务值得被抽象。相比于直接使用JTA，使用Spring事务抽象可以让测试事务代码更简单。<br>可以被任何<code>PlatformTransactionManager</code>接口的实现方法抛出的非检查（继承<code>java.lang.RuntimeException</code>的类）的<code>TransactionException</code>再次符合Spring的理念。事务基础设施的故障几乎总是致命的。应用代码在极少数情况下可以从事务失败中恢复，应用开发者可以选择捕获和处理<code>TransactionException</code>。重点是开发者不必强制去这样做。<br><code>getTransaction(..)</code>方法返回<code>TransactionStatus</code>对象，依赖一个<code>TransactionDefinition</code>参数。返回的<code>Transaction</code>可能代表一个新事务，或者可以代表一个已经存在的事务如果此事务在当前调用栈中存在匹配的事务。后者的意义是在Java EE事务上下文中，一个线程的执行和一个<code>TransactionStatus</code>相关联。<code>TransactionDefinition</code>接口指定：</p><ul><li>Isolation: 当前事务和其他事务在工作中的隔离程度。例如： 此事务是否可以看到来自其他事务的未提交的写入？</li><li>Propagation: 通常，在事务范围内运行的所有代码都将在此事务中运行。但是，你可以选择在事务上下文已经存在且执行事务方法的事件中指定行为。例如：代码可以在已存在的事务中继续运行（常见情况）;或者挂起已存在的事务，新建事务。Spring提供了EJB CMT中熟悉的所有事务传播选择。了解Spring中关于事务传播语义，<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#tx-propagation" target="_blank" rel="noopener">事务传播</a>。</li><li>Timeout: 在超时和底层事务基础设施自动回滚事务之前，事务可以运行多久？</li><li>Read-only status: 当你的代码读取但是不修改数据数据时可以使用只读事务。只读事务在某些情况下是有用的优化，例如当你使用Hibernate时。</li></ul><p>这些事务反映出了标准的事务概念，如果需要，请参阅讨论事务隔离等级和其他核心事务概念的资源。理解这些概念对使用Spring框架或者其他事务管理的解决方案是很必要的。</p><p><code>TransactionStatus</code>接口提供简单的事务代码去控制事务执行和查询事务状态。这些概念应该是熟悉的，它们对所有事务APIs都是通用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager&#123;</span><br><span class="line">    boolean isNewTransaction();</span><br><span class="line">    boolean hasSavepoint();</span><br><span class="line">    void setRollbackOnly();</span><br><span class="line">    boolean isRollbackOnly();</span><br><span class="line">    void flush();</span><br><span class="line">    boolean isCompleted();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论你在Spring中选择声明式事务还是编程式事务管理，定义正确的<code>PlatformTransactionManager</code>实现是绝对必要的。通常通过依赖注入定义这个实现。</p><p><code>PlatformTransactionManager</code>实现通常需要了解他们运行的环境：JDBC，JTA，Hibernate等等。下面的例子展示你怎样定义一个本地的<code>PlatformTransactionManager</code>实现。（这个例子适用普通的JDBC。）<br>定义一个JDBC<code>DataSource</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>相关<code>PlatformTransactionManager</code>的bean定义将有一个<code>DataSource</code>定义的引用。它看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>如果你在Java EE容器中使用JTA，你将使用通过容器从JNDI中获取的<code>DataSource</code>，和Spring的JtaTransactionManager相关联。这就是JTA和JNDI查找版本的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/jee</span><br><span class="line">        http://www.springframework.org/schema/jee/spring-jee.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;jdbc/jpetstore&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><code>JtaTransactionManager</code>不需要知道<code>DataSource</code>或者其他指定的资源，因为它使用容器的全局事务管理基础设施。</p><blockquote><p>以上定义的<code>dataSource</code>bean使用<code>jee</code>命名空间的<code>&lt;jdni-lookup/&gt;</code>标签。对于<code>schema-based</code>的更多配置信息，<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html" target="_blank" rel="noopener">Chapter40, XML Schema-based 配置</a>，对于<code>&lt;jee/&gt;</code>标签的更多信息，请看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html#xsd-config-body-schemas-jee" target="_blank" rel="noopener">Section 40.2.3</a></p></blockquote><p>你也可以使用轻松的使用Hibernate本地事务，正如在下面展示的例子。这种情况，你需要定义一个Hibernate<code>LocalSessionFactoryBean</code>，你的代码将使用它去获取Hibernate<code>Session</code>实例。</p><p><code>DataSource</code>bean定义和之前示例本地JDBC例子相似，所以下面不在展示。</p><blockquote><p>如果<code>DataSource</code>被任何非JTA事务管理使用，将通过JNDI查找，Java EE容器管理，然后它将是非事务性的，因为是使用Spring框架管理事务，而不是Java EE容器。</p></blockquote><p><code>txManager</code>bean 在这种情况下是属于<code>HibernateTransactionManager</code>类型。以相同的方式，正如<code>DataSourceTransactionManager</code>需要引用<code>DataSource</code>，<code>HiberanteTransactionManager</code>需要引用<code>SessionFactory</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;mappingResources&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;hibernateProperties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            hibernate.dialect=$&#123;hibernate.dialect&#125;</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果你使用Hibernate和Java EE容器管理JTA事务，你应该使用与之前JDBC的JTA例子相同的<code>JtaTransactionManager</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果你使用JTA，你的事务管理定义将看起来一样，而不管你用了什么数据访问技术，是JDBC，Hibernate JPA或者其他支持的技术。这个是确定的事实，JTA 事务是全局事务，可以加入任何的事务资源。</p></blockquote><p>对于以上所有情况，应用代码不需要 改变。你可以通过改变配置来改变如何管理事务，即使你从本地事务改为全局事务，反之亦然。</p><h2 id="1-4-将资源与事务同步"><a href="#1-4-将资源与事务同步" class="headerlink" title="1.4 将资源与事务同步"></a>1.4 将资源与事务同步</h2><p>现在你应该很清楚如何创建不同的事务管理，和它们怎样和需要被同步事务相关资源链接（例如：<code>DataSourceTransactionManager</code>链接JDBC<code>DataSource</code>，<code>HibernateTransactionManager</code>链接Hibernate<code>SessionFactory</code>，等等。）这个章节描述应用代码怎样直接或者非直接使用持久API，如JDBC，Hibernate，或者JDO，确保这些资源被创建，复用，和正确的清理。这个章节也讨论事务同步怎样通过相应的<code>PlatformTransactionManager</code>触发。</p><h3 id="1-4-1-高级同步方式"><a href="#1-4-1-高级同步方式" class="headerlink" title="1.4.1 高级同步方式"></a>1.4.1 高级同步方式</h3><p>首选方法是使用Spring基于高级模板的持久性集成APIs或者使用本地ORM APIs与transacton-aware工厂bean或者代理一起使用，来管理本地资源工厂。transaction-aware解决方案在内部处理资源的创建，复用，清理，资源的可选事务同步和异常映射。因此用户数据访问代码不必解决这些任务，但是可以完全关注于非样板持久逻辑。通常，你使用本地ORM API或者使用模版方式通过使用<code>JdbcTemplate</code>进行JDBC访问。这些解决方案在本参考文档的随后章节中有详细说明。</p><h3 id="1-4-2-低级同步方式"><a href="#1-4-2-低级同步方式" class="headerlink" title="1.4.2 低级同步方式"></a>1.4.2 低级同步方式</h3><p>类例如：<code>DataSourceUtils</code>（JDBC），<code>EntityManagerFactoryUtils</code>(JPA)，<code>SessionFactoryUtils</code>（Hibernate），<code>PersistenceManagerFactoryUtils</code>(JDO)，等类存在于较低级别。<br>本地持久化APIs，你使用这些类去确保Spring框架管理的实例被正确获取，事务被同步（可选），在进程中发生的异常正确的被映射到一致的API。<br>例如，在JDBC的情况下，而不是在<code>DataSource</code>调用<code>getConnection()</code>方法的传统的JDBC方式,你替换使用Spring的<code>org.springframework.jdbc.datasource.DataSourceUtils</code>类，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DataSourceUtils.getConnection(dataSource);</span><br></pre></td></tr></table></figure></p><p>如果一个已经存在的事务有一个链接和它同步，这个实例将被返回。否则，这个方法调用出方法新链接的创建，这个链接（可选）被同步到已经任何已存在的事务上，使得在随后的同一事务中重复调用。 如上所述，任何<code>SQLException</code>在Spring框架<code>CannotGetJdbcConnectionException</code>中是被包括的，是Spring框架非校验数据访问异常之一。这个方式提供了比你从<code>SQLException</code>中轻松获的更多的信息，确保跨数据库的可移植性，设置跨不同的持久化技术。</p><p>这种方式运行也没有Spring事务管理（事务同步时可选的），所以无论你是否使用Spring事务管理，你都可以使用它。</p><p>当然，一旦你使用了Spring的JDBC支持，JPA支持或者Hibernate支持，你通常更喜欢不使用<code>DataSourceUtils</code>或者其他的类，因为相比于直接使用相关的APIs，通过Spring抽象你将工作的更快乐。例如：你使用Spring<code>JdbcTemplate</code>或者<code>jdbc.object</code>包去简化你使用的JDBC，在幕后发生的链接恢复，你将不在需要写任何特定代码。</p><h3 id="1-4-3-TransactionAwareDataSourceProxy"><a href="#1-4-3-TransactionAwareDataSourceProxy" class="headerlink" title="1.4.3 TransactionAwareDataSourceProxy"></a>1.4.3 TransactionAwareDataSourceProxy</h3><p><code>TransactionAwareDataSourceProxy</code>类作为一个低级存在。这是一个<code>DataSource</code>的代理，它包装目标DataSource以增加对Spring管理的事务的认识。在这个方面，它类似于通过Java EE服务器提供的事务JNDI<code>DataSource</code>。</p><p>使用这个累根本不需要或者不可取，除非当已存在的代码必须被调用和传递了一个标准JDBC<code>DataSource</code>接口实现。在这种情况下，代码可能有用，但是参与Spring的事务管理。最好是通过使用上面提到的高级抽象去写新代码。</p><h2 id="1-5-声明式事务管理"><a href="#1-5-声明式事务管理" class="headerlink" title="1.5 声明式事务管理"></a>1.5 声明式事务管理</h2><blockquote><p>大多数Spring框架用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。</p></blockquote><p>使用Spring切面编程的Spring 框架的声明式事务管理成为可能。但是，由于事务切面代码随Spring Framework发行版一起提供并且可能以样板方式使用，因此通常没必要理解AOP概念来有效地使用此代码。</p><p>Spring 框架的声明式事务管理和 EJB CMT在给单个方法级别指定（缺少）事务的行为是相似的。在需要的情况下，不使用事务上下文调用<code>setRollbackOnly()</code>是可能的。两种事务管理类型的不同点是：</p><ul><li>和 EJB CMT不一样，绑定JTA，Spring框架的声明式事务管理可以在任何环境中运行。也可以通过调整配置文件使用JTA事务或者使用JDBC，JPA，Hibernate或者JDO本地事务。</li><li>你可以对任意类用Spring框架声明式事务管理，不仅仅是对于像EJBs的特殊类。</li><li>Spring框架提供声明式回滚规则，没有和EJB等效的功能。提供编程式和声明式两种回滚规则支持。</li><li>Spring框架允许通过使用AOP自定义事务行为。例如，你可以在事务回滚的情况下插入自定义行为。你随着事务advice也可以添加任意advice。使用EJB CMT，除了<code>setRollbackOnly</code>你无法影响容器的事务管理。</li><li>Spring框架和高端服务器一样不支持跨远程调用事务上下文传播特性。如果你需要使用这种特性，我们建议你使用EJB。但是，使用这种特性之前考略清楚，因为一般来说，不想支持事务的跨远程调用。</li></ul><blockquote><p><b>TransactionProxyFactoryBean在哪？</b><br>   在Sping的2.0版本及以上版本的声明事务配置和以前的Spring版本有很大的区别。主要的不同是不在需要配置<code>TransactionProxyFactoryBean</code>beans。<br>   Spring2.0版本之前的配置依然是100%有效的配置；将新<code>&lt;tx:tags/&gt;</code>视为代表你简单的定义<code>TransactionProxyFactoryBean</code> beans。   </p></blockquote><p>回滚规则的概念是重要的：它们允许你头指定哪种异常（或者抛出）应该造成自动的回滚。你以声明的方式指定它，在配置中，不在Java代码中。因此，尽管你可以始终在<code>TransactionStatus</code>对象上调用<code>setRollbackOnly</code>方法去回滚当前事务，但是大多数你常常可以指定<code>MyApplicationException</code>必须总是造成回滚的规则。这个选择对的重大优势是业务对象不依赖事务基础设施。例如，它们通常需要导入Spring 事务APIs或者其他Spring APIs。</p><p>尽管EJB容器默认行为在系统异常（通常是运行时异常）中自动回滚事务，EJB CMT在应用异常（除<code>java.rmi.RemoteException</code>外的检查时异常）中不自动回滚事务。虽然Spring声明式事务管理的默认行为遵循EJB约定（仅仅在非检查异常时自动回滚），但是，自定义这个行为是经常有用的。</p><h3 id="1-5-1-理解声明式事务管理实现"><a href="#1-5-1-理解声明式事务管理实现" class="headerlink" title="1.5.1 理解声明式事务管理实现"></a>1.5.1 理解声明式事务管理实现</h3><p>简单的告诉你去使用<code>@Transactional</code>注解去注解你的类，在配置中添加<code>@EnableTransactionMangement</code>，然后期待你理解它全部怎样运行的是不足够的。这个章节解释在发生与事务相关的问题时Spring的声明式事务基础设施内部工作原理。<br>关于Spring框架的说明书事务支持最重要的概念是通过AOP代理启用这个支持，事务advice由元数据（目前基于XML或者注解）驱动。事务元数据和AOP的组合生成一个代理，这个代理使用<code>TransactionInterceptor</code>和适当的<code>PlatfromTransactionManager</code>实现来驱动围绕方法调用的事务。</p><blockquote><p>Spring AOP 包含在<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring.</a></p></blockquote><p>从概念上讲，调用在一个事务代理上的一个方法像这样：</p><p><img src="media/15528176890745.png" alt=""></p><h3 id="1-5-2-声明式事务实现的例子"><a href="#1-5-2-声明式事务实现的例子" class="headerlink" title="1.5.2 声明式事务实现的例子"></a>1.5.2 声明式事务实现的例子</h3><p>考虑下面的接口，和随后的实现。这个例子使用<code>Foo</code>和<code>Bar</code>类作为标志符，以便于你可以不用管不住特殊域模型，只集中关注事务的使用。对于这个例子的目的，在每一个实现方法体内，<code>DefaultFooService</code>类抛出<code>UnsupportedOperationException</code>实例的事实是好的；它允许你查看创建的事务和然后回滚来响应<code>UnsupportedOperationException</code>实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public interface FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName, String barName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<code>FooService</code>接口的前面两个方法，<code>getFoo(String)</code>和<code>getFoo(String, String)</code>，必须在一个带有只读语义事务的上下文中执行，和其他的方法，<code>insertFoo(Foo)</code>和<code>updateFoo(Foo)</code>，必须在带有只读语义事务上下文中执行。如下配置在下面的几段中被详细解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the transactional advice (what &apos;happens&apos;; see the &lt;aop:advisor/&gt; bean below) --&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;!-- the transactional semantics... --&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!-- all methods starting with &apos;get&apos; are read-only --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;!-- other methods use the default transaction settings (see below) --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ensure that the above transactional advice runs for any execution</span><br><span class="line">        of an operation defined by the FooService interface --&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;fooServiceOperation&quot; expression=&quot;execution(* x.y.service.FooService.*(..))&quot;/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;fooServiceOperation&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- don&apos;t forget the DataSource --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;scott&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;tiger&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- similarly, don&apos;t forget the PlatformTransactionManager --&gt;</span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>检查前面的配置。你想创建一个服务对象，<code>fooService</code>bean。要应用的事务语义被封装在<code>&lt;tx:advice/&gt;</code>定义中。<code>&lt;tx:advice/&gt;</code>定义读作“在只读事务上下文中所有要执行的方法以<code>get</code>开头，所有其他要执行的方法带有默认事务语义。“<code>&lt;tx:advice/&gt;</code>标签的<code>transaction-manager</code>属性被设置为将要驱动事务的<code>PlatformTransactionManager</code>bean 的name，在当前的配置文件中，是<code>txManager</code>bean。</p><blockquote><p>如果你想设置<code>PlatformTransactionManager</code>bean的name为<code>transactionManager</code>，你可以忽略事务advice的<code>transaction-manager</code>属性。如果你想使用任何其他的name给<code>PlatformTransactionManager</code>bean，正如在之前的例子中，你之后必须明确的使用<code>transaction-manager</code>属性。</p></blockquote><p><code>&lt;aop:config/&gt;</code>的定义确保在程序中适当的点执行通过<code>txAdvice</code>bean定义的事务advice。首先你定义一个切入点，切入点与在<code>FooService</code>接口（<code>fooServiceOperation</code>）中定义的任何操作执行的相匹配。然后使用advisor关联切入点和txAdvice。结果表明在执行<code>fooServiceOperation</code>时，通过<code>txAdvice</code>定义的advice将会运行。</p><p>在<code>&lt;aop:pointcut/&gt;</code>元素中定义的表达式，是一个AspectJ切入点表达式；查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring</a>了解更多有关Spring中的切入点表达式的详细信息。</p><p>一个常见的需求时创建一个全部服务层的事务。实现这种需求的最好方式是只修改切入点表达式去匹配在你服务层的所有操作。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;fooServiceMethods&quot; expression=&quot;execution(* x.y.service.*.*(..))&quot;/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;fooServiceMethods&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中：它假设你所有服务接口在<code>x.y.service</code>包中定义；查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring </a>了解更多信息。</p></blockquote><p>现在，我们已经分析了配置，你可能会问你自己，“这所有的配置实际上做了什么？”。</p><p>以上配置将被用来去创建一个事务代理围绕从<code>fooService</code>bean 定义创建的对象。这个代理将使用事务advice配置，以便于在代理上调用一个适当的方法时，一个事务开始，挂起，被标记为只读等等，取决于与该方法关联的事务配置。考虑一下测试驱动以上配置的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Boot &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;context.xml&quot;, Boot.class);</span><br><span class="line">        FooService fooService = (FooService) ctx.getBean(&quot;fooService&quot;);</span><br><span class="line">        fooService.insertFoo (new Foo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码的输出将类似下面的。（为清楚起见，Log4J输出和DefaultFooService类的insertFoo（..）方法抛出的UnsupportedOperationException的堆栈跟踪已被截断。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- the Spring container is starting up... --&gt;</span><br><span class="line">[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean &apos;fooService&apos; with 0 common interceptors and 1 specific interceptors</span><br><span class="line"></span><br><span class="line">&lt;!-- the DefaultFooService is actually proxied --&gt;</span><br><span class="line">[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]</span><br><span class="line"></span><br><span class="line">&lt;!-- ... the insertFoo(..) method is now being invoked on the proxy --&gt;</span><br><span class="line">[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo</span><br><span class="line"></span><br><span class="line">&lt;!-- the transactional advice kicks in here... --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]</span><br><span class="line">[DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction</span><br><span class="line"></span><br><span class="line">&lt;!-- the insertFoo(..) method from DefaultFooService throws an exception... --&gt;</span><br><span class="line">[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException</span><br><span class="line">[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]</span><br><span class="line"></span><br><span class="line">&lt;!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp.PoolableConnection@a53de4]</span><br><span class="line">[DataSourceTransactionManager] - Releasing JDBC Connection after transaction</span><br><span class="line">[DataSourceUtils] - Returning JDBC Connection to DataSource</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)</span><br><span class="line">&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;</span><br><span class="line">at $Proxy0.insertFoo(Unknown Source)</span><br><span class="line">at Boot.main(Boot.java:11)</span><br></pre></td></tr></table></figure><h3 id="1-5-3-回滚一个声明式事务"><a href="#1-5-3-回滚一个声明式事务" class="headerlink" title="1.5.3 回滚一个声明式事务"></a>1.5.3 回滚一个声明式事务</h3><p>上面的章节概述了如何在你的应用中给类（通常是服务层类）声明式的指定事务设置。这个章节描述如果以一种简单的声明式方式控制事务回滚。<br>向Spring框架的事务基础设施表明回滚一个事务的推荐的方式是在当前一个事务上下文从执行的代码中抛出<code>Exception</code>。Spring框架事务基础设施代码将捕获所有未处理异常，因为它会调用堆栈，做出判定是否标记回滚事务标识。</p><p>在它的默认配置中，Spring框架的事务基础设施代码仅仅在runtime，unchecked异常时标记回滚事务；也就是说，当抛出的异常是一个实例或者RuntimeException的子类。（Errors在默认配置下也会回滚）。在一个事务方法中抛出的已检查异常在默认配置下不会造成回滚。</p><p>你可以准确的配置哪些类型的异常标记事务回滚，包括已检查的异常。下面的XML片段演示你怎样给已检查和应用指定异常类型配置回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; rollback-for=&quot;NoProductInStockException&quot;/&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>如果当抛出一个异常的时候，你不想事务回滚，你也可以指定‘不回滚规则’。下面的列子告诉你Spring框架的事务基础设施即使面对未处理的InstrumentNotFoundException也要提交<strong>伴随</strong>事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;updateStock&quot; no-rollback-for=&quot;InstrumentNotFoundException&quot;/&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>当Spring框架的事务基础设施缓存一个异常，参考回滚配置规则来决定是否标记回滚事务时，强匹配规则胜利。因此，在下面配置的这种情况，除<code>InstrumentNotFoundException</code>以外的所有异常都会造成伴随事务的回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Throwable&quot; no-rollback-for=&quot;InstrumentNotFoundException&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>你可以表示一个需要编程式回滚。尽管非常简单，这个进程时侵入式的，Spring框架的事务基础设施将紧紧侵入你的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void resolvePosition() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // some business logic...</span><br><span class="line">    &#125; catch (NoProductInStockException ex) &#123;</span><br><span class="line">        // trigger rollback programmatically</span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有可能强烈推荐使用声明式途径回滚事务。编程式事务回滚应该在你绝对需要时使用，但是它的用法在实现基于POJO的清洁框架时很明显。</p><h3 id="1-5-4-给不同的bean配置不同的事务语义"><a href="#1-5-4-给不同的bean配置不同的事务语义" class="headerlink" title="1.5.4 给不同的bean配置不同的事务语义"></a>1.5.4 给不同的bean配置不同的事务语义</h3><p>考虑具有多个服务层对象的情况，并且您希望对每个对象应用完全不同的事务配置。使用不同的切入点和advice-ref属性值定义不同的&lt;aop：advisor /&gt;元素。作为比较，首先假设您的所有服务层类都在根x.y.service包中定义。要使所有作为在该包（或子包中）中定义的类的实例的bean以及以Service结尾的名称具有默认的事务配置，您将编写以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;serviceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service..*Service.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;serviceOperation&quot; advice-ref=&quot;txAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- these two beans will be transactional... --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;barService&quot; class=&quot;x.y.service.extras.SimpleBarService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ... and these two beans won&apos;t --&gt;</span><br><span class="line">    &lt;bean id=&quot;anotherService&quot; class=&quot;org.xyz.SomeService&quot;/&gt; &lt;!-- (not in the right package) --&gt;</span><br><span class="line">    &lt;bean id=&quot;barManager&quot; class=&quot;x.y.service.SimpleBarManager&quot;/&gt; &lt;!-- (doesn&apos;t end in &apos;Service&apos;) --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>下面的例子展示怎样使用两种完全不同的事务设置配置两种不同的bean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;defaultServiceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service.*Service.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;noTxServiceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service.ddl.DefaultDdlManager.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;defaultServiceOperation&quot; advice-ref=&quot;defaultTxAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;noTxServiceOperation&quot; advice-ref=&quot;noTxAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will be transactional (see the &apos;defaultServiceOperation&apos; pointcut) --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;</span><br><span class="line">    &lt;bean id=&quot;anotherFooService&quot; class=&quot;x.y.service.ddl.DefaultDdlManager&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;defaultTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;noTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot; propagation=&quot;NEVER&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-lt-tx-advice-gt-设置"><a href="#1-5-5-lt-tx-advice-gt-设置" class="headerlink" title="1.5.5 &lt;tx:advice/&gt;设置"></a>1.5.5 <code>&lt;tx:advice/&gt;</code>设置</h3><p>这个章节总结可以指定使用<code>&lt;tx:advice/&gt;标签的各种事务配置。默认的</code><a href="tx:advice/" target="_blank" rel="noopener">tx:advice/</a>`设置：</p><ul><li>传播特性是 <code>REQUIRED</code></li><li>隔离等级是 <code>DEFAULT</code></li><li>事务是读/写</li><li>事务超时默认为底层事务系统的默认超时，如果不支持超时则为none</li><li>任意<code>RuntimeException</code>触发回滚，任意的检查时异常不回滚。</li></ul><p>你可以改变这些默认设置；嵌套在<code>&lt;tx:advice/&gt;</code>和<code>&lt;tx:attributes/&gt;</code>标签中的<code>&lt;tx:method/&gt;</code>标签的各种属性总结如下：<br><a href="tx:method/" target="_blank" rel="noopener">tx:method/</a> 设置:<br><img src="media/15531331224039.jpg" alt=""></p><h3 id="1-5-6-使用-Transactional"><a href="#1-5-6-使用-Transactional" class="headerlink" title="1.5.6 使用@Transactional"></a>1.5.6 使用@Transactional</h3><p>除了基于XML的方式声明事务配置，你也可以使用基于注解的方式。直接在Java源代码中声明事务语义使声明更接近被作用的代码。没有太多过度耦合的危险，因为无论如何，以事务方式使用的代码几乎总是以这种方式部署。</p><blockquote><p>标准<code>javax.transaction.Transactional</code>注解支持使用Spring自己的注解直接替换。请参考JTA 1.2 文档了解更多详细资料。</p></blockquote><p>使用@Transactional注释所提供的易用性最好通过一个示例来说明，该示例将在后面的文本中进行说明。考虑以下类定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// the service class that we want to make transactional</span><br><span class="line">@Transactional</span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当上面的POJO被定义为Spring IoC容器中的bean时，可以通过仅添加一行XML配置来使bean实例成为事务性的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- from the file &apos;context.xml&apos; --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;&lt;!-- a PlatformTransactionManager is still required --&gt;</span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;!-- (this dependency is defined somewhere else) --&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果要连接的<code>PlatformTransactionManager</code>的bean的名字是<code>transactionManager</code>，你可以忽略<code>&lt;tx:annotation-driven</code>/&gt;的<code>transaction-manager</code>属性。如果你要依赖注入的<code>PlatformTransactionManager</code>bean有任何其他的名字，你必须和上面的例子一样明确的使用<code>transaction-manager</code>。<br>如果你基于Java配置，<code>@EnableTransactionManagement</code>注解提供有效的支持。只需添加<code>@Configuration</code>注解类。查看全部详细内容请看javadocs。</p></blockquote><blockquote><p><b>方法可见性和@Transaction</b><br>当使用代理时，仅仅对于public可见性的方法应用<code>@Transactional</code>注解。如果你对protected，private或者包内可见的方法使用<code>@Transactional</code>注解，虽然没有错误，但是这个已经注解的方法不展示已配置的事务配置。如果你需要直接非public的方法，可以考虑使用AspectJ（见下文）。</p></blockquote><p>你可以在一个接口定义，接口上的方法，类定义或者类上的public方法前面设置<code>@Transactional</code>。但是，只有<code>@Transactional</code>注解是不足以激活事务行为的。<code>@Transactional</code>注解是一个简单的元数据，它可以被一些运行时的基础设施消费，这个基础设施是<code>@Transactional</code>-aware和可以使用元数据配置具有事务行为的适当的bean。在上面的例子中，<code>&lt;tx:annotation-driven/&gt;</code>元素打开事务行为。</p><blockquote><p>Spring 推荐你只使用<code>@Transactional</code>注解具体类（和具体类的方法），而不是注解接口。你通常可以在一个接口（或者一个接口的方法）上配置<code>@Transactional</code>注解，但是，仅仅在你使用基于接口代理的方式时才能获得你期望的运行。Java注解不从接口继承Java注解的事实意味着如果你使用基于类的代理（<code>proxy-target-class=&quot;true&quot;</code>）或者基于切面织入（<code>mode=&quot;&quot;aspectj</code>），然后代理和织入的基础设施将不识别事务设置，并且这个对象不被包裹在事务代理中，这将是非常糟糕的。</p></blockquote><blockquote><p>在代理模式（默认）中，仅外部的方法通过代理调用进入会被拦截。这意味着自我调用，实际上，在目标对象的方法调用目标对象的其他方法将不会在运行时引起一个实际的事务，即使被调用的方法使用<code>@Transactional</code>标记。这个代理也必须完整的初始化去提供你期望的行为，因此，你不应该在你的初始化代码中依赖这个特性，即<code>@PostConstruct</code>。</p></blockquote><p>如果你希望自我调用也被包裹在事务中，可以考虑切面模式（在下面的表格中查看模式的属性）的使用。在这种情况下，首先不会有一个代理；相反，为了将<code>@Transactional</code>转换为任何类型方法上的运行时行为，目标类将被织入（它的字节码将被修改）。</p><p><table><tr><td>XML Attribute</td><td>Annotation Attribute</td><td>Default</td><td>Description</td></tr><tr><td><code>transaction-manger</code></td><td>N/A(查看<code>TransactionManagementConfigurer</code> javadocs)</td><td>transactionManager</td><td>要使用的事务管理器的名称。仅在如果事务管理器的名称不是<code>transactionManager</code>时需要，如上面的例子所示</td></tr><tr><td><code>mode</code></td><td><code>mode</code></td><td>proxy</td><td>默认模式“代理”进程使用Spring的AOP框架（以下代理语义，正如上面讨论的，仅适用于通过代理进入的方法调用）代理被注解的bean。替代模式“aspectj”代替使用Spring的AspectJ事务切面织入受影响的类，修改目标类字节码以应用任何类型的方法调用。AspectJ 织入需要spring-aspects.jar在classpath中，同时加载时织入（编译时织入）开启。（查看怎样设置加载时织入的详细内容，请访问<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-aj-ltw-spring" target="_blank" rel="noopener">Spring配置</a>）</td></tr><tr><td><code>proxy-target-class</code></td><td><code>proxyTargetClass</code></td><td>false</td><td>仅适用代理模式。控制给带有<code>@Transactional</code>注解的注解类创建什么类型的事务代理。如果<code>proxy-target-class</code>属性设置为<code>true</code>，基于类的代理将被创建。如果<code>proxy-target-class</code>为false或者这个属性被忽略，标准JDK基于接口的代理将被创建。（详细检查不同类型代理请查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-proxying）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;`order`&lt;/td&gt;&lt;td&gt;`order`&lt;/td&gt;&lt;td&gt;Ordered.LOWEST_PRECEDENCE&lt;/td&gt;&lt;td&gt;定义事务advice的order适用于带有`@Transaction`注解的bean。（关于有关AOP advice的规则的更多信息，查看[Advice ordering](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">10.6 代理机制</a>。）不指定ordering意味着AOP子系统决定advice的order</td></tr></table></p><blockquote><p><code>@EnableTransactionManagement</code>和<code>&lt;tx:annotation-driven/&gt;</code>只查找它们定义在相同应用上下文bean上的<code>@Transactional</code>。这意味着，如果你在一个<code>WebApplicationContext</code>中给一个<code>DispatcherServlet</code>添加注解驱动配置，它仅仅检查你controller带有<code>@Transactional</code>的bean，而不是你的service。了解更多信息查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/mvc.html#mvc-servlet" target="_blank" rel="noopener">The DispatcherServlet</a>。</p></blockquote><p>在评估方法的事务设置时，派生最多的位置优先。下面列子的这种情况，<code>DefaultFooService</code>类在类级别中使用只读事务设置注解，但是，在相同的类中，在<code>updateFoo(Foo)</code>方法上的<code>@Transactional</code>注解优先于类级别定义的事务设置。</p><blockquote><p><b>@Transactional 设置</b><br><code>@Transactional</code>注解是一个元数据，这个元数据指定一个接口，类或者方法必须有事务语义；例如，“当方法被调用时，开始一个全新的只读事务，中止任何已存在的事务“。默认的<code>@Transactional</code>设置如下：</p></blockquote><ul><li>传播特性设置是<code>PROPAGATION_REQUIRED</code>。</li><li>隔离等级是<code>ISOLATION_DEFAULT</code>。</li><li>事务是读/写。</li><li>事务超时默认是底层事务系统的默认超时，或者如果不支持超时为none。</li><li>任何<code>RuntimeException</code>触发回滚，任何已校验异常不会。</li></ul><p>这些默认设置可以改变；在下表中总结了<code>@Transactional</code>注解的各种属性：</p><p><table><tr><td>Property</td><td>Type</td><td>Description</td></tr><tr><td>value</td><td>String</td><td>可选限定符，指定要使用的事务管理器</td></tr><tr><td>propagation</td><td>enum:<code>Propagation</code></td><td>可选传播特性设置</td></tr><tr><td><code>isolation</code></td><td>enum:<code>Isolation</code></td><td>可选隔离级别</td></tr><tr><td><code>readOnly</code></td><td>boolean</td><td>读/写 vs 只读</td></tr><tr><td><code>timeout</code></td><td>int(秒粒度)</td><td>事务超时</td></tr><tr><td><code>rollbackFor</code></td><td>类的对象数组，必须从<code>Throwable</code>派生</td><td>可选异常类数组，这些异常必须造成回滚</td></tr><tr><td><code>rollbackForClassName</code></td><td>类的名称数组，类必须从<code>Throwable</code>派生</td><td>可选异常类名称数组，必须造成回滚</td></tr><tr><td><code>noRollbackFor</code></td><td>类的对象数组，必须从<code>Throwable</code>派生</td><td>可选异常类数组，这些异常必须不造成回滚</td></tr><tr><td><code>noRollbackForClassName</code></td><td>类的名称数组，类必须从<code>Throwable</code>派生</td><td>可选异常类名称数组，必须不造成回滚</td></tr></table><br>目前，你无法明确的掌控事务的名称，如果适用，其中<code>name</code>表示将在事务监视器中显示的事务名称，以及日志记录输出。对于声明式事务，事务名总是全量类名+“.”+事务的advised类的方法名。例如，如果<code>BusinessService</code>类的<code>handlePayment(...)</code>方法开始一个事务，事务名称将会是<code>com.foo.BusinessService.handlePayment</code>。</p><h4 id="使用-Transactional的多个事务管理"><a href="#使用-Transactional的多个事务管理" class="headerlink" title="使用@Transactional的多个事务管理"></a>使用@Transactional的多个事务管理</h4><p>大多数Spring应用仅仅需要单个事务管理，但是可能也会有在单个应用中你想多个独立事务管理的情况。<code>@Transactional</code>注解的属性值可以被用来选择性指定要使用的<code>PlatformTransactionManager</code>。这可以是bean的名称或者事务管理bean的值。例如，如下Java代码使用的限定符值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TransactionalService&#123;</span><br><span class="line"></span><br><span class="line">    @Transactional(&quot;order&quot;)</span><br><span class="line">    public void setSomething(String name)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    @Transactional(&quot;account&quot;)</span><br><span class="line">    public void doSomething()&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在应用上下文中和如下的事务管理bean声明组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tx:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;transactionManager1&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value=&quot;order&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;transactionManager2&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value=&quot;account&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>TransactionalService</code>的两个方法将在单独事务管理器下运行，通过“order”和“account”区分。如果没有找到指定限定符的<code>PlatformTransactionManager</code>的bean，将一直使用<code>&lt;tx:annotation-driven&gt;</code>默认的目标bean名称<code>transactionManager</code>。</p><h4 id="自定义快捷方式注解"><a href="#自定义快捷方式注解" class="headerlink" title="自定义快捷方式注解"></a>自定义快捷方式注解</h4><p>如果你发现你在许多不同方法上重复使用<code>@Transactional</code>的相同属性值，[Spring’s meta-annotaion support]允许你在你的指定使用情况下定义自定义快捷方式的注解。例如，如下注解的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;order&quot;)</span><br><span class="line">public @interface OrderTx &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;account&quot;)</span><br><span class="line">public @interface AccountTx &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许我们将上一小节的例子写为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TransactionalService&#123;</span><br><span class="line">    </span><br><span class="line">    @OrderTx</span><br><span class="line">    public void setSomething(String name)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    @AccountTx</span><br><span class="line">    public void doSomething()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了定义事务管理器的限定符语法，但是我们也可以包含传播特性行为，回滚规则，超时等等。</p><h3 id="1-5-7-事务传播特性"><a href="#1-5-7-事务传播特性" class="headerlink" title="1.5.7 事务传播特性"></a>1.5.7 事务传播特性</h3><p>这个章节描述在Spring中的事务传统特性的一些语义。请注意这个章节不是适当的一个事务传播特性介绍；二是详细描述在Spring中关于事务传播特性的一些语义。</p><p>在Spring管理的事务中，注意物理和逻辑事务的区别，和事务传播特性设置如何应用此差异。<br><img src="media/15534834588483.jpg" alt=""></p><p><code>PROPAGATION_REQUIRES_NEW</code>，与<code>PROPAGATION_REQUIRED</code>相比，为每一个事务作用域使用一个独立的事务。在那种情况下，底层的物理事务是不同的，因此可以独立的提交或者回滚，外部事务不受内部事务回滚状态的影响。</p><h4 id="Nested"><a href="#Nested" class="headerlink" title="Nested"></a>Nested</h4><p><code>PROPAGATION_NESTED</code>使用具有多个保存点的单个物理事务，它可以回滚到该事务。一些局部是回滚允许内部事务域在它的作用域触发回滚，使用外部事务可以继续物理事务而不用管一些已经回滚的操作。这个设置常用来映射JDBC的保存点。因此仅仅和JDBC资源事务一起工作。查看Spring的<code>DataSourceTransactionManager</code>。</p><h3 id="1-5-8-Advising-事务操作"><a href="#1-5-8-Advising-事务操作" class="headerlink" title="1.5.8 Advising 事务操作"></a>1.5.8 Advising 事务操作</h3><p>假如你想同时执行事务和一些基础剖析advice。你怎样在<code>&lt;tx:annotaion-driven/&gt;</code>的上下文中实现这点？</p><p>当你调用<code>updateFoo(Foo)</code>方法，你想看到如下动作：</p><ul><li>配置的剖析切面启动</li><li>事务advice执行</li><li>advised对象上的方法执行</li><li>事务提交</li><li>剖析切面精确报告整个事务方法调用期间</li></ul><blockquote><p>这个章节不关心详细介绍AOP（除非AOP适用于事务）。有关以下AOP配置和AOP的详细介绍，请参见<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10,Aspect Oriented Programming with Spring</a>。</p></blockquote><p>这是上面讨论简单剖析切面的代码。advice的排序由<code>Ordered</code>接口控制。了解advice 排序的全部详细内容，查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">the section called “Advice ordering”</a>..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package x.y;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.springframework.util.StopWatch;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line"></span><br><span class="line">public class SimpleProfiler implements Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private int order;</span><br><span class="line"></span><br><span class="line">    // allows us to control the ordering of advice</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return this.order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrder(int order) &#123;</span><br><span class="line">        this.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this method is the around advice</span><br><span class="line">    public Object profile(ProceedingJoinPoint call) throws Throwable &#123;</span><br><span class="line">        Object returnValue;</span><br><span class="line">        StopWatch clock = new StopWatch(getClass().getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            clock.start(call.toShortString());</span><br><span class="line">            returnValue = call.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            clock.stop();</span><br><span class="line">            System.out.println(clock.prettyPrint());</span><br><span class="line">        &#125;</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the aspect --&gt;</span><br><span class="line">    &lt;bean id=&quot;profiler&quot; class=&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        &lt;property name=&quot;order&quot; __value=&quot;1&quot;__/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; __order=&quot;200&quot;__/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">            &lt;!-- this advice will execute around the transactional advice --&gt;</span><br><span class="line">            &lt;aop:aspect id=&quot;profilingAspect&quot; ref=&quot;profiler&quot;&gt;</span><br><span class="line">                &lt;aop:pointcut id=&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                        expression=&quot;execution(!void x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">                &lt;aop:around method=&quot;profile&quot; pointcut-ref=&quot;serviceMethodWithReturnValue&quot;/&gt;</span><br><span class="line">            &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;scott&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;tiger&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>上述配置的结果是一个fooService bean，它具有按所需顺序应用于它的分析和事务切面。你可以以类似的方式配置任意数量的其他切面。</p><p>以下示例实现与上述相同的配置，但是使用纯粹的XML声明式途径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the profiling advice --&gt;</span><br><span class="line">    &lt;bean id=&quot;profiler&quot; class=&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        __&lt;property name=&quot;order&quot; value=&quot;1__&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;entryPointMethod&quot; expression=&quot;execution(* x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">        &lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;entryPointMethod&quot; __order=&quot;2__&quot;/&gt;</span><br><span class="line">        &lt;!-- order value is higher than the profiling aspect --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:aspect id=&quot;profilingAspect&quot; ref=&quot;profiler&quot;&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                    expression=&quot;execution(!void x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">            &lt;aop:around method=&quot;profile&quot; pointcut-ref=&quot;serviceMethodWithReturnValue&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions such as a DataSource and a PlatformTransactionManager here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>以上配置的结果是一个<code>fooService</code>bean，它具有适用于它的所需排序的剖析和事务切面。如果你想要在事务advice在进入之后，事务advice出去之前，执行的剖析advice，你只需简单的更换剖析切面bean的order属性值，使得它比事务advice的顺序值更高。</p><p>你使用类似的方式配置其他的切面。</p><h3 id="1-5-9-使用带有切面的-Transactional"><a href="#1-5-9-使用带有切面的-Transactional" class="headerlink" title="1.5.9 使用带有切面的@Transactional"></a>1.5.9 使用带有切面的@Transactional</h3><p>在一个Spring容器之外，通过AspectJ切面，也可能使用Spring框架的<code>@Transactional</code>的支持。如果这样做，你首先使用<code>@Transactional</code>注解你的类（和可选择的你的类方法），然后你使用定义在<code>spring-aspects.jar</code>的<code>org.springframework.transaction.aspectj.AnnotationTransactionAspect</code>连接（织入）你的应用。还必须使用事务管理器配置你的切面。你当然可以使用Spring框架的IoC容器去管理依赖注入切面。配置事务管理器切面的最简单方式是使用<code>&lt;tx:annotation-driven/&gt;</code>元素和给<code>aspectj</code>指定<code>mode</code>属性，正如在<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-annotations" target="_blank" rel="noopener">Section 16.5.6 Using @Transactional</a>。因为我们关注在一个Spring容器之外程序的运行，我们将会向你展示如何以编程的方式实现它。</p><blockquote><p> 在继续之前，你可能想要分别去读<a href="">Section 16.5.6 Using @Transactional</a>和<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring</a>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// construct an appropriate transaction manager</span><br><span class="line">DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());</span><br><span class="line"></span><br><span class="line">// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods</span><br><span class="line">AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);</span><br></pre></td></tr></table></figure><blockquote><p>当使用切面，你必须注解实现类（和/或 类里的方法），不是类实现的接口。<br>AspectJ 遵守Java的规则，不继承接口上的注解。</p></blockquote><p>在类上的<code>@Transactional</code>注解给在类里的任何方法的执行指定默认事务语义。<br>在在类里的方法上的<code>@Transactional</code>注解覆盖类提供注解（如果存在）的默认事务语义。不管是否可见，任何的方法可能被注解。</p><p>使用<code>AnnotationTransactionAspect</code>织入你的应用，你要么使用AspectJ（<a href="https://www.eclipse.org/aspectj/doc/released/devguide/index.html" target="_blank" rel="noopener">AspectJ Development Guide</a>）构建你的应用，要么使用加载时织入。使用AspectJ加载时织入的讨论请看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-aj-ltw" target="_blank" rel="noopener">Load-time weaving with AspectJ in the Spring Framework</a></p><h2 id="1-6-编程事务管理"><a href="#1-6-编程事务管理" class="headerlink" title="1.6 编程事务管理"></a>1.6 编程事务管理</h2><p>Spring框架提供两种编程事务管理工具：</p><ul><li>使用<code>TransactionTemplate</code>。</li><li>直接使用<code>PlatformTransactionManager</code>实现。</li></ul><p>对于编程式事务管理Spring团队通常建议使用<code>TransactionTemplate</code>。第二种相似途径是使用JTA<code>UserTransaction</code>API，虽然异常处理不是那么笨重。</p><h3 id="1-6-1-使用TransactionTemplate"><a href="#1-6-1-使用TransactionTemplate" class="headerlink" title="1.6.1 使用TransactionTemplate"></a>1.6.1 使用TransactionTemplate</h3><p><code>TransactionTemplate</code> 采用与其他Spring模版（例如<code>JdbcTemplate</code>）一样的方式。它使用一个回调的方法，使应用代码不必执行样板获取和释放事务资源，并产生驱动程序的代码，以便于被编写的代码仅关注开发人员想要做的事情。</p><blockquote><p>正如你将在如下的例子中看到的，使用<code>TransactionTemplate</code>绝对将你和Spring的事务基础架构和API结合在一起。</p></blockquote><p>应用代码必须在事务上下文中执行，明确的使用<code>TransactionTemplate</code>，看起来和如下的相似。你作为一个应用开发者，写一个<code>TransactionCallback</code>实现（通常表现为一个匿名内部类），这个实现包含在一个事务上下文中执行的代码。然后将自定义<code>TransactionCallback</code>的实例，传递给<code>TransactionTemplate</code>上公开的<code>execute(...)</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    // single TransactionTemplate shared amongst all methods in this instance</span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    // use constructor-injection to supply the PlatformTransactionManager</span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        Assert.notNull(transactionManager, &quot;The &apos;transactionManager&apos; argument must not be null.&quot;);</span><br><span class="line">        this.transactionTemplate = new TransactionTemplate(transactionManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object someServiceMethod() &#123;</span><br><span class="line">        return transactionTemplate.execute(new TransactionCallback() &#123;</span><br><span class="line">            // the code in this method executes in a transactional context</span><br><span class="line">            public Object doInTransaction(TransactionStatus status) &#123;</span><br><span class="line">                updateOperation1();</span><br><span class="line">                return resultOfUpdateOperation2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有返回值，方便的使用<code>TransactionCallbackWithoutResult</code>类和一个匿名内部类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        updateOperation1();</span><br><span class="line">        updateOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在回调中的代码可以通过提供的<code>TransactionStatus</code>对象上调用<code>setRollbackOnly()</code>方法回滚这个事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line"></span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            updateOperation1();</span><br><span class="line">            updateOperation2();</span><br><span class="line">        &#125; catch (SomeBusinessExeption ex) &#123;</span><br><span class="line">            status.setRollbackOnly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="指定事务设置"><a href="#指定事务设置" class="headerlink" title="指定事务设置"></a>指定事务设置</h4><p>你可以以编程方式或配置方式在TransactionTemplate上指定例如传播特性模式，隔离等级，超时等等的事务设置。默认的<code>TransactionTemplate</code>实例有<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-txadvice-settings" target="_blank" rel="noopener">默认事务设置</a>。如下的例子展示对于一个指定<code>TransactionTemplate</code>事务设置的编程式定制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        Assert.notNull(transactionManager, &quot;The &apos;transactionManager&apos; argument must not be null.&quot;);</span><br><span class="line">        this.transactionTemplate = new TransactionTemplate(transactionManager);</span><br><span class="line"></span><br><span class="line">        // the transaction settings can be set here explicitly if so desired</span><br><span class="line">        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);</span><br><span class="line">        this.transactionTemplate.setTimeout(30); // 30 seconds</span><br><span class="line">        // and so forth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下的例子定义了一个使用一些自定义事务设置的<code>TransactionTemplate</code>，使用Spring XML配置。然后可以将<code>sharedTransactionTemplate</code>注入到尽可能多的需要的服务中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sharedTransactionTemplate&quot;</span><br><span class="line">        class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;isolationLevelName&quot; value=&quot;ISOLATION_READ_UNCOMMITTED&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;timeout&quot; value=&quot;30&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>最后，<code>TransactionTemplate</code>类的实例是线程安全的，因为实力不保持任何会话状态。但是，<code>TransactionTemplate</code>实例会保持配置状态，因此当许多类可能共享一个<code>TransactionTemplate</code>的一个单例时，如果一个类需要使用一个带有不同设置（例如，不同隔离等级）的<code>TransactionTemplate</code>，你就需要去创建一个两个不同的<code>TransactionTemplate</code>实例。</p><h3 id="1-6-2-使用PlatformTransactionManager"><a href="#1-6-2-使用PlatformTransactionManager" class="headerlink" title="1.6.2 使用PlatformTransactionManager"></a>1.6.2 使用PlatformTransactionManager</h3><p>你也可以直接使用<code>org.springframework.transaction.PlatformTransactionManager</code>管理你的事务。简单的通过一个bean引用传递你正在用的<code>PlatformTransactionManager</code>的实现给你的bean。然后，使用<code>TransactionDefinition</code>和<code>TransactionStatus</code>对象你可以发起，回滚和提交事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultTransactionDefinition def = new DefaultTransactionDefinition();</span><br><span class="line">// explicitly setting the transaction name is something that can only be done programmatically</span><br><span class="line">def.setName(&quot;SomeTxName&quot;);</span><br><span class="line">def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">TransactionStatus status = txManager.getTransaction(def);</span><br><span class="line">try &#123;</span><br><span class="line">    // execute your business logic here</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex) &#123;</span><br><span class="line">    txManager.rollback(status);</span><br><span class="line">    throw ex;</span><br><span class="line">&#125;</span><br><span class="line">txManager.commit(status);</span><br></pre></td></tr></table></figure><h2 id="1-7-编程式和声明式事务管理器的选择"><a href="#1-7-编程式和声明式事务管理器的选择" class="headerlink" title="1.7 编程式和声明式事务管理器的选择"></a>1.7 编程式和声明式事务管理器的选择</h2><p>编程式事务管理仅仅在你如果有一个小数量的事务操作情况下才是一个好想法。例如，如果你有一个web应用需要仅仅主要是update操作的事务，你不可能想去使用Spring或者其他任何技术去设置事务代理。在这种情况下，使用<code>transactionTemplate</code>可能是一个好方法。可能明确的设置事务名称可以仅在使用编程式途径进行事务管理的情况下去做。</p><p>从另一方面，如果你的应用有很多事务操作，声明式事务管理通常是合算的。它保持事务管理摆脱业务逻辑，配置不困难。当使用Spring框架，而不是EJB CMT时，声明式事务配置的成本将大大降低。</p><h2 id="1-8-事务约束事件"><a href="#1-8-事务约束事件" class="headerlink" title="1.8 事务约束事件"></a>1.8 事务约束事件</h2><p>作为Spring 4.2，一个事件的监听可以被约束为事务的一个阶段。常用的例子是当事务已经成功的完成时去处理事件：当当前事务的结果对于监听器实际上很重要时，这允许事件被更灵活地使用。<br>注册一个常规的监听事件可以通过<code>@EventListener</code>注解。如果你需要和事务绑定它使用<code>@TransactionEventListener</code>。当你这样做时，监听器将默认约束事务提交阶段。<br>我们举个例子说明这个概念。</p><p>假设一个组件发布了一个订单创建的事件，我们想要定义一个监听器，该监听器只应该在事件成功提交时才处理该事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyComponent &#123;</span><br><span class="line"></span><br><span class="line">    @TransactionalEventListener</span><br><span class="line">    public void handleOrderCreatedEvent(CreationEvent&lt;Order&gt; creationEvent) &#123;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>TransactionalEventListener</code>注解暴露一个<code>phase</code>属性，这个属性允许自定义监听器应该约束事务的哪个phase。这个有效的phases是<code>BEFORE_COMMIT</code>，<code>AFTER_COMMIT</code>(default)，<code>AFTER_ROLLBACK</code>和<code>AFTER_COMPLETION</code>，它们聚合事务的完整性（是一个提交或者一个回滚）。</p><p>如果没有正在运行的事务，由于我们无法遵守所需的语义，监听器根本不会被调用。但是，它可能通过设置注解的<code>fallbackExecution</code>属性为true去覆盖该行为。</p><h2 id="1-9-指定应用服务器的集成"><a href="#1-9-指定应用服务器的集成" class="headerlink" title="1.9 指定应用服务器的集成"></a>1.9 指定应用服务器的集成</h2><p>Spring的事务抽象通常是应用服务器不可知。此外，Spring的<code>JtaTransactionManager</code>类，可以可选执行对于JTA<code>UserTransaction</code>和<code>TransactionManager</code>对象的JNDI查找，对于后者对象，自动检查地址，该地址因应用服务器而变化。访问JTA TransactionManager允许增强的事务语义，特别是支持事务暂停。了解详细请查看<code>JtaTransactionManager</code>javadocs。</p><p>Spring的<code>JtaTransactionManager</code>在Java EE应用服务器上运行的标准选择，并已知可以在所有常用的服务器上运行。高级功能（事务暂停）在很多服务器上运行很好，包括GlassFish，JBoss和Geronimo，不需要任何特殊配置。但是，对于完整的支持事务暂停和进一步的高级集成，Spring ship对于WebLogic服务器和WebSphere特殊适配。这些适配在如下章节讨论。</p><p>对于标准场景，包括Weblogic Server和WebSphere，考虑使用定制<code>&lt;tx:jta-trasaction-manager/&gt;</code>配置元素。当已配置时，这元素自动检查底层服务器和选择适用于该平台的最好的事务管理器。这意味着你将不需要必须显式的配置指定服务器适配类（在如下章节讨论）；相反，它们是自动选择的，标准的<code>JtaTransactionManager</code>是默认的后备。</p><h3 id="1-9-1-IBM-WebSphere"><a href="#1-9-1-IBM-WebSphere" class="headerlink" title="1.9.1 IBM WebSphere"></a>1.9.1 IBM WebSphere</h3><p>在WebSphere6.1.0.9及以上版本，建议Spring JTA事务管理器使用<code>WebSphereUowTransactionManager</code>。这个特殊的适配器利用了IBM’s <code>UOWManager</code> API，在WebSphere应用服务器6.0.2.19和以后版本，6.1.0.9和以后版本是适用的。使用这个适配器，驱动Spring事务暂停（暂停/恢复 由<code>PROPAGATION_REQUIRES_NEW</code>发起）是由IBM官方支持的。</p><h3 id="1-9-2-Oracle-WebLogic-Server"><a href="#1-9-2-Oracle-WebLogic-Server" class="headerlink" title="1.9.2 Oracle WebLogic Server"></a>1.9.2 Oracle WebLogic Server</h3><p>在Weblogic Server及以后版本中，你通常将使用<code>WebLogicJtaTransactionManager</code>而不是存<code>JtaTransactionManager</code>类。普通<code>JtaTransactionManager</code>的这个特殊的Weblogic特定的子类在Weblogic管理的事务环境中支持Spring的事务全部功能，超出标准的JTA语义：特性包括事务名称，每个事务的隔离等级，以及在所有的情况下正确的恢复事务。</p><h2 id="1-10-常见问题解决"><a href="#1-10-常见问题解决" class="headerlink" title="1.10 常见问题解决"></a>1.10 常见问题解决</h2><h3 id="1-10-1-对于特定数据源错误的事务管理器的使用"><a href="#1-10-1-对于特定数据源错误的事务管理器的使用" class="headerlink" title="1.10.1 对于特定数据源错误的事务管理器的使用"></a>1.10.1 对于特定数据源错误的事务管理器的使用</h3><p>正确的使用<code>PlatformTransactionManager</code>实现基于你事务技术和需求的选择。正确的使用，Spring框架仅提供一个简单直接和轻便的抽象。如果你正在使用全局事务，你必须使用<code>org.springframework.transaction.jta.JtaTransactionManager</code>类（或者一个指定的应用服务器子类）进行你所有的事务操作。否则事务基础设施在资源（例如容器的<code>DataSource</code>实例）上尝试使用本地事务。这样的本地事务没有意义，一个好的应用服务器把它们当作错误。</p><h2 id="1-11-集成资源"><a href="#1-11-集成资源" class="headerlink" title="1.11 集成资源"></a>1.11 集成资源</h2><p>了解更多关于Spring框架的事务支持信息：</p><ul><li><a href="http://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html" target="_blank" rel="noopener">Distributed transaction in Spring，with and without XA</a>是一个JavaWorld演示文稿，其中Spring的David Syer引导您在Spring应用程序中通过分布式事务的七种模式，其中三种模式使用XA，另外四种没有。</li><li><a href="http://www.infoq.com/minibooks/JTDS" target="_blank" rel="noopener">Java 事务设计策略</a>是一本从<a href="http://www.infoq.com/" target="_blank" rel="noopener">InfoQ</a>得到的书，InfoQ提供一个Java事务快速介绍。它还包括如何使用Spring Framework和EJB3配置和使用事务的并排示例。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-事务管理&quot;&gt;&lt;a href=&quot;#Spring-事务管理&quot; class=&quot;headerlink&quot; title=&quot;Spring 事务管理&quot;&gt;&lt;/a&gt;Spring 事务管理&lt;/h1&gt;&lt;p&gt;翻译自&lt;a href=&quot;https://docs.spring.io
      
    
    </summary>
    
    
      <category term="翻译" scheme="https://zhongyp.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="事务" scheme="https://zhongyp.me/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
</feed>
