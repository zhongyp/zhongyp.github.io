<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DO IT</title>
  
  <subtitle>钟宇鹏的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhongyp.me/"/>
  <updated>2018-11-06T04:27:10.463Z</updated>
  <id>http://zhongyp.me/</id>
  
  <author>
    <name>zhongyp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git常用命令总结</title>
    <link href="http://zhongyp.me/2018/10/23/utils/2018-10-23-git/"/>
    <id>http://zhongyp.me/2018/10/23/utils/2018-10-23-git/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-11-06T04:27:10.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>系统系统性的学习Git，请移步<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Git中文学习文档</a>，这篇文章只是分类记录一下git的常用命令。</p><p><img src="/media/15403035072735.png" alt="Git版本控制系统VCS基本操作流程图"></p><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><h3 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h3><p><code>git init</code> 将当前目录变为可管理的仓库<br><code>git clone</code> 克隆一个仓库到本地<br><code>git clone -b branch uri</code> 克隆指定branch分支到本地</p><h3 id="设置与配置"><a href="#设置与配置" class="headerlink" title="设置与配置"></a>设置与配置</h3><p><code>git config -global user.name/email &quot;参数&quot;</code> git是分布式版本控制，所以添加用户名和邮箱作为一个标识<br><code>ssh -keygen -t rsa -C &quot;email&quot;</code> 生成本地ssh key</p><h3 id="将文件提交到版本库"><a href="#将文件提交到版本库" class="headerlink" title="将文件提交到版本库"></a>将文件提交到版本库</h3><p><code>git add &quot;filename.*&quot;</code> 添加到暂存区<br><code>git commit -m &quot;filename.*&quot;</code> 提交到仓库<br><code>git commit --amend</code> 尝试重新提交,这个操作需要组合操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add file1 // 将file1 添加至缓存区</span><br><span class="line">git commmit -m &quot;update files&quot; //提交file1到本地仓库,提交完发现忘记file2没有提交，则你可以使用如下命令，提交file2并覆盖之前的提交信息。</span><br><span class="line">git add file2 // 添加file2</span><br><span class="line">git commit -amend // 尝试重新提交commit信息，并覆盖掉之前的提交信息</span><br></pre></td></tr></table></figure><p><code>git status</code> 查看文件状态<br><code>git diff filename.*</code> 查看修改了什么<br><code>git log</code> 看看每次修改的日志<br><code>git log --pretty=oneline</code> 日志显示为缩略版<br>注：<code>git reset</code> 不加<code>--hard</code>参数对当前工作区文件不会有任何修改，只是对缓存区进行操作。一旦加了参数，操作一定要慎重，否则你当前工作区中的修改将会全部被清除。<br><code>git reset HEAD file</code> 将file退回到当前版本（仅仅是对缓存区进行操作）<br><code>git reset --hard HEAD^</code> 退回到上一版本<br><code>git reset --hard HEAD^^</code> 退回到前二的版本<br><code>git reset --hard HEAD~100</code> 退回到前100版本<br><code>git reset --hard 版本号</code> 退回到一个特定的版本<br><code>git reflog</code> 查看版本号和上一个命令一块用效果比较好<br><code>git reset --mixed</code> 将当前文件撤出缓存区，保留文件修改<br><code>git rm --cached file</code> 删除缓存区file<br><code>git checkout -- file</code> 恢复工作区file（取消工作区文件的修改）</p><h3 id="git远程库"><a href="#git远程库" class="headerlink" title="git远程库"></a>git远程库</h3><p><code>git remote add origin 远程git地址</code> 连接<br><code>git push -u origin master</code> 把本地库分支master内容推送到远程库（-u 命令在第一次关联本地库和远程库时使用）<br><code>git clone url</code> 克隆远程(url)库</p><h3 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h3><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p><code>git branch</code> 查看分支<br><code>git checkout</code> 切换分支<br><code>git checkout -b</code>  创建并切换分支<br><code>git merge</code> 合并到当前分支<br><code>git branch -d</code>删除某分支<br><code>git merge --no-ff -m &quot;注释&quot;</code>分支合并分支禁用fast forward<br><code>git stash</code> 将当前分支的工作现场保留下来<br><code>git stash list</code> 查看工作现场<br><code>git stash apply</code> 恢复内容但是你需要git stash drop删除stash<br><code>git stash pop</code> 恢复的同时把stash内容也删除</p><p>注：如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p><code>git remote</code> 查看远程库的信息<br><code>git remote -v</code> 查看远程库的详细信息<br><code>git push origin master</code> master为本地的分支名推送分支<br><code>git checkout -b dev origin/dev</code> dev为分支名，做完开发后<br><code>git push origin dev</code> 推送到远程库<br><code>git pull</code> 抓取最新的提交,并尝试自动合并到本地当前所在的分支<br><code>git fetch</code> 抓取最新的提交，不会自动合并，必须手动。<br><code>git branch --set-upstream dev origin/dev</code> 指定本地dev分支（已经创建的）与远程origin/dev分支的连接<br><code>git branch -u origin/dev</code> 指定当前所在连接远程origin/dev分支的连接<br><code>git checkout --track origin/dev</code> 创建新的dev分支，制定远程连接origin/dev</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h2&gt;&lt;p&gt;系统系统性的学习Git，请移步&lt;a href=&quot;https://git-scm.com/book/zh/v2/%E8%B5%B7%E
      
    
    </summary>
    
    
      <category term="Utils" scheme="http://zhongyp.me/tags/Utils/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP</title>
    <link href="http://zhongyp.me/2018/10/03/spring/2018-09-28-AOP/"/>
    <id>http://zhongyp.me/2018/10/03/spring/2018-09-28-AOP/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2018-10-25T07:51:03.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>本篇文章翻译自<a href="https:www.tutorialspoint.com/spring/aop_with_spring.htm" target="_blank" rel="noopener">AOP with Spring</a>，主要介绍是关于AOP的概念。</p><h3 id="Brief-introduction-（简介）"><a href="#Brief-introduction-（简介）" class="headerlink" title="Brief introduction （简介）"></a>Brief introduction （简介）</h3><p>One of the key components of Spring Framework is the Aspect oriented programming (AOP) framework. Aspect-Oriented Programming entails breaking down program logic into distinct parts called so-called concerns. The functions that span multiple points of an application are called cross-cutting concerns and these cross-cutting concerns are conceptually separate from the application’s business logic. There are various common good examples of aspects like logging, auditing, declarative transactions, security, caching, etc.</p><p>The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Dependency Injection helps you decouple your application objects from each other and AOP helps you decouple cross-cutting concerns from the objects that they affect. AOP is like triggers in programming languages such as Perl, .NET, Java, and others.</p><p>Spring AOP module provides interceptors to intercept an application. For example, when a method is executed, you can add extra functionality before or after the method execution.</p><p>翻译：</p><p>AOP面向切面编程是Spring框架中的最关键的部分之一。面向切面编程需要拆分程序逻辑到被称为关注点的不同部分。一个在应用程序内跨越多个点的方法被称为横切点，这些横切点和应用的业务逻辑在概念上是分开的。目前已经有很多应用切面的例子，比如日志，审计，声明式事务，安全，缓存等。</p><p>在面向对象编程中，模块化的关键单元是类，但是在面向切面编程中，模块化单元是切面。依赖注入帮助你将应用中的对象相互解耦，AOP帮助你将横切点从它们作用的对象中解耦。AOP就像是Perl,.NET,Java或者其他编程语言中的触发器。</p><p>Spring AOP模块提供拦截应用的拦截器。举个🌰，你可以在你运行的方法之前或者之后添加额外的功能或者方法。</p><h3 id="AOP-Terminologies（AOP-术语）"><a href="#AOP-Terminologies（AOP-术语）" class="headerlink" title="AOP Terminologies（AOP 术语）"></a>AOP Terminologies（AOP 术语）</h3><h4 id="Aspect（切面）"><a href="#Aspect（切面）" class="headerlink" title="Aspect（切面）"></a>Aspect（切面）</h4><p>This is a module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement.</p><p>翻译： Aspect一个提供横切（cross-cutting）APIs的模块。举个例子，日志模块被称为AOP 日志切面。一个应用可以根据需求拥有任何数量的切面。</p><h4 id="Join-point（连接点）"><a href="#Join-point（连接点）" class="headerlink" title="Join point（连接点）"></a>Join point（连接点）</h4><p>This represents a point in your application where you can plug-in the AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.</p><p>翻译： 在应用中可以插入AOP切面的地方可被抽象为一个点。你也可以说，这是一个在应用中存在的地方，这个地方将被Spring AOP 框架执行一些动作。</p><p>Advice（通知）</p><p>This is the actual action to be taken either before or after the method execution. This is an actual piece of code that is invoked during the program execution by Spring AOP framework.</p><p>翻译：Advice是一个实际的动作，它将在方法执行前和方法执行后执行。这段代码通过Spring AOP框架在程序运行时被调用。</p><h4 id="Pointcut（切入点）"><a href="#Pointcut（切入点）" class="headerlink" title="Pointcut（切入点）"></a>Pointcut（切入点）</h4><p>This is a set of one or more join points where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples.</p><p>翻译：Pointcut是一个或者多个连接点的集合。正如我们将在AOP例子中看到的，你可以使用表达式或者正则表达式制定你的切入点。</p><h4 id="Introduction（引入）"><a href="#Introduction（引入）" class="headerlink" title="Introduction（引入）"></a>Introduction（引入）</h4><p>An introduction allows you to add new methods or attributes to the existing classes.</p><p>翻译：引入可以允许你添加新的方法或者属性到已经存在的类中。</p><h4 id="Target-object"><a href="#Target-object" class="headerlink" title="Target object"></a>Target object</h4><p>The object being advised by one or more aspects. This object will always be a proxied object, also referred to as the advised object.</p><p>翻译：这个对象被一个或者多个切面通知。这个对象一般是代理对象，作为被通知对象引用。</p><h4 id="Weaving（织入）"><a href="#Weaving（织入）" class="headerlink" title="Weaving（织入）"></a>Weaving（织入）</h4><p>Weaving is the process of linking aspects with other application types or objects to create an advised object. This can be done at compile time, load time, or at runtime.</p><p>翻译：织入是链接切面和其他应用类型或者对象来创建通知对象的过程。这个过程可以在编译、加载或者执行期间进行。</p><h3 id="Types-of-Advice"><a href="#Types-of-Advice" class="headerlink" title="Types of Advice"></a>Types of Advice</h3><p>Spring aspects can work with five kinds of advice mentioned as follows.<br>翻译：Spring 切面可以使用如下提到的五种advice</p><ul><li><p>before: Run advice before a method execution.</p></li><li><p>after: Run advice after a method execution.</p></li><li><p>after-returning: Run advice after the a method execution only if method completes successfully.</p></li><li><p>after-throwing: Run advice after the method execution only if method exits by throwing an exception.</p></li><li><p>around: Run advice before and after the advised method is invoked.</p></li></ul><h3 id="Custom-Aspects-Implementation-自定义接口实现"><a href="#Custom-Aspects-Implementation-自定义接口实现" class="headerlink" title="Custom Aspects Implementation(自定义接口实现)"></a>Custom Aspects Implementation(自定义接口实现)</h3><p>XML Schema based（基于XML模式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http:www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http:www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http:www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:tx=&quot;http:www.springframework.org/schema/tx&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http:www.springframework.org/schema/beans</span><br><span class="line">        http:www.springframework.org/schema/beans/spring-beans-4.2.xsd</span><br><span class="line">        http:www.springframework.org/schema/aop</span><br><span class="line">        http:www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 业务逻辑类--AOP连接点 --&gt;</span><br><span class="line">    &lt;bean id=&quot;aopTest&quot; class=&quot;com.zhongyp.zen.service.aop.AOPTestService&quot; /&gt;</span><br><span class="line">    &lt;!--AOP切面--&gt;</span><br><span class="line">    &lt;bean id=&quot;timeHandler&quot; class=&quot;com.zhongyp.zen.service.handler.TimeHandler&quot; /&gt;</span><br><span class="line">    &lt;!--AOP切面--&gt;</span><br><span class="line">    &lt;bean id=&quot;printHandler&quot; class=&quot;com.zhongyp.zen.service.handler.PrintHandler&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspectj-autoproxy /&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!-- pointcut切入点（AOP连接点的集合）--&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.zhongyp.zen.service.*.*.*(..))&quot; /&gt;</span><br><span class="line">        &lt;!-- 切面 --&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt;</span><br><span class="line">            &lt;!-- AOP Advice --&gt;</span><br><span class="line">            &lt;aop:before method=&quot;printStartTime&quot; pointcut-ref=&quot;pointcut&quot; /&gt;</span><br><span class="line">            &lt;aop:after method=&quot;printEndTime&quot; pointcut-ref=&quot;pointcut&quot; /&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;print&quot; ref=&quot;printHandler&quot;&gt;</span><br><span class="line">            &lt;aop:after-returning method=&quot;printString&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after-returning&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>@AspectJ based（基于切面注解）</p><p>注解方式可以将上述xml配置以注解的形式配置一下，我这里只是给出一个样例，其他的还需读者自己实践。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component(&quot;logHandler&quot;)</span><br><span class="line">public class LogHandler &#123;</span><br><span class="line">    @Pointcut(&quot;execution(* com.zhongyp.zen.service.*.*.*(..))&quot;)</span><br><span class="line">    private void hehe()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    @Before(&quot;hehe()&quot;)</span><br><span class="line">    public void doBefore()&#123;</span><br><span class="line">        System.out.println(&quot;为毛国庆要加班！！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-AOP&quot;&gt;&lt;a href=&quot;#Spring-AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring AOP&quot;&gt;&lt;/a&gt;Spring AOP&lt;/h2&gt;&lt;p&gt;本篇文章翻译自&lt;a href=&quot;https:www.tutorialspoi
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zhongyp.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="http://zhongyp.me/2018/04/02/mysql/2018-04-02-SQL/"/>
    <id>http://zhongyp.me/2018/04/02/mysql/2018-04-02-SQL/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-10-02T01:27:53.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用SQL技巧"><a href="#常用SQL技巧" class="headerlink" title="常用SQL技巧"></a>常用SQL技巧</h2><h3 id="1-1-检索包含最大和最小值的行"><a href="#1-1-检索包含最大和最小值的行" class="headerlink" title="1.1 检索包含最大和最小值的行"></a>1.1 检索包含最大和最小值的行</h3><p><code>select max(test_score),min(test_score) from student</code></p><h3 id="1-2-巧用rand-rand-n-提取随机行"><a href="#1-2-巧用rand-rand-n-提取随机行" class="headerlink" title="1.2 巧用rand()/rand(n)提取随机行"></a>1.2 巧用rand()/rand(n)提取随机行</h3><p><code>select * from table order by rand()</code></p><h3 id="1-3-group-by的with-rollup子句做统计"><a href="#1-3-group-by的with-rollup子句做统计" class="headerlink" title="1.3 group by的with rollup子句做统计"></a>1.3 group by的with rollup子句做统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table sales(</span><br><span class="line"></span><br><span class="line">year int not null,</span><br><span class="line">country varchar(20) not null,</span><br><span class="line">product varchar(32) not null,</span><br><span class="line">profit int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2001);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2002);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2003);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2004);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2005);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2006);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2007);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2008);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2009);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2010);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2011);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2012);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year;</span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year with rollup;</span><br></pre></td></tr></table></figure><p>当你使用ROLLUP时, 你不能同时使用ORDER BY子句进行结果排序。换言之， ROLLUP和ORDER BY 是互相排斥的LIMIT 用在ROLLUP 后面。</p><h3 id="1-4-bit-group-functions做统计"><a href="#1-4-bit-group-functions做统计" class="headerlink" title="1.4 bit group functions做统计"></a>1.4 bit group functions做统计</h3><p>bit_count:用来计算二进制数中包含1的个数</p><p>bit_or:就是对两个二进制数进行或运算</p><p>bit_and:就是对两个二进制数进行并运算</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="通过show-status和应用特点了解各种SQL的执行频率。"><a href="#通过show-status和应用特点了解各种SQL的执行频率。" class="headerlink" title="通过show status和应用特点了解各种SQL的执行频率。"></a>通过show status和应用特点了解各种SQL的执行频率。</h3><p>首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)</p><p>show status</p><p>常用的:</p><p>show status like ‘uptime’ ; </p><p>show stauts like ‘com_select’  show status like ‘com_insert’ …类推 update  delete</p><p>show session或global status like …. 如果你不写session或global,默认是session 会话，指取出当前窗口的执行，如果你想看所有session,从mysql 启动到现在，则应该 global。</p><p>show status like ‘connections’; </p><p>//显示慢查询次数</p><p>show status like ‘slow_queries’;</p><p>以下几个参数对Myisam 和Innodb 存储引擎都计数：</p><ol><li><p>Com_select 执行select 操作的次数，一次查询只累加1；</p></li><li><p>Com_insert 执行insert 操作的次数，对于批量插入的insert 操作，只累加一次；</p></li><li><p>Com_update 执行update 操作的次数；</p></li><li><p>Com_delete 执行delete 操作的次数；</p></li></ol><p>以下几个参数是针对Innodb 存储引擎计数的，累加的算法也略有不同：</p><ol><li><p>Innodb_rows_read select 查询返回的行数；</p></li><li><p>Innodb_rows_inserted 执行Insert 操作插入的行数；</p></li><li><p>Innodb_rows_updated 执行update 操作更新的行数；</p></li><li><p>Innodb_rows_deleted 执行delete 操作删除的行数；</p></li></ol><p>对于事务型的应用，通过Com_commit 和Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。</p><p>此外，以下几个参数便于我们了解数据库的基本情况：</p><ol><li><p>Connections 试图连接Mysql 服务器的次数</p></li><li><p>Uptime 服务器工作时间</p></li><li><p>Slow_queries 慢查询的次数</p></li></ol><h3 id="定位执行效率较低的SQL"><a href="#定位执行效率较低的SQL" class="headerlink" title="定位执行效率较低的SQL"></a>定位执行效率较低的SQL</h3><p>可以通过以下两种方式定位执行效率较低的SQL 语句：</p><ol><li><p>可以通过慢查询日志定位那些执行效率较低的sql 语句，用–log-slowqueries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过long_query_time 秒的SQL语句的日志文件。可以链接到管理维护中的相关章节。</p></li><li><p>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist 命令查看当前MySQL 在进行的线程，包括线程的状态，是否锁表等等，可以实时的查看SQL 执行情况，同时对一些锁表操作进行优化。</p></li></ol><h3 id="通过explain分析低效SQL的执行计划"><a href="#通过explain分析低效SQL的执行计划" class="headerlink" title="通过explain分析低效SQL的执行计划"></a>通过explain分析低效SQL的执行计划</h3><h4 id="select-type：-select-类型"><a href="#select-type：-select-类型" class="headerlink" title="select_type： select 类型"></a>select_type： select 类型</h4><p>A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个</p><p>B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</p><p>C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union</p><p>D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响</p><p>E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</p><p>F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</p><p>G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</p><p>H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</p><h4 id="table：-输出结果集的表"><a href="#table：-输出结果集的表" class="headerlink" title="table： 输出结果集的表"></a>table： 输出结果集的表</h4><p>显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的<derived n="">就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的<union m,n="">，与<derived n="">类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</derived></union></derived></p><h4 id="type：-表示表的连接类型"><a href="#type：-表示表的连接类型" class="headerlink" title="type： 表示表的连接类型"></a>type： 表示表的连接类型</h4><p>当表中仅有一行是type的值为system是最佳的连接类型；</p><p>当select操作中使用索引进行表连接时type的值为ref；</p><p>当select的表连接没有使用索引时，经常会看到type的值为ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。</p><p>依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</p><p>A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p><p>B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</p><p>C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</p><p>D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</p><p>E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p><p>F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</p><p>G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</p><p>H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p><p>I：range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</p><p>J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</p><p>K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p><p>L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p><h4 id="possible-keys：-表示查询时-可以使用的索引列"><a href="#possible-keys：-表示查询时-可以使用的索引列" class="headerlink" title="possible_keys： 表示查询时,可以使用的索引列."></a>possible_keys： 表示查询时,可以使用的索引列.</h4><h4 id="key：-表示使用的索引"><a href="#key：-表示使用的索引" class="headerlink" title="key： 表示使用的索引"></a>key： 表示使用的索引</h4><h4 id="key-len：-索引长度"><a href="#key-len：-索引长度" class="headerlink" title="key_len： 索引长度"></a>key_len： 索引长度</h4><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p><h4 id="rows：-扫描范围"><a href="#rows：-扫描范围" class="headerlink" title="rows： 扫描范围"></a>rows： 扫描范围</h4><h4 id="Extra：-执行情况的说明和描述"><a href="#Extra：-执行情况的说明和描述" class="headerlink" title="Extra： 执行情况的说明和描述"></a>Extra： 执行情况的说明和描述</h4><p>A：distinct：在select部分使用了distinc关键字</p><p>B：no tables used：不带from字句的查询或者From dual查询</p><p>C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</p><p>D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</p><p>E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p><p>F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。</p><p>G：using sort_union，using_union，using intersect，using sort_intersection：</p><p>using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集</p><p>using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集</p><p>using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。</p><p>H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</p><p>I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition</p><p>J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个</p><p>K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p><p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息</p><h3 id="确定问题并采取响应的优化措施"><a href="#确定问题并采取响应的优化措施" class="headerlink" title="确定问题并采取响应的优化措施"></a>确定问题并采取响应的优化措施</h3><h3 id="索引的存储分类"><a href="#索引的存储分类" class="headerlink" title="索引的存储分类"></a>索引的存储分类</h3><p>myisam 表的数据文件和索引文件是自动分开的；innodb 的数据和索引是存储在<br>同一个表空间里面，但可以有多个文件组成。<br>创建索引语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</span><br><span class="line">[USING index_type]</span><br><span class="line">ON tbl_name (index_col_name,...)</span><br><span class="line">index_col_name:</span><br><span class="line">col_name [(length)] [ASC | DESC]</span><br></pre></td></tr></table></figure><p>索引的存储类型目前只有两种（btree 和hash），具体和表的模式相关：</p><p>myisam btree</p><p>innodb btree</p><p>memory/heap hash，btree</p><p>mysql 目前不支持函数索引，只能对列的前一部分（length）进行索引，例：</p><p><code>create index ind_test on table1(name(5))</code></p><p>对于char 和varchar 列，使用前缀索引将大大节省空间。</p><h3 id="MySQL如何使用索引"><a href="#MySQL如何使用索引" class="headerlink" title="MySQL如何使用索引"></a>MySQL如何使用索引</h3><p>索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高SELECT 操作性能的最佳途径。</p><p>查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。</p><p>下列情况下，Mysql 不会使用已有的索引：</p><p>1.如果mysql 估计使用索引比全表扫描更慢，则不使用索引。例如：如果key_part1均匀分布在1 和100 之间，下列查询中使用索引就不是很好：</p><p><code>SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90</code></p><p>2.如果使用heap 表并且where 条件中不用＝索引列，其他&gt; 、&lt;、&gt;=、&lt;=均不使用索引；</p><p>3.如果不是索引列的第一部分；</p><p>4.如果like 是以％开始；</p><p>5.对where 后边条件为字符串的一定要加引号，字符串如果为数字mysql 会自动转为字符串，但是不使用索引。</p><h3 id="查看索引的使用情况"><a href="#查看索引的使用情况" class="headerlink" title="查看索引的使用情况"></a>查看索引的使用情况</h3><p>如果索引正在工作，Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。</p><p>Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明表索引不正确或写入的查询没有利用索引。</p><p><code>show status like &#39;Handler_read%&#39;;</code></p><h3 id="定期分析表"><a href="#定期分析表" class="headerlink" title="定期分析表"></a>定期分析表</h3><h4 id="ANALYZE-TABLE"><a href="#ANALYZE-TABLE" class="headerlink" title="ANALYZE TABLE"></a>ANALYZE TABLE</h4><p>语法：</p><p><code>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM, BDB 和InnoDB 表有作用。对于MyISAM 表，本语句与使用myisamchk -a 相当。</p><h4 id="CHECK-TABLE"><a href="#CHECK-TABLE" class="headerlink" title="CHECK TABLE"></a>CHECK TABLE</h4><p>语法：</p><p><code>CHECK TABLE tbl_name [, tbl_name] ... [option] ...</code></p><p><code>option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}</code></p><p>检查一个或多个表是否有错误。CHECK TABLE 对MyISAM 和InnoDB 表有作用。对于MyISAM 表，关键字统计数据被更新。</p><p>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。</p><h4 id="CHECKSUM-TABLE"><a href="#CHECKSUM-TABLE" class="headerlink" title="CHECKSUM TABLE"></a>CHECKSUM TABLE</h4><p>语法：</p><p><code>CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]</code></p><p>报告一个表校验和。</p><h3 id="使用optimize-table"><a href="#使用optimize-table" class="headerlink" title="使用optimize table"></a>使用optimize table</h3><h4 id="OPTIMIZE-TABLE"><a href="#OPTIMIZE-TABLE" class="headerlink" title="OPTIMIZE TABLE"></a>OPTIMIZE TABLE</h4><p>语法：</p><p><code>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>如果已经删除了表的一大部分，或者如果您已经对含有可变长度行的表（含有VARCHAR, BLOB 或TEXT 列的表）进行了很多更改，则应使用OPTIMIZE TABLE。被删除的记录被保持在链接清单中，后续的INSERT 操作会重新使用旧的记录位置。您可以使用OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。</p><p>OPTIMIZE TABLE 只对MyISAM, BDB 和InnoDB 表起作用。</p><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><h4 id="对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。"><a href="#对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。" class="headerlink" title="对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。"></a>对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tblname DISABLE KEYS;</span><br><span class="line">loading the data</span><br><span class="line">ALTER TABLE tblname ENABLE KEYS;</span><br></pre></td></tr></table></figure><p>这两个命令用来打开或者关闭Myisam 表非唯一索引的更新。在导入大量的数据到一个非空的Myisam 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的Myisam 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。</p><h4 id="而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率："><a href="#而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率：" class="headerlink" title="而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率："></a>而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率：</h4><p>a. 因为Innodb 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果Innodb 表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。</p><p>b. 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SETUNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p><p>c. 如果应用使用自动提交的方式，建议在导入前执行SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p><h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><p>如果你同时从同一客户插入很多行，使用多个值表的INSERT 语句。这比使用分开INSERT 语句快(在一些情况中几倍)。</p><p><code>Insert into test values(1,2),(1,3),(1,4)…</code></p><p>如果你从不同客户插入很多行，能通过使用INSERT DELAYED 语句得到更高的速度。Delayed 的含义是让insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘；这比每条语句分别插入要快的多；LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完后才进行插入。</p><p><code>Insert delayed into test values(1,2),(1,3),(1,4)…</code></p><p><code>Insert low_priority into test values(1,2),(1,3),(1,4)…</code></p><p>将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）。</p><p>如果进行批量插入，可以增加bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对myisam 表使用。</p><p>在my.cnf中添加如下语句，将insert语句的长度设为最大。</p><p><code>Max_allowed_packet=1M</code></p><p><code>Net_buffer_length=2k</code></p><p>当从一个文本文件装载一个表时，使用LOAD DATA INFILE。这通常比使用很多INSERT 语句快20 倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//数据</span><br><span class="line"></span><br><span class="line">1669,Jim,Smith</span><br><span class="line">337,Mary,Jones</span><br><span class="line">2005,Linda,Black</span><br><span class="line"></span><br><span class="line">示例语句：</span><br><span class="line"></span><br><span class="line">load data infile &quot;/data/mysql/e.sql&quot; into table tablename fields terminated by &apos;,&apos;;</span><br></pre></td></tr></table></figure><p>根据应用情况使用replace 语句代替insert。<code>replace low_priority into ta values(1,2);</code><br>replace具备替换拥有唯一索引或者主键索引重复数据的能力，也就是如果使用replaceinto插入的数据的唯一索引或者主键索引与之前的数据有重复的情况，将会删除原先的数据，然后再进行添加。</p><p>根据应用情况使用ignore 关键字忽略重复记录。<br><code>insert ignore into</code><br>当插入数据时，如出现错误时，如重复数据，将不返回错误，只以警告形式返回。所以使用ignore请确保语句本身没有问题，否则也会被忽略掉。例如：<code>INSERT IGNORE INTO books (name) VALUES (&#39;MySQL Manual&#39;)</code></p><h3 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h3><p>默认情况下，MySQL 排序所有GROUP BY col1，col2，….。查询的方法如同在查询中指定ORDER BY col1，col2，…。如果显式包括一个包含相同的列的ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。</p><p>如果查询包括GROUP BY 但你想要避免排序结果的消耗，你可以指定ORDER BY NULL禁止排序。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO foo</span><br><span class="line">SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;</span><br></pre></td></tr></table></figure><h3 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h3><p>在某些情况中，MySQL 可以使用一个索引来满足ORDER BY 子句，而不需要额外的排序。where 条件和order by 使用相同的索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或者都是降序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如：下列sql 可以使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1,key_part2,... ;</span><br><span class="line">SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2</span><br><span class="line">DESC;</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</span><br><span class="line">但是以下情况不使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;</span><br><span class="line">--order by 的字段混合ASC 和DESC</span><br><span class="line">SELECT * FROM t1 WHERE key2=constant ORDER BY key1;</span><br><span class="line">--用于查询行的关键字与ORDER BY 中所使用的不相同</span><br><span class="line">SELECT * FROM t1 ORDER BY key1, key2;</span><br><span class="line">--对不同的关键字使用ORDER BY。</span><br></pre></td></tr></table></figure><h3 id="优化join语句"><a href="#优化join语句" class="headerlink" title="优化join语句"></a>优化join语句</h3><p>Mysql4.1 开始支持SQL 的子查询。这个技术可以使用SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。</p><p>假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><p><code>SELECT * FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerIDFROM salesinfo)</code></p><p>如果使用连接(JOIN).. 来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID 建有索引的话，性能将会更好，查询如下：</p><p><code>SELECT * FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL</code></p><p>连接(JOIN).. 之所以更有效率一些，是因为MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h3 id="mysql如何优化or条件"><a href="#mysql如何优化or条件" class="headerlink" title="mysql如何优化or条件"></a>mysql如何优化or条件</h3><p>对于or 子句，如果要利用索引，则or 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。</p><h3 id="查询优先还是更新优先"><a href="#查询优先还是更新优先" class="headerlink" title="查询优先还是更新优先"></a>查询优先还是更新优先</h3><p>MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。</p><p>我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。</p><p>下面我们提到的改变调度策略的方法主要是针对Myisam 存储引擎的，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。</p><p>MySQL 的默认的调度策略可用总结如下：</p><ol><li><p>写入操作优先于读取操作。</p></li><li><p>对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。</p></li><li><p>对某张数据表的多个读取操作可以同时地进行。</p></li></ol><p>MySQL 提供了几个语句调节符，允许你修改它的调度策略：</p><ol><li><p>LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE。</p></li><li><p>HIGH_PRIORITY关键字应用于SELECT和INSERT语句。</p></li><li><p>DELAYED关键字应用于INSERT和REPLACE语句。</p></li></ol><p>如果写入操作是一个LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在LOW_PRIORITY 写入操作永远被阻塞的情况。</p><p>SELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的SELECT 在正常的SELECT 语句之前执行，因为这些语句会被写入操作阻塞。</p><p>如果你希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么请使用–low-priority-updates 选项来启动服务器。通过使用INSERT HIGH_PRIORITY 来把INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT 语句的影响。</p><h3 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h3><p><code>SELECT SQL_BUFFER_RESULTS ...</code></p><p>将强制MySQL 生成一个临时结果集。只要所有临时结果集生成后，所有表上的锁定均被释放。这能在遇到表锁定问题时或要花很长时间将结果传给客户端时有所帮助。</p><p>当处理一个会让客户端耗费点时间才能处理的大结果集时， 可以考虑使用SQL_BUFFER_RESULT 提示字。这样可以告诉MySQL 将结果集保存在一个临时表中，这样可以尽早的释放各种锁。</p><h4 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h4><p>在你查询语句中表名的后面，添加USE INDEX 来提供你希望MySQ 去参考的索引列表，就可以让MySQL 不再考虑其他可用的索引。</p><p><code>Eg:SELECT * FROM mytable USE INDEX (mod_time, name) ...</code></p><h4 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h4><p>如果你只是单纯的想让MySQL 忽略一个或者多个索引，可以使用IGNORE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytale IGNORE INDEX (priority) ...</code></p><h4 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h4><p>为强制MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytable FORCE INDEX (mod_time) ...</code></p><h3 id="其他优化措施"><a href="#其他优化措施" class="headerlink" title="其他优化措施"></a>其他优化措施</h3><ol><li><p>使用持久的连接数据库以避免连接开销。</p></li><li><p>经常检查所有查询确实使用了必要的索引。</p></li><li><p>避免在频繁更新的表上执行复杂的SELECT 查询，以避免与锁定表有关的由于读、写冲突发生的问题。</p></li><li><p>对于没有删除的行操作的MyISAM 表，插入操作和查询操作可以并行进行，因为没有删除操作的表查询期间不会阻塞插入操作．对于确实需要执行删除操作的表，尽量在空闲时间进行批量删除操作，避免阻塞其他操作。</p></li><li><p>充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少MySQL 需要做的语法分析从而提高插入速度。</p></li><li><p>对经常访问的可以重构的数据使用内存表，可以显著提高访问的效率。</p></li><li><p>通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份期间对应用的影响，可以在复制服务器上执行备份操作。</p></li><li><p>表的字段尽量不使用自增长变量，在高并发情况下该字段的自增可能对效率有比较大的影响，推荐通过应用来实现字段的自增长。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用SQL技巧&quot;&gt;&lt;a href=&quot;#常用SQL技巧&quot; class=&quot;headerlink&quot; title=&quot;常用SQL技巧&quot;&gt;&lt;/a&gt;常用SQL技巧&lt;/h2&gt;&lt;h3 id=&quot;1-1-检索包含最大和最小值的行&quot;&gt;&lt;a href=&quot;#1-1-检索包含最大和最小值的行&quot;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://zhongyp.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>高性能MySQL -- 摘自《高性能MySQL第三版》</title>
    <link href="http://zhongyp.me/2018/04/02/mysql/2018-04-02-MySQL/"/>
    <id>http://zhongyp.me/2018/04/02/mysql/2018-04-02-MySQL/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-10-02T01:27:53.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引擎篇"><a href="#引擎篇" class="headerlink" title="引擎篇"></a>引擎篇</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li><p>Myisam是Mysql的默认存储引擎，当create创建新表时，未指定新表的存储引擎时，默认使用Myisam。</p></li><li><p>每个MyISAM在磁盘上存储成三个文件。文件名都和表名相同，扩展名分别是.frm（存储表定义）、.MYD (MYData，存储数据)、.MYI (MYIndex，存储索引)。数据文件和索引文件可以放置在不同的目录，平均分布io，获得更快的速度。</p></li><li><p>它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一 .</p></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li><p>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比Myisam的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</p></li><li><p>用于事务处理应用程序，具有众多特性，包括ACID 事务支持。</p></li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>将所有数据保存在RAM 中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。</p><table><br><tr></tr><br><tr></tr><br><tr><td>特点</td><td>Myisam</td><td> BDB</td><td> Memory</td> <td>InnoDB</td><td> Archive</td></tr><br><tr><td>存储限制</td><td>没有</td><td>没有</td><td>有</td><td>64TB </td><td>没有</td></tr><br><tr><td>事务安全</td><td></td><td>支持</td><td></td><td>支持</td><td></td></tr><br><tr><td>锁机制</td><td>表锁</td><td>页锁</td><td>表锁</td><td>行锁</td><td>行锁</td></tr><br><tr><td>B 树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><br><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><br><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><br><tr><td>集群索引</td><td></td><td></td><td></td><td>支持</td><td></td></tr><br><tr><td>数据缓存</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><br><tr><td>索引缓存</td><td>支持</td><td></td><td>支持</td><td>支持</td><td></td></tr><br><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td>支持</td></tr><br><tr><td>空间使用</td><td>低</td><td>低</td><td>N/A</td><td> 高</td><td>非常低</td></tr><br><tr><td>内存使用</td><td>低</td><td>低</td><td>中等</td><td>高</td><td>低</td></tr><br><tr><td>批量插入的速度</td><td>高</td><td>高</td><td>高</td><td>低</td><td>非常高</td></tr><br><tr><td>支持外键</td><td></td><td></td><td></td><td>支持</td><td></td></tr><br><tr></tr><br></table><h2 id="Schema与数据类型优化"><a href="#Schema与数据类型优化" class="headerlink" title="Schema与数据类型优化"></a>Schema与数据类型优化</h2><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li><p>一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p></li><li><p>简单的数据类型通常需要更少的CPU周期。</p></li><li><p>尽量避免使用NULL，原因是由于NULL可能需要单独的位（bit）去存储或者NULL使得索引、索引统计、值比较都更为复杂。</p></li></ul><h3 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h3><ul><li><p>范式化的更新操作会比反范式化的快。</p></li><li><p>当数据较好范式化的时候，只有很少或者没有重复数据，所以只需要修改更少的数据。</p></li><li><p>范式化的表通常更小。</p></li><li><p>很少有冗余数据意味着检索列表数据更少需要distinct或者group by语句。</p></li></ul><h3 id="反范式的优点和缺点"><a href="#反范式的优点和缺点" class="headerlink" title="反范式的优点和缺点"></a>反范式的优点和缺点</h3><ul><li>反范式的schema所有数据都在一张表中，可以很好的避免关联，还可以避免随机IO(和存储引擎有关)。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>尽可能避免过度设计，例如会导致复杂查询的schema设计，或者有很多列的表的设计。</p></li><li><p>使用小而简单的合适数据类型，除非真实数据模型中确切的需要，否则应尽可能的避免NULL值。</p></li><li><p>尽量使用相同的数据类型存储相似或者相关的值，尤其是在关联条件中要使用的列。</p></li><li><p>避免使用MySQL已经遗弃的特性，例如浮点数的精度，或者整数的显示宽度。</p></li><li><p>小心使用ENUM和SET。避免使用BIT。</p></li></ul><h2 id="高性能索引创建"><a href="#高性能索引创建" class="headerlink" title="高性能索引创建"></a>高性能索引创建</h2><p>系统从磁盘读取数据到内存是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页（page）的概念，页是其磁盘管理的最小单位。</p><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><h4 id="B-Tree索引（平衡多路查找树）"><a href="#B-Tree索引（平衡多路查找树）" class="headerlink" title="B-Tree索引（平衡多路查找树）"></a>B-Tree索引（平衡多路查找树）</h4><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree.png?raw=true" alt="b-tree"></p><p>B-Tree 通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。B-Tree索引能够加快访问数据的速度，存储引擎不需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放指向子节点的指针，存储引擎根据这些指针向下层查找。指针中定义了子节点页中值的<br>上限和下限。最终找到该值或者不存在。</p><p>叶子节点比较特殊，他们指向的是被索引的数据，而不是其他的节点页。</p><p>树的深度和表的大小直接相关。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree1.png?raw=true" alt="b-tree"></p><p>可以使用B-Tree索引的查询类型：</p><p>全值匹配：全值匹配指的是和索引的所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen 1960-01-01。</p><p>匹配最左前缀：可用于查找索引的第一列。</p><p>匹配列前缀：也可以匹配某一列的值的开头部分。</p><p>匹配范围值：遵循最左前缀的前提下，范围查找。</p><p>精确匹配某一列并范围匹配另外一列：可用于查找所有姓为Allen,并且名字是字母K开头的人。</p><p>只访问索引的查询：B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。</p><p>B-Tree使用限制：</p><p>必须遵循最左原则。</p><p>如果查询中某个列的范围查询，则其右边所有列都无法使用索引优化查找。</p><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>在B-tree的基础上，为叶子节点增加链表指针，而且所有的关键字都在叶子节点中出现，且数据只存储在叶子节点中。非叶子节点的关键字仅作为叶子节点的索引。</p><h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h4><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><p>在MySQL中，只有Memory引擎显式支持哈希索引且支持非唯一哈希索引的。</p><p>哈希索引每个槽点编号是有序的。</p><p>哈希索引使用限制：</p><p>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</p><p>哈希索引并不是按照索引值顺序存储的，所以无法用于排序。</p><p>哈希索引也不支持部分索引列的匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</p><p>哈希索引支持等值比较查询，包括=、in()、&lt;=&gt;也不支持任何范围查询，例如WHERE price &gt; 100。</p><p>访问哈希索引的数据非常快，除非有很多哈希冲突。</p><p>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。</p><p>除了Memory引擎外，NDB集群引擎也支持唯一哈希索引，且在NDB集群引擎中作用非常特殊。</p><p>InnoDB引擎有一个特殊的功能叫“自适应哈希索引”。当InnoDB引擎注意到某些索引值被使用的非常频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型索引，它查找的是文本中的关键词，而不是直接比较索引中的值。适用于MATCH AGINST操作，而不是普通的WHERE条件操作。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li><p>索引大大减少了服务器需要扫描的数据量。</p></li><li><p>索引可以帮助服务器避免排序和临时表。</p></li><li><p>索引可以将随机IO变为顺序IO。</p></li></ul><h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。我们应该简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。</p><p>例如：<code>select actor_id from sakila.actor where actor_id + 1 = 4</code></p><h4 id="前缀索引和索引的选择性"><a href="#前缀索引和索引的选择性" class="headerlink" title="前缀索引和索引的选择性"></a>前缀索引和索引的选择性</h4><p>问题： 有时候需要索引很长的字符串，这会让索引变的大且慢。</p><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但会降低索引的选择性。</p><p>一般情况下对于Blob、text或者很长的varchar()类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p><p>前缀的基数应该接近于完整列的基数。</p><h4 id="多索引列"><a href="#多索引列" class="headerlink" title="多索引列"></a>多索引列</h4><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。</p><h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>多列索引的列顺序经典法则：当不需要考虑排序和分组时，将选择性最高的列放到索引最前列。大都情况下是适用的，也需要根据业务去考虑一些特殊情况。</p><p>需要考虑哪些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单纯的索引类型，而是一种数据存储方式。具体细节依赖其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p><p>当表有聚簇索引时，它的数据行实际存放在索引的叶子页中。术语“聚簇”标识数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>由于是存储引擎自己实现聚簇索引，因此不是每个引擎都支持聚簇索引。</p><p>叶子页包含了行的全部数据，但是节点页只包含了索引列。InnoDB将通过主键聚集数据，这也就是说图中的“被索引列”就是主键列。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/clusterindex.png?raw=true" alt="cluster-index"></p><p>注： 如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。</p><p>聚簇索引的优点：</p><ul><li><p>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘IO。</p></li><li><p>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引查找的要快。</p></li><li><p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p></li></ul><p>聚簇索引缺点：</p><ul><li><p>聚簇索引最大限度的提高了IO密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有什么优势了。</p></li><li><p>插入速度严重依赖插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用optimize table命令重新组织一下表。</p></li><li><p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被动更新的行移动到新的位置。</p></li><li><p>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</p></li><li><p>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</p></li><li><p>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</p></li><li><p>二级索引访问需要两次索引查找，而不是一次。二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找对应的行。对于InnoDB，自适应性哈希索引能够减少这样重复的工作。</p></li></ul><h4 id="InnoDB和MyISAM的数据分布对比"><a href="#InnoDB和MyISAM的数据分布对比" class="headerlink" title="InnoDB和MyISAM的数据分布对比"></a>InnoDB和MyISAM的数据分布对比</h4><p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table    layout_test&#123;</span><br><span class="line">col1 int not null,</span><br><span class="line">col2 int not null,</span><br><span class="line">primary key(col1),</span><br><span class="line">key(col2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设该表主键取值1-10000，按照随机顺序插入并使用OPTIMIZE TABLE命令做了优化。换句话说，数据在磁盘上的存储已经做到最优，但行的顺序是随机的。</p><p>列col2的值是从1-100的随机值，所以有很多重复的值。</p><p>MyISAM数据（非聚簇）分布：</p><p>MyISAM按照数据插入顺序存储在磁盘上。</p><p>在行的旁边显示行号，从0开始递增。因为行是定长的，所以MyISAM可以从表的开头跳过所需的字节找到需要的行。</p><p>这种分布方式容易创建索引。</p><p>数据分布：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/myisam.png?raw=true" alt="数据分布"></p><p>主键分布：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/myisamcol.png?raw=true" alt="表的主键"></p><p>col2列索引分布：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/myisamkey.png?raw=true" alt="col2列索引分布"></p><p>InnoDB数据（聚簇）分布：</p><p>InnoDB支持聚簇索引，所以使用非常不同的方式存储同样的数据。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/innodbkey.png?raw=true" alt="主键分布"></p><p>该图显示了整个表，而不是只有索引。在InnoDB中，聚簇索引就是表，所以不像MyISAM那样需要独立的存储。</p><p>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。</p><p>InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。利：减少了当出现行移动或者数据页分裂时二级索引的维护工作。弊：使用主键值当做指针会让二级索引占用更多的空间。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/innodb.png?raw=true" alt="索引分布"></p><p>上图显示了示例表col2的索引，每一个叶子节点都包含了索引列（col2）,紧接着是主键值（col1）。</p><p>该图展示了B-Tree的叶子节点结构，InnoDB的非叶子节点包含了索引列和一个指向下级节点的指针（下一级节点可以是非叶子节点，也可以是叶子节点）。这对聚簇索引和二级索引都适用。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/innodba.png?raw=true" alt="聚簇索引和非聚簇索引"></p><h4 id="InnoDB表中按主键顺序插入行"><a href="#InnoDB表中按主键顺序插入行" class="headerlink" title="InnoDB表中按主键顺序插入行"></a>InnoDB表中按主键顺序插入行</h4><p>如果正在使用InnoDB表并且并没有什么数据需要聚集，可以定义一个代理键作为主键，最简单的方法是使用AUTO_INCREMENT自增列。这样可以保证数据按顺序写入，对于根据主键做关联操作的性能也会更好。</p><p>最好避免随机（不连续且值分布范围非常大）聚簇索引，特别对IO密集型应用。从性能考虑，使用UUID作为聚簇索引，使得聚簇索引的插入变的完全随机，使得数据没有任何聚集特性。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/clustersort.png?raw=true" alt="聚簇索引插入顺序的索引值"></p><p>如上图所示，因为主键的值是顺序的，所以InnoDB把每一条纪律都存储在上一条纪律后面。当达到页的最大填充因子时，下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。</p><p>聚簇索引顺序插入缺点：</p><ul><li><p>对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用（主键引起间隙锁竞争）。</p></li><li><p>另一个热点是AUTO_INCREMENT锁机制，如果遇到这个问题，可以重新设计表或者应用，或者修改innodb_autoinc_lock_mode配置。</p></li></ul><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/clusternosort.png?raw=true" alt="非聚簇索引插入顺序的索引值"></p><p>非聚簇索引因为新行的主键值不一定比之前插入的大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找需要的位置—通常是已有数据的中间位置—并且分配空间。还会增加很多额外的工作，并导致数据分布不够优化。</p><p>非聚簇索引插入缺点：</p><ul><li><p>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这样会导致大量的随机IO。</p></li><li><p>因为写入是乱序的，InnoDB不得不频繁的做页分裂操作，以便新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</p></li><li><p>由于频繁的页分裂，页会变的稀疏并被不规则的填充，所以最终会有数据碎片。</p></li></ul><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>通常大家会根据查询的where条件来创建索引，不过这只是优化索引的一个方面。如果一个索引包含所有需要查询字段的值我们就称之为“覆盖索引”。</p><p>覆盖索引的优点：</p><ul><li><p>索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大的减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对IO密集型应用也有帮助，因为索引比数据更小，更容易全部放入内存中（MyISAM压缩索引以变得更小）。</p></li><li><p>因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多。（MyISAM和Percona XtraDB，甚至可以通过OPTIMIZE命令使得索引完全顺序排列，这样简单的范围查询能使用完全顺序的索引访问）</p></li><li><p>一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。</p></li><li><p>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</p></li></ul><p>不是所有的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree做索引覆盖。</p><p>当发起一个索引覆盖查询时，在Explain的Extra列可以看到“Using index”的信息（Extra列的Using index和type列的inxex搞混淆，其实两者我完全不同，type列标识查询访问数据方式，也称之为join type）。</p><p>索引覆盖查询可能还有很多陷阱可能导致无法实现优化。MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了WHERE条件中的字段，但不是整个查询涉及的字段。如果条件为假，MySQL5.5和更早版本也总是会回表获取数据行，尽管并不需要这一行且最终也会被过滤掉。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain select * from products where actor=&apos;scan carrey&apos; and title like &apos;%APOLLO%&apos; --这条语句使用的是Extra:using where</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有列，而没有任何索引覆盖了所有的列。MySQL存在另一个途径：WHERE条件中的列是有索引可以覆盖的，因此MySQL可以使用该索引找到对应的actor并检查title是否匹配，过滤之后再读取需要的数据行。</p></li><li><p>MySQL不能再索引中执行LIKE操作。这是底层存储引擎API的限制，MySQL5.5和更早版本中只允许在索引中做简单比较操作。MySQL能在索引中做最左前缀匹配的LIKE查询，存储引擎就无法比较匹配。MySQL服务器只能提取数据行的值而不是索引值来做比较。</p></li></ul><p>解决方案：</p><p>先将索引扩展至3个（artist，title，prod_id）,然后按照如下方式重写查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain select * from products join(select prob_id from products where actor=&apos;sean carrey&apos; and title like &apos;%APOLLO%&apos;) as t1 on(t1.prod_id=products.prod_id)</span><br></pre></td></tr></table></figure><p>Extra: using where;using index</p><p>我们把这种方式叫做延迟关联，因为延迟了对列的访问。在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id,然后根据这些prop_id值在外层查询匹配获取需要的所有列值。虽然无法使用索引覆盖整个查询，但总算比完全无法利用索引覆盖的好。</p><p>这样的优化效果取决于WHERE条件匹配返回的行数。举个例子：</p><p>假设products有100w行数据，我们使用上面两个SQL在不同的三个场景中测试。</p><ol><li><p>sean carrey 出演了3w部作品，2w部标题中包含Apollo。</p></li><li><p>sean carrey 出演了3w部作品，40部标题中包含Apollo。</p></li><li><p>sean carrey 出演了50部作品，10部标题中包含Apollo。</p></li></ol><p>测试结果：</p><table><br><br><tr><td>序号</td><td>原查询</td><td>优化后</td></tr><br><tr><td>1</td><td>5</td><td>5</td></tr><br><tr><td>2</td><td>7</td><td>35</td></tr><br><tr><td>3</td><td>2400</td><td>2000</td></tr><br><br></table><p>结果分析：</p><p>实例1中，查询返回了一个很大的结果集，因此看不到优化结果。大部分时间都花在读取和发送数据上了。</p><p>实例2中，经过索引过滤，尤其第二个条件过滤后只返回很少的结果集，优化效果很明显，优化查询的效率主要得益于只需要读取40行完整的数据行。</p><p>实例3中，显示了子查询效率反而下降的情况。因为索引过滤符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。</p><h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>MySQL有两种方式生成有序的结果：通过排序操作。按索引顺序扫描。</p><p>如果explain出来的type列的值为index，则说明MySQL使用索引扫描来做排序。</p><p>扫描索引本身是很快的，因为只需要从一条索引纪律移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不没扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机IO，因此按索引顺序读取数据的速度通常要比顺序的全表扫描慢，尤其是在IO密集型的工作负载时。</p><p>MySQL可以使用同一个索引既满足排序，又满足查找行。</p><p>只有当索引的列顺序和 order by子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一个表时，才能使用索引做排序。order by子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则MySQL都需执行排序操作，而无法利用索引排序。</p><p>有一种情况下 order by子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以弥补索引的不足。</p><p>例如：表rental在列(rental_date,inventory_id,customer_id)上有名为rental_date的索引。</p><p>建表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table rental(</span><br><span class="line">    primary key(rental_id),</span><br><span class="line">    unique key rental_date(rental_date,inventory_id,customer_id),</span><br><span class="line">    key idx_fk_inventory_id(inventory_id),</span><br><span class="line">    key idx_fk_customer(customer_id),</span><br><span class="line">    key idx_fk_staff_id(staff_id),</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查询排序：</p><p><code>explain select rental_id,staff_id from sakila.rental where rental_date=&#39;2005-05-25&#39; order by inventory_id, customer_id</code></p><p>即时order by 子句不满足索引的最左前缀的要求，也可以用于查询排序，这是因为索引的第一列被指定为一个常数。</p><p>下面这个查询可以利用索引排序，是因为查询为索引的第一列提供了常量条件，而使用第二列进行排序，将两列组合在一起，就形成了索引的最左前缀,总的来说只要查询满足最左前缀即可排序：</p><p><code>where rental_date=&#39;2005-05-05&#39; order by inventory_id desc</code></p><p>下面是一些不能使用索引做排序的查询：</p><ul><li><p>这个查询使用了两种不同的排序方向，但索引列都是正序排序的：</p><p><code>where rental_date =&#39;2005-05-25&#39; order by inventory_id desc,customer_id asc</code></p></li></ul><ul><li><p>这个查询的order by 子句中引用了一个不在索引中的列：</p><p><code>where rental_date =&#39;2005-05-25&#39; order by inventory_id,staff_id</code></p></li><li><p>这个查询的where和order by中的列无法组合成索引的最左前缀：</p><p><code>where rental_date =&#39;2005-05-25&#39; order by customer_id</code></p></li><li><p>这个查询在索引列的第一列上是范围条件，所以MySQL无法使用索引的其余列：</p></li></ul><p><code>where rental_date &gt; &#39;2005-05-25 order by ...</code> </p><ul><li>这个查询在inventory_id上有多个等于条件，对于排序来说，这也是一种范围查询：</li></ul><p><code>where rental_date=&#39;2015-05-25&#39; and inventory_id in(1,2) order by customer_id</code></p><p>下面这个例子理论上是可以使用索引进行关联排序的，但由于优化器在优化时将film_actor表当做关联的第二张表，所以实际上无法使用索引：</p><p><code>explain select actor_id,title from sakila.film_actor inner join sakila.film using(film_id) order by actor_id</code></p><p>使用索引排序做排序的一个重要的用法是当查询同时有order by和limit子句的时候。</p><h4 id="压缩索引"><a href="#压缩索引" class="headerlink" title="压缩索引"></a>压缩索引</h4><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入到内存中，这在某些情况下能极大的提高性能。默认只压缩字符串，但通过参数设置也可以对整数进行压缩。</p><p>MyISAM的压缩方法是：先完全保存索引块的第一个值，然后将其他值和第一个值进行比较得到相同的前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。</p><p>压缩块使用更少的时间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以无法使用二分查找而只能从头开始。正序快，倒序慢。</p><p>使用pack_keys来控制索引压缩的方式。</p><h4 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h4><p>MySQL允许在相同列上创建多个索引，并且需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个的进行考虑，影响性能。</p><p>重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。</p><p>错误示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table test(</span><br><span class="line"> id int not null primary key,</span><br><span class="line"> a int not null,</span><br><span class="line"> b int not null,</span><br><span class="line"> unique(id),</span><br><span class="line"> index(id)</span><br><span class="line">)engine=InnoDB;</span><br></pre></td></tr></table></figure><p>上面其实给id创建了3条索引，MySQL的唯一限制和主键限制都是通过索引实现的。</p><p>通常没有理由在同一列上创建多条索引，除非在同一列上创建不同类型的索引来满足查询需求。例如key（id）和fulltext key（id）就是两种类型的索引。</p><p>冗余和重复有些不同，如果创建了索引（A,B），再创建（A），则（A）就是冗余的。这种冗余只是对B-Tree来说的。另外，其他不同类型的索引（哈希索引或者全文索引）也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是什么。</p><p>冗余索引通常发生在为表添加新索引的时候。</p><p>大多数情况下都不需要冗余索引，应该尽量扩展已经有的索引而不是创建新索引。有时候出于性能问题也考虑冗余索引，因为扩展已有的索引会导致其变的太大，从而影响其他使用该索引的查询性能。</p><h4 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h4><p>除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。建议删除。</p><p>最简单有效的办法是在Percona Server或者MariaDB中先打开userstates服务器变量，然后让服务器正常运行一段时间，再通过查询Information_schema.index_statistics就能查到每个索引的使用频率。</p><p>还可以使用Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行explain操作，然后打印出关于索引和查询的报告。</p><h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p>索引可以让查询锁定更少的行。</p><p>优点：</p><ul><li><p>InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外的开销。</p></li><li><p>锁定超过需要的行会增加锁争用并减少并发性。</p></li></ul><p>InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问行数，从而减少锁的数量。只有当InnoDB在存储引擎层能够过滤所有不需要的行时才有效。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set autocommmit = 0;</span><br><span class="line">begin;</span><br><span class="line">select actor_id from sakila.actor where actor_id &lt; 5 and actor_id &lt;&gt; 1 for update;</span><br></pre></td></tr></table></figure><table><tr><td>actor_id</td></tr><tr><td>2</td></tr><tr><td>3</td></tr><tr><td>4</td></tr></table><p>这条查询仅仅会返回2-4行数据，但是实际上获取了1-4行之间的行的排它锁。锁住第一行是因为MySQL为该查询选择的执行计划是索引范围扫描：</p><table><br>    <tr><td>id</td><td>select_type</td><td>table</td><td>type</td><td>key</td><td>Extra</td></tr><br>    <tr><td>1</td><td>SIMPLE</td><td>actor</td><td>range</td><td>PRIMARY</td><td>Using where;Using index</td></tr><br><br></table><p>问题：如果不能使用索引查找和锁定行的话问题可能会更糟糕，MySQL会做全表扫描并锁住所有的行。</p><p>InnoDB在二级索引上使用共享锁，但访问主键索引需要排他锁。这消除了使用覆盖索引的可能性，并且使得<code>select for update</code> 比<code>lock in share mode</code>或非锁定查询要慢的多。</p><h3 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h3><h3 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h3><p>维护表有3个目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。</p><h4 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h4><p>表损坏（corruption）是件很糟糕的事情。对于MyISAM，表损坏通常是系统崩溃导致的。</p><p>损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时甚至还会导致数据库的崩溃。</p><p>修复：</p><ul><li><p>check table，能找出大多数表和索引错误。有些存储引擎不支持该命令。</p></li><li><p>repair table，和check类似。</p></li><li><p>alter table innodb_tbl engine=innodb，修改表的存储引擎为当前引擎重建表。</p></li><li><p>离线工具myisamchk</p></li><li><p>将数据导出在重新导入。</p></li><li><p>如果损坏的是行数据或者系统区域，以上办法无效。</p></li><li><p>如果损坏系统区域或者行数据，可以从备份中恢复表，或者尝试从损坏的数据文件中尽可能的恢复数据。</p></li></ul><p>如果InnoDB引擎的表出现损坏，那么一定是发生了严重的错误，需要立刻调查原因。具体细节可以查看MySQL手册。</p><h4 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h4><h4 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三个原则：</p><ul><li><p>单行访问时很慢的。最好读取块中能包含尽可能多的所需要的行。使用索引可以创建位置引用以提升效率。</p></li><li><p>按顺序访问范围数据是很快的，这有两个原因。第一、顺序IO不需要多次磁盘寻道，所以比随机IO快很多。第二、如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且group by查询也无需再做排序和将行按组进行聚合计算了。</p></li><li><p>索引覆盖查询是很快的。</p></li></ul><p>一般来说，我们建议按响应时间来对查询进行分析。</p><p>如果一个查询无法从所有可能的索引中获益，则应该看看是否可以创建一个更合适的索引来提升性能。</p><h2 id="剖析MySQL查询"><a href="#剖析MySQL查询" class="headerlink" title="剖析MySQL查询"></a>剖析MySQL查询</h2><p>对查询进行性能剖析有两种方式，每种方式都有各自的问题。</p><h3 id="剖析服务器负载"><a href="#剖析服务器负载" class="headerlink" title="剖析服务器负载"></a>剖析服务器负载</h3><p>服务器端可以有效的审计效率低下的查询。</p><h4 id="捕获MySQL的查询到日志文件中"><a href="#捕获MySQL的查询到日志文件中" class="headerlink" title="捕获MySQL的查询到日志文件中"></a>捕获MySQL的查询到日志文件中</h4><p>慢查询日志是一种轻量而且功能全面的性能剖析工具，是优化服务器查询的利器。可以通过修改针对每个链接的long_query_time的阈值来捕获所以的查询。</p><p>通用日志在查询请求到服务器时进行记录，所以不包含响应时间和执行计划等重要信息。日志信息记录到数据库表中。</p><h4 id="分析查询日志"><a href="#分析查询日志" class="headerlink" title="分析查询日志"></a>分析查询日志</h4><p>工具：pt-query-digest</p><p>剖析报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest1.png?raw=true" alt="查询日志"></p><p>详细报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest2.png?raw=true" alt="详细查询日志"></p><h3 id="剖析单条查询"><a href="#剖析单条查询" class="headerlink" title="剖析单条查询"></a>剖析单条查询</h3><h4 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h4><p>show profile命令是在5.1版本之后引入的，默认是禁用的，可以通过<code>set profiling=1</code>动态的修改。这个功能有一定的作用，将来能会被Performance Schema所取代。</p><p>下面是对一个视图的剖析结果：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling1.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling2.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling3.png?raw=true" alt="详细查询日志"></p><p>剖析报告给出查询执行每个步骤花费的时间，看结果无法快速确定哪个步骤花费时间最多，因为输出是按照执行顺序排序，而不是花费的时间排序的。如果不使用show profile命令。还可以直接查询information_schema中对应的表，按照格式化输出。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/information_schema.png?raw=true" alt="详细查询日志"></p><p>效果比看show profile输出的结果好很多，可以很直观的看到哪些步骤花费时长较长。</p><h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="查询慢的原因"><a href="#查询慢的原因" class="headerlink" title="查询慢的原因"></a>查询慢的原因</h3><p>查询最重要的是响应时间，如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行更快。</p><p>MySQL执行查询的时候，查询需要在不同的地方花费时间，如网络、cpu、生成统计信息和执行计划、锁等待等。在每一个消耗大量时间的查询案例中，我们都能看到一些不必要的额外操作、某些操作被额外的执行了很多次、某些操作执行的太慢等。</p><p>优化查询的目的就是减少和消除这些操作所花费的时间。</p><h3 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h3><p>查询性能低下最基本的原因是访问的数据太多。某些查询不可避免的需要筛选大量数据，大部分查询都可以通过减少访问的数据量的方式进行优化。对于低效查询可以分为两个步骤分析：</p><ul><li><p>1.确认应用程序是否检索大量超过需要的数据。如访问过多的行或者列。</p></li><li><p>2.确定MySQL服务器层是否在分析大量超过需要的数据行。</p></li></ul><h4 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h4><ul><li><p>查询不需要的记录</p></li><li><p>多表关联返回全部的列</p></li><li><p>总是取出全部的列</p></li><li><p>重复查询相同的数据</p></li></ul><h4 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h4><p>在确定查询只返回需要的数据以后，最简单的衡量查询开销的三个指标如下：</p><ul><li><p>响应时间</p></li><li><p>扫描的行数</p></li><li><p>返回的行数</p></li></ul><p>响应时间：响应时间只是一个表面上的值。响应时间是服务时间和排队时间。服务时间指数据库处理这个时间花费的时间。排队时间指服务器因为等待某些资源而没有真正执行查询的时间。</p><p>快速上限估计：了解查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以在具体硬件条件下一次IO的消耗时间。</p><p>扫描的行数和返回的行数： 分析查询时，查看扫描的行数一定程度上可以反映出该查询找到需要的数据的效率高不高。</p><p>扫描的行数和访问类型：在explain语句中的type列反映了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。从慢到快，扫描的行数从小到大。</p><p>如果查询没有找到合适的访问类型，那么解决的最好办法通常是增加一个合适的索引。</p><p>例如：</p><p><code>select * from sakila.film_actor where film_id = 1;</code></p><p>这个查询返回10行数据，从explain的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/ref.png?raw=true" alt="详细查询日志"></p><p>explain的结果也显示MySQL预估需要访问10行数据。查询优化器认为这种访问类型可以高效的完成查询。如果我们删除索引再来运行：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/where.png?raw=true" alt="详细查询日志"></p><p>正如我们预料的，查询变成全表扫描，MySQL预估会扫描5073条记录来完成查询。</p><p>一般MySQL使用如下三种方式应用WHERE条件，从好到坏依次是：</p><ul><li><p>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</p></li><li><p>使用索引覆盖扫描（Extra:using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录。</p></li><li><p>从数据表中返回数据（Extra:using where），然后过滤不满足条件的记录。这是在服务器层完成的，MySQL需要从数据表中读出来然后再进行过滤。</p></li></ul><p>虽然例子说明了好的索引多么重要，但是也不是说增加了索引就能让扫描的行数等于返回的行数。例如使用聚合函数的查询：</p><p><code>select actor_id,count(*) from sakila.film_actor group by actor_id</code></p><p>这个例子没有什么索引能够让这样的查询减少需要扫描的行数。</p><p>通常如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试使用下面的技巧去优化：</p><ul><li><p>使用覆盖索引扫描，把所有需要的列放到索引中，这样存储引擎无需回表获取对应行就可以返回结果了。</p></li><li><p>改变库表结构。例如使用单独的汇总表。</p></li><li><p>重写复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</p></li></ul><h3 id="重构查询的方式非锁"><a href="#重构查询的方式非锁" class="headerlink" title="重构查询的方式非锁"></a>重构查询的方式非锁</h3><h4 id="一个复杂的查询还是多个简单的查询"><a href="#一个复杂的查询还是多个简单的查询" class="headerlink" title="一个复杂的查询还是多个简单的查询"></a>一个复杂的查询还是多个简单的查询</h4><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><p>将大查询分为小查询，每个查询功能完全一样，只完成一小部分，每次返回一小部分查询结果。删除旧数据就是一个很好的例子</p><h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><p>对每一个表进行一次单表查询，然后将结果在应用程序中关联。</p><p>分解关联查询的优点：</p><ul><li><p>让缓存效率跟高。</p></li><li><p>执行单个查询可以减少锁的竞争。</p></li><li><p>做应用层关联，可以更好的对数据库拆分，更容易做到，高性能可扩展。</p></li><li><p>查询效率本身效率也可能会有所提升。</p></li><li><p>可以减少冗余记录的查询。</p></li><li><p>这样做相当于在应用中实现了哈希关联而不是MySQL的嵌套循环关联。</p></li></ul><h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><p>查询执行路径：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/process.png?raw=true" alt="查询执行路径"></p><h3 id="MySQL查询优化器的局限性"><a href="#MySQL查询优化器的局限性" class="headerlink" title="MySQL查询优化器的局限性"></a>MySQL查询优化器的局限性</h3><h3 id="查询优化器的提示"><a href="#查询优化器的提示" class="headerlink" title="查询优化器的提示"></a>查询优化器的提示</h3><h3 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h3><h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><h2 id="MySQL的高级特性"><a href="#MySQL的高级特性" class="headerlink" title="MySQL的高级特性"></a>MySQL的高级特性</h2><ul><li><p>分区表</p></li><li><p>视图</p></li><li><p>外键约束</p></li><li><p>MySQL内部存储代码</p></li><li><p>游标</p></li><li><p>绑定变量</p></li><li><p>用户自定义函数</p></li><li><p>插件</p></li><li><p>字符集和校对</p></li><li><p>全文索引</p></li><li><p>分布式（XA）事务</p></li><li><p>查询缓存</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引擎篇&quot;&gt;&lt;a href=&quot;#引擎篇&quot; class=&quot;headerlink&quot; title=&quot;引擎篇&quot;&gt;&lt;/a&gt;引擎篇&lt;/h2&gt;&lt;h3 id=&quot;MyISAM&quot;&gt;&lt;a href=&quot;#MyISAM&quot; class=&quot;headerlink&quot; title=&quot;MyISAM&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://zhongyp.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Callable、Future、FutureTask</title>
    <link href="http://zhongyp.me/2018/03/29/concurrent/2018-03-29-Callable/"/>
    <id>http://zhongyp.me/2018/03/29/concurrent/2018-03-29-Callable/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-10-02T01:27:53.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>Callable接口类似于Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的，方法可以有返回值，并且可以抛出异常。但是Runnable不行。</p><p>Callable需要依赖FutureTask，用于接收运算结果。一个产生结果，一个拿到结果。FutureTask是Future接口的实现类，也可以用作闭锁（）。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/Callable.png?raw=true" alt="类图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h2&gt;&lt;p&gt;Callable接口类似于Runnable，两者都是为那些其实例可能被另一个线程执行的类设计
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>闭锁和栅栏</title>
    <link href="http://zhongyp.me/2018/03/29/concurrent/2018-03-29-Latch-CyclicBarrier/"/>
    <id>http://zhongyp.me/2018/03/29/concurrent/2018-03-29-Latch-CyclicBarrier/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-10-27T03:33:47.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><p>闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。通俗的讲就是，一个闭锁相当于一扇大门，在大门打开之前所有线程都被阻断，一旦大门打开所有线程都将通过，但是一旦大门打开，所有线程都通过了，那么这个闭锁的状态就失效了，门的状态也就不能变了，只能是打开状态。也就是说闭锁的状态是一次性的，它确保在闭锁打开之前所有特定的活动都需要在闭锁打开之后才能完成。</p><p>应用场景：</p><ul><li><p>确保某个计算在其需要的所有资源都被初始化之后才继续执行。二元闭锁（包括两个状态）可以用来表示“资源R已经被初始化”，而所有需要R的操作都必须先在这个闭锁上等待。</p></li><li><p>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。</p></li><li><p>等待直到某个操作的所有参与者都就绪在继续执行。（例如：多人游戏中需要所有玩家准备才能开始）</p></li></ul><p>CountDownLatch是JDK 5+里面闭锁的一个实现，允许一个或者多个线程等待某个事件的发生。CountDownLatch有一个正数计数器，countDown方法对计数器做减操作，await方法等待计数器达到0。所有await的线程都会阻塞直到计数器为0或者等待线程中断或者超时。</p><p><a href="https://github.com/zhongyp/Demo/tree/master/src/main/java/com/zhongyp/thread/latchcyclicbarrier" target="_blank" rel="noopener">看源码实例点我！</a></p><h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。 栅栏与闭锁的关键区别在于，所有的线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。<br>场景： 应用一些协议，比如几个家庭成员决定在某个地方集合，所有人在6：00在某地集合，到了以后要等待其他人，之后才能讨论去哪里吃饭。 并行迭代，将一个问题分成很多子问题，当一系列的子问题都解决之后（所有子问题线程都已经await（）），此时将栅栏打开，所有子问题线程被释放，而栅栏位置可以留着下次使用。</p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://blog.csdn.net/yujin753/article/details/46125283" target="_blank" rel="noopener">参考原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闭锁&quot;&gt;&lt;a href=&quot;#闭锁&quot; class=&quot;headerlink&quot; title=&quot;闭锁&quot;&gt;&lt;/a&gt;闭锁&lt;/h2&gt;&lt;p&gt;闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。通俗的讲就是，一个闭锁相当于一扇大门，在大门打开之前所有线程都
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载和双亲委派机制</title>
    <link href="http://zhongyp.me/2018/03/28/jvm/2018-03-28-Classloader/"/>
    <id>http://zhongyp.me/2018/03/28/jvm/2018-03-28-Classloader/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2018-10-27T03:30:00.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p>•全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p><p>•父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p><p>•缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>加载.class文件的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">– 从本地系统中直接加载</span><br><span class="line">– 通过网络下载.class文件</span><br><span class="line">– 从zip，jar等归档文件中加载.class文件</span><br><span class="line">– 从专有数据库中提取.class文件</span><br><span class="line">– 将Java源文件动态编译为.class文件</span><br></pre></td></tr></table></figure><p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><ul><li>加载：查找并加载类的二进制数据</li></ul><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><p>1、通过一个类的全限定名来获取其定义的二进制字节流。</p><p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。加载后在常量池存储编译器生成的各种字面量和符号引用。</p><ul><li>验证：确保被加载的类的正确性</li></ul><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><p>符号引用验证：确保解析动作能正确执行。</p><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><ul><li>准备：为类的静态变量分配内存，并将其初始化为默认值</li></ul><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><p>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p><p>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p><p>假设一个类变量的定义为：public static int value = 3；</p><p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>()方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</clinit></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里还需要注意如下几点：</span><br><span class="line"></span><br><span class="line">对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</span><br><span class="line"></span><br><span class="line">static int d;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line">    System.out.println(d + &quot; &quot; + c);//d可以编译不报错，c报错。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</span><br><span class="line"></span><br><span class="line">对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</span><br><span class="line"></span><br><span class="line">如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</span><br></pre></td></tr></table></figure><p>3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p><p>假设上面的类变量value被定义为： public static final int value = 3；</p><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p><ul><li>解析：把类中的符号引用转换为直接引用</li></ul><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><ul><li>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</li></ul><p>①声明类变量是指定初始值</p><p>②使用静态代码块为类变量指定初始值</p><p>JVM初始化步骤</p><p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p><p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p><p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><p>– 创建类的实例，也就是new的方式</p><p>– 访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>– 调用类的静态方法</p><p>– 反射（如Class.forName(“com.shengsiyuan.Test”)）</p><p>– 初始化某个类的子类，则其父类也会被初始化</p><p>– Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</p><p>在如下几种情况下，Java虚拟机将结束生命周期</p><p>– 执行了System.exit()方法</p><p>– 程序正常执行结束</p><p>– 程序在执行过程中遇到了异常或错误而异常终止</p><p>– 由于操作系统出现错误而导致Java虚拟机进程终止</p><h2 id="Java对象创建过程"><a href="#Java对象创建过程" class="headerlink" title="Java对象创建过程"></a>Java对象创建过程</h2><p>new一个对象时，根据new的参数在常量池中定位一个类的符号引用，如果没有找到，则说明类未被加载，则进行类加载等等上面5个步骤。</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>过程：</p><p>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p><p>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p><p>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</p><p>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p><p>双亲委派模型意义：</p><p>-系统类防止内存中出现多份同样的字节码</p><p>-保证Java程序安全稳定运行</p><h2 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h2><p>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p><p>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p><p>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><p>1）在执行非置信代码之前，自动验证数字签名。</p><p>2）动态地创建符合用户特定需要的定制化构建类。</p><p>3）从特定的场所取得java class，例如数据库中和网络中。</p><p>类加载有三种方式：</p><p>1、命令行启动应用时候由JVM初始化加载</p><p>2、通过Class.forName()方法动态加载</p><p>3、通过ClassLoader.loadClass()方法动态加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ClassLoader loader = HelloWorld.class.getClassLoader();</span><br><span class="line">System.out.println(loader);</span><br><span class="line">//使用ClassLoader.loadClass()来加载类，不会执行初始化块</span><br><span class="line">loader.loadClass(&quot;Test2&quot;);</span><br><span class="line">//使用Class.forName()来加载类，默认会执行初始化块</span><br><span class="line">//                Class.forName(&quot;Test2&quot;);</span><br><span class="line">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块</span><br><span class="line">//                Class.forName(&quot;Test2&quot;, false, loader);</span><br><span class="line"></span><br><span class="line">public class Test2 &#123;</span><br><span class="line">        static &#123;</span><br><span class="line">                System.out.println(&quot;静态初始化块执行了！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。</p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">尊重原创</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM类加载机制&quot;&gt;&lt;a href=&quot;#JVM类加载机制&quot; class=&quot;headerlink&quot; title=&quot;JVM类加载机制&quot;&gt;&lt;/a&gt;JVM类加载机制&lt;/h2&gt;&lt;p&gt;•全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Clas
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://zhongyp.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM(Java虚拟机)--摘自《深入理解Java虚拟机》</title>
    <link href="http://zhongyp.me/2018/03/27/jvm/2018-03-27-JVM/"/>
    <id>http://zhongyp.me/2018/03/27/jvm/2018-03-27-JVM/</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-10-22T11:30:14.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM的运行机制"><a href="#JVM的运行机制" class="headerlink" title="JVM的运行机制"></a>JVM的运行机制</h2><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>程序计数器： 当前线程所执行字节码的行号指示器，字节码解释器的作用是通过改变计数器的值来选取下一条需要执行的字节码指令。如果当前执行的是Native方法，则这个计数器为空。Java虚拟机中唯一没有OOM的区域。</p><p>Java虚拟机栈：虚拟机栈描述的是Java方法执行的内存模型，生命周期与线程相同。每个方法运行都会创建一个栈帧，存储局部变量表，操作栈，方法出口等信息。局部变量表（编译期分配）存放各种基本数据类型和对象引用类型，returnAddress。</p><p>本地方法栈：虚拟机栈为执行Java方法服务，本地方法栈为Native方法服务。</p><p>Java堆：虚拟机启动时创建被所有线程共享的内存区域，为了存储所有对象实例。垃圾回收的主要区域。</p><p>方法区：各个线程共享的内存区域，存储类信息，静态变量、常量、即时编译器编译后的代码数据。</p><p>运行时常量池：方法区的一部分（JDK1.6以前），Java7中已经将运行时常量池从永久代移除，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做元空间。 类加载后存储编译器生成的各种字面量和符号引用。基本数据类型不叫常量，可被修改，String和final修饰的才是。</p><p>直接内存：堆外内存，JVM虚拟机各个区域内存总和大于机器物理内存可能会导致OOM。</p><h2 id="对象状态算法"><a href="#对象状态算法" class="headerlink" title="对象状态算法"></a>对象状态算法</h2><p>引用计数算法： 很难解决对象之间相互引用的问题，内存泄露。</p><p>跟搜索算法：通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索的路径成为引用链，当一个对象到GC Root没有一个引用时，则证明此对象是不可用的。</p><p>注：GC对象包括：虚拟机栈（本地变量表）中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI。</p><p>跟搜索算法中，没有引用的对象并非非死不可，还有经历两次标记，第一次发现没有引用，则进行标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或finalize()已经被调用过，虚拟机将这两种情况都视为没有必要执行。</p><p>回收方法区： 回收废弃变量和无用的类，无用的类：该类所有实例都已被回收，加载该类的ClassLoader被回收，该类对应的java.lang.Class对象没有在任何地方被引用。反射、代理、bytecode框架需具备卸载功能。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>标记清除算法： 标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。效率问题，空间问题（内存碎片）。</p><p>复制算法： 将可用内存按照容量分为大小相等的两块，每次只是用其中的一块。当这块用完了，就将存活的对象复制到另一块上面，然后再把已经使用过的空间清理掉。新生代（EDEN）使用复制算法，当回收时，将Eden和Survivor中还存活的对象一次性的拷贝到另一块的Survivor上。最后清理掉Eden和刚才使用过的Survivor。</p><p>标记-整理算法：让所有存活的对象向一端移动，然后清理掉端边界以外的内存。</p><p>分代收集算法： 根据对象的存活周期不同，将内存划分为几块，根据各个年代的特点进行垃圾回收。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/gc.jpg?raw=true" alt="垃圾回收器"></p><p>如果两个收集器之间存在连线，就说明他们可以搭配使用。</p><ol><li><p>Serial</p><p> 复制算法，新生代的单线程收集器，简单高效，运行时停掉其他所有线程。</p></li><li><p>ParNew</p><p> 复制算法，Serial多线程版本，首选的新生代收集器。</p></li><li><p>Parallel Scavenge</p><p> 新生代收集器，使用复制算法，并行线程。目标达到可控制的吞吐量。运行用户代码时间/CPU消耗总时常=吞吐量。</p></li><li><p>Serial Old</p><p> Serial收集器的老年代版本，单线程收集器，使用标记-整理算法。</p></li><li><p>Parallel Old</p><p> 老年代版本，标记-整理算法。</p></li><li><p>CMS收集器</p><p> 最短回收停顿时间为目标的收集器，重视服务响应速度，标记-清除算法实现。第一款并发收集器，可与用户线程</p><p> 初始标记、并发标记、重新标记、并发清除。初始和重新stop the world。初始标记只是标记GCRoots能直接关联的对象，速度很快，并发标记进行GCROOTs Tracing的过程。重新标记为了修复并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</p><p> 缺点：1. 对CPU资源非常敏感，解决方案，减少GC线程的独占时间。2. 无法处理浮动垃圾。如果CMS运行期间，内存无法满足要求，出现Concurrent Mode Failure失败导致另一个FullGC产生，启动预备方案 Serial Old。CMS运行期间，用户线程产生的垃圾为浮动垃圾，CMS无法在本次收集中个清理这些浮动垃圾。3. 产生大量的空间碎片。</p></li><li><p>G1收集器</p><p> 标记整理算法实现，精确的控制停顿。G1将整个Java堆（老年代，新生代）划分多个大小固定的独立区域，并且追踪这些区域里面的垃圾堆积程度。在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ol><h2 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h2><p>对象在Eden中分配内存，没有足够的空间进行垃圾回收。MinorGC。</p><pre><code>MinorGC: 新生代垃圾回收的动作，频繁且速度快。MajorGC（FullGC）: 指发生在老年代的GC，慢，清理新生代和老年代，CMS</code></pre><p>大对象指需要大量连续空间的Java对象。典型就是很长的字符串和数组。直接进入老年代分配，避免在Eden及Survivor中大量复制拷贝。</p><p>长期生活的对象进入老年代。对象年龄计数器，每一次MinorGC增长1岁。默认15岁进入老年代。</p><p>动态对象年龄判断，如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄段的对象直接进入老年代。</p><p>空间担保分配，每次MinorGC,检测升级到老年代的大小是否大于老年代的空间，如果大于，则进行FullGC。</p><h2 id="JDK命令行工具-性能监控和故障处理"><a href="#JDK命令行工具-性能监控和故障处理" class="headerlink" title="JDK命令行工具 性能监控和故障处理"></a>JDK命令行工具 性能监控和故障处理</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>虚拟机进程状况工具。 显示当前所有java进程pid的命令。</p><p>-l 输出主类的全名，如果进程执行的是Jar包，输出Jar路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -l</span><br><span class="line">5696 com.intellij.rt.execution.application.AppMain</span><br><span class="line">944 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">4488</span><br><span class="line">1900 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">7244 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure><p>-v 输出虚拟机进程启动时JVM参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -v</span><br><span class="line">5696 AppMain -Didea.launcher.port=7534 -Didea.launcher.bin.path=F:\Program Files\intellij IDEA\bin -Dfile.encoding=UTF-8</span><br><span class="line">944 RemoteMavenServer -Djava.awt.headless=true -Didea.version==2016.2.5 -Xmx768m -Didea.maven.embedder.version=3.0.5 -Dfile.encoding=GBK</span><br><span class="line">1656 Jps -Denv.class.path=.;C:\Program Files\Java\jdk1.8.0_161\lib\dt.jar;C:\Program Files\Java\jdk1.8.0_161\lib\tools.jar; -Dapplication.home=C:\Program Files\Java\jdk1.8.0_161 -Xms8m</span><br><span class="line">4488  -Xms128m -Xmx750m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djb.vmOptionsFile=F:\Program Files\intellij IDEA\bin\idea64.exe.v</span><br><span class="line">moptions -Xbootclasspath/a:F:\Program Files\intellij IDEA\lib\boot.jar -Didea.paths.selector=IntelliJIdea2016.2 -Didea.jre.check=true -XX:ErrorFile=C:\Users\zhongyp\java_error_in_idea_%p.log -XX:HeapDumpPath=C:\Users\zhongyp\java_error_in_idea.hprof</span><br><span class="line">1900 Launcher -Xmx700m -Djava.awt.headless=true -Djava.endorsed.dirs=&quot;&quot; -Djdt.compiler.useSingleThread=true -Dpreload.project.path=E:/demo -Dpreload.config.path=C:/Users/zhongyp/.IntelliJIdea2016.2/config/options -Dcompile.parallel=false -Drebuild.on.dependency.change=true -Djava.net.preferIPv4Stack=true</span><br><span class="line"> -Dio.netty.initialSeedUniquifier=-1505227146882843300 -Dfile.encoding=GBK -Djps.file.types.component.name=FileTypeManager -Duser.language=zh -Duser.country=CN -Didea.paths.selector=IntelliJIdea2016.2 -Didea.home.path=F:\Program Files\intellij IDEA -Didea.config.path=C:\Users\zhongyp\.IntelliJIdea2016.2\</span><br><span class="line">config -Didea.plugins.path=C:\Users\zhongyp\.IntelliJIdea2016.2\config\plugins -Djps.log.dir=C:/Users/zhongyp/.IntelliJIdea2016.2/system/log/build-log -Djps.fallback.jdk.home=C:/Program Files/Java/jdk1.8.0_161/jre -Djps.fallback.jdk.version=1.8.0_161 -Djava.io.tmpdir=C:/Users/zhongyp/.IntelliJIdea2016.2/</span><br><span class="line">system/compile-server/_temp_ -Dkotlin.incremental.compilation.experimental=true -Dkotlin.daemon.enabled -Dkotlin.daemon.cli</span><br></pre></td></tr></table></figure><p>-q 只输出LVMID，省略主类的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -q</span><br><span class="line">5696</span><br><span class="line">8912</span><br><span class="line">944</span><br><span class="line">4488</span><br><span class="line">1900</span><br></pre></td></tr></table></figure><p>-m 输出虚拟机进程启动时传递给主类main()函数的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">5696 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">10484 Jps -m</span><br><span class="line">4488</span><br><span class="line">1900 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/intel</span><br><span class="line">lij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/id</span><br><span class="line">ea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.ja</span><br><span class="line">r;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br></pre></td></tr></table></figure><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p> 虚拟机统计信息监视工具，用于监视虚拟机各种运行状态信息的命令。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾回收、JIT编译等运行数据。运行期定位虚拟机性能问题的首选工具。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-class：监视类装载、卸载数量、总空间以及类装载所耗时间。</span><br><span class="line"></span><br><span class="line">-gc：监视JAVA堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间，GC已用时间合计等信息；</span><br><span class="line"></span><br><span class="line">-gccapacity：监视内容与-gc基本相同，但输出主要关注 java堆各个区域使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcutil：监视内容与-gc基本相同，便输出主要关注已使用空间占总空间的百分比；</span><br><span class="line"></span><br><span class="line">-gccause：与-gcutil功能一样，但是会额外输出导致 一次GC产生的原因；</span><br><span class="line"></span><br><span class="line">-gcnew：监视新生代GC状态；</span><br><span class="line"></span><br><span class="line">-gcnewcapacity：监视内容与-gcnew基本相同，输出最要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcold：监视老年代GC状况；</span><br><span class="line"></span><br><span class="line">-gcoldcapacity：监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcpermcapacity：监视永久代使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-compiler：输入JIT编译器编译过的方法，耗时等信息；</span><br><span class="line"></span><br><span class="line">-printcompilation：输出已经被JIT编译的方法；</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat1.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat2.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat3.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat4.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat5.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat6.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat7.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat8.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat9.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat10.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat11.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat12.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat13.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat14.png?raw=true" alt="jstat"></p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-flag &lt;name&gt; ：可查看虚拟机启动时显式指定的参数列表。</span><br><span class="line">-flag [+|-]&lt;name&gt;：设置或取消VM参数</span><br><span class="line">-flag &lt;name&gt;=&lt;value&gt;：给VM参数设置新值</span><br><span class="line">-flags：可查看所有VM参数；</span><br><span class="line">-sysprops：查看java系统参数;</span><br><span class="line">&lt;no option&gt;：表示在不给定任何选项时，打印出以上所有的VM参数</span><br></pre></td></tr></table></figure><p> 实时的查看和调整虚拟机的各项参数。</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-dump：生成java堆转储快照，格式为：-dump[live, ] format=b, file=&lt;filename&gt;,其中live子参数说明是否只dump出存活对象；</span><br><span class="line"></span><br><span class="line">-finalizerinfo：显示在F-QueuiK 等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-heap：显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-histo：显示堆中对象统计信息，包括类、实例数量、合计容量；</span><br><span class="line"></span><br><span class="line">-permstat：以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台有效；</span><br><span class="line"></span><br><span class="line">-F：当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，只在Linux/Solaris平台有效</span><br></pre></td></tr></table></figure><p> Java内存映像工具。用于生成堆转储快照，还可以查询finalize()执行队列，Java堆和永久代的详细信息，如空间使用率、当前使用的哪种收集器等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jmap -dump:format=b,file=D:\test.bin 2768</span><br><span class="line">Dumping heap to D:\test.bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p><code>jhat D:\test.bin</code></p><p> 分析jmap生成的堆转储快照，在浏览器查看。</p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p> 用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合，生成快照的目的是定位线程出现长时间停顿的原因。</p><p>-F    当正常输出的请求不被响应时，强制输出线程堆栈</p><p>-l    除堆栈外，显示关于锁的附加信息</p><p>-m    如果调用到本地方法的话，可以显示c/c++的堆栈</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">//        Thread t1 = new Worker(1);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        t1.start();</span><br><span class="line">        final A a = new A();</span><br><span class="line">        final B b = new B();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                a.getBLock(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                b.getALock(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getBLock(B b)&#123;</span><br><span class="line"></span><br><span class="line">        b.getALock(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getALock(A a)&#123;</span><br><span class="line">        a.getBLock(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">1904 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">11540 Jps -m</span><br><span class="line">13204 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/inte</span><br><span class="line">llij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/i</span><br><span class="line">dea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.j</span><br><span class="line">ar;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br><span class="line">4488</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jstack -F 1904</span><br><span class="line">Attaching to process ID 1904, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.161-b12</span><br><span class="line">Deadlock Detection:</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193ce108 (Object@0x00000000d6129700, a com/zhongyp/B),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193cb878 (Object@0x00000000d6127d20, a com/zhongyp/A),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line"></span><br><span class="line">Found a total of 1 deadlock.</span><br><span class="line"></span><br><span class="line">Thread 1: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 18: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=0, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=2, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$2.run() @bci=18, line=38 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 17: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=0, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=2, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$1.run() @bci=18, line=26 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 16: (state = IN_NATIVE)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.accept0(int, java.net.InetSocketAddress[]) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.socketAccept(java.net.SocketImpl) @bci=37, line=131 (Interpreted frame)</span><br><span class="line"> - java.net.AbstractPlainSocketImpl.accept(java.net.SocketImpl) @bci=7, line=409 (Interpreted frame)</span><br><span class="line"> - java.net.PlainSocketImpl.accept(java.net.SocketImpl) @bci=42, line=199 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.implAccept(java.net.Socket) @bci=60, line=545 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.accept() @bci=48, line=513 (Interpreted frame)</span><br><span class="line"> - com.intellij.rt.execution.application.AppMain$1.run() @bci=13, line=79 (Interpreted frame)</span><br><span class="line"> - java.lang.Thread.run() @bci=11, line=748 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 10: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 9: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 8: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 7: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.Object.wait() @bci=2, line=502 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference.tryHandlePending(boolean) @bci=54, line=191 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference$ReferenceHandler.run() @bci=1, line=153 (Interpreted frame)</span><br></pre></td></tr></table></figure><h2 id="JDK可视化工具"><a href="#JDK可视化工具" class="headerlink" title="JDK可视化工具"></a>JDK可视化工具</h2><p>JConsole: Java监视与管理控制台。基于JMX的可视化监视和管理工具。监视Java堆和永久代的的变化趋势。</p><p>VisualVM: 多合一故障处理工具。</p><h2 id="JVM调优案例"><a href="#JVM调优案例" class="headerlink" title="JVM调优案例"></a>JVM调优案例</h2><h3 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h3><p>使用64位JDK大内存。</p><p>问题：1.内存回收导致长时间停顿。2.64位JDK的性能测试结果普遍低于32位JDK。3.需要保证程序足够稳定，这种应用如果产生堆溢出几乎就无法产生堆转储快照。4. 相同程序64位JDK中消耗内存一般比32位大，这是由于指针膨胀和数据类型对其补白导致的。</p><p>使用若干个32位虚拟机建立逻辑集群来利用集群资源。</p><p>问题：1.尽量避免节点竞争全局资源，如并发写操作导致IO异常。2.很难高效率的利用某些资源池，比如连接池，导致一些节点满了，其他的还为零。3.各个节点仍然不可避免的受到32位的限制（2GB）。4.大量使用本地缓存的应用，改为集中式的缓存。</p><h3 id="集群间同步导致内存溢出"><a href="#集群间同步导致内存溢出" class="headerlink" title="集群间同步导致内存溢出"></a>集群间同步导致内存溢出</h3><h3 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h3><h3 id="外部命令导致系统缓慢"><a href="#外部命令导致系统缓慢" class="headerlink" title="外部命令导致系统缓慢"></a>外部命令导致系统缓慢</h3><h2 id="java内存模型和线程"><a href="#java内存模型和线程" class="headerlink" title="java内存模型和线程"></a>java内存模型和线程</h2><h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><h4 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h4><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p><p>注： 这里说的变量包括了实例变量、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有，不会被共享，自然就不存在竞争问题。</p><h2 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h2><p>线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象时线程安全的。</p><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><h4 id="1-互斥同步（阻塞同步）"><a href="#1-互斥同步（阻塞同步）" class="headerlink" title="1.互斥同步（阻塞同步）"></a>1.互斥同步（阻塞同步）</h4><p>悲观锁。</p><p>sychronized 和 ReentrantLock。</p><h4 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2.非阻塞同步"></a>2.非阻塞同步</h4><p>乐观锁，CAS。</p><p>AtomicInteger等</p><h4 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3.无同步方案"></a>3.无同步方案</h4><ul><li><p>可重入代码：可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。判断代码是否具备可重入性：如果一个方法，他的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求。</p></li><li><p>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？ThreadLocal（不共享）。volatile(共享)。</p></li></ul><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁和自适应锁"><a href="#自旋锁和自适应锁" class="headerlink" title="自旋锁和自适应锁"></a>自旋锁和自适应锁</h4><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM的运行机制&quot;&gt;&lt;a href=&quot;#JVM的运行机制&quot; class=&quot;headerlink&quot; title=&quot;JVM的运行机制&quot;&gt;&lt;/a&gt;JVM的运行机制&lt;/h2&gt;&lt;h2 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://zhongyp.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java反射和动态代理</title>
    <link href="http://zhongyp.me/2018/03/18/java/2018-03-18-JavaReflection/"/>
    <id>http://zhongyp.me/2018/03/18/java/2018-03-18-JavaReflection/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-10-02T01:27:53.330Z</updated>
    
    <content type="html"><![CDATA[<p>要想理解反射的原理，首先要了解什么是类型信息。Java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。</p><h2 id="CLASS-对象"><a href="#CLASS-对象" class="headerlink" title="CLASS 对象"></a>CLASS 对象</h2><p>每个类都会产生一个对应的Class对象，也就是保存在.class文件。所有类都是在对其第一次使用时，动态加载到JVM的，当程序创建一个对类的静态成员的引用时，就会加载这个类。Class对象仅在需要的时候才会加载，static初始化是在类加载时进行的。</p><p>类加载器首先会检查这个类的Class对象是否已被加载过，如果尚未加载，默认的类加载器就会根据类名查找对应的.class文件。</p><p>想在运行时使用类型信息，必须获取对象(比如类Base对象)的Class对象的引用，使用功能Class.forName(“Base”)可以实现该目的，或者使用base.class。注意，有一点很有趣，使用功能”.class”来创建Class对象的引用时，不会自动初始化该Class对象，使用forName()会自动初始化该Class对象。为了使用类而做的准备工作一般有以下3个步骤：</p><ul><li><p>加载：由类加载器完成，找到对应的字节码，创建一个Class对象</p></li><li><p>链接：验证类中的字节码，为静态域分配空间</p></li><li><p>初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Base &#123;</span><br><span class="line">    static int num = 1;</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Base &quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 不会初始化静态块</span><br><span class="line">        Class clazz1 = Base.class;</span><br><span class="line">        System.out.println(&quot;------&quot;);</span><br><span class="line">        // 会初始化</span><br><span class="line">        Class clazz2 = Class.forName(&quot;zzz.Base&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>如果不知道某个对象的确切类型，RTTI可以告诉你，但是有一个前提：这个类型在编译时必须已知，这样才能使用RTTI来识别它。Class类与java.lang.reflect类库一起对反射进行了支持，该类库包含Field、Method和Constructor类，这些类的对象由JVM在启动时创建，用以表示未知类里对应的成员。这样的话就可以使用Contructor创建新的对象，用get()和set()方法获取和修改类中与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getFields()、getMethods()和getConstructors()等许多便利的方法，以返回表示字段、方法、以及构造器对象的数组，这样，对象信息可以在运行时被完全确定下来，而在编译时不需要知道关于类的任何事情。</p><p>反射机制并没有什么神奇之处，当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类。因此，那个类的.class对于JVM来说必须是可获取的，要么在本地机器上，要么从网络获取。所以对于RTTI和反射之间的真正区别只在于：</p><ul><li><p>RTTI，编译器在编译时打开和检查.class文件</p></li><li><p>反射，运行时打开和检查.class文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        Test test =  new Test();</span><br><span class="line">    </span><br><span class="line">        Class clazz = Class.forName(&quot;com.zhongyp.advanced.proxy.Test&quot;);</span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        for(Constructor str:constructors)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method[] method = clazz.getDeclaredMethods();</span><br><span class="line">        for(Method method1:method)&#123;</span><br><span class="line">            System.out.println(method1);</span><br><span class="line">        &#125;</span><br><span class="line">        Method method1 = clazz.getMethod(&quot;go&quot;, null);</span><br><span class="line">        method1.invoke(test,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">class Test&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Test()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private void test()&#123;&#125;</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        System.out.println(&quot;go&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void gogogo()&#123;</span><br><span class="line">        System.out.println(&quot;gogogo&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理模式是为了提供额外或不同的操作，而插入的用来替代”实际”对象的对象，这些操作涉及到与”实际”对象的通信，因此代理通常充当中间人角色。Java的动态代理比代理的思想更前进了一步，它可以动态地创建并代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的策略。以下是一个动态代理示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface TestService&#123;</span><br><span class="line"></span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestServiceImpl implements TestService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;我要开始测试啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyInvokeHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    public MyInvokeHandler(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        return method.invoke(obj,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">        TestServiceImpl testService = new TestServiceImpl();</span><br><span class="line"></span><br><span class="line">        MyInvokeHandler myInvokeHandler = new MyInvokeHandler(testService);</span><br><span class="line"></span><br><span class="line">        TestService proxy = (TestService) Proxy.newProxyInstance(TestService.class.getClassLoader(),new Class[]&#123;TestService.class&#125;,myInvokeHandler);</span><br><span class="line"></span><br><span class="line">        proxy.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要想理解反射的原理，首先要了解什么是类型信息。Java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。&lt;/p&gt;
&lt;h2 id=&quot;CLASS-对象&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据存储-Spring事务</title>
    <link href="http://zhongyp.me/2018/03/17/spring/2018-03-17-Spring-Transaction/"/>
    <id>http://zhongyp.me/2018/03/17/spring/2018-03-17-Spring-Transaction/</id>
    <published>2018-03-16T16:00:00.000Z</published>
    <updated>2018-10-27T03:24:17.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务传播特性"><a href="#事务传播特性" class="headerlink" title="事务传播特性"></a>事务传播特性</h2><p><a href="https://github.com/zhongyp/Demo" target="_blank" rel="noopener">源码实例</a></p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><p>事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。  </p><p>在 Spring 中通常可以通过以下三种方式来实现对事务的管理： </p><ol><li><p>使用 Spring 的事务代理工厂管理事务 </p></li><li><p>使用 Spring 的事务注解管理事务 </p></li><li><p>使用 AspectJ 的 AOP 配置管理事务 </p></li></ol><p>Spring 的事务管理，主要用到两个事务相关的接口。</p><p> <img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/transaction.jpg?raw=true" alt="Spring事务接口"></p><h2 id="事务管理器接口"><a href="#事务管理器接口" class="headerlink" title="事务管理器接口"></a>事务管理器接口</h2><p>事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Public interface PlatformTransactionManager()...&#123;  </span><br><span class="line">// 由TransactionDefinition得到TransactionStatus对象</span><br><span class="line">TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; </span><br><span class="line">// 提交</span><br><span class="line">Void commit(TransactionStatus status) throws TransactionException;  </span><br><span class="line">// 回滚</span><br><span class="line">Void rollback(TransactionStatus status) throws TransactionException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A) 常用的两个实现类，PlatformTransactionManager 接口有两个常用的实现类：  　　　　　　　　　　</p><ul><li>DataSourceTransactionManager：使用 JDBC 或 iBatis  进行持久化数据时使用。  </li></ul><p>如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p><p>　　</p><ul><li>HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。 </li></ul><p>如果应用程序的持久化是通过Hibernate实现的，那么你需要使用HibernateTransactionManager。对于Hibernate3，需要在Spring上下文定义中添加如下的<bean>声明：</bean></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p><p>B) PlatformTransactionManager其他实现类</p><p>Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA(事务)、JPA(持久化)。下面分别介绍各个平台框架实现事务管理的机制。</p><ul><li>Java持久化API事务（JPA）</li></ul><p>Hibernate多年来一直是事实上的Java持久化标准，但是现在Java持久化API作为真正的Java持久化标准进入大家的视野。如果你计划使用JPA的话，那你需要使用Spring的JpaTransactionManager来处理事务。你需要在Spring中这样配置JpaTransactionManager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>JpaTransactionManager只需要装配一个JPA实体管理工厂（javax.persistence.EntityManagerFactory接口的任意实现）。JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务。</p><ul><li>Java原生API事务(JTA)</li></ul><p>如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;transactionManagerName&quot; value=&quot;java:/TransactionManager&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象，其中事务成功完成通过UserTransaction.commit()方法提交，事务失败通过UserTransaction.rollback()方法回滚。</p><p>C) Spring 的回滚方式 　　</p><ul><li>Spring 事务的默认回滚方式是：发生运行时异常时回滚，发生受查异常时提交。不过，对于受查异常，程序员也可以手工设置其回滚方式。</li></ul><h2 id="事务定义接口"><a href="#事务定义接口" class="headerlink" title="事务定义接口"></a>事务定义接口</h2><p>事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限，及对它们的操作。</p><p>A) 定义了五个事务隔离级别常量,这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX： 　　　　　　　　 </p><ul><li>DEFAULT：采用DB默认的事务隔离级别。MySql的默认为REPEATABLE_READ；  Oracle默认为 READ_COMMITTED。 　　</li><li>READ_UNCOMMITTED：读未提交。未解决任何并发问题。 　　</li><li>READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。  　　</li><li>REPEATABLE_READ：可重复读。解决脏读、不可重复读，存在幻读  　　</li><li>SERIALIZABLE：串行化。不存在并发问题。</li></ul><p>B) 定义了七个事务传播行为常量，所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如，A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。事务传播行为常量都是以 PROPAGATION_  开头，形如 PROPAGATION_XXX。  　　</p><ul><li>REQUIRED：指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是Spring 默认的事务传播行为。如该传播行为加在 doOther()方法上。若 doSome()方法在执行时就是在事务内的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法没有在事务内执行，则 doOther()方法会创建一个事务，并在其中执行。　　</li><li><p>SUPPORTS：指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。 </p></li><li><p>MANDATORY：指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。</p></li><li><p>REQUIRES_NEW：总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。</p></li><li><p>NOT_SUPPORTED：指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。</p></li><li><p>NEVER：指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。</p></li><li><p>NESTED：指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。嵌套事务在外部事务提交后，才真正的提交。</p></li></ul><p>C) 定义了默认事务超时时限 </p><ul><li><p>常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。 </p></li><li><p>注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。</p></li></ul><h2 id="Spring-的事务代理工厂管理事务"><a href="#Spring-的事务代理工厂管理事务" class="headerlink" title="Spring 的事务代理工厂管理事务"></a>Spring 的事务代理工厂管理事务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册数据源：C3P0数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册JDBC属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册Dao --&gt;</span><br><span class="line">    &lt;bean id=&quot;accountDao&quot; class=&quot;com.tongji.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;stockDao&quot; class=&quot;com.tongji.dao.StockDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册Service --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockService&quot; class=&quot;com.tongji.service.StockProcessServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;stockDao&quot; ref=&quot;stockDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;!-- 注册事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 生成事务代理 --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockServiceProxy&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;transactionManager&quot; ref=&quot;myTxManager&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot; ref=&quot;stockService&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;transactionAttributes&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;open*&quot;&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;buyStock&quot;&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED,-StockException&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="Spring-的事务注解管理事务"><a href="#Spring-的事务注解管理事务" class="headerlink" title="Spring 的事务注解管理事务"></a>Spring 的事务注解管理事务</h2><p>注：需要注意的是，@Transactional 若用在方法上，只能用于 public 方法上。对于其他非public 方法，如果加上了注解@Transactional，虽然 Spring 不会报错，但不会将指定事务织入到该方法中。因为 Spring 会忽略掉所有非 public 方法上的@Transaction 注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; </span><br><span class="line">        xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx </span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop </span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册数据源：C3P0数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册JDBC属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册Dao --&gt;</span><br><span class="line">    &lt;bean id=&quot;accountDao&quot; class=&quot;com.tongji.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;stockDao&quot; class=&quot;com.tongji.dao.StockDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册Service --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockService&quot; class=&quot;com.tongji.service.StockProcessServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;stockDao&quot; ref=&quot;stockDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;!-- 注册事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 开启注解驱动 --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;myTxManager&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED)</span><br><span class="line">public void openAccount(String aname, double money) &#123;</span><br><span class="line">    accountDao.insertAccount(aname, money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED)</span><br><span class="line">public void openStock(String sname, int amount) &#123;</span><br><span class="line">    stockDao.insertStock(sname, amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED, rollbackFor=StockException.class)</span><br><span class="line">public void buyStock(String aname, double money, String sname, int amount) throws StockException &#123;</span><br><span class="line">    boolean isBuy = true;</span><br><span class="line">    accountDao.updateAccount(aname, money, isBuy);</span><br><span class="line">    if (true) &#123;</span><br><span class="line">        throw new StockException(&quot;购买股票异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    stockDao.updateStock(sname, amount, isBuy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-使用AspectJ的AOP配置管理事务"><a href="#Spring-使用AspectJ的AOP配置管理事务" class="headerlink" title="Spring 使用AspectJ的AOP配置管理事务"></a>Spring 使用AspectJ的AOP配置管理事务</h2><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/aop-3.jpg?raw=true" alt="aop3"></p><p>AOP术语：</p><ul><li><p>连接点（joinpoint）你可以切入的方法（注意是可以）。</p></li><li><p>切点（pointcut）是你切入的方法。</p></li><li><p>增强（advice）往切点里面增加其他特殊的东西，比如事务传播。</p></li><li><p>目标对象（target）引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p></li><li><p>引介（introduction）允许我们向现有的类添加新方法属性。</p></li><li><p>织入（weaving） 把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。</p></li><li><p>代理（proxy）实现整套aop机制的，都是通过代理。</p></li><li><p>切面（aspect）切面是通知和切入点的结合,就是定义了通知的类。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; </span><br><span class="line">        xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx </span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop </span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册数据源：C3P0数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册JDBC属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册Dao --&gt;</span><br><span class="line">    &lt;bean id=&quot;accountDao&quot; class=&quot;com.tongji.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;stockDao&quot; class=&quot;com.tongji.dao.StockDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册Service --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockService&quot; class=&quot;com.tongji.service.StockProcessServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;stockDao&quot; ref=&quot;stockDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;!-- 注册事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册事务通知 --&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;myTxManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!-- 指定在切入点方法上应用的事务属性 --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;open*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;buyStock&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;StockException&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- AOP配置 --&gt;</span><br><span class="line">    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;//表示使用CGLib动态代理技术织入增强。设置为false时，表示使用jdk动态代理织入增强，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br><span class="line">        &lt;!-- 指定切入点 --&gt;</span><br><span class="line">        &lt;aop:pointcut expression=&quot;execution(* *..service.*.*(..))&quot; id=&quot;stockPointCut&quot;/&gt;//这里设置切入点，expression设置切面植入的切入点的方法地址</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;stockPointCut&quot;/&gt;// 加入事务传播特性</span><br><span class="line">        &lt;aop:aspect ref=&quot;stockService&quot;&gt;//定义一个切面</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/qjjazry/p/6366204.html" target="_blank" rel="noopener">参考博文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务传播特性&quot;&gt;&lt;a href=&quot;#事务传播特性&quot; class=&quot;headerlink&quot; title=&quot;事务传播特性&quot;&gt;&lt;/a&gt;事务传播特性&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zhongyp/Demo&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="数据存储" scheme="http://zhongyp.me/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程（一）</title>
    <link href="http://zhongyp.me/2018/03/16/concurrent/2017-03-16-Threads/"/>
    <id>http://zhongyp.me/2018/03/16/concurrent/2017-03-16-Threads/</id>
    <published>2018-03-15T16:00:00.000Z</published>
    <updated>2018-10-27T03:35:22.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul><li>新建：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。</li></ul><p style="color:red">注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</p><ul><li>就绪：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。</li></ul><p style="color:red">如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠，转去执行子线程。</p><ul><li>运行：处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</li></ul><p>处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。</p><pre><code>注： 当发生如下情况是，线程会从运行状态变为阻塞状态：     ①、线程调用sleep方法主动放弃所占用的系统资源     ②、线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞     ③、线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有     ④、线程在等待某个通知（notify）     ⑤、程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。</code></pre><ul><li><p>阻塞：处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。</p></li><li><p>死亡：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ul><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><ul><li>线程睡眠 sleep</li></ul><p>如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法。</p><p>sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread=new MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        myThread.sleep(1000);//这里sleep的就是main线程，而非myThread线程  </span><br><span class="line">        Thread.sleep(10);  </span><br><span class="line">        for(int i=0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</p><ul><li>线程让步 yield</li></ul><p>yield()方法和sleep()方法有点相似，它也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。</p><p style="color:red">sleep和yield的区别</p><pre><code>①、sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。②、sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常。③、sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行。</code></pre><ul><li>线程合并</li></ul><p>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void join()      </span><br><span class="line">     当前线程等该加入线程后面，等待该线程终止。    </span><br><span class="line">void join(long millis)  </span><br><span class="line">     当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度  </span><br><span class="line">void join(long millis,int nanos)   </span><br><span class="line">     等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String [] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1 = new Thread(&quot;小明&quot;);</span><br><span class="line">    Thread t2 = new Thread(&quot;小东&quot;);</span><br><span class="line">    t1.start();</span><br><span class="line">    /**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：</span><br><span class="line">     程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕</span><br><span class="line">     所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会</span><br><span class="line">     */</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置线程优先级</li></ul><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。</p><p style="color:red">注：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p><ul><li>后台守护</li></ul><p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：</p><pre><code>• 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。• Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final void setDaemon(boolean on)        将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。    </span><br><span class="line">         该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。   </span><br><span class="line">  参数：</span><br><span class="line">     on - 如果为 true，则将该线程标记为守护线程。    </span><br><span class="line">  抛出：    </span><br><span class="line">    IllegalThreadStateException - 如果该线程处于活动状态。    </span><br><span class="line">    SecurityException - 如果当前线程无法修改该线程。</span><br></pre></td></tr></table></figure><ul><li>线程结束</li></ul><p>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法：</p><pre><code>• 正常执行完run方法，然后结束掉；• 控制循环条件和判断条件的标识符来结束掉线程。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i=0;  </span><br><span class="line">    boolean next=true;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (next) &#123;  </span><br><span class="line">            if(i==10)  </span><br><span class="line">                next=false;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li>synchronized 关键字</li></ul><p>即有synchronized关键字修饰的方法。由于Java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public synchronized void buy(int i)&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;我买&quot; + i + &quot;个苹果&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了修饰方法，synchronized关键字也可以修饰代码块，根据传入对象的不同，可以分为Java对象锁和类锁。对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void test()&#123;</span><br><span class="line">    String a = &quot;a&quot;;// 随便一个String不变量</span><br><span class="line">    sychronized(a)&#123;// 这个锁只在方法内，加入这个类中还有其他的对象锁方法，则两者互不影响</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized(this)&#123;// 对象锁，其中this也可以使用类中定义的全局变量，不能是静态变量</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void buy(int i)&#123;// 对象锁</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized (Buy.class)&#123;//类锁</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static synchronized void test2()//类锁 </span><br><span class="line">&#123;  </span><br><span class="line">   try &#123;</span><br><span class="line">       Thread.sleep(2000);</span><br><span class="line">   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用特殊域变量volatile</li></ul><p><a href="http://zhongyp.me/2018/01/04/Volatile/">volatile详解</a></p><ul><li>使用重入锁Lock</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">private int account = 100;</span><br><span class="line">//需要声明这个锁</span><br><span class="line">private Lock lock = new ReentrantLock();</span><br><span class="line">public int getAccount() &#123;</span><br><span class="line">    return account;</span><br><span class="line">&#125;</span><br><span class="line">//这里不再需要synchronized </span><br><span class="line">public void save(int money) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        account += money;</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><ul><li><p>wait()，notify()，notifyAll()</p><p>线程执行wait()后，就放弃了运行资格，wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。；线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。notifyall(), 唤醒线程池中所有线程。</p></li></ul><p style="color:red">注：</p> <p>（1） wait(), notify(),notifyall()都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；</p><p>（2） wait(),notify(),notifyall(),  在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。</p><ul><li>Condition</li></ul><p>jdk1.5中，提供了多线程的升级解决方案为：</p><pre><code>（1）将同步synchronized替换为显式的Lock操作；（2）将Object类中的wait(), notify(),notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取;（3）一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而jdk1.5之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Resource&#123;  </span><br><span class="line">    private String name;  </span><br><span class="line">    private int count=1;  </span><br><span class="line">    private boolean flag=false;  </span><br><span class="line">    private Lock lock = new ReentrantLock();/*Lock是一个接口，ReentrantLock是该接口的一个直接子类。*/  </span><br><span class="line">    private Condition condition_pro=lock.newCondition(); /*创建代表生产者方面的Condition对象*/  </span><br><span class="line">    private Condition condition_con=lock.newCondition(); /*使用同一个锁，创建代表消费者方面的Condition对象*/  </span><br><span class="line">      </span><br><span class="line">    public void set(String name)&#123;  </span><br><span class="line">        lock.lock();//锁住此语句与lock.unlock()之间的代码  </span><br><span class="line">        try&#123;  </span><br><span class="line">            while(flag)  </span><br><span class="line">                condition_pro.await(); //生产者线程在conndition_pro对象上等待  </span><br><span class="line">            this.name=name+&quot;---&quot;+count++;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name);  </span><br><span class="line">            flag=true;  </span><br><span class="line">             condition_con.signalAll();  </span><br><span class="line">        &#125;  </span><br><span class="line">        finally&#123;  </span><br><span class="line">            lock.unlock(); //unlock()要放在finally块中。  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void out()&#123;  </span><br><span class="line">        lock.lock(); //锁住此语句与lock.unlock()之间的代码  </span><br><span class="line">        try&#123;  </span><br><span class="line">            while(!flag)  </span><br><span class="line">                condition_con.await(); //消费者线程在conndition_con对象上等待  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name);  </span><br><span class="line">        flag=false;  </span><br><span class="line">        condition_pro.signqlAll(); /*唤醒所有在condition_pro对象下等待的线程，也就是唤醒所有生产者线程*/  </span><br><span class="line">        &#125;  </span><br><span class="line">        finally&#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阻塞队列BlockingQueue</li></ul><p>BlockingQueue是一个接口，也是Queue的子接口。BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从BlockingQueue中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。</p><p>BlockingQueue提供如下两个支持阻塞的方法：</p><pre><code>（1）put(E e)：尝试把Eu元素放如BlockingQueue中，如果该队列的元素已满，则阻塞该线程。（2）take（）：尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。</code></pre><p>BlockingQueue继承了Queue接口，当然也可以使用Queue接口中的方法，这些方法归纳起来可以分为如下三组：</p><pre><code>（1）在队列尾部插入元素，包括add（E e）、offer（E e）、put（E e）方法，当该队列已满时，这三个方法分别会抛出异常、返回false、阻塞队列。（2）在队列头部删除并返回删除的元素。包括remove（）、poll（）、和take（）方法，当该队列已空时，这三个方法分别会抛出异常、返回false、阻塞队列。（3）在队列头部取出但不删除元素。包括element（）和peek（）方法，当队列已空时，这两个方法分别抛出异常、返回false。</code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a href="http://zhongyp.me/2018/03/10/ThreadPool/">线程池博文</a></p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程状态&quot;&gt;&lt;a href=&quot;#线程状态&quot; class=&quot;headerlink&quot; title=&quot;线程状态&quot;&gt;&lt;/a&gt;线程状态&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;新建：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://zhongyp.me/2018/03/16/concurrent/2018-03-16-ThreadLocal/"/>
    <id>http://zhongyp.me/2018/03/16/concurrent/2018-03-16-ThreadLocal/</id>
    <published>2018-03-15T16:00:00.000Z</published>
    <updated>2018-10-02T01:27:53.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal基本原理"><a href="#ThreadLocal基本原理" class="headerlink" title="ThreadLocal基本原理"></a>ThreadLocal基本原理</h2><h3 id="ThreadLocal的作用"><a href="#ThreadLocal的作用" class="headerlink" title="ThreadLocal的作用"></a>ThreadLocal的作用</h3><p>ThreadLocal提供本地线程变量。</p><h3 id="ThreadLocal示例"><a href="#ThreadLocal示例" class="headerlink" title="ThreadLocal示例"></a>ThreadLocal示例</h3><p>那ThreadLocal是怎样给本地线程提供线程变量的呢？看下面的示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        final ThreadLocal threadLocal = new ThreadLocal();</span><br><span class="line">        Thread thread1 = new Thread()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                threadLocal.set(&quot;a&quot;);</span><br><span class="line">                System.out.println(threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                threadLocal.set(&quot;b&quot;);</span><br><span class="line">                System.out.println(threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread3 = new Thread()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                threadLocal.set(&quot;c&quot;);</span><br><span class="line">                System.out.println(threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        </span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果输出：<br>a<br>b<br>c</p><p>代码示例解读：</p><p>1.首先声明一个ThreadLocal变量</p><p>2.在每个线程内，通过threadLocal.set()的方法为当前线程提供线程变量，set()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();// 获取当前线程</span><br><span class="line">    ThreadLocalMap map = getMap(t);// 通过getMap 获取 Thread对象的threadlocal.ThreadLocalMap</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);// 以this(ThreadLocal本身)为Key,参数value为值进行保存</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ThreadLocal 是一个和Thread无关的对象，可以把它理解成一个工具，如果需要给线程提供线程变量，就用ThreadLocal的set()方法给线程提供变量。</p><p>注：ThreadLocal在当前线程内都可用，不局限于当前方法内。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ThreadLocal基本原理&quot;&gt;&lt;a href=&quot;#ThreadLocal基本原理&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal基本原理&quot;&gt;&lt;/a&gt;ThreadLocal基本原理&lt;/h2&gt;&lt;h3 id=&quot;ThreadLocal的作
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java值传递</title>
    <link href="http://zhongyp.me/2018/03/10/java/2018-03-10-JavaPara/"/>
    <id>http://zhongyp.me/2018/03/10/java/2018-03-10-JavaPara/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-10-02T01:27:53.330Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理一些之前的博客，发现关于Java值传递的问题还是有些模糊，在此再整理一下。</p><p>对于Java的值传递，并不想C++一样可以由自己掌控，不过理解Java的值传递后感觉比C++简单。</p><p><b style="color: red">可能理解不太对，欢迎大家加我qq打我脸，谢谢！！！（QQ:879376937）</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int[] b = &#123;1&#125;;</span><br><span class="line">        StringBuilder sb = new StringBuilder(&quot;22&quot;);</span><br><span class="line">        change(sb);</span><br><span class="line">        System.out.print(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(int a)&#123;</span><br><span class="line">        a=10;// 不起作用</span><br><span class="line">    &#125;</span><br><span class="line">    public static void change(int[] b)&#123;</span><br><span class="line">        b[0]=10;// 起作用</span><br><span class="line">    &#125;</span><br><span class="line">    public static void change(StringBuilder sb)&#123;</span><br><span class="line">//        sb.append(&quot;3&quot;);// 起作用</span><br><span class="line">        StringBuilder sb1 = new StringBuilder(&quot;232&quot;);</span><br><span class="line">        sb=sb1;// 不起作用</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面这个例子我用了int常量，数组，StringBuilder对象三种参数值作为Java参数进行传递，总的来说这三种参数值从宏观上来说性质是一样的，都是对传递对象的引用复制，例如a, main方法定义的a是对常量池中1的引用，change(int a)中的a是对main方法a的引用，这里一定要明白这两个a是两个对象，所以我们更改change中a的值，实质上是把change方法中a的引用从对main方法中a的引用改为引用常量池上的10，所以main 方法中的a值不会发生变化。</p><p>对于b和sb对象参数传递，其实质a对象一样，都是对main方法中的b和sb对象的引用。不同的是，在b[0]赋值时，因为change方法中的b引用main 方法中的b对象，所以change中的b[0]没有办法赋值，只能交给main方法中的b去赋值，这样更改的就是main中b对象所引用的数组实例，所以起了作用。</p><p>change方法中sb在append赋值时和b[0]赋值的情况一样。</p><p>sb=sb1,这种情况是和a对象重新赋值类似，不过不再是常量池中的常数对象10，而是StringBuilder对象sb1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在整理一些之前的博客，发现关于Java值传递的问题还是有些模糊，在此再整理一下。&lt;/p&gt;
&lt;p&gt;对于Java的值传递，并不想C++一样可以由自己掌控，不过理解Java的值传递后感觉比C++简单。&lt;/p&gt;
&lt;p&gt;&lt;b style=&quot;color: red&quot;&gt;可能理解不太对，
      
    
    </summary>
    
    
      <category term="Java" scheme="http://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo工作原理</title>
    <link href="http://zhongyp.me/2018/03/07/dubbo/2018-03-07-DubboPrinciple/"/>
    <id>http://zhongyp.me/2018/03/07/dubbo/2018-03-07-DubboPrinciple/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-10-27T03:31:36.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo启动初始化"><a href="#Dubbo启动初始化" class="headerlink" title="Dubbo启动初始化"></a>Dubbo启动初始化</h2><p>我们大都可能都是用过Dubbo分布式服务架构，但是大部分使用的人可能只是使用并不了解Dubbo是怎样初始化加载的，本篇博文将使用最简单的dubbo-demo例子来描述Dubbo的启动初始化。</p><h2 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h2><p>dubbo框架设计总共分了10层： </p><ul><li><p>服务接口层（Service）：该层是与实际业务逻辑相关，就如下面面demo配置的<code>&lt;dubbo:service interface=&quot;com.xxx.xxx.xxxService&quot; ref=&quot;xxxService&quot; timeout=&quot;5000&quot;/&gt;</code>,这个service就是业务方自己定义的接口与其实现。</p></li><li><p>配置层（Config）：该层是将业务方的service信息，配置文件的信息收集起来，主要是以ServiceConfig和ReferenceConfig为中心，ServiceConfig是服务提供方的配置，当Spring启动的时候会相应的启动provider服务发布和注册的过程，当service在spring容器加载完成后，ServiceBean通过监听器监听spring容器是否加载完毕，然后出发监听方法，onApplicationEvent-&gt;export-&gt;doExport-&gt;doExportUrls-&gt;doExportUrlsFor1Protocol,最后得到provider的代理对象invoker，Procotol将invoker封装为Exporter。</p></li><li><p>服务代理层（Proxy）：对服务接口进行透明代理，生成服务的客户端和服务器端，使服务的远程调用就像在本地调用一样。默认使用JavassistProxyFactory，返回一个Invoker，Invoker则是个可执行核心实体，Invoker的invoke方法通过反射执行service方法。</p></li><li><p>服务注册层（Registry）：封装服务地址的注册和发现，以服务URL为中心，基于zk。</p></li><li><p>集群层（Cluster）:提供多个节点并桥接注册中心，主要负责负载均衡（loadBanlance）、容错。</p></li><li><p>监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。</p></li><li><p>远程调用层（Protocol）：封装RPC调用，provider通过export方法进行暴露服务/consumer通过refer方法调用服务。而Protocol依赖的是Invoker。通过上面说的Proxy获得的Invoker，包装成Exporter。</p></li><li><p>信息交换层（Exchange）：该层封装了请求响应模型，将同步转为异步，信息交换层依赖Exporter，最终将通过网络传输层接收调用请求RequestFuture和ResponseFuture。</p></li><li><p>网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。</p></li><li><p>数据序列化层：该层无需多言，将数据序列化反序列化。</p></li></ul><p>先看到demo中的spring-dubbo配置文件。这些配置文件全都会被装配成RegistryConfig，其属性如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RegistryConfig extends AbstractConfig &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 5508512956753757169L;</span><br><span class="line"></span><br><span class="line">    public static final String NO_AVAILABLE = &quot;N/A&quot;;</span><br><span class="line"></span><br><span class="line">    // 注册中心地址</span><br><span class="line">    private String            address;</span><br><span class="line"></span><br><span class="line">    // 注册中心登录用户名</span><br><span class="line">    private String            username;</span><br><span class="line"></span><br><span class="line">    // 注册中心登录密码</span><br><span class="line">    private String            password;</span><br><span class="line"></span><br><span class="line">    // 注册中心缺省端口</span><br><span class="line">    private Integer           port;</span><br><span class="line"></span><br><span class="line">    // 注册中心协议</span><br><span class="line">    private String            protocol;</span><br><span class="line"></span><br><span class="line">    // 客户端实现</span><br><span class="line">    private String            transporter;</span><br><span class="line"></span><br><span class="line">    private String            server;</span><br><span class="line"></span><br><span class="line">    private String            client;</span><br><span class="line"></span><br><span class="line">    private String            cluster;</span><br><span class="line"></span><br><span class="line">    private String            group;</span><br><span class="line"></span><br><span class="line">    private String            version;</span><br><span class="line"></span><br><span class="line">    // 注册中心请求超时时间(毫秒)</span><br><span class="line">    private Integer           timeout;</span><br><span class="line"></span><br><span class="line">    // 注册中心会话超时时间(毫秒)</span><br><span class="line">    private Integer           session;</span><br><span class="line"></span><br><span class="line">    // 动态注册中心列表存储文件</span><br><span class="line">    private String            file;</span><br><span class="line"></span><br><span class="line">    // 停止时等候完成通知时间</span><br><span class="line">    private Integer           wait;</span><br><span class="line"></span><br><span class="line">    // 启动时检查注册中心是否存在</span><br><span class="line">    private Boolean           check;</span><br><span class="line"></span><br><span class="line">    // 在该注册中心上注册是动态的还是静态的服务</span><br><span class="line">    private Boolean           dynamic;</span><br><span class="line"></span><br><span class="line">    // 在该注册中心上服务是否暴露</span><br><span class="line">    private Boolean           register;</span><br><span class="line"></span><br><span class="line">    // 在该注册中心上服务是否引用</span><br><span class="line">    private Boolean           subscribe;</span><br><span class="line"></span><br><span class="line">    // 自定义参数</span><br><span class="line">    private Map&lt;String, String&gt; parameters;</span><br><span class="line"></span><br><span class="line">    // 是否为缺省</span><br><span class="line">    private Boolean             isDefault;</span><br></pre></td></tr></table></figure><p>这些配置文件根据注册中心的个数会被装配拼接成Dubbo的URL（该url是dubbo中自定义的），该URL长这个样子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">registry://sit-zk.host:2181/com.alibaba.dubbo.registry.RegistryService?application=ifenqu-web&amp;dubbo=2.5.3&amp;pid=13168&amp;registry=zookeeper&amp;timestamp=1510828420296</span><br></pre></td></tr></table></figure></p><p>看完配置信息，接下来让我们看下Service发布的核心方法：ServiceConfig类中的doExportUrls<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void doExportUrls() &#123;</span><br><span class="line">    //该方法根据配置文件装配成一个URL的list</span><br><span class="line">    List&lt;URL&gt; registryURLs = loadRegistries(true);</span><br><span class="line">    //根据每一个协议配置来分别暴露服务</span><br><span class="line">    for (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个protocols长这个样子<code>&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20888&quot; id=&quot;dubbo&quot; /&gt;</code>protocols也是根据配置装配出来的。接下来让我们进入doExportUrlsFor1Protocol方法看看dubbo具体是怎么样将服务暴露出去的。这个方法特别大，有将近300多行代码，但是其中大部分都是获取类似protocols的name、port、host和一些必要的上下文，代码太长就不全都贴出来了，只贴关键部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; </span><br><span class="line">//........省略获取上下文代码</span><br><span class="line">//通过interfaceClass获取要暴露服务的所有要暴露的方法</span><br><span class="line">String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">//.......省略非核心代码</span><br><span class="line">//根据上下文创建URL对象</span><br><span class="line"> URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);</span><br><span class="line"></span><br><span class="line">//通过proxyFactory来获取Invoker对象</span><br><span class="line"> Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">//将invoker对象在protocol中封装成Exporter方便提供给信息交换层进行网络传输</span><br><span class="line"> Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line"> //将exporter添加到list中</span><br><span class="line"> exporters.add(exporter);</span><br></pre></td></tr></table></figure><p>看到这里就比较明白dubbo的工作原理了doExportUrlsFor1Protocol方法，先创建URL，URL创建出来长这样<code>dubbo://192.168.xx.63:20888/com.xxx.xxx.VehicleInfoService?anyhost=true&amp;application=test-web&amp;default.retries=0&amp;dubbo=2.5.3&amp;interface=com.xxx.xxx.VehicleInfoService&amp;methods=get,save,update,del,list&amp;pid=13168&amp;revision=1.2.38&amp;side=provider&amp;timeout=5000&amp;timestamp=1510829644847</code>，是不是觉得这个URL很眼熟，没错在注册中心看到的services的providers信息就是这个，再传入url通过proxyFactory获取Invoker，再将Invoker封装成Exporter的数组，只需要将这个list提供给网络传输层组件，然后consumer执行Invoker的invoke方法就行了。让我们再看看这个proxyFactory的getInvoker方法。proxyFactory下有JDKProxyFactory和JavassistProxyFactory。官方推荐也是默认使用的是JavassistProxyFactory。因为javassist动态代理性能比JDK的高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class JavassistProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        // TODO Wrapper类不能正确处理带$的类名</span><br><span class="line">        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName, </span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes, </span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用了动态代理的方式调用了要暴露的service的方法。并且返回了Invoker对象。在dubbo的服务发布中我们可以看到，这个Invoker贯穿始终，都可以看成是一个context的作用了，让我们进Invoker里面去看看这个Invoker到底是何方神圣。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Invoker&lt;T&gt; extends Node &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get service interface.</span><br><span class="line">     * </span><br><span class="line">     * @return service interface.</span><br><span class="line">     */</span><br><span class="line">    Class&lt;T&gt; getInterface();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * invoke.</span><br><span class="line">     * </span><br><span class="line">     * @param invocation</span><br><span class="line">     * @return result</span><br><span class="line">     * @throws RpcException</span><br><span class="line">     */</span><br><span class="line">    Result invoke(Invocation invocation) throws RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Invoker就两个方法，一个getInterface，也就是要暴露的服务接口，一个就是invoke方法，这个invoke方法在AbstractProxyInvoker中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    //调用doInvoke方法，返回一个Result</span><br><span class="line">        return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        return new RpcResult(e.getTargetException());</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Failed to invoke remote proxy method &quot; + invocation.getMethodName() + &quot; to &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实看到JavassistProxyFactory大家就应该大概明白了这个Invoker的作用，同时这个类的名字就叫Invoker也可以猜个大概，Invoker就是调用service的方法的实体类。其中doInvoke方法已经在JavassistProxyFactory中定义了，通过反射调用要暴露的service的方法。</p><p>业务方将服务接口和实现编写定义好，添加dubbo相关配置文件。</p><ul><li><p>Config层加载配置文件形成上下文，Config层包括：ServiceConfig、ProviderConfig、RegistryConfig等。</p></li><li><p>ServiceConfig根据Protocol类型，根据ProtocolConfig、ProviderConfig加载registry，根据加载的registry创建dubbo的URL。</p></li><li><p>准备工作做完后ProxyFactory上场，dubbo中有两种代理方式，JDK代理和Javassist代理，默认使用Javassist代理，Proxy代理类根据dubbo配置信息获取到接口信息、通过动态代理方式将接口的所有方法交给Proxy代理类进行代理，并封装进Invoker里面。</p></li><li><p>将所有需要暴露的service封装的Invoker组成一个list传给信息交换层提供给消费方进行调用。</p></li></ul><p>有需要的同学可以去下载源码这样可能更方便了解</p><p>Demo代码<a href="https://github.com/zhongyp/bodu/bodu-dubbo" target="_blank" rel="noopener">下载地址</a></p><p>代码结构：</p><p>src</p><ul><li><p>main</p><ul><li>java<ul><li>com.bodu.dubbo<ul><li>api<ul><li>DemoService.java</li></ul></li><li>consumer<ul><li>Consumer.java</li></ul></li><li>producer<ul><li>DemoServiceImpl.java</li><li>Producer</li></ul></li></ul></li></ul></li><li>resources<ul><li>dubbo-demo-producer.xml</li><li>dubbo-demo-consumer.xml</li></ul></li></ul></li><li><p>pom.xml</p></li></ul><p>pom.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;dubbo.version&gt;2.5.4&lt;/dubbo.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>DemoService.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface DemoService &#123;</span><br><span class="line"></span><br><span class="line">    String sayHello(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Producer.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;dubbo-demo-producer.xml&quot;&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">// 添加监听，点击任何键，退出服务</span><br><span class="line">        System.in.read(); // press any key to exit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DemoServiceImpl.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DemoServiceImpl implements DemoService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()) + &quot;] Hello &quot; + name + &quot;, request from consumer: &quot; + RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        return &quot;Hello &quot; + name + &quot;, response form provider: &quot; + RpcContext.getContext().getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dubbo-demo-producer.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 生产者的名称，用于跟踪依赖关系 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;demo-provider&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用组播注册中心来暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用dubbo协议暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 接口的实现类 --&gt;</span><br><span class="line">    &lt;bean id=&quot;demoService&quot; class=&quot;com.bodu.dubbo.producer.DemoServiceImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义用于暴露的服务接口 --&gt;</span><br><span class="line">    &lt;dubbo:service interface=&quot;com.bodu.dubbo.api.DemoService&quot; ref=&quot;demoService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arsgs)&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;dubbo-demo-producer.xml&quot;&#125;);// 获取dubbo-demo-producer.xml配置文件</span><br><span class="line">        context.start();// 初始化配置文件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Consumer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Prevent to get IPV6 address,this way only work in debug mode</span><br><span class="line">        //But you can pass use -Djava.net.preferIPv4Stack=true,then it work well whether in debug mode or not</span><br><span class="line">        // 防止取到IPV6的地址，这种方式仅适用于debug模式，但是你可以直接使用-Djava.net.preferIPv4Stack=true，这样不管是否是debug模式，运行都不会有问题</span><br><span class="line">        System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);</span><br><span class="line">        // 获取配置文件初始化xml</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;dubbo-demo-consuner.xml&quot;&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        // 获取远程服务代理</span><br><span class="line">        DemoService demoService = (DemoService) context.getBean(&quot;demoService&quot;); // get remote service proxy</span><br><span class="line">        // 循环访问远程代理服务</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                String hello = demoService.sayHello(&quot;world&quot;); // call remote method</span><br><span class="line">                System.out.println(hello); // get result</span><br><span class="line"></span><br><span class="line">            &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>dubbo-demo-consumer.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 消费者的名称，用于跟踪依赖关系，不要和生产者名称相同  --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;demo-consumer&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用广播发现服务 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 生成远程服务代理，远程服务代理可以向使用本地的接口一样使用 --&gt;</span><br><span class="line">    &lt;dubbo:reference id=&quot;demoService&quot; check=&quot;false&quot; interface=&quot;com.bodu.dubbo.api.DemoService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="http://blog.csdn.net/nethackatschool/article/details/78560574" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo启动初始化&quot;&gt;&lt;a href=&quot;#Dubbo启动初始化&quot; class=&quot;headerlink&quot; title=&quot;Dubbo启动初始化&quot;&gt;&lt;/a&gt;Dubbo启动初始化&lt;/h2&gt;&lt;p&gt;我们大都可能都是用过Dubbo分布式服务架构，但是大部分使用的人可能只是使用
      
    
    </summary>
    
    
      <category term="Dubbo" scheme="http://zhongyp.me/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://zhongyp.me/2018/03/07/algorithm/2018-03-07-RedBlackTree/"/>
    <id>http://zhongyp.me/2018/03/07/algorithm/2018-03-07-RedBlackTree/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-10-26T08:44:22.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://www.cnblogs.com/sandy2013/p/3270999.html" target="_blank" rel="noopener">博文转载：https://www.cnblogs.com/sandy2013/p/3270999.html</a></p><h2 id="红黑树和平衡二叉树的区别"><a href="#红黑树和平衡二叉树的区别" class="headerlink" title="红黑树和平衡二叉树的区别"></a>红黑树和平衡二叉树的区别</h2><ul><li><p>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。</p></li><li><p>平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。<br>平衡二叉树又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。构造与调整方法 平衡二叉树的常用算法有红黑树、AVL、Treap等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;红黑树&quot;&gt;&lt;a href=&quot;#红黑树&quot; class=&quot;headerlink&quot; title=&quot;红黑树&quot;&gt;&lt;/a&gt;红黑树&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sandy2013/p/3270999.html&quot; target=
      
    
    </summary>
    
    
      <category term="算法" scheme="http://zhongyp.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>原子读语义（转载）</title>
    <link href="http://zhongyp.me/2018/03/04/concurrent/2018-03-04-Automic/"/>
    <id>http://zhongyp.me/2018/03/04/concurrent/2018-03-04-Automic/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-10-27T03:34:29.438Z</updated>
    
    <content type="html"><![CDATA[<p>在谈谈java中的volatile一文中，我们提到过并发包中的原子类可以解决类似num++这样的复合类操作的原子性问题，相比锁机制，使用原子类更精巧轻量，性能开销更小，本章就一起来分析下原子类的实现机理。</p><h2 id="悲观的解决方案（阻塞同步）"><a href="#悲观的解决方案（阻塞同步）" class="headerlink" title="悲观的解决方案（阻塞同步）"></a>悲观的解决方案（阻塞同步）</h2><p>　　<br>    我们知道，num++看似简单的一个操作，实际上是由1.读取 2.加一 3.写入 三步组成的，这是个复合类的操作（所以我们之前提到过的volatile是无法解决num++的原子性问题的），在并发环境下，如果不做任何同步处理，就会有线程安全问题。最直接的处理方式就是加锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">synchronized(this)&#123;</span><br><span class="line">    num++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>　　使用独占锁机制来解决，是一种悲观的并发策略，抱着一副“总有刁民想害朕”的态势，每次操作数据的时候都认为别的线程会参与竞争修改，所以直接加锁。同一刻只能有一个线程持有锁，那其他线程就会阻塞。线程的挂起恢复会带来很大的性能开销，尽管jvm对于非竞争性的锁的获取和释放做了很多优化，但是一旦有多个线程竞争锁，频繁的阻塞唤醒，还是会有很大的性能开销的。所以，使用synchronized或其他重量级锁来处理显然不够合理。</p><h2 id="乐观的解决方案（非阻塞同步）"><a href="#乐观的解决方案（非阻塞同步）" class="headerlink" title="乐观的解决方案（非阻塞同步）"></a>乐观的解决方案（非阻塞同步）</h2><p>　　乐观的解决方案，顾名思义，就是很大度乐观，每次操作数据的时候，都认为别的线程不会参与竞争修改，也不加锁。如果操作成功了那最好；如果失败了，比如中途确有别的线程进入并修改了数据（依赖于冲突检测），也不会阻塞，可以采取一些补偿机制，一般的策略就是反复重试。很显然，这种思想相比简单粗暴利用锁来保证同步要合理的多。</p><p>　　鉴于并发包中的原子类其实现机理都差不太多，本章我们就通过AtomicInteger这个原子类来进行分析。我们先来看看对于num++这样的操作AtomicInteger是如何保证其原子性的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Atomically increments by one the current value.</span><br><span class="line">     *</span><br><span class="line">     * @return the updated value</span><br><span class="line">     */</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = get();</span><br><span class="line">            int next = current + 1;</span><br><span class="line">            if (compareAndSet(current, next))</span><br><span class="line">                return next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　我们来分析下incrementAndGet的逻辑：1.先获取当前的value值，2.对value加一，3.第三步是关键步骤，调用compareAndSet方法来来进行原子更新操作，这个方法的语义是：</p><p>先检查当前value是否等于current，如果相等，则意味着value没被其他线程修改过，更新并返回true。如果不相等，compareAndSet则会返回false，然后循环继续尝试更新。compareAndSet调用了Unsafe类的compareAndSwapInt方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Atomically sets the value to the given updated value</span><br><span class="line">     * if the current value &#123;@code ==&#125; the expected value.</span><br><span class="line">     *</span><br><span class="line">     * @param expect the expected value</span><br><span class="line">     * @param update the new value</span><br><span class="line">     * @return true if successful. False return indicates that</span><br><span class="line">     * the actual value was not equal to the expected value.</span><br><span class="line">     */</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Unsafe的compareAndSwapInt是个native方法，也就是平台相关的。它是基于CPU的CAS指令来完成的。</p><p><code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code></p><h3 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS(Compare-and-Swap)　"></a>CAS(Compare-and-Swap)　</h3><p>　<br>　　CAS算法是由硬件直接支持来保证原子性的，有三个操作数：内存位置V、旧的预期值A和新值B，当且仅当V符合预期值A时，CAS用新值B原子化地更新V的值，否则，它什么都不做。</p><pre><code>CAS的ABA问题</code></pre><p>　　当然CAS也并不完美，它存在”ABA”问题，假若一个变量初次读取是A，在compare阶段依然是A，但其实可能在此过程中，它先被改为B，再被改回A，而CAS是无法意识到这个问题的。CAS只关注了比较前后的值是否改变，而无法清楚在此过程中变量的变更明细，这就是所谓的ABA漏洞。 </p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/chengxiao/p/6789109.html" target="_blank" rel="noopener">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在谈谈java中的volatile一文中，我们提到过并发包中的原子类可以解决类似num++这样的复合类操作的原子性问题，相比锁机制，使用原子类更精巧轻量，性能开销更小，本章就一起来分析下原子类的实现机理。&lt;/p&gt;
&lt;h2 id=&quot;悲观的解决方案（阻塞同步）&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>经典面试题整理</title>
    <link href="http://zhongyp.me/2018/03/02/interfaceview/2018-03-02-Classic/"/>
    <id>http://zhongyp.me/2018/03/02/interfaceview/2018-03-02-Classic/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-10-02T01:27:53.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="corejava"><a href="#corejava" class="headerlink" title="corejava"></a>corejava</h2><ol><li><p>hashcode 相等两个类一定相等么？equals呢？相反呢？</p></li><li><p>介绍一下集合框架</p></li><li><p>hashmap hashtable 底层实现什么区别？hashtale和concurrenthashmap呢？</p></li><li><p>hashmap和treemap 什么区别？底层数据结构呢？</p></li><li><p>线程池用过么？都有什么参数？底层如何实现的？</p></li><li><p>sychnized和Lock什么区别？sychnize什么情况是对象锁，什么时候是全局锁？为什么？</p></li><li><p>ThreadLocal 是什么？底层如何实现？写一个例子？</p></li><li><p>volitile的工作原理？</p></li><li><p>cas知道么？如何实现的？</p></li><li><p>请用至少四种写法？写一个单例模式？</p></li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol><li><p>请介绍一下JVM内存模型？用过什么垃圾回收器，都说说？</p></li><li><p>线上发送频繁full gc如何处理？CPU使用率过高怎么办？如何定位问题？如何解决？说一下解决思路和处理方法。</p></li><li><p>知道字节码么？字节码都有那些？Integer * 5,int y=5, 比较x==y 都经过那些步骤？</p></li><li><p>讲讲类加载机制？都有哪些类加载器，这些类加载器都加载哪些文件？手写一下类加载Demo</p></li><li><p>知道osgi么？他是如何实现的？</p></li><li><p>请问你做过哪些JVM优化？使用什么方法？达到什么效果？</p></li></ol><ol start="7"><li>class.forName(“java.lang.String”)和String.class.getClassLoader.loadClass(“java.lang.String”)什么区别？</li></ol><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol><li><p>spring都有哪些机制？AOP底层如何实现的？IOC？</p></li><li><p>cglib知道么？它和JDK动态代理有什么区别？手写一个jdk动态代理？</p></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li><p>使用mysql索引都有哪些原则？索引什么数据结构？B+tree和B tree什么区别？</p></li><li><p>mysql有哪些存储引擎啊？都有啥区别？要详细？</p></li><li><p>设计高并发系统数据库层面该怎么设计？数据库锁有哪些类型？如何实现？</p></li><li><p>数据库事务有哪些？</p></li></ol><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ol><li><p>如何设计可以动态扩容缩容的分库分表方案？</p></li><li><p>用过哪些分库分表的中间件，有啥优点和缺点，讲一下你了解的分库分表中间件的底层实现原理。</p></li><li><p>我现在有一个未分库分表的系统，以后系统需要分库分表，如何设计，让未分库分表的系统动态切换到分库分表系统上？</p></li><li><p>分布式事务知道么？ 你们怎么解决的？ TCC?那若出现网络原因，网络连不通怎么办啊？</p></li><li><p>为什么分库分表？</p></li><li><p>分布式寻址方式都有哪些算法？知道一致hash么？手写一下Java实现代码？你若userId取模分片，那我要查一段连续时间里的数据怎么办？</p></li><li><p>如何解决分库分表主键问题？有什么实现方案？</p></li></ol><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><ol><li><p>redis和memched 什么区别？为什么单线程的redis比多线程的memched效率要高？</p></li><li><p>redis有什么数据类型？都在哪些场景下使用？</p></li><li><p>redis的主从复制是怎么实现的？redis的集群模式是如何实现的呢？redis的key是如何寻址的？</p></li><li><p>使用redis如何设计分布式锁？使用zk可以么？如何实现？这两种哪个效率更高？</p></li><li><p>知道redis的持久化么？有什么优点和缺点？具体底层实现呢？</p></li><li><p>redis过期策略都有哪些？LRU？写一下Java版本代码？</p></li></ol><h2 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h2><ol><li><p>说一下dubbo的实现过程，注册中心挂了可以继续通信么？</p></li><li><p>zk原理知道么？zk都可以干什么？paxos算法知道么？说一下原理和实现？</p></li><li><p>dubbo支持哪些序列化协议？hessian？说一下hessian的数据结构？PB知道么？为啥PB效率是最高的？</p></li><li><p>知道netty么？netty可以干嘛？NIO,BIO,AIO都是什么啊？有什么区别？</p></li><li><p>dubbo复制均衡策略和高可用策略都有哪些？动态代理策略呢？</p></li><li><p>为什么要进行系统拆分啊？拆分不用dubbo可以么？dubbo和thrift什么区别啊？</p></li></ol><h2 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h2><ol><li><p>为什么使用消息队列？消息队列有什么优点和缺点？</p></li><li><p>如何保证消息队列的高可用？如何保证消息不被重复消费？</p></li><li><p>kafka，activemq，rabbitmq，rocketmq都有什么优点和缺点？</p></li><li><p>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路？</p></li></ol><h2 id="分布式搜索引擎"><a href="#分布式搜索引擎" class="headerlink" title="分布式搜索引擎"></a>分布式搜索引擎</h2><ol><li><p>es的工作过程实现是如何的？如何实现分布式的啊？</p></li><li><p>es在数据量很大的情况下，如何提高查询效率？</p></li><li><p>es的查询是一个怎么的工作过程？底层的lucence介绍一下？倒排索引知道么？es和mongodb什么区别？都在什么场景下使用？</p></li></ol><h2 id="高并发高可用架构设计"><a href="#高并发高可用架构设计" class="headerlink" title="高并发高可用架构设计"></a>高并发高可用架构设计</h2><ol><li><p>如何设计一个高并发高可用系统？</p></li><li><p>如何限流？工程中怎么做的，说一下具体实现？</p></li><li><p>缓存如何使用的？缓存使用不会造成什么后果？</p></li><li><p>如何熔断？熔断框架都有哪些？具体实现原理知道么？</p></li><li><p>如何降级？ 如何进行系统拆分？如何数据库拆分？</p></li></ol><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><ol><li><p>说一下TCP/IP 四层？</p></li><li><p>http的工作流程？ http1.0 http1.1 http2.0具体哪些区别？</p></li><li><p>TCP三次握手，四层分手的工作流程？画一下流程图？为什么不是四次五次或者两次？</p></li><li><p>画一下https的工作流程？具体如何实现？如何防止被抓包？</p></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>45亿阿拉伯数字，如何进行去重？如何找出最大的那个数？</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>二叉树和红黑树</li></ol><p><a href="https://www.jianshu.com/p/a07d1d4004b0" target="_blank" rel="noopener">博文推荐</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;corejava&quot;&gt;&lt;a href=&quot;#corejava&quot; class=&quot;headerlink&quot; title=&quot;corejava&quot;&gt;&lt;/a&gt;corejava&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;hashcode 相等两个类一定相等么？equals呢？相反呢？&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhongyp.me/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo服务端发布（转载）</title>
    <link href="http://zhongyp.me/2018/02/15/dubbo/2018-02-15-Dubbo-Provider/"/>
    <id>http://zhongyp.me/2018/02/15/dubbo/2018-02-15-Dubbo-Provider/</id>
    <published>2018-02-14T16:00:00.000Z</published>
    <updated>2018-10-27T03:32:17.186Z</updated>
    
    <content type="html"><![CDATA[<p> dubbo自定义标签 里面说过启动服务时会首先加载XML文件中的标签，解析出来的标签数据会装配到对应的实体类中，dubbo框架里面也是这样的。我们首先看看com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler类的实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123;  </span><br><span class="line">  </span><br><span class="line">    static &#123;  </span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void init() &#123;  </span><br><span class="line">        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));  // ServiceBean</span><br><span class="line">        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean实现了spring的ApplicationListener接口，所以也是一个监听器。在spring容器加载完成后触发contextrefreshedevent事件，这个事件会被实现了ApplicationListener接口的类监听到，执行对应的onApplicationEvent函数。我们看看ServiceBean类的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void onApplicationEvent(ApplicationEvent event) &#123;  </span><br><span class="line">    if (ContextRefreshedEvent.class.getName().equals(event.getClass().getName())) &#123;  </span><br><span class="line">        if (isDelay() &amp;&amp; ! isExported() &amp;&amp; ! isUnexported()) &#123;  </span><br><span class="line">            if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">                logger.info(&quot;The service ready on spring started. service: &quot; + getInterface());  </span><br><span class="line">            &#125;  </span><br><span class="line">            export();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个监听方法最终调用了export方法来实现服务的发布处理。因为ServiceBean继承了ServiceConfig类，所以最终还是调用了ServiceConfig中的export方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void export() &#123;  </span><br><span class="line">    if (provider != null) &#123;  </span><br><span class="line">        if (export == null) &#123;  </span><br><span class="line">            export = provider.getExport();//是否暴露  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (delay == null) &#123;  </span><br><span class="line">            delay = provider.getDelay();//是否延迟暴露  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (export != null &amp;&amp; ! export.booleanValue()) &#123;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //是否延迟发布服务接口  </span><br><span class="line">    if (delay != null &amp;&amp; delay &gt; 0) &#123;  </span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    Thread.sleep(delay);//延迟睡眠后调用doExport发布接口  </span><br><span class="line">                &#125; catch (Throwable e) &#123;  </span><br><span class="line">                &#125;  </span><br><span class="line">                doExport();//直接发布接口  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        thread.setDaemon(true);//设置为守护线程  </span><br><span class="line">        thread.setName(&quot;DelayExportServiceThread&quot;);  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        doExport();//直接发布接口  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected synchronized void doExport() &#123;</span><br><span class="line">        if(this.unexported) &#123;//如果是已经解除暴露的接口则抛出异常</span><br><span class="line">            throw new IllegalStateException(&quot;Already unexported!&quot;);</span><br><span class="line">        &#125; else if(!this.exported) &#123; //如果已经暴露则不需要重复暴露 </span><br><span class="line">            this.exported = true;</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            ... 省略获取注册中心url、遍历所有protocol、遍历所有注册中心、给注册中心设置监控url、</span><br><span class="line"></span><br><span class="line">                this.checkApplication();</span><br><span class="line">                this.checkRegistry();</span><br><span class="line">                this.checkProtocol();</span><br><span class="line">                appendProperties(this);</span><br><span class="line">                this.checkStubAndMock(this.interfaceClass);</span><br><span class="line">                if(this.path == null || this.path.length() == 0) &#123;</span><br><span class="line">                    this.path = this.interfaceName;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.doExportUrls();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;&lt;dubbo:service interface=\&quot;\&quot; /&gt; interface not allow null!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>里面做了很多逻辑判断，但最后还是调用了doExport方法，doExport做了很多配置上检查代码比较长也非重点就不贴出来，大家可以去查看相关源码。里面调用doExportUrls方法，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void doExportUrls() &#123;</span><br><span class="line">        List&lt;URL&gt; registryURLs = this.loadRegistries(true);// </span><br><span class="line">        Iterator var2 = this.protocols.iterator();</span><br><span class="line"></span><br><span class="line">        while(var2.hasNext()) &#123;</span><br><span class="line">            ProtocolConfig protocolConfig = (ProtocolConfig)var2.next();</span><br><span class="line">            this.doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loadRegistries方法返回的是两个URL,返回注册中心的url，例如zk的url，<code>registry://192.168.14.46:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;pid=524&amp;registry=zookeeper×tamp=1498806201853</code></p><p>从URL可以看出，dubbo将我们设置的注册标签数据全部转换URL的形式，所有的配置参数均跟着URL后面。而集合protocols属性里面存储了我们配置的协议数据。协议可以配置多个种类。也就是说这里主要是使用这个循环将当前这个服务以某种协议在多个注册机上进行发布。但是我没看懂集合protocols对象是从哪里注入的数据，细节的我就懒得管啦！继续往doExportUrlsFor1Protocol方法中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123;  </span><br><span class="line">        String name = protocolConfig.getName();  </span><br><span class="line">        if (name == null || name.length() == 0) &#123;  </span><br><span class="line">            name = &quot;dubbo&quot;;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        String host = protocolConfig.getHost();  </span><br><span class="line">        if (provider != null &amp;&amp; (host == null || host.length() == 0)) &#123;  </span><br><span class="line">            host = provider.getHost();  </span><br><span class="line">        &#125;  </span><br><span class="line">        boolean anyhost = false;  </span><br><span class="line">        if (NetUtils.isInvalidLocalHost(host)) &#123;  </span><br><span class="line">            anyhost = true;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                host = InetAddress.getLocalHost().getHostAddress();  </span><br><span class="line">            &#125; catch (UnknownHostException e) &#123;  </span><br><span class="line">                logger.warn(e.getMessage(), e);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (NetUtils.isInvalidLocalHost(host)) &#123;  </span><br><span class="line">                if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0) &#123;  </span><br><span class="line">                    for (URL registryURL : registryURLs) &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            Socket socket = new Socket();  </span><br><span class="line">                            try &#123;  </span><br><span class="line">                                SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());  </span><br><span class="line">                                socket.connect(addr, 1000);  </span><br><span class="line">                                host = socket.getLocalAddress().getHostAddress();  </span><br><span class="line">                                break;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                try &#123;  </span><br><span class="line">                                    socket.close();  </span><br><span class="line">                                &#125; catch (Throwable e) &#123;&#125;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125; catch (Exception e) &#123;  </span><br><span class="line">                            logger.warn(e.getMessage(), e);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (NetUtils.isInvalidLocalHost(host)) &#123;  </span><br><span class="line">                    host = NetUtils.getLocalHost();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        Integer port = protocolConfig.getPort();  </span><br><span class="line">        if (provider != null &amp;&amp; (port == null || port == 0)) &#123;  </span><br><span class="line">            port = provider.getPort();  </span><br><span class="line">        &#125;  </span><br><span class="line">        //获取协议默认的端口号  </span><br><span class="line">        final int defaultPort = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();  </span><br><span class="line">        if (port == null || port == 0) &#123;  </span><br><span class="line">            port = defaultPort;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (port == null || port &lt;= 0) &#123;  </span><br><span class="line">            port = getRandomPort(name);//随机生成端口  </span><br><span class="line">            if (port == null || port &lt; 0) &#123;  </span><br><span class="line">                port = NetUtils.getAvailablePort(defaultPort);  </span><br><span class="line">                putRandomPort(name, port);  </span><br><span class="line">            &#125;  </span><br><span class="line">            logger.warn(&quot;Use random available port(&quot; + port + &quot;) for protocol &quot; + name);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  </span><br><span class="line">        if (anyhost) &#123;  </span><br><span class="line">            map.put(Constants.ANYHOST_KEY, &quot;true&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);  </span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());  </span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));  </span><br><span class="line">        if (ConfigUtils.getPid() &gt; 0) &#123;  </span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));  </span><br><span class="line">        &#125;  </span><br><span class="line">        appendParameters(map, application);  </span><br><span class="line">        appendParameters(map, module);  </span><br><span class="line">        appendParameters(map, provider, Constants.DEFAULT_KEY);  </span><br><span class="line">        appendParameters(map, protocolConfig);  </span><br><span class="line">        appendParameters(map, this);  </span><br><span class="line">        if (methods != null &amp;&amp; methods.size() &gt; 0) &#123;  </span><br><span class="line">            for (MethodConfig method : methods) &#123;  </span><br><span class="line">                appendParameters(map, method, method.getName());  </span><br><span class="line">                String retryKey = method.getName() + &quot;.retry&quot;;  </span><br><span class="line">                if (map.containsKey(retryKey)) &#123;  </span><br><span class="line">                    String retryValue = map.remove(retryKey);  </span><br><span class="line">                    if (&quot;false&quot;.equals(retryValue)) &#123;  </span><br><span class="line">                        map.put(method.getName() + &quot;.retries&quot;, &quot;0&quot;);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                List&lt;ArgumentConfig&gt; arguments = method.getArguments();  </span><br><span class="line">                if (arguments != null &amp;&amp; arguments.size() &gt; 0) &#123;  </span><br><span class="line">                    for (ArgumentConfig argument : arguments) &#123;  </span><br><span class="line">                        //类型自动转换.  </span><br><span class="line">                        if(argument.getType() != null &amp;&amp; argument.getType().length() &gt;0)&#123;  </span><br><span class="line">                            Method[] methods = interfaceClass.getMethods();  </span><br><span class="line">                            //遍历所有方法  </span><br><span class="line">                            if(methods != null &amp;&amp; methods.length &gt; 0)&#123;  </span><br><span class="line">                                for (int i = 0; i &lt; methods.length; i++) &#123;  </span><br><span class="line">                                    String methodName = methods[i].getName();  </span><br><span class="line">                                    //匹配方法名称，获取方法签名.  </span><br><span class="line">                                    if(methodName.equals(method.getName()))&#123;  </span><br><span class="line">                                        Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();  </span><br><span class="line">                                        //一个方法中单个callback  </span><br><span class="line">                                        if (argument.getIndex() != -1 )&#123;  </span><br><span class="line">                                            if (argtypes[argument.getIndex()].getName().equals(argument.getType()))&#123;  </span><br><span class="line">                                                appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());  </span><br><span class="line">                                            &#125;else &#123;  </span><br><span class="line">                                                throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attirbute not match :index :&quot;+argument.getIndex() + &quot;, type:&quot; + argument.getType());  </span><br><span class="line">                                            &#125;  </span><br><span class="line">                                        &#125; else &#123;  </span><br><span class="line">                                            //一个方法中多个callback  </span><br><span class="line">                                            for (int j = 0 ;j&lt;argtypes.length ;j++) &#123;  </span><br><span class="line">                                                Class&lt;?&gt; argclazz = argtypes[j];  </span><br><span class="line">                                                if (argclazz.getName().equals(argument.getType()))&#123;  </span><br><span class="line">                                                    appendParameters(map, argument, method.getName() + &quot;.&quot; + j);  </span><br><span class="line">                                                    if (argument.getIndex() != -1 &amp;&amp; argument.getIndex() != j)&#123;  </span><br><span class="line">                                                        throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attirbute not match :index :&quot;+argument.getIndex() + &quot;, type:&quot; + argument.getType());  </span><br><span class="line">                                                    &#125;  </span><br><span class="line">                                                &#125;  </span><br><span class="line">                                            &#125;  </span><br><span class="line">                                        &#125;  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;else if(argument.getIndex() != -1)&#123;  </span><br><span class="line">                            appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());  </span><br><span class="line">                        &#125;else &#123;  </span><br><span class="line">                            throw new IllegalArgumentException(&quot;argument config must set index or type attribute.eg: &lt;dubbo:argument index=&apos;0&apos; .../&gt; or &lt;dubbo:argument type=xxx .../&gt;&quot;);  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; // end of methods for  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (ProtocolUtils.isGeneric(generic)) &#123;  </span><br><span class="line">            map.put(&quot;generic&quot;, generic);  </span><br><span class="line">            map.put(&quot;methods&quot;, Constants.ANY_VALUE);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);  </span><br><span class="line">            if (revision != null &amp;&amp; revision.length() &gt; 0) &#123;  </span><br><span class="line">                map.put(&quot;revision&quot;, revision);  </span><br><span class="line">            &#125;  </span><br><span class="line">            //根据服务实现的接口获取相关服务方法  </span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();  </span><br><span class="line">            if(methods.length == 0) &#123;  </span><br><span class="line">                logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());  </span><br><span class="line">                map.put(&quot;methods&quot;, Constants.ANY_VALUE);  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (! ConfigUtils.isEmpty(token)) &#123;  </span><br><span class="line">            if (ConfigUtils.isDefault(token)) &#123;  </span><br><span class="line">                map.put(&quot;token&quot;, UUID.randomUUID().toString());  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                map.put(&quot;token&quot;, token);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (&quot;injvm&quot;.equals(protocolConfig.getName())) &#123;  </span><br><span class="line">            protocolConfig.setRegister(false);  </span><br><span class="line">            map.put(&quot;notify&quot;, &quot;false&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 导出服务  </span><br><span class="line">        String contextPath = protocolConfig.getContextpath();  </span><br><span class="line">        if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123;  </span><br><span class="line">            contextPath = provider.getContextpath();  </span><br><span class="line">        &#125;  </span><br><span class="line">        //根据Map中存储的属性组装URL地址  </span><br><span class="line">        URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);  </span><br><span class="line">  </span><br><span class="line">        if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)  </span><br><span class="line">                .hasExtension(url.getProtocol())) &#123;  </span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)  </span><br><span class="line">                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        String scope = url.getParameter(Constants.SCOPE_KEY);  </span><br><span class="line">        //配置为none不暴露  </span><br><span class="line">        if (! Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;  </span><br><span class="line">  </span><br><span class="line">            //配置不是remote的情况下做本地暴露 (配置为remote，则表示只暴露远程服务)  </span><br><span class="line">            if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;  </span><br><span class="line">                exportLocal(url);  </span><br><span class="line">            &#125;  </span><br><span class="line">            //如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露远程服务)  </span><br><span class="line">            if (! Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope) )&#123;  </span><br><span class="line">                if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">                    logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0  </span><br><span class="line">                        &amp;&amp; url.getParameter(&quot;register&quot;, true)) &#123;  </span><br><span class="line">                    for (URL registryURL : registryURLs) &#123;  </span><br><span class="line">                        url = url.addParameterIfAbsent(&quot;dynamic&quot;, registryURL.getParameter(&quot;dynamic&quot;));  </span><br><span class="line">                        URL monitorUrl = loadMonitor(registryURL);  </span><br><span class="line">                        if (monitorUrl != null) &#123;  </span><br><span class="line">                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">                            logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        //通过proxyFactory对象生成接口实现类代理对象Invoker  </span><br><span class="line">                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));  </span><br><span class="line">                        //将Invoker对象封装到protocol协议对象中，同时开启socket服务监听端口，这里socket通信是使用netty框架来处理的  </span><br><span class="line">                        Exporter&lt;?&gt; exporter = protocol.export(invoker);  </span><br><span class="line">                        //添加对象到集合  </span><br><span class="line">                        exporters.add(exporter);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);  </span><br><span class="line">  </span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(invoker);  </span><br><span class="line">                    exporters.add(exporter);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        this.urls.add(url);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>doExportUrlsFor1Protocol方法中主要做了几件事</p><p>1.根据xml中dubbo标签配置组装dubbo协议URL，如果没有配置任何协议，默认使用了dubbo协议。比如这里组装后端URL<br><code>dubbo://192.168.14.46:20880/com.service.interfaces.DubboService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.5.3&amp;interface=com.service.interfaces.DubboService&amp;methods=sayName,sayHello&amp;pid=6844&amp;revision=1.0-SNAPSHOT&amp;side=provider&amp;timestamp=1502851260474</code><br>细看这里组装的URL里面携带了发布一个接口服务所有相关的参数，包括接口全限定名，接口相关方法名称，版本号，模块名称</p><p>2.通信协议未指明端口时，随机生成端口号</p><p>3.通过proxyFactory对象生成接口实现类的代理对象invoker</p><p>4.通过protocol对象将invoker封装成Exporter对象，同时开启了socket服务监听端口。这里socket通信使用的是netty框架，</p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="http://blog.csdn.net/qiangcai/article/details/73992080" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; dubbo自定义标签 里面说过启动服务时会首先加载XML文件中的标签，解析出来的标签数据会装配到对应的实体类中，dubbo框架里面也是这样的。我们首先看看com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandle
      
    
    </summary>
    
    
      <category term="Dubbo" scheme="http://zhongyp.me/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>ENUM 枚举类</title>
    <link href="http://zhongyp.me/2018/02/04/java/2018-02-04-ENUM/"/>
    <id>http://zhongyp.me/2018/02/04/java/2018-02-04-ENUM/</id>
    <published>2018-02-03T16:00:00.000Z</published>
    <updated>2018-10-27T03:27:06.660Z</updated>
    
    <content type="html"><![CDATA[<p>枚举（Enums）<br>JDK1.5加入了一个全新的类型的“类”– 枚举类型。为此JDK1.5引入了一个新关键字enum。</p><p>定义枚举类型时本质上就是定义一个类别，只不过很多细节由编译器帮您完成了，所以某种程度上，enum关键字的作用就像是class或interface。</p><p>当您使用“enum”定义枚举类型时，实质上您定义出来的类型继承自java.lang.Enum类型，而每个枚举的成员其实就是您定义的枚举类型的一个实例（Instance），它们都被预设为final，所以您无法改变它们，它们也是static成员，所以您可以通过类型名称直接使用它们，当然最重要的它们都是公开的public。换句话说，当定义一个枚举类型后，在编译时刻就能确定该枚举类型有几个实例，分别是什么。在运行期间我们无法再使用该枚举类型创建新的实例了，这些实例在编译期间就已经完全确定下来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Coin &#123;    </span><br><span class="line">    penny(&quot;PENNY&quot;), nickel(&quot;NICKEL&quot;), dime(&quot;DIME&quot;), quarter(&quot;QUARTER&quot;);</span><br><span class="line">    private String value;</span><br><span class="line">    Coin(String value)&#123;        this.value = value;    &#125;        </span><br><span class="line">    public String getValue()&#123;        return value;    &#125;        </span><br><span class="line">    public static void main(String[] args)&#123;        </span><br><span class="line">        Coin coin = Coin.nickel;        </span><br><span class="line">        System.out.println(coin.getValue());    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的构造函数定义 Coin(String value)和penny(“PENNY”)是对应的；<br>枚举中也可以定义变量、方法，还可以定义main方法。</p><p><a href="http://blog.csdn.net/zlfprogram/article/details/74066800" target="_blank" rel="noopener">参考博文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;枚举（Enums）&lt;br&gt;JDK1.5加入了一个全新的类型的“类”– 枚举类型。为此JDK1.5引入了一个新关键字enum。&lt;/p&gt;
&lt;p&gt;定义枚举类型时本质上就是定义一个类别，只不过很多细节由编译器帮您完成了，所以某种程度上，enum关键字的作用就像是class或inte
      
    
    </summary>
    
    
      <category term="Java" scheme="http://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap1.8源码解析</title>
    <link href="http://zhongyp.me/2018/01/26/java/2018-01-26-ConcurrentHashMap/"/>
    <id>http://zhongyp.me/2018/01/26/java/2018-01-26-ConcurrentHashMap/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-10-27T03:27:15.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>采用Node + CAS + Synchronized来保证并发安全进行实现，结构如下：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/concurrenthashmap1.8.png?raw=true" alt="1.8"></p><p>只有在执行第一次put方法时才会调用initTable()初始化Node数组，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];// table还是NODE数组</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put实现<br>当执行put方法插入数据时，根据key的hash值，在Node数组中找到相应的位置，实现如下：</p><p>1、如果相应位置的Node还未初始化，则通过CAS插入相应的数据；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 判断当前table的hash位置是否为空，为空通过cas算法插入</span><br><span class="line">    if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">        break;                   // no lock when adding to empty bin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (fh &gt;= 0) &#123;</span><br><span class="line">    binCount = 1;</span><br><span class="line">    for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            if (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        if ((e = e.next) == null) &#123;</span><br><span class="line">            pred.next = new Node&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if (f instanceof TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = 2;</span><br><span class="line">    if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        if (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (binCount != 0) &#123;</span><br><span class="line">    if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    if (oldVal != null)</span><br><span class="line">        return oldVal;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p><p>size实现<br>1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if ((as = counterCells) != null ||</span><br><span class="line">    !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">    CounterCell a; long v; int m;</span><br><span class="line">    boolean uncontended = true;</span><br><span class="line">    if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">        (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">        !(uncontended =</span><br><span class="line">          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">        fullAddCount(x, uncontended);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (check &lt;= 1)</span><br><span class="line">        return;</span><br><span class="line">    s = sumCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、初始化时counterCells为空，在并发量很高时，如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，使用CounterCell记录元素个数的变化；</p><p>2、如果CounterCell数组counterCells为空，调用fullAddCount()方法进行初始化，并插入对应的记录数，通过CAS设置cellsBusy字段，只有设置成功的线程才能初始化CounterCell数组，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">         U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">    boolean init = false;</span><br><span class="line">    try &#123;                           // Initialize table</span><br><span class="line">        if (counterCells == as) &#123;</span><br><span class="line">            CounterCell[] rs = new CounterCell[2];</span><br><span class="line">            rs[h &amp; 1] = new CounterCell(x);</span><br><span class="line">            counterCells = rs;</span><br><span class="line">            init = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        cellsBusy = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (init)</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如果通过CAS设置cellsBusy字段失败的话，则继续尝试通过CAS修改baseCount字段，如果修改baseCount字段成功的话，就退出循环，否则继续循环插入CounterCell对象；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p>所以在1.8中的size实现比1.7简单多，因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int size() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h2&gt;&lt;p&gt;采用Node + C
      
    
    </summary>
    
    
      <category term="Java" scheme="http://zhongyp.me/tags/Java/"/>
    
  </entry>
  
</feed>
