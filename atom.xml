<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DO IT</title>
  
  <subtitle>钟宇鹏的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhongyp.me/"/>
  <updated>2018-12-14T08:47:11.709Z</updated>
  <id>http://zhongyp.me/</id>
  
  <author>
    <name>zhongyp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程安全</title>
    <link href="http://zhongyp.me/2018/12/06/concurrency/2018-12-06-thread-security/"/>
    <id>http://zhongyp.me/2018/12/06/concurrency/2018-12-06-thread-security/</id>
    <published>2018-12-05T16:00:00.000Z</published>
    <updated>2018-12-14T08:47:11.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程安全-读书笔记"><a href="#线程安全-读书笔记" class="headerlink" title="线程安全-读书笔记"></a>线程安全-读<a href="#引用">书</a>笔记</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>线程安全定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调动作，调用这个对象的行为都可以获得正确的结果，那这个<strong>对象就是线程安全的</strong>。摘至《<a href="">Java并发编程实践</a>》<br>编写的线程安全的代码，本质上就是管理对状态（state）的访问，而且通常都是共享的、可变的状态。共享指一个变量可以被多个线程访问；可变指变量的值在生命周期内可以改变。<br>无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。<br>保证对象线程安全的三种措施：</p><ul><li>不跨线程共享变量</li><li>使状态变量不可变</li><li>在任何访问状态变量的时候使用同步</li></ul><h2 id="2-Java线程安全"><a href="#2-Java线程安全" class="headerlink" title="2. Java线程安全"></a>2. Java线程安全</h2><h3 id="2-1-线程安全强弱等级"><a href="#2-1-线程安全强弱等级" class="headerlink" title="2.1 线程安全强弱等级"></a>2.1 线程安全强弱等级</h3><p>Java语言中操作各种共享的数据可根据安全程度分为以下5类：</p><h4 id="2-1-1-不可变"><a href="#2-1-1-不可变" class="headerlink" title="2.1.1 不可变"></a>2.1.1 不可变</h4><p>在Java线程里面，不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何的线程安全保障措施。</p><p>Java语言中，如果共享数据是一个基本数据类型，只要在定义时使用final关键字修饰它就可以保证它时不可变的；如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。只要一个不可变的对象被正确构建出来（没有发生this引用逃逸的情况），那么其外部的可见状态也不会改变。保证对象的行为不影响自己状态的途径有很多种，最简单的就是把对象中带有状态的变量都声明为final。</p><h4 id="2-1-2-绝对线程安全"><a href="#2-1-2-绝对线程安全" class="headerlink" title="2.1.2 绝对线程安全"></a>2.1.2 绝对线程安全</h4><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p><h4 id="2-1-3-相对线程安全"><a href="#2-1-3-相对线程安全" class="headerlink" title="2.1.3 相对线程安全"></a>2.1.3 相对线程安全</h4><p>对象单独的操作时线程安全的，我们在调用的时候不需要做额外的保障措施，对于特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。例如：Vector、ConcurrentHashMap等。</p><h4 id="2-1-4-线程兼容"><a href="#2-1-4-线程兼容" class="headerlink" title="2.1.4 线程兼容"></a>2.1.4 线程兼容</h4><p>线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中安全地使用。例如：HashMap等。</p><h4 id="2-1-5-线程对立"><a href="#2-1-5-线程对立" class="headerlink" title="2.1.5 线程对立"></a>2.1.5 线程对立</h4><p>线程对立指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。例如：Thread类中的suspend(),resume()方法。</p><h3 id="2-2-Java线程安全实现"><a href="#2-2-Java线程安全实现" class="headerlink" title="2.2 Java线程安全实现"></a>2.2 Java线程安全实现</h3><h4 id="2-2-1-互斥同步"><a href="#2-2-1-互斥同步" class="headerlink" title="2.2.1 互斥同步"></a>2.2.1 互斥同步</h4><p>互斥同步(Mutual Exclusion &amp; Synchronization)是最常见的一种并发正确性保障手段，同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。是一种悲观的并发策略，无论是否并发都需要加锁。<br>手段：synchronized、ReentrantLock。<br>缺点：线程阻塞和唤醒带来的性能问题，因此互斥同步也称为阻塞同步(Blocking Synchronization)。</p><h4 id="2-2-2-非阻塞同步"><a href="#2-2-2-非阻塞同步" class="headerlink" title="2.2.2 非阻塞同步"></a>2.2.2 非阻塞同步</h4><p>非阻塞同步(Non-Blocking Synchronization)是基于冲突检测的乐观并发策略，通俗的讲就是先进行操作，如果没有其他线程争用共享数据，则操作成功，否则产生冲突，然后进行补偿措施（最常见的就是不断的重试，知道试成功为止）。<br>要求：硬件指令集的发展，需要操作和检测两个步骤具备原子性。<br>常见指令：测试并设置(Test-and-Set)、获取并增加(Fetch-and-Increment)、交换(Swap)、比较并交换(Compare-and-Swap,CAS)、加载链接/条件存储(Load-linked/Store-Conditional,LL/SC)。</p><h4 id="2-2-3-无同步方案"><a href="#2-2-3-无同步方案" class="headerlink" title="2.2.3 无同步方案"></a>2.2.3 无同步方案</h4><p>要保证线程同步，不一定就要进行同步，两者没有因果关系。同步知识保证共享数据争用时正确性的手段，如果有些代码不涉及共享数据，自然无需同步保证共享数据争用时的正确性。</p><ul><li>可重入代码（Reentrant Code）：这种代码也叫纯代码（Pure Code），可以在代码执行的任何时刻中断它，转去执行另外一段代码，而控制权回来后继续执行代码，程序不会出现任何错误。</li><li>线程本地存储（Thread Local Storage）：如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，无需同步也能实现线程之间不出现数据争用的问题。</li></ul><h2 id="3-Java锁优化"><a href="#3-Java锁优化" class="headerlink" title="3. Java锁优化"></a>3. Java锁优化</h2><p>为了在线程之间更高效地共享数据，以及解决数据竞争问题，JDK实现了各种锁的优化技术，如适应性自旋(Adaptive Spinning)、锁消除(Lock Elimination)、锁粗化(Lock Coarsening)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)等。</p><h4 id="3-1-自旋锁与自适应性自旋"><a href="#3-1-自旋锁与自适应性自旋" class="headerlink" title="3.1 自旋锁与自适应性自旋"></a>3.1 自旋锁与自适应性自旋</h4><p>互斥同步对性能最大的影响是阻塞的实现，挂起和恢复线程的操作都需要转入内核态完成，这些操作给并发性能带来很大的压力。如果获取共享数据锁时仅需要等待很短的时间，为了很短的时间去挂起和恢复线程并不值得。如果处理器有一个以上的处理器，我们可以线程让请求锁的线程忙循环，不放弃处理器的执行时间，这项技术就是所谓的自旋锁。<br>自适应自旋锁意味着自旋的时间不再固定，根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><h4 id="3-2-锁消除"><a href="#3-2-锁消除" class="headerlink" title="3.2 锁消除"></a>3.2 锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为是线程私有的，同步加锁自然无需执行。</p><h4 id="3-3-锁粗化"><a href="#3-3-锁粗化" class="headerlink" title="3.3 锁粗化"></a>3.3 锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体中。如果虚拟机探测到有这样一串零碎的操作都对一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只加锁一次就可以。</p><h4 id="3-4-轻量级锁"><a href="#3-4-轻量级锁" class="headerlink" title="3.4 轻量级锁"></a>3.4 轻量级锁</h4><p>轻量级锁是JDK1.6 中加入的新型锁机制，轻量级是相对于使用操作系统互斥量来实现传统锁而言，因此传统锁机制被称为重量级锁。轻量级锁本意指在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>HotSpot虚拟机的对象头(Object Header)分为两部分，第一用于存储自身的运行时数据，这部分数据的长度在32位和64位的虚拟机分别是32个和64个bits，官网称它为”Mark Word”。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还有一个额外的部分用于存储数组长度。<br><img src="/media/object-header.png" alt="mark word"><br>表摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机空间效率，Mark Word被设计生一个非固定的数据结构以便在极小的空间内存储尽量多的信息，根据对象的状态复用自己的存储空间。<br>HotSpot 虚拟机对象头Mark Word不同状态下存储内容表：<br><img src="/media/markword.png" alt="mark word"><br>表摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br><img src="/media/markword-status.png" alt="mark word status"><br>表摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>轻量级锁的执行过程：在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word拷贝，如图：<br><img src="/media/markword-cas-before.png" alt="markword-cas-before"><br>图摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新成功了，那么该线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转为“00”，即表示该对象处于轻量级锁定状态。<br><img src="/media/markword-cas-after.png" alt="markword-cas-after"><br>图摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>如果更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了该对象的锁，可直接进入同步代码块继续执行，否则说明这个锁对象被其他线程抢占了。如果有两条以上（包括两条）的线程争用同一个锁，轻量级锁不再有效要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁的指针，后面等待的线程也要进入阻塞状态。<br>轻量级锁初始化及膨胀流程图：<br><img src="/media/lightweight-expand.png" alt="lightweight"><br>图摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍指向线程的锁记录，就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，同步完成。替换失败，有其他线程尝试获取该锁，此时锁已经膨胀，就要在释放锁的同时，唤醒被挂起的线程。</p><h4 id="3-5-偏向锁"><a href="#3-5-偏向锁" class="headerlink" title="3.5 偏向锁"></a>3.5 偏向锁</h4><p>偏向锁目的是消除数据在无竞争情况下的同步原语。<br>使用场景：锁不仅不存在多线程竞争，而且总是由同一线程多次获得。<br>偏向锁原理：当锁对象第一次被线程获取的时候，虚拟机将会吧对象头中的标志位设为“01”（Mark Word见3.4小节的表中），即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持久偏向锁的线程以后每次进入这个锁相关的同步时，虚拟机都可以不再进行任何同步操作，只需简单测试对象头的Mark Word是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁。如果测试失败，则需要在测试一下Mark Word中偏向锁的表识是否设置成”01”：如果没有设置，则使用CAS竞争锁；如果设置了则尝试使用CAS将对象头的偏向锁指向当前线程。<br>偏向锁撤销（Revoke Bias）：当有另外一个线程尝试去获取这个锁时，偏向模式结束。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置成无锁状态；如果线程还活着，拥有偏向锁额度栈会被执行，便利偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。<br>偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图：<br><img src="/media/markword-change.png" alt="markword-change"><br>图摘自<a href="#偏向锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>偏向锁初始化及膨胀流程图：<br><img src="/media/bias-expand.png" alt="bias-expand"><br>图摘自<a href="#偏向锁">Java并发编程艺术 2.2小节</a></p><h4 id="3-6-轻量级锁、偏向锁、重量级锁对比"><a href="#3-6-轻量级锁、偏向锁、重量级锁对比" class="headerlink" title="3.6 轻量级锁、偏向锁、重量级锁对比"></a>3.6 轻量级锁、偏向锁、重量级锁对比</h4><p>偏向锁初始化及膨胀流程图：<br><img src="/media/lock-advantage-disadvantage.png" alt="lock"><br>图摘自<a href="#轻量级锁、偏向锁、重量级锁对比">Java并发编程艺术 2.2小节</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与实践</a><br><a href="">Java并发编程实践</a><br><a href="">Java并发编程艺术</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程安全-读书笔记&quot;&gt;&lt;a href=&quot;#线程安全-读书笔记&quot; class=&quot;headerlink&quot; title=&quot;线程安全-读书笔记&quot;&gt;&lt;/a&gt;线程安全-读&lt;a href=&quot;#引用&quot;&gt;书&lt;/a&gt;笔记&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程启动与终止</title>
    <link href="http://zhongyp.me/2018/12/04/concurrency/2018-12-04-thread-start-end/"/>
    <id>http://zhongyp.me/2018/12/04/concurrency/2018-12-04-thread-start-end/</id>
    <published>2018-12-03T16:00:00.000Z</published>
    <updated>2018-12-10T10:07:47.487Z</updated>
    
    <content type="html"><![CDATA[<p>上篇对<a href="https://zhongyp.me/2018/03/16/concurrent/2017-03-16-Thread-brief/">什么是线程</a>做了简单的介绍,本篇主要是从构造线程、中断线程、终止线程3个方面了解线程。</p><h3 id="1-构造线程"><a href="#1-构造线程" class="headerlink" title="1. 构造线程"></a>1. 构造线程</h3><h4 id="1-1-构造线程的方式"><a href="#1-1-构造线程的方式" class="headerlink" title="1.1 构造线程的方式"></a>1.1 构造线程的方式</h4><p>Java构造一个线程有两种方式：</p><p>一种是声明子类继承Thread父类并重写父类的run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeThread extends Thread &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeThread(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeThread p = new PrimeThread(143);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure></p><p>另一种方式是声明子类实现Runnable接口，并实现run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeRun implements Runnable &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeRun(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeRun p = new PrimeRun(143);</span><br><span class="line">new Thread(p).start();</span><br></pre></td></tr></table></figure></p><p>两者其实在本质上是一致的，因为Thread类也继承了Runable接口，所以都实现/重写Runable中的run方法。Java将线程的执行和执行对象抽象开来，JDK中执行的是Thread类，Executor框架，可执行目标有Runable，Callable。对于构造线程的方式第一种方式并不推荐，因为继承Thread类限定了其基本行为，在设计上违反多用组合 少用继承的原则，所以一般构造线程使用第二种方式，实现Runable接口。</p><h4 id="1-2-构造线程的属性"><a href="#1-2-构造线程的属性" class="headerlink" title="1.2 构造线程的属性"></a>1.2 构造线程的属性</h4><p>构造线程时需要提供线程所需要的属性。一个新的（child）线程对象是由parent线程进行空间分配的，而child线程继承了parent是否为Daemon、优先级、和加载资源的contextClassLoader以及可继承的ThreadLocal等属性，同时分配唯一的ID来表示这个child线程。如果创建线程实例后需要修改线程属性，则可以通过Thread提供的一些修改属性的方法进行修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setPriority() // 优先级</span><br><span class="line">getPriority()</span><br><span class="line">setName()。// 线程名</span><br><span class="line">getName()</span><br><span class="line">setDaemon() // 守护线程</span><br><span class="line">isDaemon()</span><br><span class="line">getContextClassLoader()。// 资源加载</span><br><span class="line">setContextClassLoader()</span><br><span class="line">getStackTrace() </span><br><span class="line">getAllStackTraces()</span><br><span class="line">checkAccess()</span><br><span class="line">isCCLOverridden()</span><br><span class="line">auditSubclass() </span><br><span class="line">dumpThreads()</span><br><span class="line">getThreads()</span><br><span class="line">getId()</span><br><span class="line">getState()</span><br><span class="line">setDefaultUncaughtExceptionHandler()</span><br><span class="line">getDefaultUncaughtExceptionHandler()</span><br><span class="line">getUncaughtExceptionHandler()</span><br><span class="line">setUncaughtExceptionHandler()</span><br><span class="line">dispatchUncaughtException()</span><br><span class="line">processQueue()</span><br></pre></td></tr></table></figure></p><p>当然构造线程时有些属性还可以在创建线程实例时就设置，如线程组，栈大小，栈名称，权限控制上下文，可继承的ThreadLocal，下面是JDK初始化一个线程实例时的代码，摘至<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK8</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @param g</span><br><span class="line"> * @param target</span><br><span class="line"> * @param name</span><br><span class="line"> * @param stackSize 线程的栈大小 根据参数传递过程可以看出默认大小为零，即使用默认的线程栈大小</span><br><span class="line"> * @param acc 访问控制权限</span><br><span class="line"> * @param inheritThreadLocals // 可继承的ThreadLocal</span><br><span class="line"> *</span><br><span class="line"> * ThreadGroup 线程组（ThreadGroup）就是由线程组成的管理线程的类，</span><br><span class="line"> *     这个类是java.lang.ThreadGroup类。</span><br><span class="line"> *     定义一个线程组，通过以下代码可以实现。</span><br><span class="line"> *     ThreadGroup group=new ThreadGroup(&quot;group&quot;);</span><br><span class="line"> *     Thread thread=new Thread(group,&quot;the first thread of group&quot;);</span><br><span class="line"> *     ThreadGroup类中的某些方法，可以对线程组中的线程产生作用。例如，setMaxPriority()方法可以设定线程组中的所有线程拥有最大的优先权。</span><br><span class="line"> */</span><br><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                  long stackSize, AccessControlContext acc,</span><br><span class="line">                  boolean inheritThreadLocals) &#123;</span><br><span class="line">    if (name == null) &#123;// 线程名，可相同</span><br><span class="line">        throw new NullPointerException(&quot;name cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();// 获取当前线程，并作为父线程。</span><br><span class="line">    SecurityManager security = System.getSecurityManager();// 获取安全策略</span><br><span class="line">    if (g == null) &#123;</span><br><span class="line">        /* Determine if it&apos;s an applet or not */</span><br><span class="line"></span><br><span class="line">        /* If there is a security manager, ask the security manager</span><br><span class="line">           what to do. */</span><br><span class="line">        if (security != null) &#123;//如果存在安全管理器，则获取它重写的线程组</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If the security doesn&apos;t have a strong opinion of the matter</span><br><span class="line">           use the parent thread group. */</span><br><span class="line">        if (g == null) &#123;</span><br><span class="line">            g = parent.getThreadGroup();//使用父线程组</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* checkAccess regardless of whether or not threadgroup is</span><br><span class="line">       explicitly passed in. */</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Do we have the required permissions?</span><br><span class="line">     */</span><br><span class="line">    if (security != null) &#123;</span><br><span class="line">        if (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    this.group = g;</span><br><span class="line">    this.daemon = parent.isDaemon();//继承父线程的守护属性</span><br><span class="line">    this.priority = parent.getPriority();//继承父线程的优先级</span><br><span class="line">    //继承父线程加载资源的contextClassLoader</span><br><span class="line">    if (security == null || isCCLOverridden(parent.getClass()))</span><br><span class="line">        this.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    else</span><br><span class="line">        this.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    this.inheritedAccessControlContext =</span><br><span class="line">            acc != null ? acc : AccessController.getContext();</span><br><span class="line">    this.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    // 继承父线程可继承的ThreadLocal</span><br><span class="line">    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">        this.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    /* Stash the specified stack size in case the VM cares */</span><br><span class="line">    this.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    /* Set thread ID */</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-启动线程"><a href="#1-3-启动线程" class="headerlink" title="1.3 启动线程"></a>1.3 启动线程</h4><p>线程对象在初始化完成后，调用start方法就可以启动线程。<br><strong><em>注意：启动一个线程，最好为这个线程设置线程名称，这行有助于分析或者排查问题</em></strong></p><h3 id="2-中断线程"><a href="#2-中断线程" class="headerlink" title="2. 中断线程"></a>2. 中断线程</h3><h4 id="2-1-中断的原理"><a href="#2-1-中断的原理" class="headerlink" title="2.1 中断的原理"></a>2.1 中断的原理</h4><p>中断，可以理解为运行中的线程，是否被其他线程进行了中断操作。中断操作包含三个方法。interrupt(),interrupted(),isInterrupted()。下面我们将对这个方法进行详细了解。</p><h5 id="2-1-1-interrupt"><a href="#2-1-1-interrupt" class="headerlink" title="2.1.1 interrupt()"></a>2.1.1 interrupt()</h5><p>中断操作通过调用线程的interrupt()方法进行。例如线程A中断线程B，在线程A的代码中调用ThreadB.interrupt() 即可。</p><p>interrupt()方法不是直接将线程终止，而是针对于不同情况进行不同处理。</p><ol><li>除非终止的是当前线程（始终被允许），否则调用checkAccess方法，可能会导致抛出SecurityException异常。</li><li>如果调用Object类的wait(),wait(long)或者wait(long, int)等方法，或者调用此线程的join(),join(long),join(long, int), sleep(long), sleep(long, int)方法，<strong><em>此线程的中断状态将被清除，同时将抛出InterruptedException异常</em></strong>。</li><li>如果此线程在可中断通道的IO操作上，通道将被关闭，线程被设置中断状态，同时将抛出ClosedByInterruptException异常。</li><li>如果线程在选择器(Selector)阻塞，线程将被设置中断状态，立即从选择操作中返回，可能带有非零值，就像选择器唤醒方法被调用一样。</li><li>如果以上的条件都不满足，此线程将被设置中断状态。</li><li>中断不存活的线程不会有任何影响。</li></ol><p>翻译自<a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Java se7docs</a></p><p>注：Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。<br><strong><em>注意：</em></strong><br>对于会抛出异常的情况，异常一定要处理，一般子线程异常不能抛出非运行时异常，所以子线程我们需要抛出运行时异常，用于给父线程捕获。或者在catch块中使用 Thread.currentThread().interrupt() 重新抛出中断来保证调用栈的高层的代码知道当前线程的中断。</p><h5 id="2-1-2-interrupted"><a href="#2-1-2-interrupted" class="headerlink" title="2.1.2 interrupted()"></a>2.1.2 interrupted()</h5><p>interrupted()主要有以下两个功能：</p><ol><li>测试<strong><em>当前线程</em></strong>是否被中断,清除线程中断状态。换句话说就是，如果当前方法被成功调用两次，则返回false（除非当前线程在第一次调用此方法后第二次调用此方法前被再次中断）。</li><li>线程中断被忽略，在中断时线程处于不活动的状态将被此方法反映返回false。</li></ol><p>interrupted()不同于interrupt(),此方法用于测试当前线程是否被中断，并清除中断状态。代码示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread thread = new InterruptThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    SleepUtils.sleep(1);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">static class InterruptThread extends Thread&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       int count = 0;</span><br><span class="line">       while(true)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           if(Thread.currentThread().interrupted())&#123;//此处仅仅是为了示例</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-1-3-isInterrupted"><a href="#2-1-3-isInterrupted" class="headerlink" title="2.1.3 isInterrupted()"></a>2.1.3 isInterrupted()</h5><ol><li>isInterrupted虽然也是测试线程是否被中断，但是此方法不会更改线程的中断状态。</li><li>线程中断被忽略，在中断时线程处于不活动的状态将被此方法反映返回false。</li></ol><h3 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3. 终止线程"></a>3. 终止线程</h3><h4 id="3-1-过期的suspend-、resume-和stop"><a href="#3-1-过期的suspend-、resume-和stop" class="headerlink" title="3.1 过期的suspend()、resume()和stop()"></a>3.1 过期的suspend()、resume()和stop()</h4><p>在Java API中，suspend()、resume()和stop()三个方法是过期的，不建议使用的。<br>主要原因是：suspend()在调用后，线程不是放已经占有的资源比如说锁，而是占有着资源进入睡眠，这样容易引发死锁状态。stop()方法在终结一个线程时不会保证线程资源的释放，因此导致线程处于不确定的状态下。</p><p><strong><em>sleep和suspend区别：</em></strong><br>相同点：sleep和suspend都会持有占有的资源不释放。<br>不同点：sleep阻塞（TIMED_WAITING）后，经过一段时间自行恢复运行。而suspend必须使用resume()显示的恢复，如果不使用resume()或者resume()失败，很容易引起资源占用导致的死锁。</p><h4 id="3-2-安全的终止线程"><a href="#3-2-安全的终止线程" class="headerlink" title="3.2 安全的终止线程"></a>3.2 安全的终止线程</h4><p>在第2小节提到的中断是线程的一个标示位，中断操作是一种简便的线程间交互方式，这种交互方式适合用来取消和停止任务。除了中断，还可以使用同步变量来控制是否停止并终止该线程。<br><strong><em>线程的终止不是直接强制线程停止，而是引导线程运行结束。</em></strong></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" target="_blank" rel="noopener">Java 安全模型介绍</a><br><a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Class Thread</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程(1)-Thread类源码</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇对&lt;a href=&quot;https://zhongyp.me/2018/03/16/concurrent/2017-03-16-Thread-brief/&quot;&gt;什么是线程&lt;/a&gt;做了简单的介绍,本篇主要是从构造线程、中断线程、终止线程3个方面了解线程。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>博客声明</title>
    <link href="http://zhongyp.me/2018/11/28/life/2018-11-29-blog-announce/"/>
    <id>http://zhongyp.me/2018/11/28/life/2018-11-29-blog-announce/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2018-12-06T02:25:30.616Z</updated>
    
    <content type="html"><![CDATA[<p>博客中的文章，如果没有特殊说明，均为原创，欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任。<br>博客中可能有些内容摘录至别人的文章/博客/书，仅为个人收藏，分享知识，如有侵权，请联系博主进行删除。📧：<a href="mailto:zhongyp001@163.com" target="_blank" rel="noopener">zhongyp001@163.com</a>，收到后一定尽快删除与您的相关内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客中的文章，如果没有特殊说明，均为原创，欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任。&lt;br&gt;博客中可能有些内容摘录至别人的文章/博客/书，仅为个人收藏，分享知识，如有侵权，请联系博主进行删除。📧：&lt;a href=&quot;mailto
      
    
    </summary>
    
    
      <category term="生活" scheme="http://zhongyp.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>我的博客</title>
    <link href="http://zhongyp.me/2018/11/28/life/2018-11-29-myblog/"/>
    <id>http://zhongyp.me/2018/11/28/life/2018-11-29-myblog/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2018-12-06T02:25:57.271Z</updated>
    
    <content type="html"><![CDATA[<p><strong>少年时代对未来生活的想象虽然朦胧，但实际上却有着极高的期待。你总觉得现在只是活着，等待着，等待着某一刻会金鼓齐鸣，光芒四射，然后，真正的生活开始了。但日常生活自有它自己缓慢而平静的节奏，它波澜不兴地向前弥漫，越过岁月。直到你骤然发现，大多数人的生活不会有金鼓齐鸣的开始，大多数人的生活，就是一种水滴石穿的单调和宁静。</strong></p><p>开始写博客一段时间了，只是想找个地方记录下自己的看过的、学过的知识，记录下学习的过程中自己的想法/感悟。thinking…🌝</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;少年时代对未来生活的想象虽然朦胧，但实际上却有着极高的期待。你总觉得现在只是活着，等待着，等待着某一刻会金鼓齐鸣，光芒四射，然后，真正的生活开始了。但日常生活自有它自己缓慢而平静的节奏，它波澜不兴地向前弥漫，越过岁月。直到你骤然发现，大多数人的生活不会有金鼓
      
    
    </summary>
    
    
      <category term="生活" scheme="http://zhongyp.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>并发知识架构</title>
    <link href="http://zhongyp.me/2018/11/16/concurrency/2018-11-27-concurrency-structure/"/>
    <id>http://zhongyp.me/2018/11/16/concurrency/2018-11-27-concurrency-structure/</id>
    <published>2018-11-15T16:00:00.000Z</published>
    <updated>2018-12-04T06:03:49.953Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/concurrency.png" alt="Java并发架构图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/concurrency.png&quot; alt=&quot;Java并发架构图&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令总结</title>
    <link href="http://zhongyp.me/2018/10/23/utils/2018-10-23-git/"/>
    <id>http://zhongyp.me/2018/10/23/utils/2018-10-23-git/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-12-10T10:13:21.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>系统系统性的学习Git，请移步<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Git中文学习文档</a>，这篇文章只是分类记录一下git的常用命令。<br><img src="/media/15403035072735.png" alt="Git版本控制系统VCS基本操作流程图"></p><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><h3 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h3><p><code>git init</code> 将当前目录变为可管理的仓库<br><code>git clone</code> 克隆一个仓库到本地<br><code>git clone -b branch uri</code> 克隆指定branch分支到本地<br><code>git config user.name</code> 查看用户名<br><code>git config user.email</code> 查看邮箱</p><h3 id="设置与配置"><a href="#设置与配置" class="headerlink" title="设置与配置"></a>设置与配置</h3><p><code>git config -global user.name/email &quot;参数&quot;</code> git是分布式版本控制，所以添加用户名和邮箱作为一个标识<br><code>ssh -keygen -t rsa -C &quot;email&quot;</code> 生成本地ssh key</p><h3 id="本地版本库"><a href="#本地版本库" class="headerlink" title="本地版本库"></a>本地版本库</h3><p><code>git add &quot;filename.*&quot;</code> 添加到暂存区<br><code>git commit -m &quot;filename.*&quot;</code> 提交到仓库<br><code>git commit --amend</code> 尝试重新提交,这个操作需要组合操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add file1 // 将file1 添加至缓存区</span><br><span class="line">git commmit -m &quot;update files&quot; //提交file1到本地仓库,提交完发现忘记file2没有提交，则你可以使用如下命令，提交file2并覆盖之前的提交信息。</span><br><span class="line">git add file2 // 添加file2</span><br><span class="line">git commit -amend // 尝试重新提交commit信息，并覆盖掉之前的提交信息</span><br></pre></td></tr></table></figure><p><code>git status</code> 查看文件状态<br><code>git diff filename.*</code> 查看修改了什么<br><code>git log</code> 看看每次修改的日志<br><code>git log --pretty=oneline</code> 日志显示为缩略版<br>注：<code>git reset</code> 不加<code>--hard</code>参数对当前工作区文件不会有任何修改，只是对缓存区进行操作。一旦加了参数，操作一定要慎重，否则你当前工作区中的修改将会全部被清除。<br><code>git reset HEAD file</code> 将file退回到当前版本（仅仅是对缓存区进行操作）<br><code>git reset --hard HEAD^</code> 退回到上一版本<br><code>git reset --hard HEAD^^</code> 退回到前二的版本<br><code>git reset --hard HEAD~100</code> 退回到前100版本<br><code>git reset --hard 版本号</code> 退回到一个特定的版本<br><code>git reflog</code> 查看版本号和上一个命令一块用效果比较好<br><code>git reset --mixed</code> 将当前文件撤出缓存区，保留文件修改<br><code>git rm --cached file</code> 删除缓存区file<br><code>git checkout -- file</code> 恢复工作区file（取消工作区文件的修改）</p><h3 id="远程版本库"><a href="#远程版本库" class="headerlink" title="远程版本库"></a>远程版本库</h3><p><code>git remote add origin 远程git地址</code> 连接<br><code>git push -u origin master</code> 把本地库分支master内容推送到远程库（-u 命令在第一次关联本地库和远程库时使用）<br><code>git clone url</code> 克隆远程(url)库</p><h3 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h3><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p><code>git branch</code> 查看分支<br><code>git checkout</code> 切换分支<br><code>git checkout -b</code>  创建并切换分支<br><code>git merge</code> 合并到当前分支<br><code>git branch -d</code>删除某分支<br><code>git merge --no-ff -m &quot;注释&quot;</code>分支合并分支禁用fast forward<br><code>git stash</code> 将当前分支的工作现场保留下来<br><code>git stash list</code> 查看工作现场<br><code>git stash apply</code> 恢复内容但是你需要git stash drop删除stash<br><code>git stash pop</code> 恢复的同时把stash内容也删除<br><code>git remote</code> 查看远程库的信息<br><code>git remote -v</code> 查看远程库的详细信息<br><code>git push origin master</code> master为本地的分支名推送分支<br><code>git checkout -b dev origin/dev</code> dev为分支名，做完开发后<br><code>git push origin dev</code> 推送到远程库<br><code>git pull</code> 抓取最新的提交,并尝试自动合并到本地当前所在的分支<br><code>git fetch</code> 抓取最新的提交，不会自动合并，必须手动。<br><code>git rebase</code> 变基,将提交到某一分支上的所有修改都移至另一分支上<br><code>git rebase --continue</code> <strong><em>继续变基操作，一般用于第一次变基失败后，解决冲突文件，将冲突文件添加到缓存区，不要提交，然后再执行此命令。如果提交了，执行<code>git rebase --skip</code>命令取消rebase状态。</em></strong><br><code>git branch --set-upstream dev origin/dev</code> 指定本地dev分支（已经创建的）与远程origin/dev分支的连接<br><code>git branch -u origin/dev</code> 指定当前所在连接远程origin/dev分支的连接<br><code>git checkout --track origin/dev</code> 创建新的dev分支，制定远程连接origin/dev</p><p>注：如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ol><li>每开发一个新特性可以新建一个本地特性分支，开发完成后合并到本地主线。</li><li>如果不使用特性分支开发可以使用<code>git stash</code>保存当前的工作空间。</li><li>远程代码和本地代码合并有两种方式，<code>git pull</code>和<code>git fetch</code>，<code>git pull</code>命令会自动合并远程代码，冲突后需要解决冲突后提交。<code>git fetch</code>不自动和本地代码合并，需要手动merge。</li><li>在合并时，根据项目情况使用<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">变基</a>，<code>git pull --rebase</code>可以保持自动合并的情况下进行变基。一般情况下，远程库不保留本地操作历史，所以本地与远程代码合并时最好使用变基。</li><li><strong><em>使用变基原则</em></strong>：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h2&gt;&lt;p&gt;系统系统性的学习Git，请移步&lt;a href=&quot;https://git-scm.com/book/zh/v2/%E8%B5%B7%E
      
    
    </summary>
    
    
      <category term="Utils" scheme="http://zhongyp.me/tags/Utils/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP概念及术语</title>
    <link href="http://zhongyp.me/2018/10/03/spring/2018-09-28-AOP/"/>
    <id>http://zhongyp.me/2018/10/03/spring/2018-09-28-AOP/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2018-12-10T10:35:52.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>本篇文章翻译自<a href="https://www.tutorialspoint.com/spring/aop_with_spring.htm" target="_blank" rel="noopener">AOP with Spring</a>，主要介绍是关于AOP的概念。</p><h3 id="Brief-introduction-（简介）"><a href="#Brief-introduction-（简介）" class="headerlink" title="Brief introduction （简介）"></a>Brief introduction （简介）</h3><p>One of the key components of Spring Framework is the Aspect oriented programming (AOP) framework. Aspect-Oriented Programming entails breaking down program logic into distinct parts called so-called concerns. The functions that span multiple points of an application are called cross-cutting concerns and these cross-cutting concerns are conceptually separate from the application’s business logic. There are various common good examples of aspects like logging, auditing, declarative transactions, security, caching, etc.</p><p>The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Dependency Injection helps you decouple your application objects from each other and AOP helps you decouple cross-cutting concerns from the objects that they affect. AOP is like triggers in programming languages such as Perl, .NET, Java, and others.</p><p>Spring AOP module provides interceptors to intercept an application. For example, when a method is executed, you can add extra functionality before or after the method execution.</p><p>翻译：</p><p>AOP面向切面编程是Spring框架中的最关键的部分之一。面向切面编程需要拆分程序逻辑到被称为关注点的不同部分。一个在应用程序内跨越多个点的方法被称为横切点，这些横切点和应用的业务逻辑在概念上是分开的。目前已经有很多应用切面的例子，比如日志，审计，声明式事务，安全，缓存等。</p><p>在面向对象编程中，模块化的关键单元是类，但是在面向切面编程中，模块化单元是切面。依赖注入帮助你将应用中的对象相互解耦，AOP帮助你将横切点从它们作用的对象中解耦。AOP就像是Perl,.NET,Java或者其他编程语言中的触发器。</p><p>Spring AOP模块提供拦截应用的拦截器。举个🌰，你可以在你运行的方法之前或者之后添加额外的功能或者方法。</p><h3 id="AOP-Terminologies（AOP-术语）"><a href="#AOP-Terminologies（AOP-术语）" class="headerlink" title="AOP Terminologies（AOP 术语）"></a>AOP Terminologies（AOP 术语）</h3><h4 id="Aspect（切面）"><a href="#Aspect（切面）" class="headerlink" title="Aspect（切面）"></a>Aspect（切面）</h4><p>This is a module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement.</p><p>翻译： Aspect一个提供横切（cross-cutting）APIs的模块。举个例子，日志模块被称为AOP 日志切面。一个应用可以根据需求拥有任何数量的切面。</p><h4 id="Join-point（连接点）"><a href="#Join-point（连接点）" class="headerlink" title="Join point（连接点）"></a>Join point（连接点）</h4><p>This represents a point in your application where you can plug-in the AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.</p><p>翻译： 在应用中可以插入AOP切面的地方可被抽象为一个点。你也可以说，这是一个在应用中存在的地方，这个地方将被Spring AOP 框架执行一些动作。</p><p>Advice（通知）</p><p>This is the actual action to be taken either before or after the method execution. This is an actual piece of code that is invoked during the program execution by Spring AOP framework.</p><p>翻译：Advice是一个实际的动作，它将在方法执行前和方法执行后执行。这段代码通过Spring AOP框架在程序运行时被调用。</p><h4 id="Pointcut（切入点）"><a href="#Pointcut（切入点）" class="headerlink" title="Pointcut（切入点）"></a>Pointcut（切入点）</h4><p>This is a set of one or more join points where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples.</p><p>翻译：Pointcut是一个或者多个连接点的集合。正如我们将在AOP例子中看到的，你可以使用表达式或者正则表达式制定你的切入点。</p><h4 id="Introduction（引入）"><a href="#Introduction（引入）" class="headerlink" title="Introduction（引入）"></a>Introduction（引入）</h4><p>An introduction allows you to add new methods or attributes to the existing classes.</p><p>翻译：引入可以允许你添加新的方法或者属性到已经存在的类中。</p><h4 id="Target-object"><a href="#Target-object" class="headerlink" title="Target object"></a>Target object</h4><p>The object being advised by one or more aspects. This object will always be a proxied object, also referred to as the advised object.</p><p>翻译：这个对象被一个或者多个切面通知。这个对象一般是代理对象，作为被通知对象引用。</p><h4 id="Weaving（织入）"><a href="#Weaving（织入）" class="headerlink" title="Weaving（织入）"></a>Weaving（织入）</h4><p>Weaving is the process of linking aspects with other application types or objects to create an advised object. This can be done at compile time, load time, or at runtime.</p><p>翻译：织入是链接切面和其他应用类型或者对象来创建通知对象的过程。这个过程可以在编译、加载或者执行期间进行。</p><h3 id="Types-of-Advice"><a href="#Types-of-Advice" class="headerlink" title="Types of Advice"></a>Types of Advice</h3><p>Spring aspects can work with five kinds of advice mentioned as follows.<br>翻译：Spring 切面可以使用如下提到的五种advice</p><ul><li><p>before: Run advice before a method execution.</p></li><li><p>after: Run advice after a method execution.</p></li><li><p>after-returning: Run advice after the a method execution only if method completes successfully.</p></li><li><p>after-throwing: Run advice after the method execution only if method exits by throwing an exception.</p></li><li><p>around: Run advice before and after the advised method is invoked.</p></li></ul><h3 id="Custom-Aspects-Implementation-自定义接口实现"><a href="#Custom-Aspects-Implementation-自定义接口实现" class="headerlink" title="Custom Aspects Implementation(自定义接口实现)"></a>Custom Aspects Implementation(自定义接口实现)</h3><p>XML Schema based（基于XML模式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http:www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http:www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http:www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:tx=&quot;http:www.springframework.org/schema/tx&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http:www.springframework.org/schema/beans</span><br><span class="line">        http:www.springframework.org/schema/beans/spring-beans-4.2.xsd</span><br><span class="line">        http:www.springframework.org/schema/aop</span><br><span class="line">        http:www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 业务逻辑类--AOP连接点 --&gt;</span><br><span class="line">    &lt;bean id=&quot;aopTest&quot; class=&quot;com.zhongyp.zen.service.aop.AOPTestService&quot; /&gt;</span><br><span class="line">    &lt;!--AOP切面--&gt;</span><br><span class="line">    &lt;bean id=&quot;timeHandler&quot; class=&quot;com.zhongyp.zen.service.handler.TimeHandler&quot; /&gt;</span><br><span class="line">    &lt;!--AOP切面--&gt;</span><br><span class="line">    &lt;bean id=&quot;printHandler&quot; class=&quot;com.zhongyp.zen.service.handler.PrintHandler&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspectj-autoproxy /&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!-- pointcut切入点（AOP连接点的集合）--&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.zhongyp.zen.service.*.*.*(..))&quot; /&gt;</span><br><span class="line">        &lt;!-- 切面 --&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt;</span><br><span class="line">            &lt;!-- AOP Advice --&gt;</span><br><span class="line">            &lt;aop:before method=&quot;printStartTime&quot; pointcut-ref=&quot;pointcut&quot; /&gt;</span><br><span class="line">            &lt;aop:after method=&quot;printEndTime&quot; pointcut-ref=&quot;pointcut&quot; /&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;print&quot; ref=&quot;printHandler&quot;&gt;</span><br><span class="line">            &lt;aop:after-returning method=&quot;printString&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after-returning&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>@AspectJ based（基于切面注解）</p><p>注解方式可以将上述xml配置以注解的形式配置一下，我这里只是给出一个样例，其他的还需读者自己实践。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component(&quot;logHandler&quot;)</span><br><span class="line">public class LogHandler &#123;</span><br><span class="line">    @Pointcut(&quot;execution(* com.zhongyp.zen.service.*.*.*(..))&quot;)</span><br><span class="line">    private void hehe()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    @Before(&quot;hehe()&quot;)</span><br><span class="line">    public void doBefore()&#123;</span><br><span class="line">        System.out.println(&quot;为毛国庆要加班！！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-AOP&quot;&gt;&lt;a href=&quot;#Spring-AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring AOP&quot;&gt;&lt;/a&gt;Spring AOP&lt;/h2&gt;&lt;p&gt;本篇文章翻译自&lt;a href=&quot;https://www.tutorialsp
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zhongyp.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>线程简介</title>
    <link href="http://zhongyp.me/2018/03/16/concurrency/2017-03-16-thread-brief/"/>
    <id>http://zhongyp.me/2018/03/16/concurrency/2017-03-16-thread-brief/</id>
    <published>2018-03-15T16:00:00.000Z</published>
    <updated>2018-12-04T11:05:36.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h3><p>现代操作系统在运行程序时，会为其创建一个进程。比如你现在用的浏览器，系统就会为其创建一个甚至多个进程。<strong><em>引入进程的目的是为了更好的使操作系统并发执行程序。来提高资源利用率和系统吞吐量，增加并发程度。</em></strong><br>线程是现代操作系统调度的基本单元，是运行在进程上下文中的逻辑流，是程序执行流的最小单元，也叫轻量级进程（Light Weight Process），也可以称之为CPU的执行单元。一个程序作为一个进程来运行，程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行一个处理器核心上。<strong><em>引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。线程不拥有系统资源（代码，数据、堆、共享库、文件），只拥有运行中必不可少的资源（线程ID, 栈，栈指针，程序计数器、通用目的寄存器和条件码）。</em></strong><br>线程是调度的抽象。<strong><em>Java中将线程的执行和执行对象抽象开来，JDK包中执行的有Thread类，Executor框架，可执行目标有Runaable，Callable。</em></strong></p><h4 id="1-1-线程的优点"><a href="#1-1-线程的优点" class="headerlink" title="1.1 线程的优点"></a>1.1 线程的优点</h4><ol><li>多处理器使用： 提高资源利用率和系统吞吐量。</li></ol><h4 id="1-2-线程的风险"><a href="#1-2-线程的风险" class="headerlink" title="1.2 线程的风险"></a>1.2 线程的风险</h4><ol><li>安全风险：对于共享变量的访问、操作容易造成安全风险。</li><li>活跃度风险：死锁引发活动度失败。</li><li>性能风险：线程之间频繁调度导致上下文切换导致巨大的系统开销。</li></ol><h3 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2. 线程的状态"></a>2. 线程的状态</h3><p><img src="/media/ThreadStatus.png" alt="ThreadStatus"><br><a href="#线程简介">图片来自：Java并发编程的艺术-</a></p><ul><li>新建(NEW)：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（READY）。</li></ul><p><strong><em>注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</em></strong></p><ul><li><p>运行状态(RUNNABLE)：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行中”。</p></li><li><p>就绪(READY)：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。</p></li><li><p>运行(RUNNING)：处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>等待状态(WAITING)：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程作出一些特定动作（通知或中断）。</p></li><li><p>超时等待状态(TIME_WAITING)：该状态不同于WAITING，它是可以在指定的时间自行返回的。</p></li><li><p>阻塞(BLOCKED)：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a>关于BLOCKED的描述：Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.翻译：阻塞线程是等待获取同步监视器锁的线程。线程等待获取同步监视器锁进入同步代码块/方法,或者调用Object.wait方法后,被唤醒后等待获取同步监视器锁,<strong><em>重入</em></strong>同步代码块/方法。</p></li><li><p>死亡(DEAD)：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ul><h3 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3. 线程优先级"></a>3. 线程优先级</h3><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。</p><p><strong><em>注：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</em></strong></p><h3 id="4-Daemon线程"><a href="#4-Daemon线程" class="headerlink" title="4. Daemon线程"></a>4. Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用做程序中后台调度及支持性工作。<br><strong><em> 注意：构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</em></strong></p><p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</span><br><span class="line">• Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">    * 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line">    * 该方法必须在启动线程前调用。</span><br><span class="line">    * 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。</span><br><span class="line">    * 这可能抛出 SecurityException（在当前线程中）。   </span><br><span class="line">    *   参数：</span><br><span class="line">    *      on - 如果为 true，则将该线程标记为守护线程。    </span><br><span class="line">    *   抛出：    </span><br><span class="line">    *     IllegalThreadStateException - 如果该线程处于活动状态。    </span><br><span class="line">    *     SecurityException - 如果当前线程无法修改该线程。</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">public final void setDaemon(boolean on)</span><br></pre></td></tr></table></figure><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p><a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">Java多线程详解</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程（1）-读Thread类源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程简介&quot;&gt;&lt;a href=&quot;#线程简介&quot; class=&quot;headerlink&quot; title=&quot;线程简介&quot;&gt;&lt;/a&gt;线程简介&lt;/h2&gt;&lt;h3 id=&quot;1-什么是线程&quot;&gt;&lt;a href=&quot;#1-什么是线程&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://zhongyp.me/2018/01/04/concurrency/2018-03-04-JavaMemModel/"/>
    <id>http://zhongyp.me/2018/01/04/concurrency/2018-03-04-JavaMemModel/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-12-10T10:13:35.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型（Java Memory Model，简称：JMM），下文中如果没有特殊说明，JMM即代表“Java内存模型”。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-缓存一致性"><a href="#1-1-缓存一致性" class="headerlink" title="1.1 缓存一致性"></a>1.1 缓存一致性</h3><p>在并发编程模型中，需要处理两个关键的问题：<strong>线程之间以何种机制交换信息（通信）及如何控制不同线程之间操作发生相对顺序的机制（同步）</strong>。<br>线程之间的通信机制有两种：共享内存和消息传递，每种通信机制对应不同的内存模型。<br>共享内存模型：线程之间通过读-写内存中的公共状态进行隐式通信。<br>消息传递模型：线程之间没有公共状态，线程之间必须通过发送消息来显示的进行通信。<br><strong><em>Java并发采用的是共享内存模型</em></strong>。<br>在共享的内存模型，多处理器体系架构中，每个<a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2" target="_blank" rel="noopener">处理器</a>都有自己的缓存，并且周期性的与主内存协调一致。处理器架构提供了不同级别的缓存一致性（cache coherence），有些仅提供最小的保证，几乎在任何时间内，都允许不同的处理器在相同位置上看到不同的值。<br>举个简单的例子：在java中，执行下面这个语句：</p><p><code>i  = 10++;</code></p><p>1) 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p><p>2) 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p><p>3) 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</p><p>4) 最终结果i的值是11，而不是12。这就是缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p><p><strong>注：</strong><br>同步：<strong>指程序中用于控制不同线程间操作发生相对顺序的机制</strong>，意味着某种形式的原子性或者互斥。<br>共享内存的并发模型中，同步是显式，程序员必须显示的指定某个方法或某段代码需要在线程之间互斥执行。消息传递的并发模型中，消息的发送必须在消息的接收之前，因此同步是隐式的。</p><p>想要保证每个处理器能在任意时间内获知其他处理器正在处理的工作，代价很高而且很多时候这些信息都是不必要的，所以就牺牲掉存储的一致性来保证性能。为了共享数据时能得到存储协调的保证，Java提供了自己的JMM解决与底层平台存储模型的差异化。</p><h3 id="1-2-重排序"><a href="#1-2-重排序" class="headerlink" title="1.2 重排序"></a>1.2 重排序</h3><p>除了上述的缓存一致性问题外，在执行程序时，为了提高程序的性能，使得处理器内部的运算单元被充分利用，编译器和处理器常常会对指令做重排序。<br>从Java源代码到最终执行的指令序列，会分别经历下面的三种重排序：<br><img src="/media/java-resort.png" alt="resort"><br>图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><ol><li>编译器重排序。编译器不改变单线程语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级重排序。现代处理器采用指令级并行技术将多条指令重叠执行。<strong><em>如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</em></strong></li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>编译器和处理器重排序时会遵守数据依赖性，编译器、运行时和处理器都必须遵守as-if-serial语义。<br><strong>注：</strong><br>数据依赖性：编译器和处理器不会改变存在数据以来关系的两个操作的执行顺序。<strong>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</strong><br>as-if-serial：内部线程类似顺序化语义。不管如何的重排序，单线程程序的执行结果不能被改变。</p><h4 id="1-2-1-重排序的影响"><a href="#1-2-1-重排序的影响" class="headerlink" title="1.2.1 重排序的影响"></a>1.2.1 重排序的影响</h4><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public void writer()&#123;</span><br><span class="line">        a = 1; // 1</span><br><span class="line">        flag = true; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    public void reader()&#123;</span><br><span class="line">        if (flag)&#123; // 3</span><br><span class="line">            int i = a * a; // 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设线程A先执行writrer方法，随后线程B执行reader方法，线程执行操作4时，不一定能看到1处的赋值。原因如下图：<br><img src="/media/resort.png" alt="resort"><br>图片来自<a href="#2-4-happens-before">Java并发编程艺术</a><br>由于操作1和2没有依赖关系，所以编译器和处理器可以对这两个操作重排序，线程A首先标记了flag，随后线程B读取flag。由于flag=true，线程B可以读取a，但是此时的a并为被线程A赋值。所以这里的多线程程序的语义被破坏了。JMM提供同步机制来抑制编译器、运行时和硬件对存储操作的各种方式的重排序，保证内存的可见性。                                              </p><h2 id="2-JMM设计"><a href="#2-JMM设计" class="headerlink" title="2. JMM设计"></a>2. JMM设计</h2><p><img src="/media/jmm-abs.png" alt="JMM的抽象结构"><br>JMM在内存中的抽象结构，图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><p>JMM属于语言级别的内存模型，确保在不同的编译和不同处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，决定一个线程对共享变量的写入何时对另一个线程可见，提供内存可见性保证。<br>从JDK5开始，Java使用JSR-133内存模型。JSR-133使用<strong>happens-before概念保证内存的可见性</strong>。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ol><li><p><strong><em>程序次序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</em></strong></p></li><li><p><strong><em>监视器锁规则：一个unLock操作先行发生于后面对同一个锁的lock操作。</em></strong></p></li><li><p><strong><em>volatile变量规则：对一个volatile变量的写操作，happens-before于后续对这个volatile变量的读操作。</em></strong></p></li><li><p><strong><em>传递性：如果操作A happens-before操作B，而操作B happens-before操作C，则可以得出操作A happens-before操作C。</em></strong></p></li><li><p>start()规则：Thread对象的start()方法happens-before此线程的每个一个动作</p></li><li><p>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p></li></ol><p><img src="/media/happens-before-design.png" alt="happens-before-design"><br>JMM设计图，图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><h2 id="3-JMM的可见性保证"><a href="#3-JMM的可见性保证" class="headerlink" title="3. JMM的可见性保证"></a>3. JMM的可见性保证</h2><ul><li>单线程程序。<strong><em>单线程程序不会出现内存可见性问题。</em></strong>编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li>正确<strong><em>同步</em></strong>的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。JMM通过根据happens-before原则限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li><li>未同步/未正确同步的多线程程序。JMM为他们提供最小的安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么时默认值（0、null、false）。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://www.importnew.com/24082.html" target="_blank" rel="noopener">你真的了解volatile关键字吗？</a></p><p><a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">Java中Volatile关键字详解</a></p><p><a href="">Java并发编程艺术</a></p><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a></p><p><a href="">Java并发编程实践</a></p><p><a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2" target="_blank" rel="noopener">每个程序员都应该了解的 CPU 高速缓存</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;p&gt;Java内存模型（Java Memory Model，简称：JMM），下文中如果没有特殊说明
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>旅行</title>
    <link href="http://zhongyp.me/2017/07/05/life/2017-7-5-Journey/"/>
    <id>http://zhongyp.me/2017/07/05/life/2017-7-5-Journey/</id>
    <published>2017-07-04T16:00:00.000Z</published>
    <updated>2018-10-27T03:29:27.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>旅行让我能望得辽远，想得细密，理解人生的遗憾，与这世界的好处。</p><h2 id="生活的城市"><a href="#生活的城市" class="headerlink" title="生活的城市"></a>生活的城市</h2><ul><li><p><a href="#滕州2013-9">滕州（~2013-9）</a></p></li><li><p><a href="#烟台2013-92016-7">烟台（2013-9~2016-7）</a></p></li><li><p><a href="#北京2016-7">北京（2016-7~）</a></p></li></ul><h2 id="那些值得纪念的地方"><a href="#那些值得纪念的地方" class="headerlink" title="那些值得纪念的地方"></a>那些值得纪念的地方</h2><ul><li><p><a href="#日照2010-8">日照（2010-8）</a></p></li><li><p><a href="#廊坊2012-7">廊坊（2012-7）</a></p></li><li><p><a href="#蓬莱2013-10">蓬莱（2013-10）</a></p></li><li><p><a href="#威海2015-10">威海（2015-10）</a></p></li><li><p><a href="#长岛2017-5">长岛（2017-5）</a></p></li><li><p><a href="#乌兰布统2017-7">乌兰布统（2017-7）</a></p></li></ul><h3 id="生活的城市-1"><a href="#生活的城市-1" class="headerlink" title="生活的城市"></a>生活的城市</h3><h3 id="滕州（-2013-9）"><a href="#滕州（-2013-9）" class="headerlink" title="滕州（~2013-9）"></a>滕州（~2013-9）</h3><h3 id="烟台（2013-9-2016-7）"><a href="#烟台（2013-9-2016-7）" class="headerlink" title="烟台（2013-9~2016-7）"></a>烟台（2013-9~2016-7）</h3><p>大学四年（其实只呆过三年）生活的地方。四年也没去过多少地方，大都时间都在瞎忙，等过了最闲暇的时光，才知道自己错过太多。</p><h3 id="北京（2016-7-）"><a href="#北京（2016-7-）" class="headerlink" title="北京（2016-7~）"></a>北京（2016-7~）</h3><h3 id="那些值得纪念的地方-1"><a href="#那些值得纪念的地方-1" class="headerlink" title="那些值得纪念的地方"></a>那些值得纪念的地方</h3><h3 id="日照（2010-8）"><a href="#日照（2010-8）" class="headerlink" title="日照（2010-8）"></a>日照（2010-8）</h3><h3 id="廊坊（2012-7）"><a href="#廊坊（2012-7）" class="headerlink" title="廊坊（2012-7）"></a>廊坊（2012-7）</h3><h3 id="蓬莱（2013-10）"><a href="#蓬莱（2013-10）" class="headerlink" title="蓬莱（2013-10）"></a>蓬莱（2013-10）</h3><h3 id="威海（2015-10）"><a href="#威海（2015-10）" class="headerlink" title="威海（2015-10）"></a>威海（2015-10）</h3><h3 id="长岛（2017-5）"><a href="#长岛（2017-5）" class="headerlink" title="长岛（2017-5）"></a>长岛（2017-5）</h3><h3 id="乌兰布统（2017-7）"><a href="#乌兰布统（2017-7）" class="headerlink" title="乌兰布统（2017-7）"></a>乌兰布统（2017-7）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;旅行&quot;&gt;&lt;a href=&quot;#旅行&quot; class=&quot;headerlink&quot; title=&quot;旅行&quot;&gt;&lt;/a&gt;旅行&lt;/h2&gt;&lt;p&gt;旅行让我能望得辽远，想得细密，理解人生的遗憾，与这世界的好处。&lt;/p&gt;
&lt;h2 id=&quot;生活的城市&quot;&gt;&lt;a href=&quot;#生活的城市&quot; cl
      
    
    </summary>
    
    
      <category term="生活" scheme="http://zhongyp.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>2017书单</title>
    <link href="http://zhongyp.me/2017/01/01/life/2017-1-1-books/"/>
    <id>http://zhongyp.me/2017/01/01/life/2017-1-1-books/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2018-10-27T03:29:23.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="书架"><a href="#书架" class="headerlink" title="书架"></a>书架</h2><p>–2017书单</p><h2 id="greate-minds：source"><a href="#greate-minds：source" class="headerlink" title="greate minds：source"></a>greate minds：<a href="https://github.com/camda/mybook/tree/master/minds" target="_blank" rel="noopener">source</a></h2><pre><code>+ 深入浅出设计模式+ 人月神话+ 代码整洁之道+ 程序员修炼之道+ 编程之美：微软技术面试心得+ 编程珠玑+ 编程珠玑（续）+ 设计模式+ Java程序员修炼之道+ 算法导论3</code></pre><h2 id="java：source"><a href="#java：source" class="headerlink" title="java：source"></a>java：<a href="https://github.com/camda/mybook/tree/master/java" target="_blank" rel="noopener">source</a></h2><pre><code>+ Java_TCPIP_Socket网络编程</code></pre><h2 id="smart：source"><a href="#smart：source" class="headerlink" title="smart：source"></a>smart：<a href="https://github.com/camda/mybook/tree/master/smart" target="_blank" rel="noopener">source</a></h2><pre><code>+ 周志华-机器学习+ 周志华-数据挖掘与机器学习</code></pre><h2 id="framework：source"><a href="#framework：source" class="headerlink" title="framework：source"></a>framework：<a href="https://github.com/camda/mybook/tree/master/framework" target="_blank" rel="noopener">source</a></h2><pre><code>+ Hibernate开发指南+ SpringGuide+ Spring源码深度解析+ dubbo源码解析2.0+ ZooKeeper</code></pre><h2 id="other-source"><a href="#other-source" class="headerlink" title="other: source"></a>other: <a href="https://github.com/camda/mybook/tree/master/other" target="_blank" rel="noopener">source</a></h2><pre><code>+ 产品经理手册+ 经济学原理+ 你要如何衡量你的人生+ 牛津通识精选+ 三体2 黑暗森林+ 手把手教你读财报+ More Effective C++</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;书架&quot;&gt;&lt;a href=&quot;#书架&quot; class=&quot;headerlink&quot; title=&quot;书架&quot;&gt;&lt;/a&gt;书架&lt;/h2&gt;&lt;p&gt;–2017书单&lt;/p&gt;
&lt;h2 id=&quot;greate-minds：source&quot;&gt;&lt;a href=&quot;#greate-minds：source
      
    
    </summary>
    
    
      <category term="书单" scheme="http://zhongyp.me/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
</feed>
