<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhongyp&#39;blog</title>
  
  <subtitle>钟宇鹏的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhongyp.me/"/>
  <updated>2020-01-07T13:19:43.186Z</updated>
  <id>https://zhongyp.me/</id>
  
  <author>
    <name>zhongyp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阻塞与非阻塞队列</title>
    <link href="https://zhongyp.me/concurrency/2020-01-07/"/>
    <id>https://zhongyp.me/concurrency/2020-01-07/</id>
    <published>2020-01-04T16:00:00.000Z</published>
    <updated>2020-01-07T13:19:43.186Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="并发" scheme="https://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式的使用</title>
    <link href="https://zhongyp.me/concurrency/2019-12-26-java-lambda/"/>
    <id>https://zhongyp.me/concurrency/2019-12-26-java-lambda/</id>
    <published>2019-12-26T16:00:00.000Z</published>
    <updated>2020-01-07T12:47:13.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>匿名类有一个问题是，如果你的匿名类的实现非常简单，比如一个接口仅仅包含一个方法，那么匿名类的语法可能是笨重和模糊的。比如当一个人点击一个按钮应该执行什么动作，在这种情况下，你通常以一个方法作为参数传到另一个方法。lambda表达式允许你将方法作为另一个方法的参数，或者代码作为数据。</p><h3 id="2-Lambda表达式的理想用例"><a href="#2-Lambda表达式的理想用例" class="headerlink" title="2. Lambda表达式的理想用例"></a>2. Lambda表达式的理想用例</h3><h4 id="第1步-创建搜索符合一个特征的成员的方法"><a href="#第1步-创建搜索符合一个特征的成员的方法" class="headerlink" title="第1步. 创建搜索符合一个特征的成员的方法"></a>第1步. 创建搜索符合一个特征的成员的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersonsOlderThan(List&lt;Person&gt; roster, int age) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (p.getAge() &gt;= age) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第2步-创建更通用搜索方法"><a href="#第2步-创建更通用搜索方法" class="headerlink" title="第2步. 创建更通用搜索方法"></a>第2步. 创建更通用搜索方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersonsWithinAgeRange(</span><br><span class="line">    List&lt;Person&gt; roster, int low, int high) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第3步-在本地类中指定搜索条件代码"><a href="#第3步-在本地类中指定搜索条件代码" class="headerlink" title="第3步. 在本地类中指定搜索条件代码"></a>第3步. 在本地类中指定搜索条件代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersons(List&lt;Person&gt; roster, CheckPerson tester) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface CheckPerson &#123;</span><br><span class="line">    boolean test(Person p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CheckPersonEligibleForSelectiveService implements CheckPerson &#123;</span><br><span class="line">    public boolean test(Person p) &#123;</span><br><span class="line">        return p.gender == Person.Sex.MALE &amp;&amp;</span><br><span class="line">            p.getAge() &gt;= 18 &amp;&amp;</span><br><span class="line">            p.getAge() &lt;= 25;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printPersons(roster, new CheckPersonEligibleForSelectiveService());</span><br></pre></td></tr></table></figure><h4 id="第4步-在匿名类中指定搜索条件代码"><a href="#第4步-在匿名类中指定搜索条件代码" class="headerlink" title="第4步. 在匿名类中指定搜索条件代码"></a>第4步. 在匿名类中指定搜索条件代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    new CheckPerson() &#123;</span><br><span class="line">        public boolean test(Person p) &#123;</span><br><span class="line">            return p.getGender() == Person.Sex.MALE</span><br><span class="line">                &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">                &amp;&amp; p.getAge() &lt;= 25;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第5步-使用Lambda表达式指定搜索条件代码"><a href="#第5步-使用Lambda表达式指定搜索条件代码" class="headerlink" title="第5步. 使用Lambda表达式指定搜索条件代码"></a>第5步. 使用Lambda表达式指定搜索条件代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    (Person p) -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第6步-将标准功能接口与Lambda表达式一起使用"><a href="#第6步-将标准功能接口与Lambda表达式一起使用" class="headerlink" title="第6步. 将标准功能接口与Lambda表达式一起使用"></a>第6步. 将标准功能接口与Lambda表达式一起使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface CheckPerson &#123;</span><br><span class="line">    boolean test(Person p);</span><br><span class="line">&#125;</span><br><span class="line">interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br><span class="line">interface Predicate&lt;Person&gt; &#123;</span><br><span class="line">    boolean test(Person t);</span><br><span class="line">&#125;</span><br><span class="line">public static void printPersonsWithPredicate(</span><br><span class="line">    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPersonsWithPredicate(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第7步-在整个应用程序中使用Lambda表达式"><a href="#第7步-在整个应用程序中使用Lambda表达式" class="headerlink" title="第7步. 在整个应用程序中使用Lambda表达式"></a>第7步. 在整个应用程序中使用Lambda表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">printPersonsWithPredicate(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line">);</span><br><span class="line">public static void processPersons(</span><br><span class="line">    List&lt;Person&gt; roster,</span><br><span class="line">    Predicate&lt;Person&gt; tester,</span><br><span class="line">    Consumer&lt;Person&gt; block) &#123;</span><br><span class="line">        for (Person p : roster) &#123;</span><br><span class="line">            if (tester.test(p)) &#123;</span><br><span class="line">                block.accept(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">processPersons(</span><br><span class="line">     roster,</span><br><span class="line">     p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">         &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">         &amp;&amp; p.getAge() &lt;= 25,</span><br><span class="line">     p -&gt; p.printPerson()</span><br><span class="line">);</span><br><span class="line">public static void processPersonsWithFunction(</span><br><span class="line">    List&lt;Person&gt; roster,</span><br><span class="line">    Predicate&lt;Person&gt; tester,</span><br><span class="line">    Function&lt;Person, String&gt; mapper,</span><br><span class="line">    Consumer&lt;String&gt; block) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            String data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">processPersonsWithFunction(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第8步-更广泛的使用泛型"><a href="#第8步-更广泛的使用泛型" class="headerlink" title="第8步. 更广泛的使用泛型"></a>第8步. 更广泛的使用泛型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;X, Y&gt; void processElements(</span><br><span class="line">    Iterable&lt;X&gt; source,</span><br><span class="line">    Predicate&lt;X&gt; tester,</span><br><span class="line">    Function &lt;X, Y&gt; mapper,</span><br><span class="line">    Consumer&lt;Y&gt; block) &#123;</span><br><span class="line">    for (X p : source) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            Y data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">processElements(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第9步-使用接受Lambda表达式作为参数的聚集操作"><a href="#第9步-使用接受Lambda表达式作为参数的聚集操作" class="headerlink" title="第9步. 使用接受Lambda表达式作为参数的聚集操作"></a>第9步. 使用接受Lambda表达式作为参数的聚集操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(</span><br><span class="line">        p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">            &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">            &amp;&amp; p.getAge() &lt;= 25)</span><br><span class="line">    .map(p -&gt; p.getEmailAddress())</span><br><span class="line">    .forEach(email -&gt; System.out.println(email));</span><br></pre></td></tr></table></figure><h3 id="3-Lambda表达式的语法"><a href="#3-Lambda表达式的语法" class="headerlink" title="3. Lambda表达式的语法"></a>3. Lambda表达式的语法</h3><ul><li>用括号括起来的形式参数的逗号分隔列表。 CheckPerson.test方法包含一个参数p，它表示Person类的一个实例。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; p.getGender() == Person.Sex.MALE </span><br><span class="line">    &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">    &amp;&amp; p.getAge() &lt;= 25</span><br></pre></td></tr></table></figure><ul><li><p>箭头标记： -&gt;</p></li><li><p>一个主体，包含一个单个表达式或者一个声明块。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">p.getGender() == Person.Sex.MALE </span><br><span class="line">    &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">    &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line"></span><br><span class="line">p -&gt; &#123;</span><br><span class="line">    return p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">email -&gt; System.out.println(email)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Calculator &#123;</span><br><span class="line">  </span><br><span class="line">    interface IntegerMath &#123;</span><br><span class="line">        int operation(int a, int b);   </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public int operateBinary(int a, int b, IntegerMath op)&#123;</span><br><span class="line">        return op.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">    </span><br><span class="line">        Calculator myApp = new Calculator();</span><br><span class="line">        IntegerMath addition = (a, b) -&gt; a + b;</span><br><span class="line">        IntegerMath subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        System.out.println(&quot;40 + 2 = &quot; +</span><br><span class="line">            myApp.operateBinary(40, 2, addition));</span><br><span class="line">        System.out.println(&quot;20 - 10 = &quot; +</span><br><span class="line">            myApp.operateBinary(20, 10, subtraction));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-访问封闭范围的局部变量"><a href="#4-访问封闭范围的局部变量" class="headerlink" title="4. 访问封闭范围的局部变量"></a>4. 访问封闭范围的局部变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class LambdaScopeTest &#123;</span><br><span class="line"></span><br><span class="line">    public int x = 0;</span><br><span class="line"></span><br><span class="line">    class FirstLevel &#123;</span><br><span class="line"></span><br><span class="line">        public int x = 1;</span><br><span class="line"></span><br><span class="line">        void methodInFirstLevel(int x) &#123;</span><br><span class="line">            </span><br><span class="line">            // The following statement causes the compiler to generate</span><br><span class="line">            // the error &quot;local variables referenced from a lambda expression</span><br><span class="line">            // must be final or effectively final&quot; in statement A:</span><br><span class="line">            //</span><br><span class="line">            // x = 99;</span><br><span class="line">            </span><br><span class="line">            Consumer&lt;Integer&gt; myConsumer = (y) -&gt; </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;x = &quot; + x); // Statement A</span><br><span class="line">                System.out.println(&quot;y = &quot; + y);</span><br><span class="line">                System.out.println(&quot;this.x = &quot; + this.x);</span><br><span class="line">                System.out.println(&quot;LambdaScopeTest.this.x = &quot; +</span><br><span class="line">                    LambdaScopeTest.this.x);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            myConsumer.accept(x);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        LambdaScopeTest st = new LambdaScopeTest();</span><br><span class="line">        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(23);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 23</span><br><span class="line">y = 23</span><br><span class="line">this.x = 1</span><br><span class="line">LambdaScopeTest.this.x = 0</span><br></pre></td></tr></table></figure><p>局部类有权访问其所在类的成员。此外，局部类可以访问局部变量。但是，局部类只能访问声明为final的局部变量（对于非final的数据也能访问，但是不能赋值）。当局部类访问封闭块的局部变量或参数时，它将捕获该变量或参数。</p><p>Lambda表达式和匿名类、局部类类似，它可以捕获变量，但是Lambda表达式不会出现匿名类和局部类的变量遮蔽问题，如下 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ShadowTest &#123;</span><br><span class="line"></span><br><span class="line">    public int x = 0;</span><br><span class="line"></span><br><span class="line">    class FirstLevel &#123;</span><br><span class="line"></span><br><span class="line">        public int x = 1;</span><br><span class="line"></span><br><span class="line">        void methodInFirstLevel(int x) &#123;</span><br><span class="line">            System.out.println(&quot;x = &quot; + x);</span><br><span class="line">            System.out.println(&quot;this.x = &quot; + this.x);</span><br><span class="line">            System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.this.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        ShadowTest st = new ShadowTest();</span><br><span class="line">        ShadowTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(23);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 23</span><br><span class="line">this.x = 1</span><br><span class="line">ShadowTest.this.x = 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaScopeTest &#123;</span><br><span class="line"></span><br><span class="line">    public int x = 0;</span><br><span class="line"></span><br><span class="line">    class FirstLevel &#123;</span><br><span class="line"></span><br><span class="line">        public int x = 1;</span><br><span class="line"></span><br><span class="line">        void methodInFirstLevel(int x) &#123;</span><br><span class="line">            </span><br><span class="line">            // The following statement causes the compiler to generate</span><br><span class="line">            // the error &quot;local variables referenced from a lambda expression</span><br><span class="line">            // must be final or effectively final&quot; in statement A:</span><br><span class="line">            //</span><br><span class="line">            // x = 99;</span><br><span class="line">            </span><br><span class="line">            Consumer&lt;Integer&gt; myConsumer = (y) -&gt; </span><br><span class="line">            &#123;</span><br><span class="line">                // 直接访问methodInFirstLevel方法参数</span><br><span class="line">                System.out.println(&quot;x = &quot; + x); // Statement A</span><br><span class="line">                // Lamda表达式参数</span><br><span class="line">                System.out.println(&quot;y = &quot; + y);</span><br><span class="line">                // FirstLevel参数</span><br><span class="line">                System.out.println(&quot;this.x = &quot; + this.x);</span><br><span class="line">                // LambdaScopeTest参数 </span><br><span class="line">                System.out.println(&quot;LambdaScopeTest.this.x = &quot; +</span><br><span class="line">                    LambdaScopeTest.this.x);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            myConsumer.accept(x);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        LambdaScopeTest st = new LambdaScopeTest();</span><br><span class="line">        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(23);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 23</span><br><span class="line">y = 23</span><br><span class="line">this.x = 1</span><br><span class="line">LambdaScopeTest.this.x = 0</span><br></pre></td></tr></table></figure></p><p>但是，从Java SE 8开始，局部类可以访问final变量或具有final效果的局部变量和封闭块的参数。如果你在一个方法内定义局部类，它可以访问方法的参数。Lambda表达式同样如此。</p><h3 id="5-目标类型和方法参数"><a href="#5-目标类型和方法参数" class="headerlink" title="5. 目标类型和方法参数"></a>5. 目标类型和方法参数</h3><p>对于方法参数，Java编译器使用其他两种语言特性确定目标类型：重载解析和类型参数推断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void invoke(Runnable r) &#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T invoke(Callable&lt;T&gt; c) &#123;</span><br><span class="line">    return c.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-序列化"><a href="#6-序列化" class="headerlink" title="6. 序列化"></a>6. 序列化</h3><p>如果lambda表达式的目标类型和捕获的参数可序列化，则可以对其进行序列化。但是，像内部类一样，强烈建议不要对lambda表达式进行序列化。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda Expressions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;匿名类有一个问题是，如果你的匿名类的实现非常简单，比如一个接口仅仅包含一个方法，那么匿名类的语法可能是笨重和模糊的。比如
      
    
    </summary>
    
    
      <category term="并发" scheme="https://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Stream</title>
    <link href="https://zhongyp.me/java/2019-12-25-java8-stream/"/>
    <id>https://zhongyp.me/java/2019-12-25-java8-stream/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-01-07T13:18:10.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Java8-Stream"><a href="#什么是Java8-Stream" class="headerlink" title="什么是Java8 Stream"></a>什么是Java8 Stream</h2><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚集操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。</p><p>A pipeline is a sequence of aggregate operations. The following example prints the male members contained in the collection roster with a pipeline that consists of the aggregate operations filter and forEach:</p><p>管道是一个聚集操作的序列。下面的例子使用包含聚集操作filter和forEach的管道打印包含在roster集合中男性成员的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(e -&gt; e.getGender() == Person.Sex.MALE)</span><br><span class="line">    .forEach(e -&gt; System.out.println(e.getName()));</span><br></pre></td></tr></table></figure><p>管道包含如下的组件：</p><ul><li>一个源：可以是一个集合、数组、一个生成方法，或者I/O channel。</li><li>零个或者多个中间操作。一个中间操作，例如filter，生成一个流。</li><li>一个终止操作，一个终止操作例如forEach，产生一个非流结果。例如原始值（如double值），集合，或者在forEach的情况下根本没有任何值。 </li></ul><blockquote><p>流是一个元素的序列。不像一个集合，它不是一个数据结构存储元素。相反，一个流通过管道从一个源中提取值。filter操作返回一个包含匹配它断言的要素集的新流。</p></blockquote><h2 id="聚集操作相比于Iterator的不同"><a href="#聚集操作相比于Iterator的不同" class="headerlink" title="聚集操作相比于Iterator的不同"></a>聚集操作相比于Iterator的不同</h2><ul><li>使用内部遍历： 聚集操作不包含类似于指示处理集合内的下一个元素的next方法。使用内部委派，你的应用程序确定要迭代的集合，而JDK确定如何迭代该集合。使用外部迭代，你的应用决定它迭代什么集合和它怎样迭代。但是，外部迭代仅仅可以有序的迭代集合的元素。内部迭代没有这个限制，它可以更好的发挥并行计算的优势，它可以将问题分发为子问题，同时解决这些问题，然后将解决子问题方案的结果组合。</li><li>从流中处理元素：聚集操作从流中处理元素，不是直接从集合中。因此，它们也称作流操作。</li><li>他们支持行为作为参数：对于大多数聚集操作你可以指定lambda表达式作为参数，这允许你自定义一个特定的聚集操作的行为动作。</li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><code>boolean    allMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether all elements of this stream match the provided predicate.</li><li><code>boolean    anyMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether any elements of this stream match the provided predicate.</li><li><code>static &lt;T&gt; Stream.Builder&lt;T&gt; builder()</code><br>Returns a builder for a Stream.</li><li><code>&lt;R,A&gt; R    collect(Collector&lt;? super T,A,R&gt; collector)</code><br>Performs a mutable reduction operation on the elements of this stream using a Collector.</li><li><code>&lt;R&gt; R    collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code><br>Performs a mutable reduction operation on the elements of this stream.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code><br>Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.</li><li><code>long    count()</code><br>Returns the count of elements in this stream.</li><li><code>Stream&lt;T&gt;    distinct()</code><br>Returns a stream consisting of the distinct elements (according to Object.equals(Object)) of this stream.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    empty()</code><br>Returns an empty sequential Stream.</li><li><code>Stream&lt;T&gt;    filter(Predicate&lt;? super T&gt; predicate)</code><br>Returns a stream consisting of the elements of this stream that match the given predicate.</li><li><code>Optional&lt;T&gt;    findAny()</code><br>Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.</li><li><code>Optional&lt;T&gt;    findFirst()</code><br>Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty.</li><li><code>&lt;R&gt; Stream&lt;R&gt;    flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code><br>Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>DoubleStream    flatMapToDouble(Function&lt;? super T,? extends DoubleStream&gt; mapper)</code><br>Returns an DoubleStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>IntStream    flatMapToInt(Function&lt;? super T,? extends IntStream&gt; mapper)</code><br>Returns an IntStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>LongStream    flatMapToLong(Function&lt;? super T,? extends LongStream&gt; mapper)</code><br>Returns an LongStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>void    forEach(Consumer&lt;? super T&gt; action)</code><br>Performs an action for each element of this stream.</li><li><code>void    forEachOrdered(Consumer&lt;? super T&gt; action)</code><br>Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    generate(Supplier&lt;T&gt; s)</code><br>Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    iterate(T seed, UnaryOperator&lt;T&gt; f)</code><br>Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.</li><li><code>Stream&lt;T&gt;    limit(long maxSize)</code><br>Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.</li><li><code>&lt;R&gt; Stream&lt;R&gt;    map(Function&lt;? super T,? extends R&gt; mapper)</code><br>Returns a stream consisting of the results of applying the given function to the elements of this stream.</li><li><code>DoubleStream    mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code><br>Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>IntStream    mapToInt(ToIntFunction&lt;? super T&gt; mapper)</code><br>Returns an IntStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>LongStream    mapToLong(ToLongFunction&lt;? super T&gt; mapper)</code><br>Returns a LongStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>Optional&lt;T&gt;    max(Comparator&lt;? super T&gt; comparator)</code><br>Returns the maximum element of this stream according to the provided Comparator.</li><li><code>Optional&lt;T&gt;    min(Comparator&lt;? super T&gt; comparator)</code><br>Returns the minimum element of this stream according to the provided Comparator.</li><li><code>boolean    noneMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether no elements of this stream match the provided predicate.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    of(T... values)</code><br>Returns a sequential ordered stream whose elements are the specified values.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    of(T t)</code><br>Returns a sequential Stream containing a single element.</li><li><code>Stream&lt;T&gt;    peek(Consumer&lt;? super T&gt; action)</code><br>Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.</li><li><code>Optional&lt;T&gt;    reduce(BinaryOperator&lt;T&gt; accumulator)</code><br>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.</li><li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code><br>Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.</li><li><code>&lt;U&gt; U    reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</code><br>Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions.</li><li><code>Stream&lt;T&gt;    skip(long n)</code><br>Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream.</li><li><code>Stream&lt;T&gt;    sorted()</code><br>Returns a stream consisting of the elements of this stream, sorted according to natural order.</li><li><code>Stream&lt;T&gt;    sorted(Comparator&lt;? super T&gt; comparator)</code><br>Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.</li><li><code>Object[]    toArray()</code><br>Returns an array containing the elements of this stream.</li><li><code>&lt;A&gt; A[]    toArray(IntFunction&lt;A[]&gt; generator)</code><br>Returns an array containing the elements of this stream, using the provided generator function to allocate the returned array, as well as any additional arrays that might be required for a partitioned execution or for resizing.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">Java 8 中的 Streams API 详解-陈争云, 占宇剑, 和司磊</a></p><p><a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html#pipelines" target="_blank" rel="noopener">Pipelines and Streams</a></p><p><a href="https://docs.oracle.com/javase/10/index.html" target="_blank" rel="noopener">Java™ Platform Standard Ed. 8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Java8-Stream&quot;&gt;&lt;a href=&quot;#什么是Java8-Stream&quot; class=&quot;headerlink&quot; title=&quot;什么是Java8 Stream&quot;&gt;&lt;/a&gt;什么是Java8 Stream&lt;/h2&gt;&lt;p&gt;Java 8 中的 Stream 是
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>初探 Spring Boot</title>
    <link href="https://zhongyp.me/spring/2019-12-13-spring-boot-init/"/>
    <id>https://zhongyp.me/spring/2019-12-13-spring-boot-init/</id>
    <published>2019-12-12T16:00:00.000Z</published>
    <updated>2020-01-07T13:21:59.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-起步"><a href="#1-起步" class="headerlink" title="1. 起步"></a>1. 起步</h2><h3 id="1-1-Spring-Boot启动"><a href="#1-1-Spring-Boot启动" class="headerlink" title="1.1 Spring Boot启动"></a>1.1 Spring Boot启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//开启组件扫描和自动配置@SpringBootApplication</span><br><span class="line">public class ReadingListApplication &#123;</span><br><span class="line"> public static void main(String[] args) &#123; </span><br><span class="line">    SpringApplication.run(ReadingListApplication.class, args);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@SpringBootApplication开启了Spring的组件扫描和Spring Boot的自动配置功能。实际上，@SpringBootApplication将三个有用的注解组合在了一起。</p><ul><li>Spring的@Configuration:标明该类使用Spring基于Java的配置。虽然本书不会写太多配置，但我们会更倾向于使用基于Java而不是XML的配置。</li><li>Spring的@ComponentScan:启用组件扫描，这样你写的Web控制器类和其他组件才能被 自动发现并注册为Spring应用程序上下文里的Bean。本章稍后会写一个简单的Spring MVC控制器，使用@Controller进行注解，这样组件扫描才能找到它。</li><li>Spring Boot的@EnableAutoConfiguration:这个不起眼的小注解也可以称为 @Abracadabra1，就是这一行配置开启了Spring Boot自动配置的魔力，让你不用再写成篇的配置了</li></ul><h3 id="1-2-Spring-Boot测试"><a href="#1-2-Spring-Boot测试" class="headerlink" title="1.2 Spring Boot测试"></a>1.2 Spring Boot测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(classes = ReadingListApplication.class) @WebAppConfiguration</span><br><span class="line">public class ReadingListApplicationTests &#123;</span><br><span class="line">  @Test</span><br><span class="line">  public void contextLoads() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadingListApplication.class不止是个用于测试的占位符，它还是一个例 子，告诉你如何为Spring Boot应用程序编写测试。</p><h3 id="1-3-Spring-Boot构建过程"><a href="#1-3-Spring-Boot构建过程" class="headerlink" title="1.3 Spring Boot构建过程"></a>1.3 Spring Boot构建过程</h3><p>构建插件的主要功能是把项目打包成一个可执行的超级JAR(uber-JAR)，包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行 应用程序。</p><p>除了构建插件，Maven构建说明中还将spring-boot-starter-parent作为上一级，这样就能利用Maven的依赖管理功能。继承很多常用库的依赖版本，注意这个pom.xml里的<denpendency>都没有指定版本。</denpendency></p><h3 id="1-4-起步依赖"><a href="#1-4-起步依赖" class="headerlink" title="1.4 起步依赖"></a>1.4 起步依赖</h3><p>Spring Boot通过提供众多起步依赖降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型(Project Object Model，POM)，定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。</p><p>起步依赖和你项目里的其他依赖没什么区别。也就是说，你可以通过构建工具中的功能，选择性地覆盖它们引入的传递依赖的版本号，排除传递依赖，当然还可以为那些Spring Boot起步依赖没有涵盖的库指定依赖。<br>以Spring Boot的Web起步依赖为例，它传递依赖了Jackson JSON库。如果你正在构建一个生产或消费JSON资源表述的REST服务，那它会很有用。但是，要构建传统的面向人类用户的Web应用程序，你可能用不上Jackson。虽然把它加进来也不会有什么坏处，但排除掉它的传递依赖，可以为你的项目瘦身。</p><p>Maven总是会用最近的依赖，也就是说，你在项目的构建说明文件里增加的这个依赖，会覆 盖传递依赖引入的另一个依赖。</p><h3 id="1-5-使用自动配置"><a href="#1-5-使用自动配置" class="headerlink" title="1.5 使用自动配置"></a>1.5 使用自动配置</h3><p>Spring Boot的自动配置是一个运行时的过程，考虑了众多因素才决定Spring配置用哪个。</p><p>例如：</p><ul><li>Spring的JdbcTemplate是不是在Classpath里?如果是，并且有DataSource的Bean，则自动配置一个JdbcTemplate的Bean。</li><li>Thymeleaf是不是在Classpath里?如果是，则配置Thymeleaf的模板解析器、视图解析器以<br>及模板引擎。</li><li>Spring Security是不是在Classpath里?如果是，则进行一个非常基本的Web安全设置。</li></ul><h3 id="1-6-定义领域模型"><a href="#1-6-定义领域模型" class="headerlink" title="1.6 定义领域模型"></a>1.6 定义领域模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Book &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy=GenerationType.AUTO) 7 private Long id;</span><br><span class="line">    private String reader;</span><br><span class="line">    private String isbn;</span><br><span class="line">    private String title;</span><br><span class="line">    private String author;</span><br><span class="line">    private String description;</span><br><span class="line">    </span><br><span class="line">    set...();</span><br><span class="line">    ...</span><br><span class="line">    get...();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-定义仓库接口"><a href="#1-7-定义仓库接口" class="headerlink" title="1.7 定义仓库接口"></a>1.7 定义仓库接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line">public interface ReadingListRepository extends JpaRepository&lt;Book, Long&gt; &#123; </span><br><span class="line">    List&lt;Book&gt; findByReader(String reader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过扩展JpaRepository，ReadingListRepository直接继承了18个执行常用持久化操作的方法。JpaRepository是个泛型接口，有两个参数:仓库操作的领域对象类型，及其ID属性的类型。此外，我还增加了一个findByReader()方法，可以根据读者的用户名来查找阅读列表。</p><h3 id="1-8-创建Web"><a href="#1-8-创建Web" class="headerlink" title="1.8 创建Web"></a>1.8 创建Web</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/&quot;)</span><br><span class="line">public class ReadingListController &#123;</span><br><span class="line">      private ReadingListRepository readingListRepository;</span><br><span class="line">      @Autowired</span><br><span class="line">      public ReadingListController(ReadingListRepository readingListRepository) </span><br><span class="line">      &#123; </span><br><span class="line">        this.readingListRepository = readingListRepository;</span><br><span class="line">      &#125;</span><br><span class="line">      @RequestMapping(value=&quot;/&#123;reader&#125;&quot;, method=RequestMethod.GET) </span><br><span class="line">      public String readersBooks(@PathVariable(&quot;reader&quot;) String reader,Model model) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; readingList = readingListRepository.findByReader(reader);</span><br><span class="line">        if (readingList != null) &#123; </span><br><span class="line">            model.addAttribute(&quot;books&quot;, readingList);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;readingList&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      @RequestMapping(value=&quot;/&#123;reader&#125;&quot;, method=RequestMethod.POST) </span><br><span class="line">      public String addToReadingList(@PathVariable(&quot;reader&quot;) String reader, Book book) &#123; </span><br><span class="line">        book.setReader(reader);</span><br><span class="line">        readingListRepository.save(book);</span><br><span class="line">        return &quot;redirect:/&#123;reader&#125;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-自定义配置"><a href="#2-自定义配置" class="headerlink" title="2. 自定义配置"></a>2. 自定义配置</h2><h3 id="2-1-覆盖自动配置"><a href="#2-1-覆盖自动配置" class="headerlink" title="2.1 覆盖自动配置"></a>2.1 覆盖自动配置</h3><p>有些时候Spring Boot的自动配置并不能覆盖你的需求，需要自定义一些配置覆盖自动配置。</p><p>想要覆盖Spring Boot的自动配置，仅仅需要编写一个显式的配置。</p><p>自动配置自带了很多配置类，他们都使用了Spring 4.0的条件化配置，可以在运行时判断是该被运用还是该被忽略。</p><h3 id="2-2-通过属性文件外置配置"><a href="#2-2-通过属性文件外置配置" class="headerlink" title="2.2 通过属性文件外置配置"></a>2.2 通过属性文件外置配置</h3><p>Spring Boot提供了300多个用于微调的属性。<br>Spring Boot能从多种属性源获得属性：</p><ul><li>命令行参数</li><li>java:comp/env里的JNDI属性</li><li>JVM系统属性</li><li>操作系统环境变量</li><li>随机生成的带Random.*前缀的属性。例如：${random.long}</li><li>应用程序以外的application.properties或者application.yml</li><li>打包在应用程序以内的application.properties或者application.yml</li><li>通过@PropertySource标注的属性源</li><li>默认属性</li></ul><h3 id="2-3-Bean的配置外置"><a href="#2-3-Bean的配置外置" class="headerlink" title="2.3 Bean的配置外置"></a>2.3 Bean的配置外置</h3><p><code>@ConfigurationProperties(&quot;amzon&quot;)</code> 注入带amazon前缀的属性。<br><code>@Profile(&quot;production&quot;)</code>production环境运行时激活。</p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><h3 id="3-1-集成测试自动配置"><a href="#3-1-集成测试自动配置" class="headerlink" title="3.1 集成测试自动配置"></a>3.1 集成测试自动配置</h3><p>Spring Framework的核心工作是将所有组件编织在一起，构成一个应用程序。整个过程就是读取配置说明(可以是XML、基于Java的配置、基于Groovy的配置或其他类型的配置)，在应用程序上下文里初始化Bean，将Bean注入依赖它们的其他Bean中。<br>对Spring应用程序进行集成测试时，让Spring遵照生产环境来组装测试目标Bean是非常重要的一点。自Spring 2.5开始，集成测试支持的形式就变成了SpringJUnit4ClassRunner。这是一个JUnit类运行器，会为JUnit测试加载Spring应用程序上下文，并为测试类自动织入所需的Bean。<br>SpringApplication不仅加载应用程序上下文，还会开启日志、加载外部属性(application.properties或application.yml)，以及其他Spring Boot特性。用@Context- Configuration则得不到这些特性。<br>@SpringApplicationConfiguration的用法和@ContextConfiguration大致相同，但<br>也有不同的地方，@SpringApplicationConfiguration加载Spring应用程序上下文的方式同 SpringApplication相同，处理方式和生产应用程序中的情况相同。这包括加载外部属性和 Spring Boot日志。<br>我们有充分的理由说，在大多数情况下，为Spring Boot应用程序编写测试时应该用@Spring-ApplicationConfiguration代替@ContextConfiguration。在本章中，我们当然也会用 @SpringApplicationConfiguration来为Spring Boot应用程序(包括那些面向前端的应用程 序)编写测试。</p><h3 id="3-2-模拟Spring-MVC"><a href="#3-2-模拟Spring-MVC" class="headerlink" title="3.2 模拟Spring MVC"></a>3.2 模拟Spring MVC</h3><p>早在Spring 3.2，Spring Framework就有了一套非常实用的Web应用程序测试工具，能模拟 Spring MVC，不需要真实的Servlet容器也能对控制器发送HTTP请求。Spring的Mock MVC框架模拟了Spring MVC的很多功能。它几乎和运行在Servlet容器里的应用程序一样，尽管实际情况并非如此。<br>要在测试里设置Mock MVC，可以使用MockMvcBuilders，该类提供了两个静态方法。</p><ul><li>standaloneSetup():构建一个Mock MVC，提供一个或多个手工创建并配置的控制器。 </li><li>webAppContextSetup():使用Spring应用程序上下文来构建Mock MVC，该上下文里</li></ul><p>可以包含一个或多个配置好的控制器。 两者的主要区别在于，standaloneSetup()希望你手工初始化并注入你要测试的控制器，而webAppContextSetup()则基于一个WebApplicationContext的实例，通常Spring加载。前者同单元测试更加接近，你可能只想让它专注于单一控制器的测试，而后者让Spring加载控制 器及其依赖，以便进行完整的集成测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import static org.hamcrest.Matchers.*;</span><br><span class="line">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line">@SpringApplicationConfiguration(classes = ReadingListApplication.class)</span><br><span class="line">@WebAppConfiguration</span><br><span class="line">public class MockMvcWebTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private WebApplicationContext webContext;</span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line">    @Before</span><br><span class="line">    public void setupMockMvc() &#123;</span><br><span class="line">        mockMvc = MockMvcBuilders .webAppContextSetup(webContext) .build();</span><br><span class="line">    &#125; </span><br><span class="line">    @Test</span><br><span class="line">    public void homePage() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/readingList&quot;)) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.view().name(&quot;readingList&quot;)) .andExpect(MockMvcResultMatchers.model().attributeExists(&quot;books&quot;)) .andExpect(MockMvcResultMatchers.model().attribute(&quot;books&quot;,Matchers.is(Matchers.empty())));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void homePage() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(get(&quot;/readingList&quot;)) .andExpect(status().isOk()) .andExpect(view().name(&quot;readingList&quot;)) .andExpect(model().attributeExists(&quot;books&quot;)) .andExpect(model().attribute(&quot;books&quot;, is(empty())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">Spring Boot实战-丁雪丰</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-起步&quot;&gt;&lt;a href=&quot;#1-起步&quot; class=&quot;headerlink&quot; title=&quot;1. 起步&quot;&gt;&lt;/a&gt;1. 起步&lt;/h2&gt;&lt;h3 id=&quot;1-1-Spring-Boot启动&quot;&gt;&lt;a href=&quot;#1-1-Spring-Boot启动&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://zhongyp.me/tags/Spring/"/>
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Spring Boot" scheme="https://zhongyp.me/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统概念</title>
    <link href="https://zhongyp.me/mysql/2019-12-05-database/"/>
    <id>https://zhongyp.me/mysql/2019-12-05-database/</id>
    <published>2019-12-04T16:00:00.000Z</published>
    <updated>2019-12-08T02:51:07.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1. 什么是数据库？"></a>1. 什么是数据库？</h3><p>数据库管理系统（DataBase-Management System， DBMS）由一个互相关联的数据的集合和一组用以访问这些数据的程序组成。这个数据集通常称为数据库。</p><p>数据库结构的基础是数据模型（data model）。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。</p><p>数据模型可被划分为四类：</p><ul><li>关系模型（relational）：关系模型用表的集合来表示数据和数据间的联系。</li><li>实体-联系模型（entity-relationship model）：实体-联系（E-R）数据模型给予对现实世界的这样一种认识：现实世界由一组称作实体的基本对象以及这些对象间的联系构成。</li><li>基于对象的数据模型（object-based data model）：面向对象的数据模型可以看成是E-R模型增加封装、方法和对象标识等概念后的扩展。</li><li>半结构化数据模型（semistructured data model）：半结构化数据结构模型允许那些相同类型的数据项含有不同的属性集的数据定义。可扩展标记语言（eXtensible Markup Language， XML）被广泛的用来表示半结构化数据。</li></ul><h3 id="2-数据库语言"><a href="#2-数据库语言" class="headerlink" title="2. 数据库语言"></a>2. 数据库语言</h3><p>数据库操纵语言（Data-manipulationn Language）来表达数据的查询和更新。数据库定义语言（data-definition language）来定义数据库模型。</p><h3 id="3-关系数据库"><a href="#3-关系数据库" class="headerlink" title="3. 关系数据库"></a>3. 关系数据库</h3><p>关系数据库基于关系模型，使用一系列来表达数据以及这些数据之间的联系。</p><h4 id="3-1-关系数据库的结构"><a href="#3-1-关系数据库的结构" class="headerlink" title="3.1 关系数据库的结构"></a>3.1 关系数据库的结构</h4><p>关系数据库由表的集合构成，每个表有唯一的名字。</p><p>一般来说，表中一行代表了一组值之间的一种联系。由于一个表就是这种联系的一个集合，表这个概念和数学上的关系这个概念是密切相关的，这也正是关系数据模型名称的由来。</p><h3 id="4-数据库存储和查询"><a href="#4-数据库存储和查询" class="headerlink" title="4. 数据库存储和查询"></a>4. 数据库存储和查询</h3><p>存储管理器是数据库系统中负责在数据库中存储的低层数据与应用程序以及向系统提交的查询之间提供接口的部件。存储管理器负责与文件管理器交互。原始数据通过操作系统提供的文件系统存储在磁盘上。存储管理器将各种DML语句翻译为底层文件系统命令。</p><p>存储管理部件：</p><ul><li>权限及完整性管理器（authorization and integrity manager）,它检测是否满足完整性约束，并检查试图访问数据的用户的权限。</li><li>事务管理器（transaction manager），它保证即使发生了故障，数据库也保持在一致的状态，并保证并发事务的执行不发生冲突。</li><li>文件管理器（file manager），它管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构。</li><li>缓冲区管理器（buffer manager），它负责将数据从磁盘取到内存中来，并决定你哪些数据应被缓冲存储在内存中。缓冲区管理器 是数据库系统中的一个关键部分，因为它使用数据库可以处理比内存更大的数据。</li></ul><p>存储管理器实现了集中数据结构：</p><ul><li>数据文件（data files），存储数据库自身。</li><li>数据字典（data dictionary），存储关于数据库结构的元数据，尤其是数据库模式。</li><li>索引（index），提供对数据项的快速访问。</li></ul><p>查询处理器：</p><ul><li>DDL解释器（DDL interpreter），它解释DDL语句并将这些定义记录在数据字典中。</li><li>DML编译器（DML compiler），将查询语言中的 DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。</li></ul><p>一个查询通常可被翻译为多种等价的具有相同结果的执行方案的一种。DML编译器还进行查询优化（query optimization），也就是从几种选择中选出代价最小的一种。</p><ul><li>查询执行引擎（query evaluation engine），执行由DML编译器产生的低级指令。</li></ul><h3 id="5-事务管理"><a href="#5-事务管理" class="headerlink" title="5. 事务管理"></a>5. 事务管理</h3><p>事务（transaction）是数据库应用中完成单一逻辑功能的操作集合。每一个事务是一个既具有原子性又具有一致性的单元。</p><p>事务管理器（transaction manager）包括并发控制管理器和恢复管理器。</p><p>并发管理器（concurrency-control manager）控制并发事务间的相互影响，保证数据库一致性。</p><p>恢复管理器（recovery manager）负责保证原子性和持久性。</p><h3 id="6-数据库体系结构"><a href="#6-数据库体系结构" class="headerlink" title="6. 数据库体系结构"></a>6. 数据库体系结构</h3><p>数据库应用通常可分为两或三个部分。</p><p><img src="/media/article/database-structure.png" alt="database-structure"></p><h3 id="7-数据挖掘和信息检索"><a href="#7-数据挖掘和信息检索" class="headerlink" title="7. 数据挖掘和信息检索"></a>7. 数据挖掘和信息检索</h3><p>数据挖掘（data mining）这个术语指半自动地分析大型数据库并从中找出有用的模式的过程。</p><h2 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h2><h3 id="1-SQL查询语言预览"><a href="#1-SQL查询语言预览" class="headerlink" title="1. SQL查询语言预览"></a>1. SQL查询语言预览</h3><ul><li>数据定义语言 （Data-Definition Language， DDL）：SQL DDL提供定义关系模式、删除关系以及修改关系模式的命令。</li><li>数据操作语言（Data-Manipulation Language， DML）：SQL DML提供从数据库中查询信息，以及 在数据库中插入元组、删除元组、修改元组的能力。</li><li>完整性（integrity）：SQL DDL包括定义完整性约束的命令，保存在数据库中的数据必须满足所定义的完整性约束。破坏完整性约束的更新是不允许的。</li><li>视图定义 （view definition）：SQL DDL包括定义视图的命令。</li><li>事务控制（transaction control）：SQL 包括定义事务的开始和结束的命令。</li><li>嵌入式SQL和动态SQL（embedded SQL and dynamic SQL）：嵌入式和动态SQL定义SQL语句如何嵌入到通用编程语言，如C、C++和Java中。</li><li>授权（authorization）：SQL DDL包括定义对关系和视图的访问权限的命令。</li></ul><h4 id="1-1-SQL数据定义"><a href="#1-1-SQL数据定义" class="headerlink" title="1.1 SQL数据定义"></a>1.1 SQL数据定义</h4><p>基本类型：</p><ul><li>char(n)：固定长度的字符串，用户指定长度n。也可以使用全称character。</li><li>varchar(n)：可变长度的字符串，用户指定最大长度n，等价于全称character varying。</li><li>int：整数类型，等价于integer。</li><li>smallint：小整数类型。</li><li>numeric(p,d)：定点数，精度由用户指定。</li><li>real，double precision：浮点数与双精度浮点数，精度与机器相关。</li><li>float(n)：精度至少为n位的浮点数。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>两种基本的索引类型：</p><ul><li>顺序索引。基于值的顺序排序。</li><li>散列索引。介于将值平均分不到若干散列桶中。一个值所属的散列桶是由一个函数决定的，该函数称为散列函数。</li></ul><p>对于索引的考虑因素：</p><ul><li>访问类型（access type）：能有效支持的访问类型。访问类型可以包括找到具有特定属性值的记录，以及找到属性值落在某个特定范围内的记录。</li><li>访问时间（access time）：在查询中使用该技术找到一个特定数据项货数据项集所需的时间。</li><li>插入时间（insertion time）：插入一个新数据项所需的时间。该值包括找到待删除项所需的时间，以及更新索引结构所需的时间。</li><li>空间开销（space overhead）：索引结构所占用的额外存储空间。</li></ul><h3 id="1-顺序索引"><a href="#1-顺序索引" class="headerlink" title="1. 顺序索引"></a>1. 顺序索引</h3><p>顺序索引按照顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。<br>被索引的文件中的记录自身也可以按照某种排序顺序存储，正如图书馆中的书按某些属性顺序存放一样。一个文件可以有多个索引，分别基于不同的搜索码。<br><strong><em>如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为聚集索引（clustering index）</em></strong>。聚集索引也称为 主索引（primary index）；搜索码指定的顺序与文件中记录的物理顺序不同的索引称为非聚集索引（nonclustering index）或辅助索引（secondary index）。</p><h4 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h4><p>索引项（index entry）或索引记录（index record）由一个搜索码值和指向具有该搜索码值的一条或者多条记录的指针构成。指向记录的指针包括磁盘块的标识和标识磁盘块内记录的块内偏移量。<br>可以使用的顺序索引有两类：</p><ul><li>稠密索引（dense index）：在稠密索引中，文件中的每个搜索码值都有一个索引项。在稠密索引中，索引项包括搜索码值以及指向具有该搜索码的第一条数据记录的指针。具有相同搜索码值的其余记录顺序的存储在第一条数据记录之后，由于该索引是聚集索引，因此记录根据相同的索引码值排序。在稠密非聚集索引中，索引必须存储指向所有具有相同搜索码值的记录的指针列表。</li><li>稀疏索引（sparse index）：在稀疏索引中，只为搜索码的某些值建立索引项。只有当关系按搜索码排列顺序存储时才能使用稀疏索引，换句话说，只有索引是聚集索引时才能使用稀疏索引。和稠密索引一样，每个索引项也包括一个搜索码和指向具有该搜索码值的第一条记录的指针。为了定位一条记录，我们找到其最大搜索码值小于或等于所查找记录的搜索码值的索引项。然后从该索引项指向的记录开始，沿着文件的指针查找，直到找到记录为止。</li></ul><p><img src="/media/article/dense-sparse-index.png" alt="dennse-sparse"></p><h4 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h4><p>具有两级或者两级以上的索引称为多集（multilevel）索引。多级索引搜索记录于用二分法搜索记录相比需要的I/O操作要少得多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;1-什么是数据库？&quot;&gt;&lt;a href=&quot;#1-什么是数据库？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是数
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="https://zhongyp.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis空间优化</title>
    <link href="https://zhongyp.me/redis/2019-11-13-redis-space-optimization/"/>
    <id>https://zhongyp.me/redis/2019-11-13-redis-space-optimization/</id>
    <published>2019-11-12T16:00:00.000Z</published>
    <updated>2019-11-15T10:57:00.167Z</updated>
    
    <content type="html"><![CDATA[<p>我们项目使用Redis越来越多，可是Redis毕竟是基于内存的数据库，所以对于Redis的空间使用如果不加注意，很容易导致内存溢出。</p><h3 id="1-Redis数据结构"><a href="#1-Redis数据结构" class="headerlink" title="1. Redis数据结构"></a>1. Redis数据结构</h3><p>Redis使用了五种数据对象：字符串对象，列表对象，哈希对象，集合对象，有序集合对象。</p><p>Redis基于这五种对象也给出了优化：</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串中有int、embstr和raw（Simple Dynamic String）两种存储字符串的结构。如果只读且大小小于32字节，则使用embstr，否则使用raw，embstr只能转化为raw，raw不能转化为embstr。关于两者的区别详细了解<a href="/redis/2019-06-21-redis/#1-8-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1">Redis设计与实现</a></p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的底层数据结构在3.2版本之前可以是链表（linkedlist），也可以是压缩列表（ziplist），对于链表保存不需要连续的内存空间（是优点也是缺点，容易造成内存碎片），相比于压缩列表多了保存pre、next指针的空间，ziplist保存在连续内存空间上，不需要维护pre、next指针。当保存的字符串长度小于64字节且列表对象个数小于512时使用压缩列表。</p><p>在3.2版本之后唯一的数据结构是快表（quicklist），它是一个双向链表，而且是一个ziplist的双向链表。这是什么意思呢？我们知道，双向链表是由多个节点（Node）组成的。这个描述的意思是：quicklist的每个节点都是一个ziplist。</p><p>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</p><p>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象底层数据结构可以是ziplist和字典hashtable。ziplist存储字符串不超过32字节和总个数不超过512的数据。</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象底层数据结构是intset或者hashtable。</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合对象底层数据结构是ziplist或者是skiplist。当存储的字符串长度大于64时转为skiplist。<br>skiplist存储时使用skiplist和hashtabl两种结构进行存储，如果我们只是用字典hashtable来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p><p>需要注意的是<strong><em>字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p>使用上述对象时，需要考虑底层数据结构特性，是否会因为频繁删除增加修改，造成Redis的内存碎片化，频繁修改的数据不建议放入到Redis。不仅如此，考虑到Redis空间的复用性，对于不常用的key设置过期时间。</p><h3 id="2-Redis存储优化"><a href="#2-Redis存储优化" class="headerlink" title="2. Redis存储优化"></a>2. Redis存储优化</h3><p>本章节摘自《<a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a>》</p><ol><li><p>利用Redis内存分配器做第一层优化。例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p></li><li><p>尽量使用整型/长整型。如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。</p></li><li><p>利用共享对象，共享对象包括10000个整数，可以通过REDIS_SHARED_INTEGERS参数提高共享对象的个数。</p></li><li><p>关注内存碎片率，如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。</p></li><li><p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p></li><li><p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a></p><p><a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a></p><p><a href="/redis/2019-06-21-redis/#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8%E5%AD%98%E5%82%A8%E6%95%88%E7%8E%87">quicklist存储效率</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们项目使用Redis越来越多，可是Redis毕竟是基于内存的数据库，所以对于Redis的空间使用如果不加注意，很容易导致内存溢出。&lt;/p&gt;
&lt;h3 id=&quot;1-Redis数据结构&quot;&gt;&lt;a href=&quot;#1-Redis数据结构&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://zhongyp.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://zhongyp.me/redis/2019-11-18-redis-strike/"/>
    <id>https://zhongyp.me/redis/2019-11-18-redis-strike/</id>
    <published>2019-11-12T16:00:00.000Z</published>
    <updated>2019-11-21T08:52:07.387Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/linxiyue/p/11295463.html" target="_blank" rel="noopener">浅谈布隆过滤器Bloom Filter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linxiyue/p/11295463.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浅谈布隆过滤器Bloom Filter&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Redis" scheme="https://zhongyp.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis和消息中间件</title>
    <link href="https://zhongyp.me/redis/2019-11-16-redis-queue/"/>
    <id>https://zhongyp.me/redis/2019-11-16-redis-queue/</id>
    <published>2019-11-12T16:00:00.000Z</published>
    <updated>2019-11-18T06:35:04.356Z</updated>
    
    <content type="html"><![CDATA[<p>Redis自带的PUB/SUB机制，即发布-订阅模式。这种模式生产者(producer)和消费者(consumer)是1-M的关系，即一条消息会被多个消费者消费。如果消息丢失、Redis宕机部分数据没有持久化甚至突然的网络抖动都可能带来数据的丢失，应该是无法忍受的。其次，扩展不灵活，没法通过多加consumer来加快消费的进度，如果前端写入数据太多，同步会比较慢，数据不同步的状态越久，风险越大，可以通过channel拆分的方式来解决，虽然不灵活，但可以规避。这种方案更适合于对数据可靠性要求不高，比如一些统计日志打点。</p><p>Redis的PUSH/POP机制，利用的Redis的列表(lists)数据结构。比较好的使用模式是，生产者lpush消息，消费者brpop消息，并设定超时时间，可以减少redis的压力。这种方案相对于第一种方案是数据可靠性提高了，只有在Redis宕机且数据没有持久化的情况下丢失数据，可以根据业务通过AOF和缩短持久化间隔来保证很高的可靠性，而且也可以通过多个client来提高消费速度。但相对于专业的消息队列来说，该方案消息的状态过于简单(没有状态)，且没有ack机制，消息取出后消费失败依赖于client记录日志或者重新push到队列里面。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">从Redis谈起（三）—— Redis和消息中间件<br>–中间件架构</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis自带的PUB/SUB机制，即发布-订阅模式。这种模式生产者(producer)和消费者(consumer)是1-M的关系，即一条消息会被多个消费者消费。如果消息丢失、Redis宕机部分数据没有持久化甚至突然的网络抖动都可能带来数据的丢失，应该是无法忍受的。其次，扩
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://zhongyp.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://zhongyp.me/concurrency/2019-11-07-threadpool/"/>
    <id>https://zhongyp.me/concurrency/2019-11-07-threadpool/</id>
    <published>2019-11-06T16:00:00.000Z</published>
    <updated>2019-11-15T07:16:03.081Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在生产环境中，应避免直接创建线程，线程数量必须得到控制。</p></blockquote><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>为了控制线程，JDK类库提供了一套Executor框架。</p><p><img src="/media/article/executor.png" alt="executor"></p><p>线程池是JDK用来管理线程的的静态工厂。上图中ThreadPoolExecutor表示一个线程池。<br>Executor是一个接口，接口中只有<code>void execute(Runnable command)</code>方法。<br>ExecutorService也是一个接口，继承ExecutorService，增加了许多使用线程池的公用方法定义。<br>AbstactExecutorService为ExecutorService接口提供了默认实现。<br>ThreadPoolExecutor继承AbstactExecutorService抽象类。<br>Executors类是JDK1.5版本时封装的线程池工厂和工具类，这个类提供了几种默认的<a href="/concurrency/2019-11-07-threadpool/#1-2-Executor%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90">线程池类型</a>和默认线程池工厂。<br>ForkJoinPool是Java7加入的一种用于并行执行任务的框架</p><h3 id="1-1-创建线程池"><a href="#1-1-创建线程池" class="headerlink" title="1.1 创建线程池"></a>1.1 创建线程池</h3><p>创建线程池的实现其实是实例化ThreadPoolExecutor的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>corePoolSize：指定线程池中的线程数量。<br>maximumPoolSize：线程池中的最大线程数量。<br>keepAliveTime：当线程池超过corePoolSize时，多余的空闲线程的空闲时间。<br>unit：keepAliveTime的时间单位。<br>workQueue：任务队列，被提交但未被执行的任务。<br>threadFactory工厂：创建线程的工厂，一般默认就可以。<br>handler：拒绝策略，当线程池满负荷运行，如何拒绝新的任务的策略。</p><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>keepAliveTime，unit，threadFactory几个参数可根据线程池的任务场景去做简单的变化，在此不再赘述，一般自定义线程池我们的关注点大都在corePoolSize，maximumPoolSize，workQueue，handler四个参数上。</p><p>corePoolSize，根据业务的通用场景确定即可。《Java并发编程实践》书中给出了一个估算线程池corePoolSize大小的经验公式：<br>Ncpu=cpu数量<br>Ucpu=希望cpu的使用率，0&lt;Ucpu&lt;1<br>W/C=等待时间与计算时间的比率， <a href="https://www.cnblogs.com/gatsby123/p/11127158.html" target="_blank" rel="noopener">CPU计算时间计算方式</a></p><p><code>Nthreads=Ncpu*Ucpu*(1+W/C)</code></p><p>如果你处理的是阻塞比较多的任务，你可以根据上述公式大致算出需要的线程数量（一般会远远超出当前实例所在服务器的cpu数量）；如果是阻塞比较少的任务即cpu计算比重较大的任务，线程的数量可能就会相应的减少一些，避免服务器的超负荷运行。总之线程数不是精确的一个数，只要符合你业务的场景的大概数量就可以。</p><p>workQueue任务队列分为有限、无限、同步移交三种阻塞队列，常用的有如下几个：</p><ul><li>ArrayBlockingQueue: 一个基于数组结构的有界阻塞队列，此队列按照FIFO原则排序。</li><li>LinkedBlockingQueue: 一个基于链表的阻塞队列，此队列按照FIFO原则排序，吞吐量高于ArrayBlockingQueue。</li><li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须阻塞到另一个线程的移除操作。</li><li>PriorityBlockingQueue: 具有优先级的无限阻塞队列。</li></ul><p>线程池的执行过程：</p><p><img alt="threadpool-processor" src="/media/article/threadpool-processor.png" width="75%"></p><p>–图摘自《Java并发编程艺术》9.1小节-线程池的实现原理。</p><p>队列的大小和maxmumPoolSize息息相关，如果使用无界队列，则maxmumPoolSize也就失效了，如果使用的是有界队列，则当有界队列满了，则新启动线程执行任务。直到最大线程也满了之后执行拒绝策略。</p><p>最后就是拒绝策略:</p><ul><li>AbortPolicy: 直接抛出异常。</li><li>CallerRunPolicy: 使用调用者的线程执行任务。</li><li>DiscardOldestPolicy: 丢弃队列里最老的任务，并执行当前任务。</li><li>DiscardPolicy: 不处理，不丢弃。</li></ul><p>除此之外还可以实现RejectExecutionHandler接口，自定义拒绝策略。</p><h3 id="1-2-Executor提供的几种类型的线程池解析"><a href="#1-2-Executor提供的几种类型的线程池解析" class="headerlink" title="1.2 Executor提供的几种类型的线程池解析"></a>1.2 Executor提供的几种类型的线程池解析</h3><ol><li>Executors.newFixedThreadPool(1);</li></ol><p>Executors.newFixedThreadPool创建的线程池可以指定核心线程数，但是使用的是无界队列，如果是IO密集型任务，可能导致内存溢出。</p><ol start="2"><li>Executors.newSingleThreadExecutor();</li></ol><p>Executors.newSingleThreadExecutor()创建一个线程的线程池，同样使用无界队列，和newFixedThreadPool的差别仅限于核心线程数。</p><ol start="3"><li>Executors.newCachedThreadPool();</li></ol><p>Executors.newCachedThreadPool()创建的线程池是一个没有队列的存储任务的线程池，线程池最大数量为Integer.MAX_VALUE。所以这个线程池会一直创建新的线程执行任务，可能导致内存溢出。适用于中小数量级的任务，且任务非CPU密集型。</p><ol start="4"><li>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory());</li></ol><p>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory())创建可以定时或延时执行任务的线程池，与Timer相比，具有更多的弹性。<a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-add1.html" target="_blank" rel="noopener">详解Java定时任务—极客学院</a></p><ol start="5"><li>Executors.newWorkStealingPool();</li></ol><p>封装的ForkJoinPool线程池，线程数量为当前运行环境的cpu数量，不处理异常，异步模式。下一小节详细介绍。</p><h3 id="1-3-ForkJoinPool线程池初探"><a href="#1-3-ForkJoinPool线程池初探" class="headerlink" title="1.3 ForkJoinPool线程池初探"></a>1.3 ForkJoinPool线程池初探</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成小任务，最终汇总小任务结果后得到大任务结果的框架。</p><p><img src="/media/article/forkjoin.png" alt="forkjoin"></p><p>–图片摘自《Java并发编程的艺术》6.4.1 什么是Fork/Join框架 小节。</p><p>缺点：在某些情况下，该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。</p><h4 id="使用ForkJoinPool"><a href="#使用ForkJoinPool" class="headerlink" title="使用ForkJoinPool"></a>使用ForkJoinPool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private static final int THRESHOLD = 2;  // 阈值 private int start;</span><br><span class="line">private int end;</span><br><span class="line">public CountTask(int start, int end) &#123;</span><br><span class="line">    this.start = start; this.end = end;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected Integer compute() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    // 如果任务足够小就计算任务</span><br><span class="line">    boolean canCompute = (end - start) &lt;= THRESHOLD; </span><br><span class="line">    if (canCompute) &#123;</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">         sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">        int middle = (start + end) / 2;</span><br><span class="line">        CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end); // 执行子任务</span><br><span class="line">        leftTask.fork();</span><br><span class="line">        rightTask.fork();</span><br><span class="line">        // 等待子任务执行完，并得到其结果</span><br><span class="line">        int leftResult=leftTask.join();</span><br><span class="line">        int rightResult=rightTask.join();</span><br><span class="line">        // 合并子任务</span><br><span class="line">        sum = leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">    // 生成一个计算任务，负责计算1+2+3+4</span><br><span class="line">    CountTask task = new CountTask(1, 4);</span><br><span class="line">    // 执行一个任务</span><br><span class="line">    Future&lt;Integer&gt; result = forkJoinPool.submit(task); </span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–示例摘自《Java并发编程的艺术》6.4.4 使用Fork/Join框架 小节。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>ForkJoinTask提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被 取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(task.isCompletedAbnormally()) &#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>ForkJoinPool继承AbstractExecutorService。</p><p>ForkJoinPool参数：</p><ul><li>parallelism线程数量；</li><li>ForkJoinWorkerThreadFactory是ForkJoin线程工厂，创建ForkJoinWorkerThread的线程类实例；</li><li>mode是使用FIFO模式（true）还是LIFO模式（false）；</li><li>UncaughtExceptionHandler是异常处理；</li><li>workerNamePrefix工作线程的名称前缀；</li></ul><p>通常来说，我们使用ForkJoinPool时如果不指定线程数量时默认取2047和当前服务器cpu数量中的最小值。简单来说就是创建了一个fork/join线程的线程池。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">Effective Java 第二版 中文版 </a><br><a href="">实战Java高并发程序设计 葛一鸣，郭超编著</a><br><a href="">Java并发编程艺术 方腾飞，魏鹏，程晓明 著</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在生产环境中，应避免直接创建线程，线程数量必须得到控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-线程池&quot;&gt;&lt;a href=&quot;#1-线程池&quot; class=&quot;headerlink&quot; title=&quot;1. 线程池&quot;&gt;&lt;/a&gt;1. 线程池&lt;
      
    
    </summary>
    
    
      <category term="并发" scheme="https://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理浅析</title>
    <link href="https://zhongyp.me/java/2019-10-04-jdk-proxy/"/>
    <id>https://zhongyp.me/java/2019-10-04-jdk-proxy/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-12T13:02:30.637Z</updated>
    
    <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><h2 id="1-使用JDK动态代理"><a href="#1-使用JDK动态代理" class="headerlink" title="1. 使用JDK动态代理"></a>1. 使用JDK动态代理</h2><p>JDK动态代理使用起来很简单，如下：</p><p>TestService是一个业务接口，接口中有个test方法， TestServiceImpl是TestService的实现类。<br>InvocationHandler是JDK动态代理的调用代理方法处理接口，我们JDK使用动态代理时需要实现这个接口，在这个接口的处理方法中编写处理逻辑，你想怎样控制目标方法的访问都可以在这个方法中实现。然后调用Proxy类的静态方法newProxyInstance方法即可获得到代理类实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        TestServiceImpl testService = new TestServiceImpl();</span><br><span class="line">        // 声明自己的处理类</span><br><span class="line">        MyInvokeHandler myInvokeHandler = new MyInvokeHandler(testService);</span><br><span class="line">        // 第一次生成代理类</span><br><span class="line">        TestService proxy = (TestService) Proxy.newProxyInstance(TestService.class.getClassLoader(),new Class[]&#123;TestService.class&#125;,myInvokeHandler);</span><br><span class="line">        // 代理类调用接口方法</span><br><span class="line">        proxy.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestServiceImpl implements TestService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;我要开始测试啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyInvokeHandler implements InvocationHandler&#123;</span><br><span class="line">    Object obj;</span><br><span class="line">    public MyInvokeHandler(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        //在反射调用之前，可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        method.invoke(obj,args);</span><br><span class="line">        //在反射调用之后，也可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface TestService&#123;</span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java通过<code>Proxy</code>类和<code>InvocationHandler</code>接口生成动态代理类<code>$Proxy0</code>。<code>Proxy</code>类是JDK生成动态代理的核心类，包含了JDK动态代理生成代理类的大部分逻辑。</p><!--![java-proxy](/media/article/java-proxy.001.png)--><h2 id="2-Java动态代理源码解析"><a href="#2-Java动态代理源码解析" class="headerlink" title="2. Java动态代理源码解析"></a>2. Java动态代理源码解析</h2><blockquote><p>Class对象每个类只有一个（同一个类加载器的情况下），该Class对象在类加载阶段生成，存储在内存中，非Java虚拟机堆，是该类对外访问的唯一入口。<a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-12.html#jls-12.4" target="_blank" rel="noopener">Java Language Specification 12.4</a></p></blockquote><p>Java生成动态代理类的核心方法是：ProxyClassFactory的<code>Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>。</p><p>参数：<code>ClassLoader loader</code>接口类加载器，<code>Class&lt;?&gt;[] interfaces</code>接口类的Class。</p><p>下面代码主要作用就是通过遍历接口数组，校验接口数组中的数据是否合法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 遍历接口类的Class数组</span><br><span class="line">  for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">      </span><br><span class="line">      Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          // 反射获得接口类Class对象</span><br><span class="line">          interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      // 校验是否是同一个类加载器，如果是不同的类加载器，生成的接口Class对象是不同的</span><br><span class="line">      if (interfaceClass != intf) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // Java动态代理仅支持接口代理</span><br><span class="line">      if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 使用Set来验证传入的接口数组中是否存在相同的接口</span><br><span class="line">      if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>下面这么多代码是为了给下面生成的代理类找到一个合理的包名和类名，如果接口数组中有非public属性的接口，如果此接口的包名不为null，则使用这个接口的包名，否则使用默认的<code>com.sun.proxy</code>包名，类名则是“上述包名+$Proxy+自增数字”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String proxyPkg = null;     </span><br><span class="line">int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">    int flags = intf.getModifiers();</span><br><span class="line">    if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">        accessFlags = Modifier.FINAL;</span><br><span class="line">        String name = intf.getName();</span><br><span class="line">        int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">        String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            proxyPkg = pkg;</span><br><span class="line">        &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (proxyPkg == null) &#123;</span><br><span class="line">    // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">    proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用自增数字区分不同的类</span><br><span class="line">long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br></pre></td></tr></table></figure><p>下面就是整个动态代理最核心的代码。生成代理类class文件的字节码，根据这个文件的字节码生成代理类的Class对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成字节数组，这个字节数组是生成的Class文件的字节数组，将这个字节流输出到class文件，就是上面的$Proxy0代理类。  </span><br><span class="line">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line"> proxyName, interfaces, accessFlags);</span><br><span class="line">try &#123;</span><br><span class="line"> // 通过刚才生成的代理类文件，生成代理类的Class对象。</span><br><span class="line"> return defineClass0(loader, proxyName,</span><br><span class="line">                     proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">&#125; catch (ClassFormatError e) &#123;</span><br><span class="line"> throw new IllegalArgumentException(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码仅仅是生成动态代理类的逻辑，不是JDK Proxy生成动态代理类实例的流程。</p><p>建议下面跟着源码一点点看如下的流程图。</p><p><img src="/media/article/weakcache.png" alt="weakcache"></p><p>第一个结构图是WeakCache的缓存结构图，WeakCache是Proxy的一个实例，每次去创建代理时，都会先去访问WeakCache，WeakCache中没有才会去创建。WeakCache采用两级缓存机制，第一层使用classloader生成的弱引用key，map实例valueMap的value在ConcurrentHashMap map中，valueMap是ConcurrentHasshMap， valueMap中使用接口数组（创建代理类传入的接口数组参数）生成的subKey，这个subKey不是弱引用，valueMap的value即可能是WeakCache.Factory实例，也可能是实现Supplier接口和继承WeakReference类的CacheValue实例。CacheValue用于封装动态生成的代理类的Class对象，WeakCache.Factory中包含生成动态代理类字节码和Class对象的逻辑，这个逻辑就是上面源码分析中的apply方法。<br>第二个是流程图，使用Proxy.newProxyInnstance生成动态代理类时，读取缓存的流程，结合着结构图和代码，应该可以理解JDK Proxy的整个缓存存储结构及读取流程。</p><p>生成的<code>$Proxy0</code>代理类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zhongyp.advanced.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">// 这个地方有两个接口，是因为我之前做测试的时候多加了一个TestService1接口。</span><br><span class="line">final class $Proxy0 extends Proxy implements TestService, TestService1 &#123;</span><br><span class="line"></span><br><span class="line">    // TestSerivce，TestService1两个接口总共就4个方法，test()，test1()，test3()，test4()，这里有7个方法，其中三个是hashCode，toString，equals。</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    private static Method m6;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m5;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 接口中的所有方法都会在代理类中生成，然后将代理类中的方法对象与方法名匹配放到InvocaotionHandler实现类实例的方法参数中</span><br><span class="line">    public final void test() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test3() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m4, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test4() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m6, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test1() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m5, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 动态代理在初始化是会初始化所有的方法对象</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m3 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test&quot;);</span><br><span class="line">            m4 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test3&quot;);</span><br><span class="line">            m6 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test4&quot;);</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m5 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test1&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于JDK动态代理的调用很简单，上面是我们上面的例子输出的动态代理类反编译的代码，我们看到接口中的每个方法<code>super.h.invoke(this, m5, (Object[])null)</code>，super就是Proxy，h是Proxy中的InvocationnHandler实例，InvocationHandler实例反射调用你的方法。InvocationHandler是在生成动态代理类的class对象后，创建动态代理类实例作为构造参数传进去的，所以虽然当前接口参数相同时，可能返回同一个动态代理类Class对象，但是只要InvocationHandler不同，他们就是不同的实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">    super(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/jdk-proxy-invoke.png" alt="jdk-proxy-invoke"></p><p>优点：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比cglib更加可靠。</li><li>平滑进行JDK版本升级，而字节码类库通常需要进行更新来保证在新版Java上能够使用。</li><li>代码实现简单。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>为什么JDK动态代理仅支持实现接口类的动态代理？</li></ol><p>这个问题我觉得可以从JDK做动态代理的初衷来说，JDK动态代理类是在运行时实现指定的接口列表的类，这个是JDK在设计实现动态代理最初就已经确定了的，所以可以看到在生成代理类的过程中，基本上就把接口类当作一个已知条件在使用，包括在定义缓存使用的subKey，代理类包名的生成规则中，反射获取Method对象等等地方，所以不存在为什么只支持实现接口类，而是JDK动态代理类的设计就是这样子的。</p><ol start="2"><li>为什么WeakCache采用两级缓存接口？</li></ol><p>这个问题我们可以从两个缓存的不同点来看，第一层缓存map是一个弱引用key，非弱引用valueMap，第二层缓存valueMap使用的是非弱引用subKey，弱引用CacheValue。我们都知道弱引用只要有垃圾回收时就会被回收，主要是为了防止缓存太多导致服务频繁的FullGC，所以第一层的作用就是当垃圾回收时，将缓存的valueMap全部清空。还有一个原因是第一层缓存使用的是classloader生成的key，所以map其实缓存的是所有当前同一个classloader生成的代理类的class对象。再说第二层缓存，第二层缓存使用的是创建代理类时传入的接口数组生成的subKey，这个是为了区分实现不同接口的动态代理类Class对象，如果说两个类都实现了同一个接口，那岂不是获取的同样的Class对象，这么说也是对的，区别在于实现的InvocationHandler接口的子类h不同，而这个h才是生成代理类实例的最终区别。第二层缓存为什么CacheValue使用弱引用，原因在于第一层缓存虽然key时弱引用，但是value不是，所以垃圾回收时只会回收key，不会回收value，value只会在下一次调用Proxy.newProxyInstance方法时才会去清空无效key的value。所以为了value能及时清空，所以CacheValue也使用了弱引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文承接自&lt;a href=&quot;/java/2019-09-09-java-proxy/&quot;&gt;动态代理浅析&lt;/a&gt;这篇文章，对代理没有什么概念的同学建议先读下这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;1-使用JDK动态代理&quot;&gt;&lt;a href=&quot;#1-使用JDK动态代理&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB浅析</title>
    <link href="https://zhongyp.me/java/2019-10-04-cglib/"/>
    <id>https://zhongyp.me/java/2019-10-04-cglib/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-11-13T13:27:57.595Z</updated>
    
    <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><p>本文打算从这几个方面来理解CGLIB怎样生成动态代理类的：</p><ol><li><a href="#1-使用Cglib动态代理">怎样使用CGLIB？</a></li><li><a href="#2-CGLIB原理解析">CGLIB怎样生成/缓存动态代理类实例的？</a></li><li><a href="#3-CGLIB代理类调用方法原理解析">CGLIB生成的动态代理类怎样调用的，过程是怎样的，这样有什么好处？</a></li><li>常见问题<a href="#FAQ">FAQ</a></li></ol><h2 id="1-使用Cglib动态代理"><a href="#1-使用Cglib动态代理" class="headerlink" title="1. 使用Cglib动态代理"></a>1. 使用Cglib动态代理</h2><p>CGLIB的使用和JDK Proxy类似，不同的是CGLIB既可以指定接口，也可以直接代理未实现接口的普通类。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">LogInterceptor logInterceptor = new LogInterceptor();</span><br><span class="line">// 设置超类，cglib是通过继承来实现的</span><br><span class="line">enhancer.setSuperclass(UserDao.class);</span><br><span class="line">enhancer.setCallback(logInterceptor);</span><br><span class="line">/**</span><br><span class="line"> * 如果是实现指定接口，可以使用setInterfaces方法设置接口</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// enhancer.setInterfaces(new Class[]&#123;Dao.class&#125;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果使用createClass方法返回值为代理类的Class对象，需要设置CallbackType参数；当使用create方法时，CallbackType和callback都不为空时，两者类型必须相等。</span><br><span class="line"> * create方法返回的是代理类实例</span><br><span class="line"> * enhancer.setCallbackType(LogInterceptor.class);</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 创建代理类</span><br><span class="line">Dao dao = (Dao)enhancer.create();</span><br><span class="line">dao.select();</span><br></pre></td></tr></table></figure></p><p>// 方法拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">//        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">//        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>// 实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao implements Dao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-CGLIB生成动态代理类的原理解析"><a href="#2-CGLIB生成动态代理类的原理解析" class="headerlink" title="2. CGLIB生成动态代理类的原理解析"></a>2. CGLIB生成动态代理类的原理解析</h2><p>CGLIB，JDK proxy生成过程上大同小异，都是使用弱引用缓存已生成的Class对象，如果缓存中没有，则使用字节码技术生成动态代理类字节码和Class对象，只不过使用的字节码技术不太一样罢了。<br>下图是CGLIB动态代理生成代理类Class对象的流程：<a href="/media/article/cglib-processor.png">点击看大图</a></p><p><img src="/media/article/cglib-processor.png"></p><p>CGLIB动态代理基于ASM技术，使用<a href="/java/2019-10-06-asm/">ASM</a>技术的部分就是图中标红的模块。</p><p>CGLIB动态代理如果没有特殊设置也会缓存已生成的动态代理类的Class对象。</p><p><img src="/media/article/cglib-cache.png" alt="cglib-cache"></p><p>上图是CGLIB缓存动态代理类的Class对象的结构。</p><p>CGLIB第一次生成动态代理类Class对象的方法调用流程：</p><p><img src="/media/article/cglib-method.png" alt="cglib-method"></p><h2 id="3-CGLIB代理类调用方法原理解析"><a href="#3-CGLIB代理类调用方法原理解析" class="headerlink" title="3. CGLIB代理类调用方法原理解析"></a>3. CGLIB代理类调用方法原理解析</h2><blockquote><p>使用<code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;./&quot;)</code>可以输出生成的代理类的class文件。这里由于篇幅问题，只展示文章需要的内容，想看完整的代理类的字节码文件可以自己输出查看。</p></blockquote><p>CGLIB针对一个目标类一般会生成3个动态代理类，1个<code>UserDao$$EnhancerByCGLIB$$c00e2e9b extends UserDao implements Factory</code>，还有2个和调用有关的FastClass代理类<code>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc extends FastClass</code>，<code>UserDao$$FastClassByCGLIB$$890e5f18 extends FastClass</code></p><p>UserDao$$EnhancerByCGLIB$$c00e2e9b类的静态初始化块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 当前线程的缓存</span><br><span class="line">CGLIB$THREAD_CALLBACKS = new ThreadLocal();</span><br><span class="line">// 空参数对象</span><br><span class="line">CGLIB$emptyArgs = new Object[0];</span><br><span class="line">// 动态代理类的Class对象</span><br><span class="line">Class var0 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao$$EnhancerByCGLIB$$c00e2e9b&quot;);</span><br><span class="line">Class var1;</span><br><span class="line">// 只获取update和select的方法对象</span><br><span class="line">Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;update&quot;, &quot;()V&quot;, &quot;select&quot;, &quot;()V&quot;&#125;, (var1 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao&quot;)).getDeclaredMethods());</span><br><span class="line">CGLIB$update$0$Method = var10000[0];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$update$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;update&quot;, &quot;CGLIB$update$0&quot;);</span><br><span class="line">CGLIB$select$1$Method = var10000[1];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$select$1$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;select&quot;, &quot;CGLIB$select$1&quot;);</span><br></pre></td></tr></table></figure><p>当动态代理类调用update()方法（update是DAO接口内的方法）时，首先调用下面这个动态生成的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * cglib使用Class对象创建对象实例(Enhancer.nextNewInstance())的时候，会反射调用CGLIB$SET_THREAD_CALLBACKS方法，将MethodInterceptor实例缓存在CGLIB$THREAD_CALLBACKS这个代理类的的ThreadLocal中，然后初始化动态代理类实例时，调用CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">public final void update() &#123;</span><br><span class="line">   // 初始化动态代理类实例时，已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">   MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">       CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">       var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (var10000 != null) &#123;</span><br><span class="line">       var10000.intercept(this, CGLIB$update$0$Method, CGLIB$emptyArgs, CGLIB$update$0$Proxy);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       super.update();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">   UserDao$$EnhancerByCGLIB$$c00e2e9b var1 = (UserDao$$EnhancerByCGLIB$$c00e2e9b)var0;</span><br><span class="line">   if (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">       var1.CGLIB$BOUND = true;</span><br><span class="line">       Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">       if (var10000 == null) &#123;</span><br><span class="line">           var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">           if (CGLIB$STATIC_CALLBACKS == null) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 也就是说，初始化动态代理类实例时，最后如果var1.CGLIB$BOUND = true，则说明已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">       var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在调用到了MethodInterceptor的intercept方法了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">   // methodProxy.invokeSuper</span><br><span class="line">   Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>methodProxy，还记得动态代理类的static代码块么，在那时就已经初始化好了methodProxy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) &#123;</span><br><span class="line">   MethodProxy proxy = new MethodProxy();</span><br><span class="line">   // 使用Signature对象封装方法名和返回值</span><br><span class="line">   proxy.sig1 = new Signature(name1, desc);</span><br><span class="line">   proxy.sig2 = new Signature(name2, desc);</span><br><span class="line">   // 将UserDAO和UserDAO的动态代理类的Class文件放入CreateInfo对象</span><br><span class="line">   proxy.createInfo = new MethodProxy.CreateInfo(c1, c2);</span><br><span class="line">   return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了知道methodProxy怎么来的，继续往下走，invokeSuper():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       this.init();</span><br><span class="line">       MethodProxy.FastClassInfo fci = this.fastClassInfo;</span><br><span class="line">       // 这里调用的实际是FastClass代理类中的invoke方法</span><br><span class="line">       return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">   &#125; catch (InvocationTargetException var4) &#123;</span><br><span class="line">       throw var4.getTargetException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void init() &#123;</span><br><span class="line">   if (this.fastClassInfo == null) &#123;</span><br><span class="line">       Object var1 = this.initLock;</span><br><span class="line">       synchronized(this.initLock) &#123;</span><br><span class="line">           if (this.fastClassInfo == null) &#123;</span><br><span class="line">               MethodProxy.CreateInfo ci = this.createInfo;</span><br><span class="line">               MethodProxy.FastClassInfo fci = new MethodProxy.FastClassInfo();</span><br><span class="line">               // UserDAO和UserDAO的代理类分别有自己的FastClassInfo，分别使用个字的ClassInfo生成FastClass代理类</span><br><span class="line">               // 生成UserDAO的FastClass代理类</span><br><span class="line">               fci.f1 = helper(ci, ci.c1);</span><br><span class="line">               // 生成UserDAO代理类的FastClass代理类</span><br><span class="line">               fci.f2 = helper(ci, ci.c2);</span><br><span class="line">               // 生成方法索引</span><br><span class="line">               fci.i1 = fci.f1.getIndex(this.sig1);</span><br><span class="line">               fci.i2 = fci.f2.getIndex(this.sig2);</span><br><span class="line">               this.fastClassInfo = fci;</span><br><span class="line">               this.createInfo = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据索引调用方法，fci.i2的值为12，调用索引12的方法。<br>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc动态代理类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123;</span><br><span class="line">   c00e2e9b var10000 = (c00e2e9b)var2;</span><br><span class="line">   int var10001 = var1;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">       switch(var10001) &#123;</span><br><span class="line">       case 0:</span><br><span class="line">           return new Boolean(var10000.equals(var3[0]));</span><br><span class="line">       case 1:</span><br><span class="line">           return var10000.toString();</span><br><span class="line">       case 2:</span><br><span class="line">           return new Integer(var10000.hashCode());</span><br><span class="line">       case 3:</span><br><span class="line">           return var10000.clone();</span><br><span class="line">       case 4:</span><br><span class="line">           var10000.update();</span><br><span class="line">           return null;</span><br><span class="line">       case 5:</span><br><span class="line">           return var10000.newInstance((Class[])var3[0], (Object[])var3[1], (Callback[])var3[2]);</span><br><span class="line">       case 6:</span><br><span class="line">           return var10000.newInstance((Callback)var3[0]);</span><br><span class="line">       case 7:</span><br><span class="line">           return var10000.newInstance((Callback[])var3[0]);</span><br><span class="line">       case 8:</span><br><span class="line">           var10000.select();</span><br><span class="line">           return null;</span><br><span class="line">       case 9:</span><br><span class="line">           var10000.setCallback(((Number)var3[0]).intValue(), (Callback)var3[1]);</span><br><span class="line">           return null;</span><br><span class="line">       case 10:</span><br><span class="line">           return c00e2e9b.CGLIB$findMethodProxy((Signature)var3[0]);</span><br><span class="line">       case 11:</span><br><span class="line">           c00e2e9b.CGLIB$STATICHOOK1();</span><br><span class="line">           return null;</span><br><span class="line">       case 12:</span><br><span class="line">           var10000.CGLIB$update$0();</span><br><span class="line">           return null;</span><br><span class="line">       case 13:</span><br><span class="line">           var10000.CGLIB$select$1();</span><br><span class="line">           return null;</span><br><span class="line">       case 14:</span><br><span class="line">           return new Boolean(var10000.CGLIB$equals$2(var3[0]));</span><br><span class="line">       case 15:</span><br><span class="line">           return var10000.CGLIB$toString$3();</span><br><span class="line">       case 16:</span><br><span class="line">           return new Integer(var10000.CGLIB$hashCode$4());</span><br><span class="line">       case 17:</span><br><span class="line">           return var10000.CGLIB$clone$5();</span><br><span class="line">       case 18:</span><br><span class="line">           var10000.setCallbacks((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 19:</span><br><span class="line">           c00e2e9b.CGLIB$SET_STATIC_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 20:</span><br><span class="line">           c00e2e9b.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 21:</span><br><span class="line">           return var10000.getCallback(((Number)var3[0]).intValue());</span><br><span class="line">       case 22:</span><br><span class="line">           return var10000.getCallbacks();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; catch (Throwable var4) &#123;</span><br><span class="line">       throw new InvocationTargetException(var4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问流程图：</p><p><img src="/media/article/cglib-invoke.png" alt="cglib-invoke"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是CGLIB还是JDK proxy都是为了控制对象的访问，但是怎样控制访问是CGLIB和JDK proxy思想上的最大区别，JDK proxy通过接口得到method对象后使用反射直接调用目标方法，CGLIB则是更复杂的多，CGLIB先是继承目标类，然后通过字节码技术生成代理方法（CGLIB$update$0）和update（上述例子中的方法，这里用来举例），然后通过方法代理（MethodProxy）和FastClass访问机制（通过方法名和返回值生成索引，调用时直接索引至目标方法）回调目标方法。</p><blockquote><p>TIPS:其实这里还有很多想说的，但是总也感觉表达的总是不是那么的到位，所以暂且先这样了，等着后续再继续完善。</p></blockquote><p>优点：</p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似CGLIB动态代理就没有这种限制。</li><li>只操作我们关心的类，不必为其他相关类增加工作量。</li><li>高性能，高性能体现方法的调用上，CGLIB的方法调用为FastClass机制，JDK Proxy为反射调用。</li></ul><h2 id="4-一些源码"><a href="#4-一些源码" class="headerlink" title="4. 一些源码"></a>4. 一些源码</h2><p>下面是一些比较核心的一些代码解析：</p><p>入口，AbstractGenerator中的create(key)方法，参数key=KeyFactory.newInstance()。KeyFactory也是CGLIB动态生成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 参数key是Enhancer.KeyFactory(superclassname)的实例，这个KeyFactory类也是cglib动态生成的，当你new Enhancer()时，Enhancer会动态的生成该实例对象，superclassname就是上面的UserDAO。</span><br><span class="line">protected Object create(Object key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ClassLoader loader = this.getClassLoader();</span><br><span class="line">        // CACHE时WeakHashMap 第一层缓存的容器</span><br><span class="line">        Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        // 第一层缓存 key是classLoader</span><br><span class="line">        AbstractClassGenerator.ClassLoaderData data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">        if (data == null) &#123;</span><br><span class="line">            Class var5 = AbstractClassGenerator.class;</span><br><span class="line">            // 加锁意义在于CACHE时静态变量，属于该类，不是该实例对象，所以线程安全需要加锁。</span><br><span class="line">            synchronized(AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">                if (data == null) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; newCache = new WeakHashMap(cache);</span><br><span class="line">                    // 创建第二层缓存容器</span><br><span class="line">                    data = new AbstractClassGenerator.ClassLoaderData(loader);</span><br><span class="line">                    // 将第二层缓存容器放入第一层容器内，key为classloader</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.key = key;</span><br><span class="line">        // 使用ClassLoaderData data获取Enhancer.EnhancerFactoryData对象，Enhancer.EnhancerFactoryData对象中是代理类的Class对象，也可以直接获取KeyFactory的Class对象</span><br><span class="line">        Object obj = data.get(this, this.getUseCache());</span><br><span class="line">        // firstInstance主要是针对KeyFactory生成的Class对象，例如接口方法生成的MethodWraper的代理类Class对象，nextInstance针对Enhancer实例生成的Enhancer.EnhancerFactoryData实例，实例中存储着真正的代理类的Class对象，如果生成的代理类中有接口方法，生成代理类时，会生成接口方法的MethodWrapper的代理类实例。</span><br><span class="line">        return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);</span><br><span class="line">    &#125; catch (Error | RuntimeException var9) &#123;</span><br><span class="line">        throw var9;</span><br><span class="line">    &#125; catch (Exception var10) &#123;</span><br><span class="line">        throw new CodeGenerationException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一级缓存中的value，ClassLoaderData的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoaderData(ClassLoader classLoader) &#123;</span><br><span class="line">  if (classLoader == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;classLoader == null is not yet supported&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // 首先用弱引用封装classLoader，垃圾回收时可以直接回收</span><br><span class="line">      this.classLoader = new WeakReference(classLoader);</span><br><span class="line">      Function&lt;AbstractClassGenerator, Object&gt; load = new Function&lt;AbstractClassGenerator, Object&gt;() &#123;</span><br><span class="line">          public Object apply(AbstractClassGenerator gen) &#123;</span><br><span class="line">              Class klass = gen.generate(ClassLoaderData.this);</span><br><span class="line">              // 这里需要注意gen是Enhancer实例，还是KeyFactory$Genertor实例，两者的wrapCachedClass完全不一样，使用的数据结构也不一样。Enhancer使用的数据结构是EnhancerFactoryData，KeyFactory$Genertor使用LoadingCache</span><br><span class="line">              return gen.wrapCachedClass(klass);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      // this.generatedClasses的key是KeyFactory根据superclassName生成的key实例，将load放入LoadingCache，等下如果LoadingCache的map获取代理类为null，需要回调这个load重新生成代理类</span><br><span class="line">      this.generatedClasses = new LoadingCache(GET_KEY, load);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二级缓存的对象LoadingCache中的核心方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// key是Enhancer实例，或者是KeyFactory$Generator实例</span><br><span class="line">public V get(K key) &#123;</span><br><span class="line">   KK cacheKey = this.keyMapper.apply(key);</span><br><span class="line">   Object v = this.map.get(cacheKey);</span><br><span class="line">   return v != null &amp;&amp; !(v instanceof FutureTask) ? v : this.createEntry(key, cacheKey, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected V createEntry(final K key, KK cacheKey, Object v) &#123;</span><br><span class="line">   boolean creator = false;</span><br><span class="line">   FutureTask task;</span><br><span class="line">   Object result;</span><br><span class="line">   if (v != null) &#123;</span><br><span class="line">       task = (FutureTask)v;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       task = new FutureTask(new Callable&lt;V&gt;() &#123;</span><br><span class="line">           public V call() throws Exception &#123;</span><br><span class="line">               // 回调AbstractGenerator.ClassLoaderData构造器中的load</span><br><span class="line">               return LoadingCache.this.loader.apply(key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 获取map中的value，如果是Enhancer.EnhancerFactoryData就直接返回，如果不是，继续往下获取Class对象</span><br><span class="line">       result = this.map.putIfAbsent(cacheKey, task);</span><br><span class="line">       // 如果等于null，需要重新生成</span><br><span class="line">       if (result == null) &#123;</span><br><span class="line">           creator = true;</span><br><span class="line">           task.run();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (!(result instanceof FutureTask)) &#123;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           task = (FutureTask)result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">       result = task.get();</span><br><span class="line">   &#125; catch (InterruptedException var9) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Interrupted while loading cache item&quot;, var9);</span><br><span class="line">   &#125; catch (ExecutionException var10) &#123;</span><br><span class="line">       Throwable cause = var10.getCause();</span><br><span class="line">       if (cause instanceof RuntimeException) &#123;</span><br><span class="line">           throw (RuntimeException)cause;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       throw new IllegalStateException(&quot;Unable to load cache item&quot;, cause);</span><br><span class="line">   &#125;</span><br><span class="line">   // 新建的Class对象或者Enhancer.EnhancerFactoryData需要存起来</span><br><span class="line">   if (creator) &#123;</span><br><span class="line">       this.map.put(cacheKey, result);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Enhancer中生成动态代理类的逻辑，使用了ASM技术：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public void generateClass(ClassVisitor v) throws Exception &#123;</span><br><span class="line">   Class sc = this.superclass == null ? Object.class : this.superclass;</span><br><span class="line">   if (TypeUtils.isFinal(sc.getModifiers())) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Cannot subclass final class &quot; + sc.getName());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">       this.filterConstructors(sc, constructors);</span><br><span class="line">       List actualMethods = new ArrayList();</span><br><span class="line">       List interfaceMethods = new ArrayList();</span><br><span class="line">       final Set forcePublic = new HashSet();</span><br><span class="line">       // 将接口中的方法获取放入到forcePublic中，获取的其实是KeyFactory生成的MethodWrapper实例 select,&#125;, void</span><br><span class="line">       // actualMethods是一个包含所有方法的数组，值类似public void com.zhongyp.advanced.proxy.cglib.UserDao.update()</span><br><span class="line">       getMethods(sc, this.interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line">       // 获取到所有的方法及访问标识</span><br><span class="line">       List methods = CollectionUtils.transform(actualMethods, new Transformer() &#123;</span><br><span class="line">           public Object transform(Object value) &#123;</span><br><span class="line">               Method method = (Method)value;</span><br><span class="line">               int modifiers = 16 | method.getModifiers() &amp; -1025 &amp; -257 &amp; -33;</span><br><span class="line">               if (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                   // 如果接口中有相同的方法，</span><br><span class="line">                   modifiers = modifiers &amp; -5 | 1;</span><br><span class="line">               &#125;</span><br><span class="line">               return ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 下面就是ASM的操作逻辑了</span><br><span class="line">       // 参数v是ClassVisitor</span><br><span class="line">       ClassEmitter e = new ClassEmitter(v);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), Type.getType(sc), this.useFactory ? TypeUtils.add(TypeUtils.getTypes(this.interfaces), FACTORY) : TypeUtils.getTypes(this.interfaces), &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), (Type)null, new Type[]&#123;FACTORY&#125;, &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       // 构造器信息</span><br><span class="line">       List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line">       e.declare_field(2, &quot;CGLIB$BOUND&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       e.declare_field(9, &quot;CGLIB$FACTORY_DATA&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (!this.interceptDuringConstruction) &#123;</span><br><span class="line">           e.declare_field(2, &quot;CGLIB$CONSTRUCTED&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(26, &quot;CGLIB$THREAD_CALLBACKS&quot;, THREAD_LOCAL, (Object)null);</span><br><span class="line">       e.declare_field(26, &quot;CGLIB$STATIC_CALLBACKS&quot;, CALLBACK_ARRAY, (Object)null);</span><br><span class="line">       if (this.serialVersionUID != null) &#123;</span><br><span class="line">           e.declare_field(26, &quot;serialVersionUID&quot;, Type.LONG_TYPE, this.serialVersionUID);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for(int i = 0; i &lt; this.callbackTypes.length; ++i) &#123;</span><br><span class="line">           e.declare_field(2, getCallbackField(i), this.callbackTypes[i], (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(10, &quot;CGLIB$CALLBACK_FILTER&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           this.emitMethods(e, methods, actualMethods);</span><br><span class="line">           this.emitConstructors(e, constructorInfo);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.emitDefaultConstructor(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       this.emitSetThreadCallbacks(e);</span><br><span class="line">       this.emitSetStaticCallbacks(e);</span><br><span class="line">       this.emitBindCallbacks(e);</span><br><span class="line">       if (this.useFactory || this.currentData != null) &#123;</span><br><span class="line">           int[] keys = this.getCallbackKeys();</span><br><span class="line">           this.emitNewInstanceCallbacks(e);</span><br><span class="line">           this.emitNewInstanceCallback(e);</span><br><span class="line">           this.emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">           this.emitGetCallback(e, keys);</span><br><span class="line">           this.emitSetCallback(e, keys);</span><br><span class="line">           this.emitGetCallbacks(e);</span><br><span class="line">           this.emitSetCallbacks(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.end_class();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>CGLIB针对final方法怎么处理的呢？</li></ol><p>不处理，因为继承了目标类，所以动态代理类实例可以直接调用目标类的final方法。</p><ol start="2"><li>CGLIB动态代理是通过字节码底层继承要代理类来实现，如果被代理类被final关键字所修饰，那么代理会失败么？</li></ol><p>代理不会失败，只会直接调用目标类的final方法。如update方法是final的，代理类不会做其他的处理，会直接调用UserDAO的update方法。   </p><ol start="3"><li>CGLIB到底比JDk Proxy快在哪里？</li></ol><p>测试环境JDK1.8，平台macOS Catalina。</p><p>一般意义上认为CGLIB在创建动态代理类比JDK Proxy慢，但是在方法调用上CGLIB比JDK Proxy快。<br>但是通过个人的测试，CGLIB在创建动态代理类确实比JDK Proxy慢一点，基本上CGLIB创建一个动态代理类实例需要30ms，JDK Proxy基本上也就10ms。<br>方法调用上100w次JDK proxy用时33233ms，CGLIB用时34259ms。两者差距并不是很明显。</p><ol start="4"><li>为什么CGLIB要使用fastclass机制？</li></ol><p>JDK之前的版本对于反射调用优化不是特别好，反射方法调用很慢，所以为了避免反射带来的性能消耗，采用fastclass机制，fastclass其实就是把需要需要调用的目标方法进行封装，获取到每个方法的索引值，调用时，通过调用方法获取索引值，直接调用到封装的目标方法。这种调用和直接调用性能差别不大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文承接自&lt;a href=&quot;/java/2019-09-09-java-proxy/&quot;&gt;动态代理浅析&lt;/a&gt;这篇文章，对代理没有什么概念的同学建议先读下这篇文章。&lt;/p&gt;
&lt;p&gt;本文打算从这几个方面来理解CGLIB怎样生成动态代理类的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://zhongyp.me/java/2019-10-04-reflection/"/>
    <id>https://zhongyp.me/java/2019-10-04-reflection/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-22T17:11:01.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这种动态获取信息以及动态创建/调用对象方法的功能称为Java语言的反射机制。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以在运行时动态的确定类型并创建实例，可以调用实例中的任意方法即是方法时private的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>相比于编译时确定类型的方式，运行时确定类型创建实例会带来一定的性能消耗。</li><li>反射需要运行时的权限在安全管理器下运行时可能不存在。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。</li><li>由于反射允许代码执行非反射代码中非法的操作（例如访问私有字段和方法），因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射代码破坏了抽象，因此可能会随着平台的升级而改变行为。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><p>反射调用慢在哪里？</p></blockquote><p>相对于在编译时确定对象类型，反射是在运行时动态创建对象并确定对象类型，所以会比编译时确定对象类型多一些性能消耗即慢。<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  User user = new User();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在4.5ms左右</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  Class&lt;?&gt; clazz =  Class.forName(&quot;com.zhongyp.advanced.refect.User&quot;, true, ReflectDemo.class.getClassLoader());</span><br><span class="line">            User user = (User) clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在20ms左右</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;p&gt;在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AspectJ</title>
    <link href="https://zhongyp.me/java/2019-10-04-aspectj/"/>
    <id>https://zhongyp.me/java/2019-10-04-aspectj/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-22T17:16:13.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文引用自<a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p></blockquote><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><blockquote><p>AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言。当然，AspectJ需要使用额外的编译器。</p></blockquote><blockquote><p>AspectJ可以通过多种方式实现，包括源码织入或字节码织入，并且可以直接在虚拟机（VM）中实现。在所有情况下，AspectJ程序都将成为在Java VM中运行的有效Java程序。受切面影响的类与不受影响的类具有二进制兼容性（以保持与不受影响的原始文件编译的类兼容）。支持多种实现方式使该语言可以随着技术的变化而发展，并且与Java兼容可确保平台可用性。<br>AspectJ采用编译期织入和类加载期织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<br>使用AspectJ LTW有两个主要步骤，第一，通过JVM的-javaagent参数设置LTW的织入器类包，以代理JVM默认的类加载器；第二，LTW织入器需要一个aop.xml文件，在该文件中指定切面类和需要进行切面织入的目标类。</p></blockquote><blockquote><p>设置-javaagent JVM参数的方法:<br>(1)在Eclipse下的设置:<br>运行类-&gt;右键单击-&gt;Run As-&gt;Run…，可以在弹出的Run设置窗口设置该类的各项运行属性，切换到Arguments Tab页，在VM arguments中通过-javaagent指定AspectJ 织入器类包。<br>-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar<br>(2)在Tomcat下的设置<br>打开&lt;Tomcat_Home&gt;\bin\catalina.bat，在该批处理文件头部添加以下的设置：<br>set JAVA_OPTS=-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文引用自&lt;a href=&quot;https://www.iteye.com/blog/log-cd-562056&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AspectJ LTW(Load Time Weaving)&lt;/a&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>知识结构图</title>
    <link href="https://zhongyp.me/java/2019-09-29-knowledge-structure/"/>
    <id>https://zhongyp.me/java/2019-09-29-knowledge-structure/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2019-09-29T01:51:10.571Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/article/knowledge-structure.png" alt="knowledge-structure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/article/knowledge-structure.png&quot; alt=&quot;knowledge-structure&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>闲谈Java引用</title>
    <link href="https://zhongyp.me/java/2019-09-15-reference/"/>
    <id>https://zhongyp.me/java/2019-09-15-reference/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-23T11:33:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。</p><h2 id="1-强引用-StrongReference"><a href="#1-强引用-StrongReference" class="headerlink" title="1. 强引用(StrongReference)"></a>1. 强引用(StrongReference)</h2><p>Java中最常见的引用方式。当一个对象被一个或者一个以上的引用变量引用时，它处于激活状态，不可能被系统垃圾回收机制回收。</p><h2 id="2-软引用-SoftReference"><a href="#2-软引用-SoftReference" class="headerlink" title="2. 软引用(SoftReference)"></a>2. 软引用(SoftReference)</h2><p>软引用需要通过SoftRefrence类来实现，当一个对象只具有软引用时，可能被垃圾回收机制回收。当系统内存空间足够时，它不会被系统回收，当系统内存空间不够时，系统将会回收。</p><p>和弱引用的区别仅仅在于垃圾回收时， 是否根据空间大小回收的区别。</p><p>何时回收软引用的对象？</p><p>从1.3.1开始软可达对象将在最后被引用之后存活一段时间。默认值是堆中每MB空闲空间一秒的生存时间。这个值可以使用<code>-XX:SoftRefLRUPolicyMSPerMB</code>调整。<br>Java Hotspot服务端虚拟机使用最大可能的堆大小计算剩余可用空间。<br>Java Hotspot客户端虚拟机使用当前堆大小计算空闲空间。<br>这就意味着对于服务端虚拟机总体趋势是增长堆而不是清理软引用，因此在垃圾回收时<code>-Xmx</code>对软引用的回收有重要的影响。<br>相反，客户端虚拟机将很大趋势去清理软引用而不是增长堆。</p><p>上述行为对于1.3.1到Java SE 6版本的Java HotSpot VM都是正确的。但是，此行为不是VM规范的一部分，并且在将来的版本中可能会更改。同样，不保证-XX：SoftRefLRUPolicyMSPerMB标志在任何给定的发行版中均不存在。</p><p>在1.3.1版之前，Java HotSpot VM会在发现软引用时清除它们。</p><p>当我定期打开-verbose：gc时，我得到了很多完整的GC，已经调整了堆并且没有什么区别，这是怎么回事？</p><p>如果您使用的是RMI，则可能会遇到分布式GC。另外，某些应用程序添加了显式GC的思想，即它将使它们的应用程序更快。幸运的是，您可以在1.3及更高版本中使用命令行选项禁用此功能。尝试将-XX：+ DisableExplicitGC与-verbose：gc一起使用，看看是否有帮助。</p><h2 id="3-虚引用-PhantomReference"><a href="#3-虚引用-PhantomReference" class="headerlink" title="3. 虚引用(PhantomReference)"></a>3. 虚引用(PhantomReference)</h2><p>虚引用通过PhantomReference实现，虚引用类似于完全没有引用，虚引用对对象本身没有太大的影响。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列(ReferenceQueue)联合使用。</p><p>举例来说就是，如果垃圾回收时，发现一个实例对象除了虚引用外没有任何其他的引用，将会把这个引用放到<br><code>java.lang.ref.Reference.pending</code>队列里，GC完成时，通知ReferenceHandler这个守护线程做一些后续处理（如释放内存等等操作）。</p><h2 id="4-弱引用-WeakReference"><a href="#4-弱引用-WeakReference" class="headerlink" title="4. 弱引用(WeakReference)"></a>4. 弱引用(WeakReference)</h2><p>弱引用通过WeakReference类实现，对只有弱引用的对象而言，当系统垃圾回收机制运行时，不管内存是否足够，总会回收该对象所占用的内存。</p><h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue referenceQueue = new ReferenceQueue();</span><br><span class="line">WeakReference weakReference = new WeakReference(new TestEntity(), referenceQueue);</span><br><span class="line">((TestEntity) weakReference.get()).test();</span><br></pre></td></tr></table></figure><p>ReferenceQueue的作用是为了查看哪些WeakReference和SoftReferece被回收了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p><p><a href="https://www.jianshu.com/p/e66930caca9c" target="_blank" rel="noopener">Java PhantomReference详解</a></p><p><a href="oracle.com/technetwork/java/hotspotfaq-138619.html#gc_softrefs">Frequently Asked Questions About the Java HotSpot VM</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。&lt;/p&gt;
&lt;h2 id=&quot;1-强引用-StrongReference&quot;&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机知识点架构图</title>
    <link href="https://zhongyp.me/jvm/2019-09-08-jvm-structure/"/>
    <id>https://zhongyp.me/jvm/2019-09-08-jvm-structure/</id>
    <published>2019-09-07T16:00:00.000Z</published>
    <updated>2019-09-08T12:59:18.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/article/jvm-structure.png" alt="jvm-structure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/article/jvm-structure.png&quot; alt=&quot;jvm-structure&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhongyp.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>动态代理浅析</title>
    <link href="https://zhongyp.me/java/2019-09-09-java-proxy/"/>
    <id>https://zhongyp.me/java/2019-09-09-java-proxy/</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2019-10-09T12:25:46.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是动态代理？"><a href="#1-什么是动态代理？" class="headerlink" title="1. 什么是动态代理？"></a>1. 什么是动态代理？</h2><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问，而不是增强目标对象的功能。</p><blockquote><p>访问控制包括同步，身份验证，远程访问（RPC），惰性实例化（休眠，Mybatis），AOP（事务）。</p></blockquote><p><img src="/media/article/proxy-invoke-method.png" alt="代理方法调用"></p><p>实现代理的技术有很多，如 CGLIB(ASM)、AspectJ、Javassist、JDK Proxy等。</p><ul><li>ASM: 针对<strong><em>运行时</em></strong>动态生成和转换类（class）的Java语言工具，旨在处理已编译的Java类（class）。<a href="/java/2019-10-04-cglib/">CGLIB浅析</a></li><li>AspectJ: AspectJ采用<strong><em>编译时</em></strong>织入和<strong><em>类加载时</em></strong>织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<a href="/java/2019-10-04-aspectj/">AspectJ</a></li><li>Javassist: Javassist在Java中是一个用来编辑字节码的扩展包，它允许Java程序在<strong><em>运行时</em></strong>定义一个新类或者在JVM<strong><em>加载class文件时</em></strong>修改class文件。<br><a href="/java/2019-09-04-javassist/">Javassist</a></li><li>JDK Proxy: JDK动态代理类是在<strong><em>运行时</em></strong>实现指定的接口列表的类，该类实例上的其中一个接口进行的方法调用时，将被通过统一的接口进行编码并调用到另一个对象。因此，动态代理类可用于为接口列表创建类型安全的代理对象，而无需诸如在编译时使用编译工具预生成代理类。动态代理类实例的代理方法调用将在该代理类实例中的处理程序中通过java.lang.reflect.Method对象进行调用，该对象标识了所调用的方法和包含参数的Object类型数组，翻译自<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a>。详情<a href="/java/2019-10-04-jdk-proxy/">《JDK 动态代理浅析》</a></li></ul><p>在Java语言中，从构建代理类的时期上来看，有三种：编译时、类加载时和运行时。从方式上来说有两种，一种是静态代理，一种是动态代理。<br>动态代理则是一种方便<strong><em>运行时</em></strong>动态构建代理、动态处理代理方法调用的机制。例如ASM，Javassist，Java Proxy。</p><p><strong><em>编译时</em></strong>和<strong><em>类加载时</em></strong>构建代理类则属于静态代理。例如AspectJ。</p><h2 id="2-常用代理方式"><a href="#2-常用代理方式" class="headerlink" title="2. 常用代理方式"></a>2. 常用代理方式</h2><p>由于篇幅问题，本文进行了拆分，详细了解常用的代理方式的原理，请点击下方链接。</p><p><a href="/java/2019-10-04-jdk-proxy/">JDK proxy</a></p><p><a href="/java/2019-10-04-cglib/">CGLIB浅析</a></p><p><a href="/java/2019-10-04-aspectj/">AspectJ</a></p><p><a href="/java/2019-09-04-javassist/">Javassist</a></p><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h2><p><img src="/media/article/15688575046625.png" alt="jclasslib"><br>图片引用自<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">《美团技术团队》-字节码增强技术探索</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>1.Java生成动态代理的时候，使用WeakCache缓存已经生成的动态代理工厂，疑问点在于，为什么缓存的key使用的是<a href="/java/2019-09-15-reference/">弱引用</a>？</p><p>答: 类中的静态变量，当它持有一个指向一个对象的引用时，它就作为GC Root，第一类被列为GC Root的元素就是静态成员变量。因此若缓存不再需要时，使用强引用会让GC进行标记分析时认为从GC Root可达，不太会去标记这块内存，反之能够有效地标记这些缓存，从而提高内存回收效率。引用自<a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a></p><p>个人分析: 既然缓存代理工厂类，为什么不使用SoftReference，这样只有内存空间不够时才会进行回收。这样可以最大限度的缓存生成的代理工厂？<br>如果使用SoftReference，当服务使用动态代理较多时，可能会导致频繁的FullGC。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html" target="_blank" rel="noopener">Java动态代理机制分析及扩展，第1部分</a><br><a href="https://www.cnblogs.com/whirly/p/10154887.html" target="_blank" rel="noopener">Java 动态代理详解</a><br><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a><br><a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a><br><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a><br><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是动态代理？&quot;&gt;&lt;a href=&quot;#1-什么是动态代理？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是动态代理？&quot;&gt;&lt;/a&gt;1. 什么是动态代理？&lt;/h2&gt;&lt;p&gt;代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>了解ASM</title>
    <link href="https://zhongyp.me/java/2019-10-06-asm/"/>
    <id>https://zhongyp.me/java/2019-10-06-asm/</id>
    <published>2019-09-05T16:00:00.000Z</published>
    <updated>2019-10-21T11:34:13.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASM-是个啥"><a href="#ASM-是个啥" class="headerlink" title="ASM 是个啥"></a>ASM 是个啥</h2><blockquote><p><strong><a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a>技术是个啥？</strong><br>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br>ASM是一个通用的Java字节码操作和分析框架。它可以直接以二进制形式用于修改现有类或动态生成类。 ASM提供了一些常见的字节码转换和分析算法，可以从中构建定制的复杂转换和代码分析工具。 ASM提供与其他Java字节码框架类似的功能，但侧重于性能。因为它的设计和实现是尽可能的小和尽可能快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中使用）。<br>ASM应用广泛：OpenJDK lambda call sites，<a href="http://hg.openjdk.java.net/jdk8/jdk8/nashorn/file/096dc407d310/src/jdk/nashorn/internal/codegen/ClassEmitter.java" target="_blank" rel="noopener">Nashorn compiler</a><br>CGLIB，以动态生成代理类（用于其他项目，例如Mockito和EasyMock），Gradle，在运行时生成一些类。</p></blockquote><h2 id="ASM的原理解析"><a href="#ASM的原理解析" class="headerlink" title="ASM的原理解析"></a>ASM的原理解析</h2><p>ASM中最主要通过<a href="https://github.com/zhongyp/demo/tree/master/src/main/java/com/zhongyp/advanced/pattern/visitor" target="_blank" rel="noopener">访问模式</a>对字节码文件进行修改，读取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ASM-是个啥&quot;&gt;&lt;a href=&quot;#ASM-是个啥&quot; class=&quot;headerlink&quot; title=&quot;ASM 是个啥&quot;&gt;&lt;/a&gt;ASM 是个啥&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://asm.ow2.io/&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机类加载机制</title>
    <link href="https://zhongyp.me/jvm/2019-08-18-jvm-classloading/"/>
    <id>https://zhongyp.me/jvm/2019-08-18-jvm-classloading/</id>
    <published>2019-08-17T16:00:00.000Z</published>
    <updated>2019-09-10T08:44:34.872Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p></blockquote><p>Java 虚拟机动态的加载，连接，初始化类或者接口。</p><p>加载是一个通过特殊符号查找类或者接口类型的二进制文件，同时使用二进制文件创建类或者接口的过程。</p><p>连接是一个加载类或者接口并结合它变为Java虚拟机的运行时状态的过程，以便于它可以被Java虚拟机执行。</p><p>一个类或者接口的初始化由执行类或者接口的初始化方法<code>&lt;clinit&gt;</code>组成(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener">§2.9</a>)。</p><p>下图是类或者接口动态加载、连接、初始化的过程：</p><p><img src="/media/article/jvm-classloading.png" alt="jvm-classloading"></p><p>图片摘自<a href="">深入理解Java虚拟机</a></p><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h2><p>加载阶段：</p><ul><li><ol><li>通过一个类的全限定名来获取定义此类二进制字节流。</li></ol></li><li><ol start="2"><li>将这个字节流代表的静态存储结构转换为方法区的运行时数据结构(运行时数据结构详见第四小节<a href="#4-运行时常量池"></a>)。</li></ol></li><li><ol start="3"><li>在<strong><em>内存(Class对象比较特殊，它虽然是对象，但是存储在方法区中)</em></strong>生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol></li></ul><p>对于数组类本身不通过类加载器创建，它由Java虚拟机直接创建。数组类型却由类加载器创建，创建过程遵循以下规则：</p><ul><li>如果数组组件类型是引用类型，则数组被标记为组件类型定义的类加载器定义。否则，数组被标记为引导类加载器定义。</li><li>如果数组的组件类型不是引用类型，Java虚拟机将会把数组标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认是public。</li></ul><p>加载和连接阶段是交叉进行的。</p><h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h2><p>如果需要连接类或接口涉及验证和准备该类或接口，直接超类，直接超接口及其元素类型（如果它是数组类型）。类或接口中符号引用的解析是连接的可选部分。</p><p>只要维护了以下所有属性，此规范允许实现灵活性，以便何时发生连接活动（以及由于递归，加载）。</p><ul><li><p>类或接口在连接之前已完全加载。</p></li><li><p>在初始化之前，类或接口已完全验证并准备好。</p></li></ul><p>在连接期间检测到的错误被抛出到程序中的某个点，程序可能会直接或间接地需要连接到错误中涉及的类或接口。</p><p>例如，Java虚拟机实现可以选择在使用它时分别解析类或接口中的每个符号引用，或者在验证类时立即解析它们。这意味着在一些实现中，在初始化类或接口之后，解析过程可以继续。无论采用哪种策略，在解析期间检测到的任何错误都必须抛出到程序中（直接或间接）使用对类或接口的符号引用的位置。</p><p>因为连接涉及新数据结构的分配，所以它可能会失败OutOfMemoryError。</p><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>验证阶段会完成4个阶段的验证动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置类变量<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。进行内存分配的仅包括<strong><em>类变量[static变量]</em></strong>，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><h3 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic，这些虚拟机指令对运行时常量池进行符号引用，执行任何这些指令都需要解析其符号引用。</p><p>解析是从运行时常量池中的符号引用动态确定具体值的过程。</p><p>对出现在invokedynamic指令的相同的符号引用被解析一次并不意味着被任何其他invokedynamic指令认为已解析。</p><p>对于上述提到的所有指令，如果其中一个指令对符号引用进行了解析，则意味着任何非invokedynamic指令认为这个符号引用已经解析。</p><p>如果在解析符号引用期间发生错误，则必须在程序中(直接或间接)使用符号引用时的某一点抛出IncompatibleClassChangeError(或子类)的实例。</p><p>如果Java虚拟机尝试解析符号引用失败，抛出的错误是LinkageError(或子类)的实例，后续尝试解析引用始终失败，并且和初始解析尝试而引发的错误相同。</p><p>在执行指令之前，不得解析特定invokedynamic指令对调用site说明符的符号引用。</p><p>在<code>invokedynamic</code>指令解析失败的情况下，后续解析尝试不会重新执行引导方法。</p><p>上述某些指令在解析符号引用时需要额外的连接检查。例如，为了使getfield指令成功解析对其运行的字段的符号引用，它不仅必须完成第<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2" target="_blank" rel="noopener">5.4.3.2</a>节中给出的字段解析步骤，还要检查字段是否为静态。如果它是静态字段，则必须抛出链接异常。</p><p>值得注意的是，为了使<code>invokedynamic</code>指令成功解析对调用site说明符的符号引用，其中指定的引导方法必须正常完成并返回合适的调用站点对象。如果引导方法突然完成或返回不合适的调用站点对象，则必须抛出连接异常。</p><p>连接由特定执行特定Java虚拟机指令检查生成的异常在该指令的描述中给出，并且在本解析的一般性讨论中未涉及。请注意，此类异常虽然被描述为Java虚拟机指令执行而非解析的一部分，但仍然被视为解析失败。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h2><p>一个类的加载过程中加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，解析阶段则不一定。解析可以在初始化完成后再开始，这时为了支持Java的运行时绑定。</p><p>Java虚拟机没有进行强制约束什么时候加载，只是严格规范了5中情况必须对类进行”初始化”。</p><ul><li>遇到new、getstatic、putstatic或invokestatic这4条指令时，如果类没有进行初始化，则需要先触发其初始化。4条指令的常见场景是:使用new 关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)、以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7及以上版本的动态语言(详细了解 <a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a>)支持时，如果一个java.lang.incoke.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。</li></ul><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有 <strong><em>类变量的赋值动作</em></strong>和<strong><em>静态语句块(static{}块)中的语句</em></strong>合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语义块之前的变量，定义在它之后的变量，可以赋值，但是不能访问。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test()&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>不需要执行其父接口的<code>&lt;clinit&gt;()</code>方法。<br>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待。</p></blockquote><h2 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4. 运行时常量池"></a>4. 运行时常量池</h2><p>Java虚拟机维护每种类型常量池，这是一种运行时数据结构，它服务于常规编程语言实现的符号表的许多目的。</p><p>类或接口的二进制表示形式中的constant_pool表用于在创建类或接口对象时构造运行时常量池。运行时常量池中的所有引用最初都是符号引用。运行时常量池中的符号引用是从类或接口的二进制表示中的结构派生的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">String str = &quot;str&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">// 基本类型</span><br><span class="line">int i = 1;</span><br><span class="line"></span><br><span class="line">// 基本类型数组</span><br><span class="line">int[] arrayI = new int[3];</span><br><span class="line"></span><br><span class="line">// 引用类型数组</span><br><span class="line">A [] arrayA = new A[3];</span><br><span class="line"></span><br><span class="line">// 引用类型</span><br><span class="line">A a = new A();</span><br><span class="line"></span><br><span class="line">// 引用方法</span><br><span class="line">a.test();</span><br><span class="line"></span><br><span class="line">// 接口声明</span><br><span class="line">C c = new B();</span><br><span class="line"></span><br><span class="line">// 接口方法</span><br><span class="line">c.test();</span><br><span class="line"></span><br><span class="line">// lambda</span><br><span class="line">Runnable x = ()-&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p><code>javap -v</code>编译如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #13.#42        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #25            // str</span><br><span class="line">   #3 = Fieldref           #43.#44        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #45.#46        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #47            // com/zhongyp/test/A</span><br><span class="line">   #6 = Methodref          #5.#42         // com/zhongyp/test/A.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #7 = Methodref          #5.#48         // com/zhongyp/test/A.test:()V</span><br><span class="line">   #8 = Class              #49            // com/zhongyp/test/B</span><br><span class="line">   #9 = Methodref          #8.#42         // com/zhongyp/test/B.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #10 = InterfaceMethodref #50.#48        // com/zhongyp/test/C.test:()V</span><br><span class="line">  #11 = InvokeDynamic      #0:#55         // #0:run:()Ljava/lang/Runnable;</span><br><span class="line">  #12 = Class              #56            // com/zhongyp/test/Test</span><br><span class="line">  #13 = Class              #57            // java/lang/Object</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               LocalVariableTable</span><br><span class="line">  #19 = Utf8               this</span><br><span class="line">  #20 = Utf8               Lcom/zhongyp/test/Test;</span><br><span class="line">  #21 = Utf8               main</span><br><span class="line">  #22 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               args</span><br><span class="line">  #24 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               str</span><br><span class="line">  #26 = Utf8               Ljava/lang/String;</span><br><span class="line">  #27 = Utf8               i</span><br><span class="line">  #28 = Utf8               I</span><br><span class="line">  #29 = Utf8               arrayI</span><br><span class="line">  #30 = Utf8               [I</span><br><span class="line">  #31 = Utf8               arrayA</span><br><span class="line">  #32 = Utf8               [Lcom/zhongyp/test/A;</span><br><span class="line">  #33 = Utf8               a</span><br><span class="line">  #34 = Utf8               Lcom/zhongyp/test/A;</span><br><span class="line">  #35 = Utf8               c</span><br><span class="line">  #36 = Utf8               Lcom/zhongyp/test/C;</span><br><span class="line">  #37 = Utf8               x</span><br><span class="line">  #38 = Utf8               Ljava/lang/Runnable;</span><br><span class="line">  #39 = Utf8               lambda$main$0</span><br><span class="line">  #40 = Utf8               SourceFile</span><br><span class="line">  #41 = Utf8               Test.java</span><br><span class="line">  #42 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #43 = Class              #58            // java/lang/System</span><br><span class="line">  #44 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #45 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #46 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #47 = Utf8               com/zhongyp/test/A</span><br><span class="line">  #48 = NameAndType        #64:#15        // test:()V</span><br><span class="line">  #49 = Utf8               com/zhongyp/test/B</span><br><span class="line">  #50 = Class              #65            // com/zhongyp/test/C</span><br><span class="line">  #51 = Utf8               BootstrapMethods</span><br><span class="line">  #52 = MethodHandle       #6:#66         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #53 = MethodType         #15            //  ()V</span><br><span class="line">  #54 = MethodHandle       #6:#67         // invokestatic com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #55 = NameAndType        #68:#69        // run:()Ljava/lang/Runnable;</span><br><span class="line">  #56 = Utf8               com/zhongyp/test/Test</span><br><span class="line">  #57 = Utf8               java/lang/Object</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #64 = Utf8               test</span><br><span class="line">  #65 = Utf8               com/zhongyp/test/C</span><br><span class="line">  #66 = Methodref          #70.#71        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #67 = Methodref          #12.#72        // com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #68 = Utf8               run</span><br><span class="line">  #69 = Utf8               ()Ljava/lang/Runnable;</span><br><span class="line">  #70 = Class              #73            // java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #71 = NameAndType        #74:#78        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #72 = NameAndType        #39:#15        // lambda$main$0:()V</span><br><span class="line">  #73 = Utf8               java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #74 = Utf8               metafactory</span><br><span class="line">  #75 = Class              #80            // java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #76 = Utf8               Lookup</span><br><span class="line">  #77 = Utf8               InnerClasses</span><br><span class="line">  #78 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #79 = Class              #81            // java/lang/invoke/MethodHandles</span><br><span class="line">  #80 = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #81 = Utf8               java/lang/invoke/MethodHandles</span><br></pre></td></tr></table></figure><h3 id="4-1-CONSTANT-Class-info结构"><a href="#4-1-CONSTANT-Class-info结构" class="headerlink" title="4.1 CONSTANT_Class_info结构"></a>4.1 CONSTANT_Class_info结构</h3><p>对类或接口的符号引用是从类或接口的二进制表示形式中的CONSTANT_Class_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1" target="_blank" rel="noopener">第4.4.1节</a>派生的。这样的引用给出了Class.getName方法返回的表单中的类或接口的名称。</p><p>对于非数组类或接口，名称是类或接口的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>。</p><p>对于n维的数组类，名称以n个出现的ASCII“[”字符开头，后跟元素类型的表示：</p><ul><li><p>如果元素类型是基本类型，则它由相应的字段描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">第4.3.2节</a>表示。</p></li><li><p>否则，如果元素类型是引用类型，则它由ASCII“L”字符后跟元素类型的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>后跟ASCII“;”符号表示。</p></li></ul><h3 id="4-2-CONSTANT-Fieldref-info结构"><a href="#4-2-CONSTANT-Fieldref-info结构" class="headerlink" title="4.2 CONSTANT_Fieldref_info结构"></a>4.2 CONSTANT_Fieldref_info结构</h3><p>对类或接口的字段的符号引用是从类或接口的二进制表示形式中的CONSTANT_Fieldref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了字段的名称和描述符，以及对要在其中找到字段的类或接口的符号引用。</p><h3 id="4-3-CONSTANT-Methodref-info结构"><a href="#4-3-CONSTANT-Methodref-info结构" class="headerlink" title="4.3 CONSTANT_Methodref_info结构"></a>4.3 CONSTANT_Methodref_info结构</h3><p>对类的方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_Methodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了方法的名称和描述符，以及对要在其中找到方法的类的符号引用。</p><h3 id="4-4-CONSTANT-InterfaceMethodref-info"><a href="#4-4-CONSTANT-InterfaceMethodref-info" class="headerlink" title="4.4 CONSTANT_InterfaceMethodref_info"></a>4.4 CONSTANT_InterfaceMethodref_info</h3><p>对接口方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_InterfaceMethodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了接口方法的名称和描述符，以及对要在其中找到方法的接口的符号引用。</p><h3 id="4-5-CONSTANT-MethodHandle-info结构"><a href="#4-5-CONSTANT-MethodHandle-info结构" class="headerlink" title="4.5 CONSTANT_MethodHandle_info结构"></a>4.5 CONSTANT_MethodHandle_info结构</h3><p>方法句柄的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodHandle_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.8" target="_blank" rel="noopener">第4.4.8节</a>派生的。这样的引用根据方法句柄的类型给出了类或接口的字段，类的方法或接口的方法的符号引用。</p><h3 id="4-6-CONSTANT-MethodType-info结构"><a href="#4-6-CONSTANT-MethodType-info结构" class="headerlink" title="4.6 CONSTANT_MethodType_info结构"></a>4.6 CONSTANT_MethodType_info结构</h3><p>方法类型的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodType_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.9" target="_blank" rel="noopener">第4.4.9节</a>派生的。这样的引用给出了方法描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">§4.3.3</a>。</p><h3 id="4-7-CONSTANT-InvokeDynamic-info结构"><a href="#4-7-CONSTANT-InvokeDynamic-info结构" class="headerlink" title="4.7 CONSTANT_InvokeDynamic_info结构"></a>4.7 CONSTANT_InvokeDynamic_info结构</h3><blockquote><h3 id="invokedynamic-instructions"><a href="#invokedynamic-instructions" class="headerlink" title="invokedynamic instructions"></a>invokedynamic instructions</h3><p>A dynamic call site is originally in an unlinked state. In this state, there is no target method for the call site to invoke.<br>动态的调用site起初处在未连接的状态。在这种状态下，调用site没有调用的目标方法。<br>Before the JVM can execute a dynamic call site (an invokedynamic instruction), the call site must first be linked. Linking is accomplished by calling a bootstrap method which is given the static information content of the call site, and which must produce a method handle that gives the behavior of the call site.<br>在JVM可以执行动态调用site（invokedynamic指令）之前，必须首先连接调用site。连接是通过调用一个bootstrap方法来完成的，该方法被赋予了调用站点的静态信息内容，并且必须产生一个方法句柄来给出调用站点的行为。<br>Each invokedynamic instruction statically specifies its own bootstrap method as a constant pool reference. The constant pool reference also specifies the call site’s name and type descriptor, just like invokevirtual and the other invoke instructions.<br>每个invokedynamic指令静态的将它自己的引导方法指定作为一个常量池引用。常量池引用也指定调用site的名称和类型描述，就像invokevirtual和其他的调用描述一样。<br>Linking starts with resolving the constant pool entry for the bootstrap method, and resolving a MethodType object for the type descriptor of the dynamic call site. This resolution process may trigger class loading. It may therefore throw an error if a class fails to load. This error becomes the abnormal termination of the dynamic call site execution. Linkage does not trigger class initialization.<br>连接从解析引导方法的常量池条目开始，并为动态调用site的类型描述符解析MethodType对象。这个解决的进程可能触发类加载。如果一个类加载失败，可能因此抛出一个error。这个error将成为动态调用site执行的异常终止。连接不能触发类的初始化。<br>The bootstrap method is invoked on at least three values:<br>引导方法至少使用3个值调用:</p><ul><li>a MethodHandles.Lookup, a lookup object on the caller class in which dynamic call site occurs</li><li>一个是MethodHandles.Lookup，发生动态调用site的调用类上的一个lookup对象。</li><li>a String, the method name mentioned in the call site</li><li>一个字符创，在调用site中提到的方法名称。</li><li>a MethodType, the resolved type descriptor of the call</li><li>一个MethodType，已解析的调用的类型描述。</li><li>optionally, between 1 and 251 additional static arguments taken from the constant pool。</li><li>可选地，从常量池中获取1到251个额外的静态参数。</li></ul></blockquote><p>对调用站点说明符的符号引用是从类或接口的二进制表示形式中的CONSTANT_InvokeDynamic_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.10" target="_blank" rel="noopener">第4.4.10节</a>派生的。这样的参考给出：</p><ul><li><p>方法句柄的符号引用，它将作为invokedynamic指令的引导方法<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic" target="_blank" rel="noopener">§invokedynamic</a>;</p></li><li><p>一系列符号引用(对类，方法类型和方法句柄)，字符串文字和运行时常量值，它们将作为引导方法的静态参数;</p></li><li><p>方法名称和方法描述符。</p></li></ul><h3 id="4-8-CONSTANT-String-info结构"><a href="#4-8-CONSTANT-String-info结构" class="headerlink" title="4.8 CONSTANT_String_info结构"></a>4.8 CONSTANT_String_info结构</h3><p>此外，某些不是符号引用的运行时值是从constant_pool表中找到的项派生的：</p><p>字符串文字是对类String实例的引用，它是从类或接口的二进制表示形式的CONSTANT_String_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3" target="_blank" rel="noopener">第4.4.3节</a>派生而来的。 CONSTANT_String_info结构给出了构成字符串文字的Unicode代码点序列。</p><p>Java编程语言要求相同的字符串文字[即包含相同代码点序列的文字]必须引用类String的相同实例(JLS§3.10.5)。此外，如果在任何字符串上调用String.intern方法，则结果是对该字符串显示为文字时将返回的同一类实例的引用。因此，以下表达式的值必须为true：</p><p><code>(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</code></p><p>为了派生字符串文字，Java虚拟机检查CONSTANT_String_info结构给出的代码点序列。</p><p>如果先前在类String的实例上调用了String.intern方法，该类包含与CONSTANT_String_info结构给出的Unicode代码点序列相同的Unicode代码点序列，则字符串文字派生的结果是对类String的同一实例的引用。</p><p>否则，将创建一个类String的新实例，其中包含CONSTANT_String_info结构给出的Unicode代码点序列;对该类实例的引用是字符串文字派生的结果。最后，调用新String实例的intern方法。</p><h3 id="4-9-其他结构"><a href="#4-9-其他结构" class="headerlink" title="4.9 其他结构"></a>4.9 其他结构</h3><p>运行时常量值是从类或接口的二进制表示形式中的CONSTANT_Integer_info，CONSTANT_Float_info，CONSTANT_Long_info或CONSTANT_Double_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">第4.4.4节，第4.4.5节</a>派生的。</p><p>请注意，CONSTANT_Float_info结构表示IEEE 754单一格式的值，CONSTANT_Double_info结构表示IEEE 754双格式<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">§4.4.4，§4.4.5</a>中的值。因此，从这些结构导出的运行时常数值必须是可以分别使用IEEE 754单格式和双格式表示的值。</p><p>类或接口的二进制表示的constant_pool表中的其余结构 - CONSTANT_NameAndType_info和CONSTANT_Utf8_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.6" target="_blank" rel="noopener">§4.4.6，§4.4.7</a> - 仅在派生对类，接口，方法，字段的符号引用时间接使用，方法类型和方法句柄，以及派生字符串文字和调用站点说明符时。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a></p><p><a href="">深入理解Java虚拟机</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/package-summary.html#package.description" target="_blank" rel="noopener">Package java.lang.invoke Description</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chapter 5. Loadin
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhongyp.me/tags/JVM/"/>
    
      <category term="翻译" scheme="https://zhongyp.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM官方文档指南</title>
    <link href="https://zhongyp.me/jvm/2019-08-08-offical-document/"/>
    <id>https://zhongyp.me/jvm/2019-08-08-offical-document/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-11T11:01:42.708Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">Java虚拟机规范</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java虚拟机规范&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhongyp.me/tags/JVM/"/>
    
  </entry>
  
</feed>
