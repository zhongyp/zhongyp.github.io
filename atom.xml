<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhongyp&#39;blog</title>
  
  <subtitle>钟宇鹏的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.programer.group/"/>
  <updated>2021-06-08T15:51:56.322Z</updated>
  <id>http://blog.programer.group/</id>
  
  <author>
    <name>zhongyp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员的自我修养</title>
    <link href="http://blog.programer.group/career/try-my-best/"/>
    <id>http://blog.programer.group/career/try-my-best/</id>
    <published>2020-11-16T16:00:00.000Z</published>
    <updated>2021-06-08T15:51:56.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序员的自我修养"><a href="#程序员的自我修养" class="headerlink" title="程序员的自我修养"></a>程序员的自我修养</h2><h3 id="工程师素养"><a href="#工程师素养" class="headerlink" title="工程师素养"></a>工程师素养</h3><h4 id="工程师价值观"><a href="#工程师价值观" class="headerlink" title="工程师价值观"></a>工程师价值观</h4><ul><li><a href="https://www.quora.com/What-are-some-of-the-most-basic-things-every-programmer-should-know" target="_blank" rel="noopener">What are some of the most basic things every programmer should know?</a></li><li><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/index.html" target="_blank" rel="noopener">97 Things Every Programmer Should Know</a></li><li><a href="https://coolshell.cn/articles/20276.html" target="_blank" rel="noopener">酷壳-CoolShell.别让自己“墙”了自己</a></li></ul><h4 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h4><h5 id="编程语言的设计和思想"><a href="#编程语言的设计和思想" class="headerlink" title="编程语言的设计和思想"></a>编程语言的设计和思想</h5><h6 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h6><p>In this chapter, we<br>• Introduce you to object-oriented programming;<br>• Show you how you can create objects that belong to classes in the standard Java library;<br>• Show you how to write your own classes.</p><p>If you do not have a background in object-oriented programming, you will want to read this chapter carefully.</p><p>Thinking about object-oriented programming requires a different way of thinking than for procedural languages.</p><p>The transition is not always easy, but you do need some familiarity with object concepts to go further with Java.</p><p>For experienced C++ programmers, this chapter, like the previous chapter, presents familiar information;</p><p>however, there are enough differences between the two languages that you should read the later sections of this chapter carefully.</p><p>You’ll find the C++ notes helpful for making the transition.</p><p>Introduction to Object-Oriented Programming Object-oriented programming (or OOP for short) is the dominant programming paradigm these days,</p><p>having replaced the “structured,” procedural programming techniques that were developed in the 1970s.</p><p>Java is totally object oriented, and you have to be familiar with OOP to become productive with Java.</p><p>An object-oriented program is made of objects. Each object has a specific functionality that is exposed to its users, and a hidden implementation.</p><p>Many objects in your programs will be taken “off-the-shelf” from a library; others are custom designed.</p><p>Whether you build an object or buy it might depend on your budget or on time.</p><p>But, basically, as long as objects satisfy your specifications, you don’t care how the functionality was implemented.</p><p>In OOP, you don’t care how an object is implemented as long as it does what you want.</p><p>Traditional structured programming consists of designing a set of procedures (or algorithms) to solve a problem.</p><p>After the procedures were determined, the traditional next step was to find appropriate ways to store the data.</p><p>This is why the designer of the Pascal language, Niklaus Wirth, called his famous book on programming Algorithms + Data Structures = Programs (Prentice Hall, 1975). Notice that in Wirth’s title, algorithms come first, and data structures come second. This mimics the way programmers worked at that time.</p><p>First, they decided the procedures for manipulating the data; then, they decided what structure to impose on the data to make the manipulations easier.</p><p>OOP reverses the order and puts data first, then looks at the algorithms that operate on the data.</p><p>For small problems, the breakdown into procedures works very well. But objects are more appropriate for larger problems.</p><p>Consider a simple web browser. It might require 2,000 procedures for its implementation, all of which manipulate a set of global data.</p><p>In the object-oriented style, there might be 100 classes with an average of 20 methods per class (see Figure 4–1).</p><p>The latter structure is much easier for a programmer to grasp. It is also much easier to find bugs. Suppose the data of a particular object is in an incorrect state.</p><p>It is far easier to search for the culprit among the 20 methods that had access to that data item than among 2,000 procedures.</p><h3 id="英文能力"><a href="#英文能力" class="headerlink" title="英文能力"></a>英文能力</h3><p>listen, speak, read and write.</p><h3 id="问题和表达"><a href="#问题和表达" class="headerlink" title="问题和表达"></a>问题和表达</h3><ul><li><a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank" rel="noopener">How To Ask Questions The Smart Way</a></li><li><a href="https://meta.stackexchange.com/questions/7931/faq-for-stack-exchange-sites" target="_blank" rel="noopener">FAQ for StackExchange Site</a></li></ul><h3 id="Coding-能力"><a href="#Coding-能力" class="headerlink" title="Coding 能力"></a>Coding 能力</h3><h4 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h4><h5 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h5><ul><li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">重构：改善既有代码的设计</a></li><li><a href="https://book.douban.com/subject/2248759/" target="_blank" rel="noopener">修改代码的艺术</a></li><li><a href="https://book.douban.com/subject/4199741/" target="_blank" rel="noopener">代码整洁之道</a></li><li><a href="https://book.douban.com/subject/11614538/" target="_blank" rel="noopener">程序员的职业素养</a></li></ul><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><p>算法</p><ul><li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">算法</a></li><li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">算法图解</a></li><li><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">算法导论</a></li><li><a href="https://book.douban.com/subject/3227098/" target="_blank" rel="noopener">编程珠玑</a></li><li><strong><a href="https://www.wikiwand.com/en/List_of_algorithms" target="_blank" rel="noopener">List of Algorithms</a></strong></li><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualizations</a></li></ul><blockquote><ul><li><strong>基础算法题</strong>。其中有大量的算法题，解这些题都是有套路的，不是用递归（深度优先 DFS，广度优先 BFS），就是要用动态规划（Dynamic Programming），或是折半查找（Binary Search），或是回溯（Back tracing），或是分治法（Divide and Conquer），还有大量的对树、数组、链表、字符串和 hash 表的操作。通过做这些题能让你对这些最基础的算法的思路有非常扎实的了解和训练。对我而言，Dynamic Programming 是我的短板，尤其是一些比较复杂的问题，在推导递推公式上总是有思维的缺陷（数学是我的硬伤）。做了这些题后，我能感到我在动态编程的思路上受到了很大的启发。</li><li><strong>编程题</strong>。比如：atoi，strstr，add two nums，括号匹配，字符串乘法，通配符匹配，文件路径简化，Text Justification，反转单词等，这些题的 Edge Case 和 Corner Case 有很多。这些题需要你想清楚了再干，只要你稍有疏忽，就会有几个 case 让你痛不欲生，而且一不小心就会让你的代码写得又臭又长，无法阅读。通过做这些题，可以非常好地训练你对各种情况的考虑，以及你对程序代码组织的掌控（其实就是其中的状态变量）</li></ul></blockquote><p>数据结构</p><ul><li><a href="https://book.douban.com/subject/1139426/" target="_blank" rel="noopener">数据结构与算法分析</a></li><li><a href="https://book.douban.com/subject/1929984/" target="_blank" rel="noopener">数据库系统概念</a></li></ul><p>网络模型</p><ul><li><a href="https://book.douban.com/subject/1391207/" target="_blank" rel="noopener">计算机网络</a></li><li><a href="http://www.tcpipguide.com/free/index.htm" target="_blank" rel="noopener">The TCP/IP Guide</a></li><li><a href="https://book.douban.com/subject/21691692/" target="_blank" rel="noopener">Wireshark 数据包分析实战</a></li></ul><p>计算机原理</p><ul><li><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">计算机程序的构造和解释</a></li><li><a href="https://book.douban.com/subject/3296317/" target="_blank" rel="noopener">编译原理</a></li></ul><p>操作系统</p><ul><li><a href="https://book.douban.com/subject/3852290/" target="_blank" rel="noopener">现代操作系统</a></li><li><a href="https://book.douban.com/subject/5333562/" target="_blank" rel="noopener">深入理解计算机系统</a></li><li><a href="https://book.douban.com/subject/1788421/" target="_blank" rel="noopener">Unix 高级环境编程</a></li><li>Unix 网络编程 <a href="https://book.douban.com/subject/1500149/" target="_blank" rel="noopener">第 1 卷 套接口 API</a> 、<a href="https://book.douban.com/subject/4118577/" target="_blank" rel="noopener">第 2 卷 进程间通信</a> 。</li><li><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP 详解 卷 I 协议</a></li><li><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">C10K Problem</a> （<a href="https://www.oschina.net/translate/c10k" target="_blank" rel="noopener">中文翻译版</a>）</li></ul><blockquote><ul><li>用这些系统知识操作一下文件系统，实现一个可以拷贝目录树的小程序。</li><li>用 fork / wait / waitpid 写一个多进程的程序，用 pthread 写一个多线程带同步或互斥的程序。比如，多进程购票的程序。</li><li>用 signal / kill / raise / alarm / pause / sigprocmask 实现一个多进程间的信号量通信的程序。</li><li>学会使用 gcc 和 gdb 来编程和调试程序（参看我的《<strong>用 gdb 调试程序</strong>》<a href="https://blog.csdn.net/haoel/article/details/2879" target="_blank" rel="noopener">一</a>、<a href="https://blog.csdn.net/haoel/article/details/2880" target="_blank" rel="noopener">二</a>、<a href="https://blog.csdn.net/haoel/article/details/2881" target="_blank" rel="noopener">三</a>、<a href="https://blog.csdn.net/haoel/article/details/2882" target="_blank" rel="noopener">四</a>、<a href="https://blog.csdn.net/haoel/article/details/2883" target="_blank" rel="noopener">五</a>、<a href="https://blog.csdn.net/haoel/article/details/2884" target="_blank" rel="noopener">六</a>、<a href="https://blog.csdn.net/haoel/article/details/2885" target="_blank" rel="noopener">七</a>）。</li><li>学会使用 makefile 来编译程序（参看我的《<strong>跟我一起写 makefile</strong>》<a href="https://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">一</a>、<a href="https://blog.csdn.net/haoel/article/details/2887" target="_blank" rel="noopener">二</a>、<a href="https://blog.csdn.net/haoel/article/details/2888" target="_blank" rel="noopener">三</a>、<a href="https://blog.csdn.net/haoel/article/details/2889" target="_blank" rel="noopener">四</a>、<a href="https://blog.csdn.net/haoel/article/details/2890" target="_blank" rel="noopener">五</a>、<a href="https://blog.csdn.net/haoel/article/details/2891" target="_blank" rel="noopener">六</a>、<a href="https://blog.csdn.net/haoel/article/details/2892" target="_blank" rel="noopener">七</a>、<a href="https://blog.csdn.net/haoel/article/details/2893" target="_blank" rel="noopener">八</a>、<a href="https://blog.csdn.net/haoel/article/details/2894" target="_blank" rel="noopener">九</a>、<a href="https://blog.csdn.net/haoel/article/details/2895" target="_blank" rel="noopener">十</a>、<a href="https://blog.csdn.net/haoel/article/details/2896" target="_blank" rel="noopener">十一</a>、<a href="https://blog.csdn.net/haoel/article/details/2897" target="_blank" rel="noopener">十二</a>、<a href="https://blog.csdn.net/haoel/article/details/2898" target="_blank" rel="noopener">十三</a>、<a href="https://blog.csdn.net/haoel/article/details/2899" target="_blank" rel="noopener">十四</a>）。</li><li>Socket 的进程间通信。用 C 语言写一个 1 对 1 的聊天小程序，或是一个简单的 HTTP 服务器。</li></ul></blockquote><p>操作系统处理大并发请求的问题（世界级难题）：<a href="http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html" target="_blank" rel="noopener">The Secret To 10 Million Concurrent Connections -The Kernel Is The Problem, Not The Solution</a></p><blockquote><p>实现一个 telnet 版本的聊天服务器，主要有以下需求。</p><ul><li>每个客户端可以用使用<code>telnet ip:port</code>的方式连接到服务器上。</li><li>新连接需要用用户名和密码登录，如果没有，则需要注册一个。</li><li>然后可以选择一个聊天室加入聊天。</li><li>管理员有权创建或删除聊天室，普通人员只有加入、退出、查询聊天室的权力。</li><li>聊天室需要有人数限制，每个人发出来的话，其它所有的人都要能看得到。</li></ul><p>实现一个简单的 HTTP 服务器，主要有以下需求。</p><ul><li>解释浏览器传来的 HTTP 协议，只需要处理 URL path。</li><li>然后把所代理的目录列出来。</li><li>在浏览器上可以浏览目录里的文件和下级目录。</li><li>如果点击文件，则把文件打开传给浏览器（浏览器能够自动显示图片、PDF，或 HTML、CSS、JavaScript 以及文本文件）。</li><li>如果点击子目录，则进入到子目录中，并把子目录中的文件列出来。</li></ul><p>实现一个生产者 / 消费者消息队列服务，主要有以下需求。</p><ul><li>消息队列采用一个 Ring-buffer 的数据结构。</li><li>可以有多个 topic 供生产者写入消息及消费者取出消息。</li><li>需要支持多个生产者并发写。</li><li>需要支持多个消费者消费消息（只要有一个消费者成功处理消息就可以删除消息）。</li><li>消息队列要做到不丢数据（要把消息持久化下来）。</li><li>能做到性能很高。</li></ul></blockquote><h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h5><h6 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h6><ul><li><a href="https://time.geekbang.org/column/article/301" target="_blank" rel="noopener">编程范式游记（1）- 起源</a></li><li><a href="https://time.geekbang.org/column/article/303" target="_blank" rel="noopener">编程范式游记（2）- 泛型编程</a></li><li><a href="https://time.geekbang.org/column/article/2017" target="_blank" rel="noopener">编程范式游记（3）- 类型系统和泛型的本质</a></li><li><a href="https://time.geekbang.org/column/article/2711" target="_blank" rel="noopener">编程范式游记（4）- 函数式编程</a></li><li><a href="https://time.geekbang.org/column/article/2723" target="_blank" rel="noopener">编程范式游记（5）- 修饰器模式</a></li><li><a href="https://time.geekbang.org/column/article/2729" target="_blank" rel="noopener">编程范式游记（6）- 面向对象编程</a></li><li><a href="https://time.geekbang.org/column/article/2741" target="_blank" rel="noopener">编程范式游记（7）- 基于原型的编程范式</a></li><li><a href="https://time.geekbang.org/column/article/2748" target="_blank" rel="noopener">编程范式游记（8）- Go 语言的委托模式</a></li><li><a href="https://time.geekbang.org/column/article/2751" target="_blank" rel="noopener">编程范式游记（9）- 编程的本质</a></li><li><a href="https://time.geekbang.org/column/article/2752" target="_blank" rel="noopener">编程范式游记（10）- 逻辑编程范式</a></li><li><p><a href="https://time.geekbang.org/column/article/2754" target="_blank" rel="noopener">编程范式游记（11）- 程序世界里的编程范式</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Programming_paradigm" target="_blank" rel="noopener">Wikipedia: Programming paradigm</a></p></li><li><p><a href="https://www.ybrikman.com/writing/2014/04/09/six-programming-paradigms-that-will/" target="_blank" rel="noopener">Six programming paradigms that will change how you think about coding</a>（<a href="https://my.oschina.net/editorial-story/blog/890965" target="_blank" rel="noopener">六个编程范型将改变你对编程的看法</a>）</p></li><li><p><a href="https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf" target="_blank" rel="noopener">Programming Paradigms for Dummies: What Every Programmer Should Know</a></p></li><li><p><a href="http://open.163.com/special/opencourse/paradigms.html" target="_blank" rel="noopener">斯坦福大学公开课：编程范式</a></p></li></ul><p><a href="https://my.oschina.net/editorial-story/blog/890965" target="_blank" rel="noopener">六个编程范型将改变你对编程的看法</a></p><p>Thinking more before coding.</p><h6 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h6><p>####### 设计原则</p><ul><li><a href="http://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself" target="_blank" rel="noopener">Don’t Repeat Yourself (DRY) </a></li><li><a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener">Keep It Simple, Stupid(KISS)</a></li><li><a href="http://en.wikipedia.org/wiki/You_Ain&#39;t_Gonna_Need_It" target="_blank" rel="noopener">You Ain’t Gonna Need It (YAGNI)</a></li><li><a href="http://en.wikipedia.org/wiki/Principle_of_Least_Knowledge" target="_blank" rel="noopener">Law of Demeter</a></li><li><a href="http://en.wikipedia.org/wiki/Solid" target="_blank" rel="noopener">面向对象的 S.O.L.I.D 原则</a></li><li><a href="http://c2.com/cgi/wiki?CommonClosurePrinciple" target="_blank" rel="noopener">CCP（Common Closure Principle） - 共同封闭原则</a></li><li><a href="http://c2.com/cgi/wiki?CommonReusePrinciple" target="_blank" rel="noopener">CRP（Common Reuse Principle）- 共同重用原则</a></li><li><a href="http://en.wikipedia.org/wiki/Hollywood_Principle" target="_blank" rel="noopener">好莱坞原则 - Hollywood Principle</a></li><li><a href="http://en.wikipedia.org/wiki/Coupling_(computer_science" target="_blank" rel="noopener">高内聚， 低耦合 &amp; - High Cohesion &amp; Low/Loose coupling</a>)</li><li><a href="http://www.math-cs.gordon.edu/courses/cs211/lectures-2009/Cohesion,Coupling,MVC.pdf" target="_blank" rel="noopener">High Cohesion and Low Coupling</a></li><li><a href="http://en.wikipedia.org/wiki/Convention_over_Configuration" target="_blank" rel="noopener">CoC（Convention over Configuration）- 惯例优于配置原则</a></li><li><a href="http://sulong.me/archives/99" target="_blank" rel="noopener">SoC (Separation of Concerns) - 关注点分离</a></li><li><a href="http://en.wikipedia.org/wiki/Design_by_contract" target="_blank" rel="noopener">DbC（Design by Contract）- 契约式设计</a></li><li><a href="http://c2.com/cgi/wiki?AcyclicDependenciesPrinciple" target="_blank" rel="noopener">ADP（Acyclic Dependencies Principle）- 无环依赖原则</a></li><li><a href="https://book.douban.com/subject/26819666/" target="_blank" rel="noopener">领域驱动设计</a></li><li><a href="https://book.douban.com/subject/1467587/" target="_blank" rel="noopener">UNIX 编程艺术</a></li><li><a href="https://book.douban.com/subject/26915970/" target="_blank" rel="noopener">Clean Architecture</a></li><li><a href="https://12factor.net/" target="_blank" rel="noopener">The Twelve-Factor App</a>（<a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">中译版</a>）【必读】</li><li><a href="https://medium.com/@rdsubhas/10-modern-software-engineering-mistakes-bc67fbef4fc8" target="_blank" rel="noopener">Avoid Over Engineering</a></li><li><a href="https://medium.com/@DataStax/instagram-engineerings-3-rules-to-a-scalable-cloud-application-architecture-c44afed31406" target="_blank" rel="noopener">Instagram Engineering’s 3 rules to a scalable cloud application architecture</a></li><li><a href="https://www.infoq.com/presentations/effective-api-design" target="_blank" rel="noopener">How To Design A Good API and Why it Matters - Joshua Bloch</a></li><li><a href="https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api" target="_blank" rel="noopener">Best Practices for Designing a Pragmatic RESTful API</a></li><li><a href="https://betimdrenica.wordpress.com/2015/03/09/ideal-rest-api-design/" target="_blank" rel="noopener">Ideal REST API design</a></li><li><a href="https://github.com/interagent/http-api-design" target="_blank" rel="noopener">HTTP API Design Guide</a></li><li><a href="https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md" target="_blank" rel="noopener">Microsoft REST API Guidelines</a></li><li><a href="https://github.com/watson-developer-cloud/api-guidelines" target="_blank" rel="noopener">IBM Watson REST API Guidelines</a></li><li><a href="https://opensource.zalando.com/restful-api-guidelines/" target="_blank" rel="noopener">Zalando RESTful API and Event Scheme Guidelines</a></li><li><a href="https://blog.codinghorror.com/the-problem-with-logging/" target="_blank" rel="noopener">The Problem With Logging</a></li><li><a href="http://berb.github.io/diploma-thesis/community/index.html" target="_blank" rel="noopener">Concurrent Programming for Scalable Web Architectures</a></li></ul><h5 id="Coding-Language"><a href="#Coding-Language" class="headerlink" title="Coding Language"></a>Coding Language</h5><h6 id="C-and-C"><a href="#C-and-C" class="headerlink" title="C and C++"></a>C and C++</h6><ul><li><a href="https://book.douban.com/subject/1139336/" target="_blank" rel="noopener">C 程序设计语言</a></li><li><a href="https://book.douban.com/subject/2280547/" target="_blank" rel="noopener">C 语言程序设计现代方法</a></li><li><a href="https://en.wikipedia.org/wiki/The_C_Programming_Language" target="_blank" rel="noopener">The C Programming Language</a></li><li><a href="https://book.douban.com/subject/2778632/" target="_blank" rel="noopener">C 陷阱与缺陷</a></li><li><a href="https://book.douban.com/subject/25708312/" target="_blank" rel="noopener">C++ Primer 中文版</a></li><li><a href="https://book.douban.com/subject/5387403/" target="_blank" rel="noopener">Effective C++</a></li><li><a href="https://book.douban.com/subject/5908727/" target="_blank" rel="noopener">More Effective C++</a></li><li><a href="https://book.douban.com/subject/10427315/" target="_blank" rel="noopener">深度探索 C++ 对象模型</a></li><li><a href="https://coolshell.cn/articles/12165.html" target="_blank" rel="noopener">C++ 虚函数表解析</a></li><li><a href="https://coolshell.cn/articles/12176.html" target="_blank" rel="noopener">C++ 对象内存布局</a></li><li><a href="http://www.stroustrup.com/bs_faq.html" target="_blank" rel="noopener">C++ FAQ</a>（<a href="http://www.stroustrup.com/bsfaqcn.html" target="_blank" rel="noopener">中文版</a>）</li></ul><h6 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h6><ul><li><a href="https://book.douban.com/subject/26880667/" target="_blank" rel="noopener">Java 核心技术：卷 1 基础知识</a></li><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Java 编程思想</a></li><li><a href="https://book.douban.com/subject/26740520/" target="_blank" rel="noopener">Java 性能权威指南</a></li><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">深入理解 Java 虚拟机</a></li><li><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">Java 并发编程实战</a></li><li><a href="https://github.com/google/guava" target="_blank" rel="noopener">Google Guava 库</a></li><li><a href="https://book.douban.com/subject/27047716/" target="_blank" rel="noopener">Effective Java</a></li><li><a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">Spring 实战</a></li><li><a href="https://book.douban.com/subject/26857423/" target="_blank" rel="noopener">Spring Boot 实战</a></li><li><a href="https://book.douban.com/subject/26952826/" target="_blank" rel="noopener">精通 Spring 4.x</a></li><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">Head First 设计模式</a></li></ul><h6 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h6><ul><li><a href="https://coolshell.cn/articles/18190.html" target="_blank" rel="noopener">Go 语言、Docker 和新技术</a></li><li><a href="https://gobyexample.com/" target="_blank" rel="noopener">Go by Example</a></li><li><a href="https://book.douban.com/subject/26337545/" target="_blank" rel="noopener">The Go Programming Language</a></li><li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a></li><li><a href="https://github.com/golang/go/wiki/Articles" target="_blank" rel="noopener">Go 精华文章列表</a></li><li><a href="https://github.com/golang/go/wiki/Blogs" target="_blank" rel="noopener">Go 相关博客列表</a></li><li><a href="https://github.com/golang/go/wiki/GoTalks" target="_blank" rel="noopener">Go Talks</a></li><li><a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">Awesome Go</a></li><li>Go Concurrency Patterns（ <a href="https://talks.golang.org/2012/concurrency.slide" target="_blank" rel="noopener">幻灯片</a>和<a href="https://www.youtube.com/watch?v=f6kdp27TYZs" target="_blank" rel="noopener">演讲视频</a>）</li><li>Advanced Go Concurrency Patterns（<a href="https://talks.golang.org/2013/advconc.slide" target="_blank" rel="noopener">幻灯片</a>、<a href="https://youtu.be/QDDwwePbDtw" target="_blank" rel="noopener">演讲视频</a>）</li></ul><h4 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h4><ul><li><a href="https://medium.com/@palantir/code-review-best-practices-19e02780015f" target="_blank" rel="noopener">Code Review Best Practices</a></li><li><a href="https://dzone.com/articles/how-google-does-code-review" target="_blank" rel="noopener">How Google Does Code Review</a></li></ul><ul><li><a href="https://thenewstack.io/linkedin-code-review/" target="_blank" rel="noopener">LinkedIn’s Tips for Highly Effective Code Review</a></li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li><a href="https://stackify.com/unit-testing-basics-best-practices/" target="_blank" rel="noopener">You Still Don’t Know How to Do Unit Testing</a></li><li><a href="https://dzone.com/articles/unit-testing-best-practices" target="_blank" rel="noopener">Unit Testing Best Practices: JUnit Reference Guide</a></li><li><a href="http://www.kyleblaney.com/junit-best-practices/" target="_blank" rel="noopener">JUnit Best Practices</a></li></ul><h4 id="工程师需要注意的安全问题"><a href="#工程师需要注意的安全问题" class="headerlink" title="工程师需要注意的安全问题"></a>工程师需要注意的安全问题</h4><ul><li><a href="https://www.owasp.org/index.php/Main_Page" target="_blank" rel="noopener">OWASP - Open Web Application Security Project</a></li><li><a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project" target="_blank" rel="noopener">OWASP TOP Ten Project</a></li><li><a href="https://www.owasp.org/images/d/dc/OWASP_Top_10_2017_中文版v1.3.pdf" target="_blank" rel="noopener">OWASP Top 10 2017 PDF 中文版</a></li><li><a href="https://security.berkeley.edu/secure-coding-practice-guidelines" target="_blank" rel="noopener">伯克立大学的 Secure Coding Practice Guidelines</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/seccode/SEI+CERT+Coding+Standards" target="_blank" rel="noopener">卡内基梅隆大学的 SEI CERT Coding Standards</a></li><li><a href="https://www.keycdn.com/blog/http-security-headers/" target="_blank" rel="noopener">Hardening Your HTTP Security Headers</a></li><li><a href="https://medium.com/web-engineering-vox/the-art-of-defensive-programming-6789a9743ed4" target="_blank" rel="noopener">The Art of Defensive Programming</a></li><li><a href="https://medium.com/@cvitullo/overly-defensive-programming-e7a1b3d234c2" target="_blank" rel="noopener">Overly defensive programming</a></li></ul><h4 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h4><ul><li><a href="https://book.douban.com/subject/4187479/" target="_blank" rel="noopener">完美软件：对软件测试的各种幻想</a></li><li><a href="https://book.douban.com/subject/25742200/" target="_blank" rel="noopener">Google 软件测试之道</a></li><li><a href="https://github.com/mtdvio/going-to-production/blob/master/serverside-checklist.md" target="_blank" rel="noopener">Server Side checklist</a></li><li><a href="https://github.com/mtdvio/going-to-production/blob/master/spa-checklist.md" target="_blank" rel="noopener">Single Page App Checklist</a></li><li>A&amp;B论</li></ul><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><ul><li><a href="https://www.datadoghq.com/blog/monitoring-101-collecting-data/" target="_blank" rel="noopener">Monitoring 101</a></li></ul><h3 id="认识自己"><a href="#认识自己" class="headerlink" title="认识自己"></a>认识自己</h3><p><a href="https://coolshell.cn/articles/20977.html" target="_blank" rel="noopener">酷壳-CoolShell.程序员如何把控自己的职业</a></p><p>Google SRE评分卡</p><blockquote><p>0 – 对于相关的技术领域还不熟悉<br>1 – 可以读懂这个领域的基础知识<br>2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节。</p><p>3 – 基本精通这个技术领域，完全不需要别人的帮助<br>4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作。</p><ul><li>对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识。</li><li>对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。</li></ul><p>5 – 对于该技术领域有非常底层的了解和深入的技能。</p><p>6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构<br>7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作。<br>8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施</p><p>9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法。<br>10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人。</p></blockquote><p>SRE 技能表</p><blockquote><p><em>– TCP/IP Networking (OSI stack, DNS etc)</em><br><em>– Unix/Linux internals</em><br><em>– Unix/Linux Systems administration</em><br><em>– Algorithms and Data Structures</em><br><em>– C/C++</em><br><em>– Python</em><br><em>– Java</em><br><em>– Perl</em><br><em>– Go</em><br><em>– Shell Scripting (sh, Bash, ksh, csh)</em><br><em>– SQL and/or Database Admin</em><br><em>– Scripting language of your choice (not already mentioned) <strong><strong><strong>_</strong></strong></strong></em><br><em>– People Management</em><br><em>– Project Management</em></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://coolshell.cn/" target="_blank" rel="noopener">酷壳-COOLSHELL</a></p><p><a href="https://time.geekbang.org/column/intro/100002201" target="_blank" rel="noopener">极客时间-左耳听风-陈皓</a></p><p><a href="https://docs.oracle.com/javase/tutorial/java/concepts/index.html" target="_blank" rel="noopener">Object-Oriented Programming Concepts</a></p><p><a href="https://www.codeproject.com/Articles/22769/Introduction-to-Object-Oriented-Programming-Concep" target="_blank" rel="noopener">Introduction to Object Oriented Programming Concepts (OOP) and More</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;程序员的自我修养&quot;&gt;&lt;a href=&quot;#程序员的自我修养&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养&quot;&gt;&lt;/a&gt;程序员的自我修养&lt;/h2&gt;&lt;h3 id=&quot;工程师素养&quot;&gt;&lt;a href=&quot;#工程师素养&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="mocker" scheme="http://blog.programer.group/tags/mocker/"/>
    
  </entry>
  
  <entry>
    <title>时间管理</title>
    <link href="http://blog.programer.group/career/2020-07-14-time-manage/"/>
    <id>http://blog.programer.group/career/2020-07-14-time-manage/</id>
    <published>2020-07-03T16:00:00.000Z</published>
    <updated>2021-06-08T15:52:30.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><h3 id="时间管理分两方面"><a href="#时间管理分两方面" class="headerlink" title="时间管理分两方面"></a>时间管理分两方面</h3><ul><li>对于自己要有一个长期目标，将目标分解化为周期性目标to-do。</li><li>对于外部环境，首先要营造一个自己能让自己专注自己问题的环境。这需要你对于同事或者上级或其他部门的同事有良好的组织。主动管理这部分很重要。</li></ul><h3 id="对于时间的利用上，一定要注意投资自己的时间："><a href="#对于时间的利用上，一定要注意投资自己的时间：" class="headerlink" title="对于时间的利用上，一定要注意投资自己的时间："></a>对于时间的利用上，一定要注意投资自己的时间：</h3><ul><li>花时间学习基础知识，花时间读文档。</li><li>花时间在解放自己生产力的事上。</li><li>花时间在让自己成长的事上。</li><li>花时间建立高效的环境上。</li></ul><h3 id="对于习惯："><a href="#对于习惯：" class="headerlink" title="对于习惯："></a>对于习惯：</h3><p><strong><em>好的习惯要坚持。</em></strong><br><strong><em>好的习惯要坚持。</em></strong><br><strong><em>好的习惯要坚持。</em></strong></p><h3 id="每周末复盘"><a href="#每周末复盘" class="headerlink" title="每周末复盘"></a>每周末复盘</h3><ul><li>复盘什么?</li><li>怎么复盘?</li><li>复盘效果与产出?</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://time.geekbang.org/column/intro/100002201" target="_blank" rel="noopener">左耳听风</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间管理&quot;&gt;&lt;a href=&quot;#时间管理&quot; class=&quot;headerlink&quot; title=&quot;时间管理&quot;&gt;&lt;/a&gt;时间管理&lt;/h1&gt;&lt;h3 id=&quot;时间管理分两方面&quot;&gt;&lt;a href=&quot;#时间管理分两方面&quot; class=&quot;headerlink&quot; title=&quot;时
      
    
    </summary>
    
    
      <category term="mocker" scheme="http://blog.programer.group/tags/mocker/"/>
    
  </entry>
  
  <entry>
    <title>Java对象创建</title>
    <link href="http://blog.programer.group/jvm/2020-06-22/"/>
    <id>http://blog.programer.group/jvm/2020-06-22/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-06-25T14:30:12.470Z</updated>
    
    <content type="html"><![CDATA[<p>Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来。虚拟机遇到一个new 指令时，首先将会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过、解析、初始化过。</p><p>类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p><p>虚拟根据堆内存是否规整使用不同的内存分配方式：如果内存是规整的，则仅仅是把指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为“指针碰撞”。如果Java堆中的内存并不是规整的，已使用内存和未使用内存相互交错，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，这种分配方式称为“空闲列表”。</p><p>并发情况下，创建对象并不是线程安全的，针对指针碰撞有两种解决方案，一种时候对分配内存空间的动作同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种方式是把内存分配动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。</p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为0值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象时哪个类的实例、如果才能找到类的元数据信息、对象的hash码、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)中。</p><p>之后执行new指令后会接着执行<init>方法，把对象按照程序员的意愿进行初始化。</init></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来。虚拟机遇到一个new 指令时，首先将会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过、解析、初始化过。&lt;/p&gt;
&lt;p&gt;类加载检查通
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.programer.group/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://blog.programer.group/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java Performance Companion</title>
    <link href="http://blog.programer.group/jvm/2020-05-20-g1/"/>
    <id>http://blog.programer.group/jvm/2020-05-20-g1/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2020-11-14T09:06:18.031Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://www.oreilly.com/library/view/java-performance-companion/9780133796896/" target="_blank" rel="noopener">Charlie H, Monica B, Poonam P, Bengt R. Java Performance Companion</a></p></blockquote><h2 id="G1概览"><a href="#G1概览" class="headerlink" title="G1概览"></a>G1概览</h2><p>G1 GC在回收暂停期间回收其大部分堆region。唯一的例外是多阶段并行标记周期的清理阶段。在清理阶段，如果G1 GC遇到全是垃圾的的region，它可以立即回收这些region并将它们返回到空闲region的列表；因此，释放这些region不必等待下一个垃圾回收 pause。</p><p>G1 GC具有三种主要类型的垃圾回收周期：年轻代的回收周期，多阶段并发标记周期和混合的回收周期。还有一个单线程的回退暂停，称为“完全”垃圾回收 pause，这是G1 GC的故障安全机制，以防GC遇到疏散失败的情况。</p><blockquote><p>疏散失败也被称为升迁失败，空间耗尽甚至空间溢出。失败通常发生在没有更多的可用空间来升级对象时。面对这种情况，所有Java HotSpot VM GC都会尝试扩展其堆。但是，如果堆已经达到最大，则GC会尝试保留成功复制对象的region并更新其引用。对于G1 GC，将无法复制的对象保留在位。然后，所有GC的引用都将自动转发。这些自我转发的引用在垃圾回收周期结束时被删除。</p></blockquote><p>在年轻代回收期间，G1 GC会 pause应用程序线程，以将活动对象从年轻region移动到survivor region，或者将它们提升到old region，或者两者同时进行。对于Mixed GC，G1 GC还将存活对象从最“efficient”的old region移动到free region，这些region成为老年代的一部分。</p><blockquote><p>“ GC efficient”实际上是指要回收的空间与回收该region的GC耗时之比。由于缺乏更好的术语，在本书中，我们将使用堆region排序来确定候选region，计算“ GC efficient”。使用相同术语的原因是，GC efficient评估回收region的成本与回收region的收益。而且，我们在这里所指的“efficient”完全取决于活跃度的计算，因此仅是回收region的成本。例如，与其他耗时更多的old region相比，回收耗时较少的old region被视为efficient高的region。efficient最高的region将是region排序数组中的第一个region。</p></blockquote><h2 id="G1年轻代"><a href="#G1年轻代" class="headerlink" title="G1年轻代"></a>G1年轻代</h2><p>G1 GC是由年轻一代和老一代组成的世代GC。大多数分配，除了少数例外，例如对象太大而无法放入线程的本地分配缓冲区（也称为TLAB），但被认为小于是“庞大”的对象，当然还包括等于“庞大”对象本身（请参见部分中的“ Humongous Regions”部分），将由任意特定线程放入该线程的TLAB。由于拥有的Java线程能够以无锁方式进行分配，因此TLAB可使分配速度更快。这些TLAB来自G1 regions，已成为年轻代的一部分。除非在命令行上明确指定，否则当前的年轻代大小是根据初始和最大的年轻代大小边界计算的（从JDK 8u45开始，默认值为初始年轻代大小的Java堆总数的5％（-XX：G1NewSizePercent ）和Java堆总数的60％（最大年轻代大小）（-XX：G1MaxNewSizePercent）和应用程序的最大 pause时间（-XX：MaxGCPauseMillis）。</p><blockquote><p>如果未在命令行上设置-XX：MaxGCPauseMillis，则G1 GC将选择默认的200ms。如果用户设置-Xmn或相关的年轻代大小调整命令行选项（例如-XX：NewRatio），则G1 GC可能无法基于 pause时间目标来调整年轻代大小，因此应用程序的最大 pause时间可能会变成无意义配置。</p></blockquote><p>根据Java应用程序的对象分配率，根据需要将新的空闲region添加到年轻代中，直到满足所需的年轻代大小为止。堆region大小是在JVM启动时确定的。堆region大小必须为2的幂，范围可以从1MB到32MB。 JVM分为大约2048个region，并相应地设置堆region大小（堆region大小=堆大小/ 2048）。对齐并调整堆region的大小，使其落在1MB至32MB的范围内，边界必须为2的幂。通过使用-XX：G1HeapRegionSize = n设置，可以在命令行上覆盖堆region大小的自适应选择。第3章，“垃圾优先的垃圾回收器性能调整”，包含有关何时覆盖JVM自动大小调整的更多信息。</p><h2 id="年轻代垃圾回收暂停"><a href="#年轻代垃圾回收暂停" class="headerlink" title="年轻代垃圾回收暂停"></a>年轻代垃圾回收暂停</h2><p>年轻的代由指定为eden region的G1 GC region和指定为survivor region G1 GC region 组成。当JVM无法分配到eden region时，即eden满了时，将触发年轻代垃圾回收。然后，GC介入以释放一些空间。年轻代第一次垃圾回收将把所有存活对象从eden region转移到survivor region。这就是所谓的“幸存者副本”。从那时起，任何年轻垃圾回收都将把整个年轻一代（即eden和survivor region）的存活对象复制到新的region，这些region现在是新的survivor region。当年轻代垃圾回收达到一个预定的提升阀值，它们偶尔还会将一些对象提升到老一代之外的地区。这称为“aging”存活对象。将存活对象从年轻代提升到老年代的过程称为“tenuring”对象，因此年龄阈值称为“tenuring阈值”。将对象提升到survivor region或升级到老年代时，发生在Promoting GC线程的本地分配的缓冲区（也称为Promotion Lab，简称PLAB）中。对于survivor和老年代来说，每个GC线程都有PLAB。</p><p>在每个年轻代垃圾回收 pause期间，G1 GC根据执行当前操作所需的总时间来计算要对当前年轻代大小执行的扩展或收缩（即，G1 GC决定添加或删除free region） 回收；Remembered Sets或RSets的大小（有关详细信息，请参阅本章后面的“Remembered Sets及其重要性”部分）；当前，最大和最小的年轻代容量；和 pause时间目标。因此，在垃圾回收 pause结束时调整了年轻代的大小。可以通过查看-XX：+ PrintGCDetails的输出来观察和计算年轻代的上一个和下一个大小。让我们看一个例子。 （请注意，在整本书中，所有输出行都进行了包装，以适合本书的页面。）</p><h2 id="对象老化与老年代"><a href="#对象老化与老年代" class="headerlink" title="对象老化与老年代"></a>对象老化与老年代</h2><p>正如上一节“年轻代垃圾回收 pause”中简要介绍的那样，在每个年轻代垃圾回收期间，G1 GC都会维护每个对象的年龄字段。当前年轻代 回收的任何特定对象幸存的总数称为该对象的“年龄”。 GC在称为“age table”的表中维护年龄信息以及已提升为该年龄的对象的总大小。根据age table，survivor region对象存活比率，幸存者年龄阀值（由-XX：TargetSurvivorRatio（默认值= 50）确定）和-XX：MaxTenuringThreshold（默认值= 15），JVM会为所有存活对象自适应地设置最大tenuring阈值。一旦这些对象超过了最大tenuring阈值，它们就会被提升/tenured到老一代region。当这些保留对象在老年代中死亡时，可以通过混合 回收或在清理过程中释放它们的空间（但前提是可以回收整个region），作为最后的选择，或者在完全垃圾 回收时 回收。</p><h2 id="Humongous-Regions"><a href="#Humongous-Regions" class="headerlink" title="Humongous Regions"></a>Humongous Regions</h2><p>对于G1 GC， 回收单位是一个region。因此，堆region大小（-XX：G1HeapRegionSize）是重要的参数，因为它确定对象可以放入region的大小。堆region的大小还确定了哪些对象被称为“巨大”。巨大的对象是非常大的物体，占G1 GC region的50％或更多。这样的对象并没有遵循通常的快速分配方式，而是直接从老年代中分配出来。标记为Humongous region的region。</p><p>在JDK 8u40之前，如果任何巨大的region都是完全空闲的，则只能在并发 回收周期的清理 pause期间 回收它。为了优化短期生存的大型对象的 回收，JDK 8u40进行了值得注意的更改，使得如果确定大型region没有传入的引用，则可以在年轻代的 回收期间将其回收并返回到空闲region列表中。完整的垃圾 回收 pause还将 回收完全空闲的大型region。</p><blockquote><p>这里需要强调一个重要的潜在问题或困惑。假设当前的G1region大小为2MB。并说一个字节数组的长度对齐为1MB。此字节数组仍将被认为是一个庞大的对象，因此需要进行分配，因为1MB的数组长度不包括该数组的对象标头大小。</p></blockquote><h2 id="混合垃圾回收暂停"><a href="#混合垃圾回收暂停" class="headerlink" title="混合垃圾回收暂停"></a>混合垃圾回收暂停</h2><p>随着越来越多的对象被提升到老年代中，或者当庞大的对象被分配到庞大的region中时，老年代的占用率因此增加了Java堆的总占用量。为了避免堆空间用完，JVM进程需要启动垃圾回收，该垃圾回收不仅覆盖年轻代的region，而且还向混合region添加一些old region。请参阅上一节中关于hummongousregion的内容，以了解有关hummongous对象的特殊处理（分配和回收）的信息。<br>为了识别出垃圾最多的old region，G1 GC启动了一个并发标记周期，这有助于标记根并最终标识所有存活对象，并计算每个region的活动因子。在分配和提升的速率以及此标记周期的触发之间必须达到微妙的平衡，以使JVM进程不会耗尽Java堆空间。因此，在JVM进程开始时设置了占用阈值。至少在JDK 8u45之前，此占用阈值是不自适应的，可以通过命令行选项-XX：InitiatingHeapOccupancyPercent（我称其为IHOP）来设置。</p><blockquote><p>在G1中，IHOP阈值默认为Java总堆的45％。重要的是要注意，此堆占用百分比适用于整个Java堆，这与CMS GC所使用的堆占用命令行选项不同，后者仅适用于旧版本。在G1 GC中，没有物理上分离的老年代-只有一个空闲region池，可以将其分配为eden，survivor，老年代或humongous。同样，分配的region数量（例如eden）可以随时间变化。因此，老年代的百分比并没有多大意义。</p></blockquote><p>-当老一代占用率达到（或超过）IHOP阈值时，将启动并发标记周期。在标记即将结束时，G1 GC计算每个旧region的活动物体数量。另外，在清理阶段，G1 GC根据旧region的“ GC效率”对旧region进行排名。现在可以进行混合 回收了！在混合 回收 pause期间，G1 GC不仅 回收年轻一代中的所有region，而且还 回收一些候选的旧region，以便回收垃圾最多的旧region。</p><blockquote><p>比较CMS和G1日志时要记住的重要一点是，G1中的多阶段并发周期比CMS中的多阶段并发周期要少。</p></blockquote><p>单个混合垃圾回收器类似于年轻代垃圾回收期 pause，并通过复制实现存活对象的压缩。唯一的区别是，在混合垃圾回收期间，垃圾回收还包含一些efficient的old region。根据一些参数（如本章稍后所述），可能会有一个以上的mixed Collection pause。这称为“mixed Collection周期”。只有在超过标记/ IHOP阈值之后以及完成并行标记周期之后，才可能发生mixed Collection周期。<br>有两个重要的参数可帮助确定混合回收周期中混合回收的次数和什么时候结束mixed gc：-XX：G1MixedGCCountTarget和-XX：G1HeapWastePercent。<br>-XX：G1MixedGCCountTarget（默认值为8（JDK 8u45））是混合GC计数目标参数，其目的是对标记周期完成后将出现的mixed Collection的region数量进行物理限制。 G1 GC将可回收的候选old region总数除以-XX：G1MixedGCCountTarget，并将其设置为每个mixed Collection pause要回收的最小old region数。这可以表示为以下等式：<br>每个mixed Collection pause 回收的最小old CSet = 在一个mixed Collection周期中所有的候选old region总数/ G1MixedGCCountTarget。<br>-XX：G1HeapWastePercent缺省为Java总堆的5％（JDK 8u45），它是控制mixed Collection周期中要回收的旧region数量的重要参数。对于每个mixed Collection pause，G1 GC都会根据可以回收的死对象空间来标识可回收堆的数量。一旦G1 GC达到此堆G1HeapWastePercent，G1 GC就会停止启动mixed Collection pause，从而达到混合 回收周期的终点。设置堆G1HeapWastePercent基本上可以帮助限制你设置允许浪费的堆大小，以有效地加快mixed Collection周期。<br>因此，每个mixed Collection周期的mixed Collection数量可以通过每个mixed Collection pause回收的最小 old CSet和G1HeapWastePercent来控制。</p><h2 id="Collection-Sets-与-它的重要性"><a href="#Collection-Sets-与-它的重要性" class="headerlink" title="Collection Sets 与 它的重要性"></a>Collection Sets 与 它的重要性</h2><p>在任何垃圾回收pause期间，将释放CSet中的所有region。 CSet是在垃圾回收pause期间要回收的一组region。这些候选region中的所有存活对象将在回收过程中复制转移，这些region将返回到空闲region列表中。在年轻代回收期间，CSet只能包含要回收的年轻代region。另一方面，混合垃圾回收不仅会在其CSet中添加所有年轻代region，还会添加一些old regions（基于它们的GC效率）。<br>有两个重要的参数有助于选择混合垃圾回收的CSet的候选old region：-XX：G1MixedGCLiveThresholdPercent和-XX：G1OldCSetRegionThresholdPercent。<br><strong><em>-XX：G1MixedGCLiveThresholdPercent（默认值为G1 GCregion的85％（JDK 8u45））是活动阈值，是一个设置限制，用于从混合垃圾回收的CSet中排除最耗时的old region。 G1 GC设置了一个限制，以使任何低于此活动性阈值的old region都包含在混合集合的CSet中。</em></strong><br>-XX：G1OldCSetRegionThresholdPercent，默认为Java堆总数的10％（JDK 8u45），它设置了每个混合垃圾回收pause可回收的old region数的最大限制。该阈值取决于JVM进程可用的Java总堆，并表示为Java总堆的百分比。</p><h2 id="Remembered-Sets与它的重要性"><a href="#Remembered-Sets与它的重要性" class="headerlink" title="Remembered Sets与它的重要性"></a>Remembered Sets与它的重要性</h2><p>分代垃圾回收器根据对象的使用期限将对象隔离在堆中的不同region中。堆中的这些不同region称为世代。然后，分代垃圾回收器可以将其大部分垃圾回收工作集中在最近分配的对象上，因为它希望发现大多数对象早早的死掉。堆中的这些世代可以独立回收。独立回收有助于降低响应时间，因为GC不必扫描整个堆，而且（例如，在复制世代回收器的情况下）不必来回复制较旧的长期存在的对象，从而减少了复制和引用更新的开销。</p><p> 为了促进垃圾回收的独立性，许多垃圾回收器为它们的代维护RSets。 RSet是一种数据结构，可帮助维护和跟踪对其自身的引用（在G1 GC的情况下是一个region），从而无需扫描整个堆以获取此类信息。当G1 GC执行STW垃圾回收（年轻或混合）时，它将扫描其CSet中包含的region的RSet。一旦移动了该region中的存活对象，它们的传入引用就会更新。<br>使用G1 GC，在任何年轻或混合垃圾回收期间，始终会完整垃圾回收年轻代，从而无需跟踪其包含对象驻留在年轻代中的引用。这减少了RSet开销。因此，G1 GC仅需要在以下两种情况下维护RSets：</p><ul><li>老年代到年轻代的引用-G1 GC维护从老年代region到年轻代region的指针。年轻代region被称为“属于” RSet，因此该region被称为“拥有” region 的Rset。</li><li>老年代到老年代的引用-来自老年代中不同region的指针将保留在“own”老年代region的RSet中。</li></ul><p><img src="/media/article/g1-rset.png" alt="g1-rset"></p><p> 在图2.3中，我们可以看到一个young region（x region）和两个old region（y region和z region）。region x具有来自region z的传入引用。在region x的RSet中记录了此参考。我们还观察到，region z有两个传入引用，一个来自region x，另一个来自region y。region Z的RSet只需要记下来自region y的传入参考，而不必记住来自region x的参考，因为如前所述，年轻代总是被完整地垃圾回收。最后，对于region y，我们看到来自region x的传入引用，这在region y的RSet中未注明，因为region x是young region。<br>如图2.3所示，每个region只有一个RSet。根据应用程序的不同，可能是某个特定region（因此它的RSet）是“popular”，因此在同一region甚至在同一位置可能会有许多更新。这在Java应用程序中并不罕见。<br>G1 GC具有处理此类popular需求的方式；它通过更改RSets的密度来实现。 RSets的密度遵循三个级别的粒度，即稀疏，细粒度和粗粒度。对于一般region，RSet可能会被粗化以容纳来自其他各个region的指针。这将反映在这些region的RSet扫描时间中。 这三种粒度级别中的每一种都有一个针对任何特定RSet的PRT(per-region-table, PRT)抽象容器。由于G1 GC region在内部进一步划分为块，在G1 GC region级别中，可实现的最低粒度是512字节堆块，称为“card”（请参见图2.4）。全局卡表维护所有卡。</p><p>当指针引用RSet的所属region时，在PRT中会记录包含该指针的card。稀疏的PRT本质上是那些card索引的哈希表。这种简单的实现可加快垃圾回收器的扫描速度。另一方面，细粒度的PRT和粗粒度的bit map以不同的方式处理。对于细粒度的PRT，其开放哈希表中的每个entry都对应一个region（具有对所属region的引用），该region中的卡片索引存储在bit map中。细粒度的PRT有一个最大限制，当超过该值时，会在粗粒度bit map中设置一个位（称为“粗粒度位”）。设置了粗粒度位后，将删除细粒度PRT中的相应entry。粗粒度的bit map就是一个bit map，每个region有一个位，这样一个设置位就意味着相应的region可能包含对所属region的引用。因此，必须扫描与设置位关联的整个region以找到引用。因此，将Remembered set粗化为粗粒度bit map对于扫描垃圾回收器而言是最慢的。</p><p>在任何回收周期中，当扫描Remembered set并因此扫描PRT中的card时，G1 GC都会在全局卡表中标记相应的entry，以避免重新扫描该card。在回收周期结束时，此卡表被清除；这在GC输出（用-XX：+ PrintGCDetails打印）中显示为Clear CT，并且紧接在GC线程完成的并行工作之后（例如，外部根扫描，更新和扫描Remembered set，对象复制，和终止协议）。还有其他顺序活动，例如选择和释放CSet以及引用处理和排队。这是使用JDK 8u45构建的-XX：+ UseG1GC -XX：PrintGCDetails -XX：PrintGCTimeStamps的示例输出。 RSet和card表活动突出显示。</p><h2 id="并发优化线程与屏障"><a href="#并发优化线程与屏障" class="headerlink" title="并发优化线程与屏障"></a>并发优化线程与屏障</h2><p>高级的RSet结构以写入障碍和并发“细化”线程的形式带来了其自身的维护成本。<br>屏障是在托管运行中执行某些语句时执行的native代码段。垃圾回收算法中使用屏障的方法已经很成熟，由于本机指令路径长度增加，执行屏障代码的相关成本也相应的增加。<br>OpenJDK HotSpot的Parallel Old和CMS GC使用写屏障，该屏障在HotSpot JVM执行对象引用写操作时执行：</p><p><code>object.field = some_other_object;</code></p><p>屏障更新了卡片表类型的结构[2]，以跟踪跨代引用。在minor垃圾回收期间将扫描卡表。写屏障算法基于UrsHölzle的快速写屏障[3]，可将屏障开销减少中只有两条额外的编译后的代码指令。<br>G1 GC采用pre-write和post-write屏障。前者在实际应用程序分配之前执行，并在并发标记部分中进行了详细介绍，而后者在分配之后执行，并在此处进行了详细描述。</p><p>每当引用更新时，G1 GC都会发出写屏障。例如，考虑以下伪代码中的更新：</p><p><code>object.field = some_other_object;</code></p><p>该分配将触发屏障代码。由于屏障是在写入任何引用之后发出的，因此称为“post-write”屏障。写障碍指令顺序会变得非常昂贵，并且应用程序的吞吐量将与屏障代码的复杂性成比例地下降；因此，由于需要在拥有region的RSet中捕获跨region引用更新，因此G1 GC会进行最少的工作量来确定引用更新是否为跨region更新。对于G1 GC，屏障代码包括一种过滤技术，该过滤技术在“Older-First Garbage Collection in Practice”中[4]进行了简要讨论，该技术涉及一个简单的检查，当更新在同一region时，该检查的结果为零。以下伪代码说明了G1 GC的写障碍：</p><p><code>(&amp;object.field XOR &amp;some_other_object) &gt;&gt; RegionSize</code></p><p>每当进行跨region更新时，G1 GC都会将相应的card排入称为“更新日志缓冲区”或“dirty card队列”的缓冲区中。在我们的更新示例中，包含card的对象记录在更新日志缓冲区中。</p><p>并发优化线程是专用于通过以下方式维护线程的线程：通过扫描已填充日志缓冲区中的已记录卡，然后为那些region更新remembered sets来维护remembered sets。优化线程的最大数量由–XX：G1ConcRefinementThreads确定。从JDK 8u45开始，如果未在命令行上设置–XX：G1ConcRefinementThreads，则按照人体工程学将其设置为与–XX：ParallelGCThreads相同。</p><p>一旦更新日志缓冲区达到其容纳容量，它将被淘汰，并分配一个新的日志缓冲区。然后，card入队在此新缓冲区中发生。retired的缓冲区放置在全局列表中。一旦优化线程在全局列表中找到entry，它们就会开始并发处理retired的缓冲区。优化线程始终处于活动状态，尽管最初只有几个可用。 G1 GC以分层的方式处理并发优化线程的部署，添加了更多线程以跟上已填充的日志缓冲区的数量。激活阈值由以下标志设置：-XX：G1ConcRefinementGreenZone，-XX：G1ConcRefinementYellowZone和-XX：G1ConcRefinementRedZone。如果并发的优化线程无法跟上已填充缓冲区的数量，请向mutator线程寻求帮助。此时，mutator线程将停止其工作，并帮助并发的优化线程完成对已填充日志缓冲区的处理。 GC术语中的mutator线程是Java应用程序线程。因此，当并发​​优化​​线程无法满足已填充缓冲区的数量时，Java应用程序将被暂停，直到处理已填充日志缓冲区为止。因此，应采取措施避免这种情况。</p><blockquote><p>不应要求用户手动调整三个优化region中的任何一个。有时很少需要调整–XX：G1ConcRefinementThreads或–XX：ParallelGCThreads。</p></blockquote><h2 id="G1-GC的并发标记"><a href="#G1-GC的并发标记" class="headerlink" title="G1 GC的并发标记"></a>G1 GC的并发标记</h2><p>随着G1 GC region的引入和每个region的活跃度统计，很明显，需要一种增量且完整的并发标记算法。 Taiichi Yuasa提出了一种增量标记和扫描GC的算法，其中他采用了“snapshot-at-the-beginning”（SATB）标记算法[5]。</p><p>Yuasa的SATB标记优化集中在mark-sweep GC的并发标记阶段。 SATB标记算法非常适合G1 GC的region化堆结构，并解决了有关HotSpot JVM的CMS GC算法的主要抱怨，即潜在的长时间注释暂停。</p><p>G1 GC建立了标记阈值，该阈值表示为Java总堆的百分比，默认为45％。超过此阈值时，可以使用-XX：InitiatingHeapOccupancyPercent（IHOP）选项在命令行中设置该阈值，将启动并发标记周期。标记任务被划分为多个块，以使大多数工作在mutator线程处于活动状态时同时完成。目标是在整个Java堆达到其最大容量之前对其进行标记。</p><p>SATB算法仅创建一个对象图，该对象图是堆的逻辑“snapshot”。 SATB标记可确保快照将识别并发标记阶段开始时存在的所有垃圾对象。<strong><em>在并发标记阶段分配的对象将被视为存活对象，但不会跟踪它们，从而减少了标记开销。</em></strong> 该技术确保在标记阶段开始时仍处于活动状态的所有存活对象被标记和跟踪，并且在标记周期内由并发的mutator线程进行的任何新分配都被标记为存活，因此不会被收集。</p><p>标记数据结构仅包含两个bitmap：previous和next。previous bitmap保存最后的完整标记信息。当前标记周期创建并更新next bitmap。随着时间的流逝，先前的标记信息变得越来越陈旧。最终，next bitmap将在标记周期完成时替换previous bitmap。</p><p>对应于next bitmap和previous bitmap，每个G1 GC堆region都有两个标记开始（TAMS）字段，分别称为previous TAMS（或PTAMS）和 next TAMS（或NTAMS）。 TAMS字段可用于标识在标记周期内分配的对象。</p><p><img src="/media/article/g1-marking.png" alt="g1-marking"></p><p>在标记周期开始时，NTAMS字段设置为每个region的当前顶部，如图2.5所示。自标记周期开始以来已分配（或已死亡）的对象位于相应的TAMS值之上，并被认为是隐式存在的。 TAMS下的存活对象需要明确标记。让我们来看一个例子：</p><p><img src="/media/article/g1-marking2.png" alt="g1-marking2"></p><p>在图2.6中，我们看到了并发标记，如图所示，带有“previous bitmap”，“next bitmap”，“ PTAMS”，“ NTAMS”和“Top”。 PTAMS与堆的Bottom（在图中表示为“Bottom”）之间的活动对象均已标记并保留在先前的位图中，如图2.7所示。如图2.8所示，PTAMS与堆区顶部之间的所有对象都是隐式活动的（相对于以前的位图）。这些包括在并发标记期间分配的对象，因此被分配在NTAMS上方，并且相对于next bitmap隐式存在，如图2.10所示。标记暂停后，PTAMS上方和NTAMS下方的所有活动对象都被完全标记，如图2.9所示。如前所述，在并发标记周期中分配的对象将分配给NTAMS之上，并被视为相对于next bitmap隐式存在（请参见图2.10）。</p><p><img src="/media/article/g1-marking3.png" alt="g1-marking3"></p><h2 id="并发标记阶段"><a href="#并发标记阶段" class="headerlink" title="并发标记阶段"></a>并发标记阶段</h2><p>标记任务块几乎同时执行。在短暂的STW期间，一些任务已完成。现在让我们谈谈这些任务的重要性。</p><h3 id="Initial-Mark-Stop-the-World-Event"><a href="#Initial-Mark-Stop-the-World-Event" class="headerlink" title="Initial Mark(Stop the World Event)"></a>Initial Mark(Stop the World Event)</h3><p>在初始标记期间，mutator线程将停止，以便于标记Java堆中所有可由GC Roots直接访问的对象（也称为根对象）。</p><blockquote><p>根对象是可以从Java堆外部访问的对象。本机堆栈对象和JNI（Java本机接口）本地或全局对象是一些示例。</p></blockquote><p>由于mutator线程已停止，因此初始标记阶段是“STW”阶段。另外，由于年轻代也可以追溯到roots，因此可以与常规的年轻代同时进行初始标记（方便且省时）。这也称为“piggybacking”。在初始标记暂停期间，每个region的NTAMS值将设置为该region的当前Top（请参见图2.5）。重复进行此操作，直到处理完堆的所有region为止。</p><p><img src="/media/article/g1-marking.png" alt="g1-marking"></p><h3 id="Root-region-Scanning"><a href="#Root-region-Scanning" class="headerlink" title="Root region Scanning"></a>Root region Scanning</h3><p>在为每个区域设置TAMS之后，重新启动mutator线程，并且G1 GC现在与mutator线程并发工作。为确保标记算法的正确性，在Initial-Mark年轻代垃圾回收期间需要扫描复制到survivor region的对象，并将其视为marking roots。因此，G1 GC开始扫描survivor region。从survivor region引用的任何对象都被标记。因此，将以此方式扫描的survivor region称为“root regions”。<br>root region扫描阶段必须在下一个垃圾回收暂停之前完成，因为从survivor region引用的所有对象都必须被识别并标记，然后才能扫描整个堆中的活动对象。</p><h3 id="Concurrent-Marking"><a href="#Concurrent-Marking" class="headerlink" title="Concurrent Marking"></a>Concurrent Marking</h3><p>并发标记阶段是并发和多线程的。设置要使用的并发线程数的命令行选项是-XX：ConcGCThreads。默认情况下，G1 GC将线程总数设置为并行线程(-XX:ParallelGCThreads)的四分之一，并行GC线程是在VM启动时由JVM计算的。并发线程一次扫描一个region，并使用“finger”指针优化来标识该region。这种“finger”指针优化类似于CMS GC的“finger”优化，可以在[2]中进行研究。<br>如“ RSets及其重要性”部分所述，G1 GC还使用pre-write屏障来执行SATB并发标记算法所需的操作。当应用程序更改其对象图时，在标记开始时可到达的对象和快照的一部分可能会被<strong>标记线程发现和跟踪之前</strong>被覆盖。因此，SATB标记保证要求修改变量线程在SATB日志队列/缓冲区中记录需要修改的指针的先前值。这被称为“并发标记/ SATB pre-write屏障”，因为屏障代码是在更新之前执行的。pre-write屏障可以记录对象引用字段的previous value，以便并发标记可以通过值被覆盖的对象进行标记。</p><p>marking_is_active条件是对thread-local标志的简单检查，该标志在 initial-mark pause期间在标记开始时设置为true。通过此检查来保护其余的屏障前代码，可减少标记未激活时执行屏障代码其余部分的开销。由于该标志是线程本地的，并且其值可能会多次加载，因此任何单个检查都可能会命中缓存，从而进一步减少了屏障的开销。<br>satb_enqueue（）首先尝试将先前的值放入线程本地缓冲区（称为SATB缓冲区）中。 SATB缓冲区的初始大小为256个entries，并且每个应用程序线程都有一个SATB缓冲区。如果没有空间将pre_val放置在SATB缓冲区中，则会调用JVM runtime。该线程的当前SATB缓冲区将retired，并放置在已填充SATB缓冲区的全局列表中，为该线程分配一个新的SATB缓冲区，并记录pre_val。并发标记线程的工作是定期检查和处理已填充的缓冲区，以启用对已记录对象的标记。<br>通过遍历每个缓冲区并通过设置来标记每个记录的对象，从全局列表中处理（在标记阶段）已填充的SATB缓冲区标记bitmap中的相应位（如果对象位于finger后面，则将对象推到本地标记堆栈上）。标记然后遍历标记bitmap的一部分中的设置位，跟踪标记对象的字段引用，在标记bitmap中设置更多位，并根据需要推送对象。<br>实时数据记帐在标记操作中进行。因此，每次标记一个对象时，该对象也会被计数（即，其字节将添加到该region的总数中）。仅标记和计数NTAMS以下的对象。在此阶段结束时，将清除next标记bitmap，以便在下一个标记周期开始时准备就绪。这是与mutator线程同时完成的。</p><blockquote><p>JDK 8u40引入了一个新的命令行选项-XX：+ ClassUnloadingWithConcurrentMark，默认情况下，它启用带有并发标记的类卸载。因此，并发标记可以跟踪类并计算其活跃度。在备注阶段，可以卸载不可达的类。</p></blockquote><p><img src="/media/article/concurrent-marking.png" alt=""></p><h3 id="Remark-Stop-the-World-Event"><a href="#Remark-Stop-the-World-Event" class="headerlink" title="Remark(Stop the World Event)"></a>Remark(Stop the World Event)</h3><p>Remark阶段是最后的标记阶段。在这个STW的阶段，G1 GC完全耗尽了所有剩余的SATB日志缓冲区并处理了所有更新。 G1 GC还可以遍历所有未访问的活动对象。从JDK 8u40开始，备注阶段是STW，因为更改程序线程负责更新SATB日志缓冲区，并因此“own”了这些缓冲区。因此，最终的STW是必要的，以覆盖所有实时数据并安全地完成实时数据记帐。为了减少在此暂停中花费的时间，使用多个GC线程并行处理日志缓冲区。 -XX：ParallelGCThreads帮助设置任何GC暂停期间可用的GC线程数。引用处理也是备注阶段的一部分。</p><blockquote><p>任何大量使用引用对象（弱引用，软引用，虚引用或强引用）的应用程序都可能由于引用处理开销而导致较高的remark时间。我们将在第3章中了解更多信息。</p></blockquote><p><img src="/media/article/remark-phase.png" alt=""></p><h3 id="Cleanup-Stop-the-World-Event-and-Concurrent"><a href="#Cleanup-Stop-the-World-Event-and-Concurrent" class="headerlink" title="Cleanup(Stop the World Event and Concurrent)"></a>Cleanup(Stop the World Event and Concurrent)</h3><p>在清理暂停期间，两个标记bitmap会互换角色：next bitmap成为previous bitmap（假定当前标记周期已完成，并且previous bitmap现在具有一致的标记信息），并且previous bitmap将成为next bitmap（将在下一个循环中用作当前标记bitmap）。同样，PTAMS和NTAMS也会互换角色。清理暂停的三个主要作用是识别完全空闲的region，对堆region进行排序以识别用于混合垃圾回收的有效旧region以及RSet清理。当前的启发式排名根据活动性对region进行排序（具有大量活动对象的region的收集确实非常耗时，因为复制是一项耗时的操作）和Remembered Set的大小（同样，具有大Remembered Set的region因region‘s popularity 回收而非常耗时）。目标是首先回收/疏散被认为耗时较少（存活较少，较低的popular）的候选region。<br>识别每个region中存活对象的一个​​优势是，遇到完全空闲的region（即没有存活对象的region）时，可以不必等待回收（混合）垃圾器回收暂停，清除其Remembered Set，并且可以立即回收该region并将其返回到空闲region列表中，而不是将其放置在GC-efficient的已排序数组中。 RSet清理还有助于检测过时的引用。例如，如果标记发现某个特定card上的所有对象均已失效，则该特定card的entry将从“owning” RSet中清除。</p><p><img src="/media/article/clean-up.png" alt=""></p><h2 id="Copying-Stop-the-World-Event"><a href="#Copying-Stop-the-World-Event" class="headerlink" title="(*) Copying(Stop the World Event)"></a>(*) Copying(Stop the World Event)</h2><p>These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as [GC pause (young)]. Or both young and old generation regions which are logged as [GC Pause (mixed)].</p><p>疏散或者复制存活对象到新的未使用regions。这个可以发生在年轻代regions，被标记为<code>[GC pause(young)]</code>。或者年轻代和老年代regions都发生，被标记为<code>[GC Pause (mixed)]</code>。</p><p><img src="/media/article/copying-phase.png" alt=""></p><h2 id="疏散失败和全部回收"><a href="#疏散失败和全部回收" class="headerlink" title="疏散失败和全部回收"></a>疏散失败和全部回收</h2><p>有时，G1 GC在尝试从young region复制存活对象时或在从old region撤离期间尝试复制存活对象时找不到空闲region。此类故障在GC日志中报告为空间耗尽故障，并且故障持续时间在日志中进一步显示为疏散故障时间（在以下示例中为331.5ms）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111.912: [GC pause (G1 Evacuation Pause) (young) (to-space exhausted), 0.6773162 secs]</span><br><span class="line">&lt;snip&gt;</span><br><span class="line">[Evacuation Failure: 331.5 ms]</span><br></pre></td></tr></table></figure><p>有时，大型分配可能无法在老年代中找到用于分配大型对象的连续region。<br>此时，G1 GC将尝试增加其对Java堆的使用。如果无法成功扩展Java堆空间，则G1 GC触发其故障保护机制，并退回到serial（单线程）full gc。</p><p>在full gc期间，单个线程在整个堆上运行，并做标记，清除和压缩构成世代的所有region（昂贵或其他）。回收完成之后，生成的堆现在由存活对象组成，并且所有世代都已完全压缩。</p><blockquote><p>在JDK 8u40之前，只能在full gc中卸载类。</p></blockquote><p>serial full gc的单线程性质以及该集合跨越整个堆的事实会使它成为非常耗时的垃圾回收操作，尤其是在堆大小相当大的情况下。因此，强烈建议在这样的情况下进行非常规的调优测试，在这种情况下，经常发生full gc。</p><p>选项和默认值：<br>-XX：+ UseG1GC    使用G1垃圾回收器<br>-XX：MaxGCPauseMillis = n    设置最大GC pause时间的目标。这是一个软目标，JVM将尽最大的努力来实现它。<br>-XX：InitiatingHeapOccupancyPercent = n    启动并发GC周期的（整个）堆占用百分比。GC使用它来触发GC，该GC基于整个堆的占用来触发并发GC周期，而不仅仅是世代之一（例如，G1）。值为0表示“进行恒定的GC循环”。默认值为45。<br>-XX：NewRatio = n    年轻代/老年代内存占比。预设值为2。<br>-XX：SurvivorRatio = n     eden/survior空间大小之比。预设值为8。<br>-XX：MaxTenuringThreshold = n 年轻代升级阀值。预设值为15。<br>-XX：ParallelGCThreads = n    设置在垃圾回收器的并行阶段使用的线程数。缺省值随运行JVM的平台而异。<br>-XX：ConcGCThreads = n    并发垃圾 回收器将使用的线程数。缺省值随运行JVM的平台而异。<br>-XX：G1ReservePercent = n    保留空间，虚拟机至少保证晋升时有这么多的空间可以使用，默认10%<br>-XX：G1HeapregionSize = n    使用G1，Java堆可细分为大小一致的region。这将设置各个细分的大小。该参数的默认值是根据堆大小按人机工程学确定的。最小值为1Mb，最大值为32Mb。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a><br><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a><br><a href="https://www.jianshu.com/p/aef0f4765098" target="_blank" rel="noopener">G1垃圾回收器详解  </a><br><a href="https://cloud.tencent.com/developer/article/1459638" target="_blank" rel="noopener">详解 JVM Garbage First(G1) 垃圾 回收器</a><br><a href="">Charlie H, Monica B, Poonam P, Bengt R. Java Performance Companion</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://www.oreilly.com/library/view/java-performance-companion/9780133796896/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://blog.programer.group/tags/JVM/"/>
    
      <category term="翻译" scheme="http://blog.programer.group/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 学习随笔</title>
    <link href="http://blog.programer.group/middleware/2020-02-21-rabbitmq/"/>
    <id>http://blog.programer.group/middleware/2020-02-21-rabbitmq/</id>
    <published>2020-02-20T16:00:00.000Z</published>
    <updated>2020-05-21T14:33:44.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-关于RabbitMQ的Connection"><a href="#1-关于RabbitMQ的Connection" class="headerlink" title="1. 关于RabbitMQ的Connection"></a>1. 关于RabbitMQ的Connection</h2><p>Connection可以用来创建多个Channel实例，但是Channel实例不能在线程间共享。某些情况下Channel的操作可以并发运行，但是在其他情况下会导致网络上出现错误的通信帧交错，同时也会影响发送方确认(publisher confirm)机制的运行，所以多线程间共享Channel是非线程安全的。</p><p>应用程序应该为每一个线程开辟一个Channel。</p><h2 id="2-慎用方法"><a href="#2-慎用方法" class="headerlink" title="2. 慎用方法"></a>2. 慎用方法</h2><ul><li>isOpen，这个方法返回值依赖shutdownCause，会引起锁竞争。</li></ul><h2 id="3-交换器声明参数说明"><a href="#3-交换器声明参数说明" class="headerlink" title="3. 交换器声明参数说明"></a>3. 交换器声明参数说明</h2><p><code>exchangeDeclare(String exchange, String type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; args) throws IOException;</code></p><ul><li>exchange: 交换器名称。</li><li>type: 交换器名称，四种: direct、fanout、topic、headers。</li><li>durable: 设置是否持久化。durable设置为true表示持久化，反之是非持久化。</li><li>autoDelete: 设置是否自动删除，设置为true表示自动删除，自动删除的前提是: 至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。</li><li>internal: 设置是否是内置的，设置为true表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到这个交换器这种方式。</li><li>argument: 其他的一些结构化参数。alternate-exchange。</li></ul><p>其他重载方法参数说明：</p><p><code>exchangeDeclareNoWait(String exchange, String type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; args) throws IOException;</code></p><p>nowait 参数指AMQP中定义队列不需要服务器返回，返回值为void。<strong><em>不建议使用</em></strong></p><p><code>exechangeDeclarePassive(String name)</code>这个方法主要用来检测交换器是否存在，存在正常返回，不存在抛出异常。</p><p>ifUnused: 设置是否在交换器没有被使用情况下删除。否则任何情况下都可以删除。</p><h2 id="4-队列参数说明"><a href="#4-队列参数说明" class="headerlink" title="4. 队列参数说明"></a>4. 队列参数说明</h2><p><code>queueDeclare(String queue, boolean durable, boolean execlusive, boolean autoDelete, Map&lt;String, Object arguments) throws IOException;</code></p><ul><li>queue: 队列名称。</li><li>durable: 设置是否持久化。为true则设置队列持久化。</li><li>exclusive: 设置是否排他。如果设置为排他，则仅对首次声明它的连接可见，并在连接断开时（即使设置了持久化）自动删除。排他队列是基于连接(Connection)可见的，同一个连接断开时自动删除。排他是基于连接的，同一个连接的不同信道是可以同时访问同一连接创建的排他队列。</li><li>autoDelete: 设置是否自动删除，自动删除的前提是: 至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。</li><li>arguments: 设置队列的其他参数。x-message-ttl、x-expires、x-max-length、x-max-length-bytes、x-dead-letter-exchange、x-dead-letter-routing-key、x-max-priority等。</li></ul><p>消费者在信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，将信道设置为“传输”。</p><p>ifEmpty: 设置为true,表示在队列为空的情况下才能删除。</p><h2 id="5-发送消息参数说明"><a href="#5-发送消息参数说明" class="headerlink" title="5. 发送消息参数说明"></a>5. 发送消息参数说明</h2><p><code>void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException;</code></p><ul><li>exchange: 交换器名称，如果设置为空，则消息会发送到默认交换器中。</li><li>routingKey: 路由健， 交换器根据路由健将消息存储到相应的队列中。</li><li>props: 消息的基本属性集: 其中包含属性成员，分别有contentType、contentEncoding、headers(Map&lt;String, Object&gt;)、deliverMode、priority、correlationId、replyTo、expriation、messageId、timestamp、type、userId、appId、clusterId。</li><li>byte[] body: 消息体。</li><li>mandatory: 设置为true时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ会调用Basic.return命令将消息返回给生产者。否则消息直接被丢弃。</li><li>immediate: 设置为true时， 如果交换器在将消息路由到队列都没有消费者时，该消息会通过Basic.Return返回至生产者。</li></ul><h2 id="6-使用mandatory参数时如何获取没有被正确路由到合适队列的消息"><a href="#6-使用mandatory参数时如何获取没有被正确路由到合适队列的消息" class="headerlink" title="6. 使用mandatory参数时如何获取没有被正确路由到合适队列的消息"></a>6. 使用mandatory参数时如何获取没有被正确路由到合适队列的消息</h2><p>可以通过调用channel.addReturnListener来添加ReturnListener监听器实现。</p><h2 id="7-消费消息参数说明"><a href="#7-消费消息参数说明" class="headerlink" title="7. 消费消息参数说明"></a>7. 消费消息参数说明</h2><p><code>String basicConsume(String queue, boolean actoAck, String consumerTag, boolean noLocal, boolean exclusive, Map&lt;String, Object&gt; arguments, Consumer callback) throws IOException;</code></p><ul><li>queue: 队列的名称。</li><li>autoAck: 设置是否自动确认。</li><li>consumerTag: 消费者标签，用来区分多个消费者。</li><li>noLocal: 设置true表示不能将同一个Connection中生产者发送的消息传送给这个Connection中的消费者。</li><li>exclusive: 设置是否排他。只允许当前连接消费。</li><li>argument: 设置消费者的其他参数。</li><li>callback: 设置消费者的回调函数。</li></ul><h2 id="8-确认消息参数说明"><a href="#8-确认消息参数说明" class="headerlink" title="8. 确认消息参数说明"></a>8. 确认消息参数说明</h2><p><code>void basicAck(long deliveryTag, boolean multiple) throws IOException;</code></p><ul><li>deliveryTag: 当一个消费者向RabbitMQ注册后，RabbitMQ会用 basic.deliver方法向消费者推送消息，这个方法携带了一个delivery tag，它在一个channel中唯一代表了一次投递。delivery tag的唯一标识范围限于channel（待验证）。delivery tag是单调递增的正整数，客户端获取投递的方法用dellivery tag作为一个参数。</li><li>mutiple: ack unack 的mutiple参数设置为true，则可以一次性应答delivery_tag小于等于传入值的所有应答。</li></ul><h2 id="9-备份交换器"><a href="#9-备份交换器" class="headerlink" title="9. 备份交换器"></a>9. 备份交换器</h2><p>如果不设置mandatory参数，那么在消息在未被路由的情况下将会丢失，设置了mandatory参数，那么需要添加ReturnListener的编程逻辑，生产者代码将变的复杂。</p><p>如果不想采取上述措施取确保消息发送成功，可以通过声明备份交换器，声明交换器时使用alternate-exchange参数实现，也可以通过Policy方式实现。</p><p>备份交换器如下特殊情况：</p><ul><li>如果设置的备份交换器不存在，则不会有异常出现，消息丢失。</li><li>如果设置的备份交换器未绑定任何队列，则不会有异常出现，消息丢失。</li><li>如果设置的备份交换器未匹配任何队列，则不会有异常出现，消息丢失。</li><li>如果备份交换器和mandatory一起使用，则mandatory失效。</li></ul><h2 id="10-消息过期时间"><a href="#10-消息过期时间" class="headerlink" title="10. 消息过期时间"></a>10. 消息过期时间</h2><p>目前有两种方式设置消息的过期时间：</p><ol><li><p>通过队列属性设置，所有消息都有相同的过期时间。设置队列属性x-message-ttl或者通过Policy设置。也可以通过HTTP API。消息过期会被立即删除。</p></li><li><p>通过对消息本身单独设置。在basicPulish方法中添加expiration的属性参数。也可以通过HTTP API。消息过期不会被立即删除，只有当消费者消费消息时判定消息是否过期。</p></li></ol><p>如果两种方式一块使用，则以过期时间较小的为准。</p><p>消息一旦到达过期时间，就会变成死信。</p><p>如果不设置ttl，则消息不会过期；如果ttl设置为0，此时除非将消息直接投递给消费者，否则该消息会被立即丢弃。</p><p>设置消息队列x-expires参数可以控制自动删除前处于未使用状态的时间。未使用的意思是队列上没有任何消费者，队列也没有被重新声明，并且在过期时间段内也未调用过Basic.Get命令。</p><h2 id="11-死信队列、死信交换器（Dead-Letter-Exchange）"><a href="#11-死信队列、死信交换器（Dead-Letter-Exchange）" class="headerlink" title="11. 死信队列、死信交换器（Dead-Letter-Exchange）"></a>11. 死信队列、死信交换器（Dead-Letter-Exchange）</h2><p>当一个消息在一个队列中变成死信时，它可以被重新发送到另一个交换器(DLX)中，绑定DLX的就被称为私信队列。</p><h2 id="12-延迟队列"><a href="#12-延迟队列" class="headerlink" title="12. 延迟队列"></a>12. 延迟队列</h2><p>延迟队列存储的对象时对应的延迟消息。延迟消息指消息被发送后（生产者？），并不想让消费者立即拿到这个消息，而是等待特定时间后，消费者才能拿这个消息消费。</p><h2 id="13-优先级队列"><a href="#13-优先级队列" class="headerlink" title="13. 优先级队列"></a>13. 优先级队列</h2><p>具有高优先级的队列具有高的被优先消费的特权。设置x-max-priority参数实现。</p><h2 id="14-RPC"><a href="#14-RPC" class="headerlink" title="14. RPC"></a>14. RPC</h2><p>时序图：</p><p><img src="/media/article/rabbitmq-rpc-seq.png" alt="rabbitmq-rpc-seq"></p><p>流程图：<br><img src="/media/article/rabbitmq-rpc-logic.png" alt="rabbitmq-rpc-logic"></p><h2 id="15-持久化"><a href="#15-持久化" class="headerlink" title="15. 持久化"></a>15. 持久化</h2><p>RabbitMQ持久化分为3个部分：交换器、队列、消息持久化。</p><p>交换器和队列通过durable设置持久化；消息持久化通过投递模式(deliveryMode)设置为2实现。</p><p>注意：<strong><em>持久化消息正确存入RabbitMQ时，还需要一定时间才能存入磁盘。</em></strong>为了解决这个问题，可以引入RabbitMQ的队列镜像机制，如果主节点挂掉，可以自动切换到从节点，这样就保证了队列的可靠性。</p><h2 id="16-生产者确认"><a href="#16-生产者确认" class="headerlink" title="16. 生产者确认"></a>16. 生产者确认</h2><p>为了保证消息正确存入RabbitMQ，有两种解决方式：</p><ul><li>事务方式: 虽然保证了数据的正确性，但是损耗RabbitMQ性能非常大（每次多一次命令帧的交互）。</li><li>通过发送方确认实现: 消息被发送到匹配队列后，RabbitMQ就会发送一个Basic.Ack给生产者。如果消息和队列是可持久化的，那么消息被写入磁盘后，才会发出ack确认。</li></ul><p>发送方确认有4种方式: 事务和普通confirm，批量和异步confirm。</p><p>批量confirm: 发送一批数据后，调用waitForConfirms方法，等待服务器确认返回。缺点是，如果存在一条NACK，则全部需要重新发送，容易造成重复数据。<br>异步confirm: 提供一个回调方法，服务端确认了一条或者多条消息后客户端会回调这个方法处理。</p><p>事务机制和发送确认机制是互斥的。</p><p>事务机制和发送确认机制确保消息能够正确的发至RabbitMQ，这里的发至指正确的发往至RabbitMQ的交换器，如果此时交换器没有绑定队列，消息丢失。</p><h2 id="17-消费消息"><a href="#17-消费消息" class="headerlink" title="17. 消费消息"></a>17. 消费消息</h2><p>消费消息需要注意：</p><ul><li>消息分发: 轮询的方式。</li><li>消息的顺序性: 消费者消息的消息和发布消息的顺序是一致的。RabbitMQ的顺序保障是从消息存入队列开始的。</li><li>弃用QueueingConsumer</li></ul><p><code>basicQos(int prefetchCount, int PrefetchSize,  boolean global)</code>参数说明：</p><ul><li>prefetchCount: 设置为0表示消息数量没有上限。</li><li>prefetchSize: 表示消费者所能接收为确认的总体大小上限，单位为B，设置为0表示没有上限。</li><li>global: true表示信道上所有的消费者都要遵从prefetchCount的限定值；false表示信道上新的消费者需要遵循prefetchCount的限定值。</li></ul><p>如果需要保证消息的顺序性，可以在消息体内加入序列来保持消息消费的有序性。</p><p>QueueingConsumer存在的问题:</p><ul><li>消费者内存溢出，导致服务宕机，队列堆积。</li><li>拖累同一个Connection的所有信道，使其性能降低。</li><li>同步递归调用QueueingConsumer会导致死锁。</li><li>RabbitMQ的自动连接恢复机制不支持QueueingConsumer。</li><li>QueueingConsumer不是事件驱动的。</li></ul><p>建议尽量使用继承DefaultConsumer的方式。</p><h2 id="18-消息传输保障"><a href="#18-消息传输保障" class="headerlink" title="18. 消息传输保障"></a>18. 消息传输保障</h2><p>At most once: 最多一次。可能丢失，但不重复。</p><p>At least once: 最少一次。不会丢失，可能重复。</p><p>Exactly once: 恰好一次。不会丢失，不会重复。此方式RabbitMQ无法保证。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/27591386/" target="_blank" rel="noopener">RabbitMQ实战指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-关于RabbitMQ的Connection&quot;&gt;&lt;a href=&quot;#1-关于RabbitMQ的Connection&quot; class=&quot;headerlink&quot; title=&quot;1. 关于RabbitMQ的Connection&quot;&gt;&lt;/a&gt;1. 关于RabbitMQ的Co
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.programer.group/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="中间件" scheme="http://blog.programer.group/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="RabbitMQ" scheme="http://blog.programer.group/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Spring AMQP</title>
    <link href="http://blog.programer.group/spring/2020-02-13-spring-amqp/"/>
    <id>http://blog.programer.group/spring/2020-02-13-spring-amqp/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2021-05-19T07:57:28.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ConnectionFactory"><a href="#1-ConnectionFactory" class="headerlink" title="1. ConnectionFactory"></a>1. ConnectionFactory</h2><p>工厂类的一些属性：</p><p>Connection and Channel Listeners用来监听Connection和Channel相关的事件（创建、关闭、终止)。</p><p>Channel关闭事件日志策略。</p><p>运行时缓存属性配置。在运行时动态的修改连接属性，比如，channel缓存大小、事务channel缓存大小。</p><p>RabbitMQ 自动的连接和拓扑恢复。</p><p>添加自定义客户端连接属性。<br><code>connectionFactory.getRabbitConnectionFactory().getClientProperties().put(&quot;thing1&quot;, &quot;thing2&quot;);</code></p><h3 id="1-1-CachingConnectionFactory"><a href="#1-1-CachingConnectionFactory" class="headerlink" title="1.1 CachingConnectionFactory"></a>1.1 CachingConnectionFactory</h3><p>CachingConnectionFactory有两种缓存模式：Connection和Channel。</p><p>CachingConnectionFactory是一个Connection工厂实现类（当缓存模式是<code>CachingConnectionFactory.CacheMode.CHANNEL</code>（默认）时，返回所有<code>createConnection()</code>调用都返回相同的Connection，忽略对<code>Connection.close()</code>的调用并缓存<code>Channel</code>）。<br>默认情况下，只缓存25个Channel，并根据需要创建和处理其他请求的Channel。在高并发情况下考虑提高<code>channelCacheSize</code>的值。<code>channelCacheSize</code>不限制channel的创建数量，如果需要限制，可以使用<code>channelCheckoutTimeout</code>，当此 <code>channelCheckoutTimeout</code> 大于零时，channelCacheSize将成为可以在连接上创建的 channel 数量的限制。如果达到限制，则调用线程将阻塞，直到 channel 可用或达到此超时，在这种情况下抛出AmqpTimeoutException。</p><p>当缓存模式是<code>CachingConnectionFactory.CacheMode.CONNECTION</code>时，每个<code>createConnection()</code>都会使用一个新的（缓存的）Connection；连接将根据<code>connectionCacheSize</code>的值缓存。在这种模式下，Connections和Channels都会被缓存。<code>connectionLimit</code>可以用来限制创建Connection的数量，当数量到达时可以使用<code>channelCheckoutTimeLimit</code>等待缓存中的连接空闲，如果超时，将抛出<code>AmqpTimeoutException</code>。</p><p>当使用比较大数量的Connection时，应该考虑在<code>CachingConnectionFactory</code>设置自定义的<code>executor</code>。<code>executor</code>的线程池应不受限制，或应针对预期用途进行适当设置（通常一个线程一个连接）。如果在每个Connection创建多个Channel，线程池的大小影响并发。因此，可变（或简单缓存）线程池执行程序将是最合适的。</p><p><code>CachingConnectionFactory.CacheMode.CONNECTION</code>模式和Rabbit Admin自动声明的队列不兼容。</p><p>CachingConnectionFactory要求显式关闭从其Connection获得的所有Channel。通常，代码都需要显式的关闭所有的Channel。但是，对于此ConnectionFactory，必须使用显式关闭才能真正使Channel重用。如果有空间（channelCacheSize），Channel.close（）会将通道返回到缓存，否则物理上关闭该通道。</p><h3 id="1-2-SimpleRoutingConnectionFactory"><a href="#1-2-SimpleRoutingConnectionFactory" class="headerlink" title="1.2 SimpleRoutingConnectionFactory"></a>1.2 SimpleRoutingConnectionFactory</h3><p>对多个ConnectionFactory进行管理。</p><ol><li>SimpleResourceHolder绑定lookupKey</li><li>RabbitTemplate表达式支持</li></ol><h2 id="2-AmqpTemplate"><a href="#2-AmqpTemplate" class="headerlink" title="2. AmqpTemplate"></a>2. AmqpTemplate</h2><h3 id="2-1-添加重试机制"><a href="#2-1-添加重试机制" class="headerlink" title="2.1 添加重试机制"></a>2.1 添加重试机制</h3><p>第一种方式是在rabbitTemplate中注入RetryTemplate，这种方式如果使用RecoveryCallback则只能在重试上下文中使用lastThrowable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public AmqpTemplate rabbitTemplate() &#123;</span><br><span class="line">    RabbitTemplate template = new RabbitTemplate(connectionFactory());</span><br><span class="line">    RetryTemplate retryTemplate = new RetryTemplate();</span><br><span class="line">    ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();</span><br><span class="line">    backOffPolicy.setInitialInterval(500);</span><br><span class="line">    backOffPolicy.setMultiplier(10.0);</span><br><span class="line">    backOffPolicy.setMaxInterval(10000);</span><br><span class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</span><br><span class="line">    template.setRetryTemplate(retryTemplate);</span><br><span class="line">    return template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种方式是直接使用retryTemplate进行重试，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">retryTemplate.execute(</span><br><span class="line">    new RetryCallback&lt;Object, Exception&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object doWithRetry(RetryContext context) throws Exception &#123;</span><br><span class="line">            context.setAttribute(&quot;message&quot;, message);</span><br><span class="line">            return rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, new RecoveryCallback&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object recover(RetryContext context) throws Exception &#123;</span><br><span class="line">            Object message = context.getAttribute(&quot;message&quot;);</span><br><span class="line">            Throwable t = context.getLastThrowable();</span><br><span class="line">            // Do something with message</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方式你可以在上下文中获取属性信息。</p><h3 id="2-2-怎样确认异步消息的成功和失败"><a href="#2-2-怎样确认异步消息的成功和失败" class="headerlink" title="2.2 怎样确认异步消息的成功和失败"></a>2.2 怎样确认异步消息的成功和失败</h3><p>默认情况下，rabbitmq将会删除不能被路由的消息，对于成功的消息，会返回一个异步的确认信息。<br>考虑如下两种情况：</p><ul><li>发送消息没有匹配的队列</li><li>发送消息没有匹配exchange</li></ul><p>第一种情况可以使用消息返回处理；第二种情况消息被删除，不会返回消息，channel关闭并抛出异常。这种情况你可以注册ChannelListener。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">this.connectionFactory.addConnectionListener(new ConnectionListener() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Connection connection) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    // signal中包含reson信息</span><br><span class="line">    public void onShutDown(ShutdownSignalException signal) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-3-发送消息确认与返回"><a href="#2-3-发送消息确认与返回" class="headerlink" title="2.3 发送消息确认与返回"></a>2.3 发送消息确认与返回</h3><h4 id="2-3-1-消息返回"><a href="#2-3-1-消息返回" class="headerlink" title="2.3.1 消息返回"></a>2.3.1 消息返回</h4><p>消息返回必须设置<code>mandatory</code>属性，或者发送消息时针对特定消息设置<code>mandatory-expression</code>属性。</p><p>消息返回可以通过rabbitTemplate设置返回回调。</p><p><code>rabbitTemplate.setReturnCallback(ReturnCallback callback)</code></p><p><strong><em> 注意：一个rabbitTemplate实例仅支持一个ReturnCallback。</em></strong></p><h4 id="2-3-2-消息确认"><a href="#2-3-2-消息确认" class="headerlink" title="2.3.2 消息确认"></a>2.3.2 消息确认</h4><p>消息确认需要设置<code>publisherConfirms</code>属性。</p><p>消息确认同样可以设置<code>ConfirmCallback</code>，用来处理消息返回确认。</p><p>值得特别注意的是使用消息确认时，需要等到最后一个消息确认完成时再关闭channel。</p><p>因为当connectfactory的channelCacheSize满了时，框架会在保持5秒channel后关闭channel，有可能导致没有足够的时间确认和消息返回。<br>当仅使用返回时，channel保持5秒开启。</p><p>只要返回回调在60秒或更短时间内执行，就可以保证在确认之前仍接收到返回的消息。确认在返回回调退出后或60秒后（以先到者为准）进行传递。</p><p>自从2.1版本开始，开始使用<code>CorrelationData</code>,而不是ConfirmCallback。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData cd1 = new CorrelationData();</span><br><span class="line">this.templateWithConfirmsEnabled.convertAndSend(&quot;exchange&quot;, queue.getName(), &quot;foo&quot;, cd1);</span><br><span class="line">assertTrue(cd1.getFuture().get(10, TimeUnit.SECONDS).isAck());</span><br></pre></td></tr></table></figure><p>另外，当同时启用确认和返回，<code>CorrelationData</code>由返回消息组成。它保证在使用将来设置ack之前发生这种情况。</p><h3 id="2-4-一种更简单的等待发布者确认的机制"><a href="#2-4-一种更简单的等待发布者确认的机制" class="headerlink" title="2.4 一种更简单的等待发布者确认的机制"></a>2.4 一种更简单的等待发布者确认的机制</h3><p>有时可能希望更好地控制通道的使用，并确保在同一通道上执行全部操作。</p><p>从2.0版本，提供了<code>invoke</code>方法，并带有一个<code>OperationCallback</code>。任何操作在callback的范围内及在提供的<code>RabbitOpertions</code>参数中执行都使用相同的<code>Channel</code>，这个channel在结束时关闭（不返回至缓存）。如果<code>Channel</code>是<code>PublisherCallbackChannel</code>，它在所有确认收到后返回至缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface OperationsCallback&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T doInRabbit(RabbitOperations operations);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可能需要这样做的一个示例是，如果您希望在基础Channel上使用waitForConfirms（）方法。如前所述，Spring API以前并未公开此方法，因为通常是对通道进行缓存和共享。<strong><em> RabbitTemplate现在提供了waitForConfirms（long timeout）和waitForConfirmsOrDie（long timeout），它们委托给OperationsCallback范围内使用特定channel。由于明显的原因，不能在该范围之外使用这些方法。</em></strong></p><p>如果您只想等待broker确认交付，则可以使用以下示例中显示的技术：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; messages = getMessagesToSend();</span><br><span class="line">Boolean result = this.template.invoke(t -&gt; &#123;</span><br><span class="line">    messages.forEach(m -&gt; t.convertAndSend(ROUTE, m));</span><br><span class="line">    t.waitForConfirmsOrDie(10_000);</span><br><span class="line">    return true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果您希望在OperationsCallback范围内的同一通道上调用RabbitAdmin操作，则必须使用与调用操作相同的RabbitTemplate构造admin。</p><p>如果在现有事务的范围内已经执行了template操作，例如，当在事务处理的listener container线程上运行并在事务处理的template上执行操作时，前面的讨论就没有什么意义了。在这种情况下，操作将在该通道上执行，并在线程返回到容器时提交。在这种情况下，不必使用invoke。</p><h3 id="2-5-Publisher使用单独的连接"><a href="#2-5-Publisher使用单独的连接" class="headerlink" title="2.5 Publisher使用单独的连接"></a>2.5 Publisher使用单独的连接</h3><p>从2.0.2版本开始，将<code>usePublisherConnection</code>属性设置为true，以便可能的情况下使用与listener容器使用的连接不同的连接。</p><p>如果声明的是独占队列，会因为使用不同的连接，导致其中某一个连接获取不到队列<br>通常，不应将RabbitAdmin与具有此设置为 true 的模板一起使用。使用带有连接工厂的RabbitAdmin构造函数;如果使用其他构造函数来获取模板，请确保模板的 property 为 false。这是因为通常使用 admin 来为 listener 容器声明队列;使用 property 设置为 true 的模板意味着将在与 listener 容器使用的连接不同的连接上声明独占队列(例如AnonymousQueue)。在这种情况下，容器不能使用队列。</p><h2 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3. 发送消息"></a>3. 发送消息</h2><h3 id="3-1-Message创建API"><a href="#3-1-Message创建API" class="headerlink" title="3.1 Message创建API"></a>3.1 Message创建API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(&quot;123&quot;)</span><br><span class="line">    .setHeader(&quot;bar&quot;, &quot;baz&quot;)</span><br><span class="line">    .build();</span><br><span class="line">Message message = MessageBuilder.withBody(&quot;foo&quot;.getBytes())</span><br><span class="line">    .andProperties(props)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Message message = MessageBuilder.withBody(&quot;foo&quot;.getBytes())</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(&quot;123&quot;)</span><br><span class="line">    .setHeader(&quot;bar&quot;, &quot;baz&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="3-2-批处理"><a href="#3-2-批处理" class="headerlink" title="3.2 批处理"></a>3.2 批处理</h3><p><code>BatchingRabbitTemplate</code></p><p>批量数据保存在 memory 中;未发送的消息可能会在系统故障的 event 中丢失。</p><p><code>BatchingRabbitTemplate</code>根据SimpleBatchingStrategy发送消息。它支持将消息发送到单个 exchange/routing key。它有 properties:</p><ul><li><p>batchSize - 发送前批处理中的消息数</p></li><li><p>bufferLimit - 批量消息的最大大小;如果超过，将抢占batchSize，并导致发送部分批次</p></li><li><p>timeout - 一个 time，当没有新的活动向批处理添加消息时，将发送部分批处理</p></li></ul><p>SimpleBatchingStrategy通过在每个嵌入消息之前使用4字节二进制长度来格式化批处理。通过将springBatchFormat message property 设置为lengthHeader4，将其传达给接收系统。</p><h2 id="3-3-消费消息"><a href="#3-3-消费消息" class="headerlink" title="3.3 消费消息"></a>3.3 消费消息</h2><h3 id="3-3-1-轮询消费者"><a href="#3-3-1-轮询消费者" class="headerlink" title="3.3.1 轮询消费者"></a>3.3.1 轮询消费者</h3><p>默认情况下，如果没有可用消息，则立即返回null;没有阻挡。从 version 1.5 开始，您现在可以设置receiveTimeout(以毫秒为单位)，接收方法将阻塞，知道最大过期时间。value 小于零意味着无限期地阻塞(或者至少在与 broker 的连接丢失之前)。 Version 1.6 引入了receive方法的变体，允许在每次调用时传递超时时间。</p><p>这种轮询操作会为每一个消息创建一个<code>QueueingConsumer</code>。所以不适用于大数据量的环境。</p><h3 id="3-3-2-异步消费者"><a href="#3-3-2-异步消费者" class="headerlink" title="3.3.2 异步消费者"></a>3.3.2 异步消费者</h3><h4 id="3-3-2-1-MessageListener"><a href="#3-3-2-1-MessageListener" class="headerlink" title="3.3.2.1 MessageListener"></a>3.3.2.1 MessageListener</h4><p>异步消息接收，涉及专用的回调容器。回调则是我们与消息集成的地方。MessageListener就是这种回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageListener &#123;</span><br><span class="line">    void onMessage(Message message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您的回调逻辑出于任何原因依赖于 AMQP Channel 实例，您可以改为使用ChannelAwareMessageListener。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ChannelAwareMessageListener &#123;</span><br><span class="line">    void onMessage(Message message, Channel channel) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-2-MessageListenerAdapter"><a href="#3-3-2-2-MessageListenerAdapter" class="headerlink" title="3.3.2.2 MessageListenerAdapter"></a>3.3.2.2 MessageListenerAdapter</h4><p>如果您希望在 application 逻辑和消息传递 API 之间保持更严格的分离，则可以依赖 framework 提供的适配器 implementation。这通常被称为“Message-driven POJO”支持。</p><p>从 version 2.0 开始，提供了方便的FunctionalInterface：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface ReplyingMessageListener&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">R handleMessage(T t);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这有助于使用 Java 8 lamdas 方便地配置适配器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new MessageListenerAdapter((ReplyingMessageListener&lt;String, String&gt;) data -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-3-消费者优先权"><a href="#3-3-2-3-消费者优先权" class="headerlink" title="3.3.2.3 消费者优先权"></a>3.3.2.3 消费者优先权</h4><p>从RabbitMQ Version 3.2开始，broker 现在支持 consumer 优先级(参见在 RabbitMQ 中使用 Consumer 优先级)。通过在 consumer 上设置x-priority参数来启用此功能。 SimpleMessageListenerContainer现在支持设置 consumer arguments：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">container.setConsumerArguments(Collections.</span><br><span class="line">&lt;String, Object&gt; singletonMap(&quot;x-priority&quot;, Integer.valueOf(10)));</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-4-容器监听自动删除队列"><a href="#3-3-2-4-容器监听自动删除队列" class="headerlink" title="3.3.2.4 容器监听自动删除队列"></a>3.3.2.4 容器监听自动删除队列</h4><p>当容器配置为侦听auto-delete queue(s)，或者队列具有x-expires选项或 Broker 上配置了Time-To-Live policy 时，broker 在容器停止时删除队列(最后 consumer 被取消)。在 version 1.3 之前，由于队列丢失，无法重新启动容器;当连接是 closed/opens 时，RabbitAdmin仅自动重新声明队列等，当容器为 stopped/started 时不会发生。</p><p>从 version 1.3 开始，容器现在将使用RabbitAdmin在启动期间重新声明任何丢失的队列。</p><p>您还可以使用条件声明和auto-startup=”false”一起来管理延迟声明队列，直到容器启动。</p><p>在这种情况下，队列和交换由containerAdmin声明，它具有auto-startup=”false”，因此在 context 初始化期间不会声明元素。此外，出于同样的原因，容器未启动。稍后启动容器时，它会使用 reference containerAdmin来声明元素。</p><h4 id="3-3-2-5-批处理消息"><a href="#3-3-2-5-批处理消息" class="headerlink" title="3.3.2.5 批处理消息"></a>3.3.2.5 批处理消息</h4><p>批处理的消息（由生产者创建）由侦听器容器自动分批处理（使用springBatchFormat消息头）。拒绝批次中的任何消息都会导致整个批次被拒绝。有关批处理的更多信息，请参见批处理。</p><p>设置容器属性ConsumerBatchEnabled以启用此功能。 deBatchingEnabled也必须为true，以便容器负责处理这两种类型的批次。当ConsumerBatchEnabled为true时，实现BatchMessageListener或ChannelAwareBatchMessageListener。有关将此功能与@RabbitListener一起使用的信息，请参阅带有批处理的@RabbitListener。</p><h4 id="3-3-2-6-消费者事件"><a href="#3-3-2-6-消费者事件" class="headerlink" title="3.3.2.6 消费者事件"></a>3.3.2.6 消费者事件</h4><p>每当侦听器（消费者）遇到某种类型的故障时，容器就会发布应用程序事件。事件ListenerContainerConsumerFailedEvent具有以下属性：</p><ul><li>container: 消费者遇到问题的侦听器容器。</li><li>reason: 失败的文字原因。</li><li>fatal: 指示失败是否致命的布尔值。对于非致命异常，容器将根据recoveryInterval或recoveryBackoff（对于SimpleMessageListenerContainer）或monitorInterval（对于DirectMessageListenerContainer）尝试重新启动消费者。</li><li>throwable: 被捕获的Throwable。</li></ul><p>如果消费者由于默认情况下不专门使用其队列以及发布事件而失败，那么将发出WARN日志。要更改此日志记录行为，请在SimpleMessageListenerContainer实例的ExclusiveConsumerExceptionLogger属性中提供自定义的ConditionalExceptionLogger。另请参阅记录通道关闭事件。</p><p>致命错误始终记录在ERROR级别。这是不可修改的。</p><p>在容器生命周期的各个阶段还发布了其他一些事件：</p><ul><li><p>AsyncConsumerStartedEvent：启动消费者时。</p></li><li><p>AsyncConsumerRestartedEvent：消费者在发生故障后重新启动时-仅SimpleMessageListenerContainer。</p></li><li><p>AsyncConsumerTerminatedEvent：消费者正常停止时。</p></li><li><p>AsyncConsumerStoppedEvent：消费者停止时-仅SimpleMessageListenerContainer。</p></li><li><p>ConsumeOkEvent：当从Broker接收到一个consumerOk时，包含队列名称和consumerTag</p></li><li><p>ListenerContainerIdleEvent：请参阅检测空闲的异步消费者。</p></li></ul><h4 id="3-3-2-7-消费者标签"><a href="#3-3-2-7-消费者标签" class="headerlink" title="3.3.2.7 消费者标签"></a>3.3.2.7 消费者标签</h4><p>默认情况下，消费者标签由broker提供。你可以使用ConsumerTagStrategy实现自己的命名策略。</p><h4 id="3-3-2-8-注解驱动的侦听器端点"><a href="#3-3-2-8-注解驱动的侦听器端点" class="headerlink" title="3.3.2.8 注解驱动的侦听器端点"></a>3.3.2.8 注解驱动的侦听器端点</h4><p>异步接收消息的最简单方法是使用带注释的侦听器端点基础结构。简而言之，它使您可以将托管bean的方法公开为Rabbit侦听器端点。以下示例显示了如何使用@RabbitListener批注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">    public void processOrder(String data) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式，绑定了已经存在的队列。除了上述的方式，你还可以使用自动声明队列的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">  @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue(value = &quot;myQueue&quot;, durable = &quot;true&quot;),</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.exch&quot;, ignoreDeclarationExceptions = &quot;true&quot;),</span><br><span class="line">        key = &quot;orderRoutingKey&quot;)</span><br><span class="line">  )</span><br><span class="line">  public void processOrder(Order order) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue,</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.exch&quot;),</span><br><span class="line">        key = &quot;invoiceRoutingKey&quot;)</span><br><span class="line">  )</span><br><span class="line">  public void processInvoice(Invoice invoice) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @RabbitListener(queuesToDeclare = @Queue(name = &quot;$&#123;my.queue&#125;&quot;, durable = &quot;true&quot;))</span><br><span class="line">  public String handleWithSimpleDeclare(String data) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一个示例中，队列myQueue与交换（如果需要）一起自动（持久）声明，并与路由键绑定到交换。在第二个示例中，声明并绑定了一个匿名（专有的，自动删除）队列。可以提供多个QueueBinding条目，让侦听器侦听多个队列。在第三个示例中，如有必要，将声明一个具有从属性my.queue检索到的名称的队列，并使用该队列名称作为路由键将其默认绑定到默认交换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue(value = &quot;auto.headers&quot;, autoDelete = &quot;true&quot;,</span><br><span class="line">                        arguments = @Argument(name = &quot;x-message-ttl&quot;, value = &quot;10000&quot;,</span><br><span class="line">                                                type = &quot;java.lang.Integer&quot;)),</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.headers&quot;, type = ExchangeTypes.HEADERS, autoDelete = &quot;true&quot;),</span><br><span class="line">        arguments = &#123;</span><br><span class="line">                @Argument(name = &quot;x-match&quot;, value = &quot;all&quot;),</span><br><span class="line">                @Argument(name = &quot;thing1&quot;, value = &quot;somevalue&quot;),</span><br><span class="line">                @Argument(name = &quot;thing2&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">)</span><br><span class="line">public String handleWithHeadersExchange(String foo) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RabbitListener属性参数：</p><ul><li>String id</li><li>String containerFactory</li><li>String[] queues</li><li>Queue[] queuesToDeclare</li><li>boolean exclusive</li><li>String priority</li><li>String admin</li><li>QueueBinding[] bindings<ul><li>Queue value</li><li>Exchange exchange</li><li>String[] key // routingKey</li><li>String ignoreDeclarationExceptions</li><li>Argument[] arguments</li><li>String declare // 如果admin存在，需要声明此属性</li><li>String[] admins</li></ul></li><li>String group // 如果存在Listener容器，则可以将容器的beanName赋予此属性</li><li>String returnExceptions // 设置为true时，设置为true会导致Listener抛出的异常使用正常的<code>replyto/SendTo</code>语义发送给发送者，设置false时，将异常抛出到Listener容器并执行正常的重试/死信处理。</li><li>String errorHandler //如果Listener容器出现异常，则处理异常</li><li>String concurrency</li><li>String autoStartup // 延迟创建队列，交换器</li></ul><h4 id="3-3-2-9-创建自己的监听注解-元注解"><a href="#3-3-2-9-创建自己的监听注解-元注解" class="headerlink" title="3.3.2.9 创建自己的监听注解(元注解)"></a>3.3.2.9 创建自己的监听注解(元注解)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue,</span><br><span class="line">        exchange = @Exchange(value = &quot;metaFanout&quot;, type = ExchangeTypes.FANOUT)))</span><br><span class="line">public @interface MyAnonFanoutListener &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MetaListener &#123;</span><br><span class="line"></span><br><span class="line">    @MyAnonFanoutListener</span><br><span class="line">    public void handle1(String foo) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @MyAnonFanoutListener</span><br><span class="line">    public void handle2(String foo) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2.3 版本开始，支持@AliasFor以允许在元注释的注释上覆盖属性。而且，用户注释现在可以是@Repeatable的，从而允许为一个方法创建多个容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">static class MetaAnnotationTestBean &#123;</span><br><span class="line"></span><br><span class="line">    @MyListener(&quot;queue1&quot;)</span><br><span class="line">    @MyListener(&quot;queue2&quot;)</span><br><span class="line">    public void handleIt(String body) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Repeatable(MyListeners.class)</span><br><span class="line">static @interface MyListener &#123;</span><br><span class="line"></span><br><span class="line">    @AliasFor(annotation = RabbitListener.class, attribute = &quot;queues&quot;)</span><br><span class="line">    String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">static @interface MyListeners &#123;</span><br><span class="line"></span><br><span class="line">    MyListener[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-10-启用侦听器端点注释"><a href="#3-3-2-10-启用侦听器端点注释" class="headerlink" title="3.3.2.10 启用侦听器端点注释"></a>3.3.2.10 启用侦听器端点注释</h4><p>要启用对@RabbitListener批注的支持，可以将@EnableRabbit添加到您的@Configuration类之一。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        factory.setConcurrentConsumers(3);</span><br><span class="line">        factory.setMaxConcurrentConsumers(10);</span><br><span class="line">        factory.setContainerCustomizer(container -&gt; /* customize the container */);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从2.0版开始，DirectMessageListenerContainerFactory也可用。它创建DirectMessageListenerContainer实例。</p><p>从2.2.2版开始，您可以提供ContainerCustomizer实现（如上所示）。创建和配置容器后，可以使用该方法进一步配置容器。例如，您可以使用它来设置容器工厂未公开的属性。</p><p>默认情况下，底层将查找名为RabbitListenerContainerFactory的bean作为工厂的源，以用于创建消息侦听器容器。在这种情况下，忽略了RabbitMQ底层设置，可以使用三个线程的核心池大小和十个线程的最大池大小来调用processOrder方法。</p><p>您可以定制用于每个注释的侦听器容器工厂，也可以通过实现RabbitListenerConfigurer接口来配置显式默认值。仅当至少一个端点在没有特定容器工厂的情况下注册时，才需要使用默认值。有关完整的详细信息和示例，请参见Javadoc。</p><p>容器工厂提供了添加MessagePostProcessor实例的方法，这些实例在接收消息之后（调用侦听器之前）和发送回复之前应用。</p><p>从版本2.0.6开始，可以将RetryTemplate和RecoveryCallback添加到侦听器容器工厂。发送回复时使用。重试用尽时将调用RecoveryCallback。您可以使用SendRetryContextAccessor从上下文中获取信息。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">factory.setRetryTemplate(retryTemplate);</span><br><span class="line">factory.setReplyRecoveryCallback(ctx -&gt; &#123;</span><br><span class="line">    Message failed = SendRetryContextAccessor.getMessage(ctx);</span><br><span class="line">    Address replyTo = SendRetryContextAccessor.getAddress(ctx);</span><br><span class="line">    Throwable t = ctx.getLastThrowable();</span><br><span class="line">    ...</span><br><span class="line">    return null;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从2.0版开始，@RabbitListener批注具有并发属性。它支持SpEL表达式（＃{…}）和属性占位符（$ {…}）。其含义和允许的值取决于容器类型，如下所示：</p><ul><li><p>对于DirectMessageListenerContainer，该值必须是单个整数值，该值设置容器上的consumersPerQueue属性。</p></li><li><p>对于SimpleRabbitListenerContainer，该值可以是一个单个整数值，该值在容器上设置了concurrentConsumers属性，也可以具有m-n的形式，其中m是parallelConsumers属性，n是maxConcurrentConsumers属性。</p></li></ul><p>无论哪种情况，此设置都将覆盖出厂设置。以前，如果您有需要不同并发性的侦听器，则必须定义不同的容器工厂。</p><p>该注释还允许通过autoStartup和executor（自2.2起）注释属性覆盖工厂的autoStartup和taskExecutor属性。为每个执行程序使用不同的执行程序可能有助于在日志和线程转储中标识与每个侦听器关联的线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(id = &quot;manual.acks.1&quot;, queues = &quot;manual.acks.1&quot;, ackMode = &quot;MANUAL&quot;)</span><br><span class="line">public void manual1(String in, Channel channel,</span><br><span class="line">    @Header(AmqpHeaders.DELIVERY_TAG) long tag) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    channel.basicAck(tag, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-11-带注释方法的消息转换"><a href="#3-3-2-11-带注释方法的消息转换" class="headerlink" title="3.3.2.11 带注释方法的消息转换"></a>3.3.2.11 带注释方法的消息转换</h4><p>调用侦听器之前，管道中有两个转换步骤。第一步使用MessageConverter将传入的Spring AMQP消息转换为Spring消息。调用目标方法时，如有必要，消息将转换为方法参数类型。</p><p>第一步的默认MessageConverter是Spring AMQP SimpleMessageConverter，它处理到String和java.io.Serializable对象的转换。所有其他的都保留为byte []。在下面的讨论中，我们称其为“消息转换器”。</p><p>第二步的默认转换器是GenericMessageConverter，它委派给转换服务（DefaultFormattingConversionService的实例）。在下面的讨论中，我们将其称为“方法参数转换器”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    ...</span><br><span class="line">    factory.setMessageConverter(new Jackson2JsonMessageConverter());</span><br><span class="line">    ...</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.6之前的版本中，必须在消息头中提供用于转换JSON的类型信息，或者需要自定义ClassMapper。从版本1.6开始，如果没有类型信息标头，则可以从目标方法参数中推断类型。</p><p>自定义消息转换器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() &#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();</span><br><span class="line">        factory.setMessageConverter(new GenericMessageConverter(myConversionService()));</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConversionService myConversionService() &#123;</span><br><span class="line">        DefaultConversionService conv = new DefaultConversionService();</span><br><span class="line">        conv.addConverter(mySpecialConverter());</span><br><span class="line">        return conv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-12-程序化端点注册"><a href="#3-3-2-12-程序化端点注册" class="headerlink" title="3.3.2.12 程序化端点注册"></a>3.3.2.12 程序化端点注册</h4><p>RabbitListenerEndpoint提供了Rabbit端点的模型，并负责为该模型配置容器。除了RabbitListener批注检测到的端点之外，基础结构还允许您以编程方式配置端点。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();</span><br><span class="line">        endpoint.setQueueNames(&quot;anotherQueue&quot;);</span><br><span class="line">        endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">            // processing</span><br><span class="line">        &#125;);</span><br><span class="line">        registrar.registerEndpoint(endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的示例中，我们使用了SimpleRabbitListenerEndpoint，它提供了实际的MessageListener来调用，但是您也可以构建自己的端点变体来描述自定义调用机制。</p><p>应该注意的是，您也可以完全跳过@RabbitListener的使用，并通过RabbitListenerConfigurer以编程方式注册端点。</p><h4 id="3-3-2-13-带注释的端点方法签名"><a href="#3-3-2-13-带注释的端点方法签名" class="headerlink" title="3.3.2.13 带注释的端点方法签名"></a>3.3.2.13 带注释的端点方法签名</h4><p>到目前为止，我们已经在端点中注入了一个简单的String，但实际上它可以具有非常灵活的方法签名。以下示例将其重写为使用自定义标头注入Order：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">    public void processOrder(Order order, @Header(&quot;order_type&quot;) String orderType) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下列表显示了可以在侦听器端点中注入的主要元素：</p><ul><li><p>原始的org.springframework.amqp.core.Message。</p></li><li><p>接收消息的com.rabbitmq.client.Channel。</p></li><li><p>代表传入的AMQP消息的org.springframework.messaging.Message。请注意，此消息同时包含自定义标头和标准标头（由AmqpHeaders定义）。</p></li></ul><p>例如，如果我们想在处理订单之前确保其有效，则可以使用@Valid注释有效负载并配置必要的验证器，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() &#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();</span><br><span class="line">        factory.setValidator(myValidator());</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-14-监听多个队列"><a href="#3-3-2-14-监听多个队列" class="headerlink" title="3.3.2.14 监听多个队列"></a>3.3.2.14 监听多个队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &#123; &quot;queue1&quot;, &quot;queue2&quot; &#125; )</span><br><span class="line">    public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;#&#123;&apos;$&#123;property.with.comma.delimited.queue.names&#125;&apos;.split(&apos;,&apos;)&#125;&quot; )</span><br><span class="line">    public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-15-回复管理"><a href="#3-3-2-15-回复管理" class="headerlink" title="3.3.2.15 回复管理"></a>3.3.2.15 回复管理</h4><p>MessageListenerAdapter中的现有支持已经使您的方法具有非空返回类型。在这种情况下，调用的结果将封装在一条消息中，该消息发送到原始消息的ReplyToAddress标头中指定的地址或侦听器上配置的默认地址。您可以使用消息传递抽象的@SendTo批注设置该默认地址。</p><p>假设我们的processOrder方法现在应该返回一个OrderStatus，我们可以如下编写它以自动发送回复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(destination = &quot;myQueue&quot;)</span><br><span class="line">@SendTo(&quot;status&quot;)</span><br><span class="line">public OrderStatus processOrder(Order order) &#123;</span><br><span class="line">    // order processing</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要以与传输无关的方式设置其他标头，则可以返回一条Message，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RabbitListener(destination = &quot;myQueue&quot;)</span><br><span class="line">@SendTo(&quot;status&quot;)</span><br><span class="line">public Message&lt;OrderStatus&gt; processOrder(Order order) &#123;</span><br><span class="line">    // order processing</span><br><span class="line">    return MessageBuilder</span><br><span class="line">        .withPayload(status)</span><br><span class="line">        .setHeader(&quot;code&quot;, 1234)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者，可以在beforeSendReplyMessagePostProcessors容器工厂属性中使用MessagePostProcessor添加更多标头。从版本2.2.3开始，在答复消息中可以使用被调用的bean/方法，可以在消息后处理器中使用它来将信息传达回调用方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">factory.setBeforeSendReplyPostProcessors(msg -&gt; &#123;</span><br><span class="line">    msg.getMessageProperties().setHeader(&quot;calledBean&quot;,</span><br><span class="line">            msg.getMessageProperties().getTargetBean().getClass().getSimpleName());</span><br><span class="line">    msg.getMessageProperties().setHeader(&quot;calledMethod&quot;,</span><br><span class="line">            msg.getMessageProperties().getTargetMethod().getName());</span><br><span class="line">    return m;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从版本2.2.5开始，您可以配置ReplyPostProcessor在发送回复消息之前对其进行修改；在为相关请求设置了relatedId标头之后，将调用此方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;test.header&quot;, group = &quot;testGroup&quot;, replyPostProcessor = &quot;echoCustomHeader&quot;)</span><br><span class="line">public String capitalizeWithHeader(String in) &#123;</span><br><span class="line">    return in.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public ReplyPostProcessor echoCustomHeader() &#123;</span><br><span class="line">    return (req, resp) -&gt; &#123;</span><br><span class="line">        resp.getMessageProperties().setHeader(&quot;myHeader&quot;, req.getMessageProperties().getHeader(&quot;myHeader&quot;));</span><br><span class="line">        return resp;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@SendTo值被假定为跟随exchange / routingKey模式的回复交换和routingKey对，其中这些部分之一可以省略。有效值如下：</p><p>something1 / thing2：replyTo交换和routingKey。 something1 /：replyTo交换和默认（空）routingKey。 something2或/ thing2：replyTo routingKey和默认（空）交换。 /或为空：replyTo默认交换和默认routingKey。</p><p>此外，您可以使用不带值属性的@SendTo。这种情况下等于一个空的sendTo模式。仅当入站邮件没有ReplyToAddress属性时才使用@SendTo。</p><p>从版本1.5开始，@SendTo值可以是bean初始化SpEL表达式，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;test.sendTo.spel&quot;)</span><br><span class="line">@SendTo(&quot;#&#123;spelReplyTo&#125;&quot;)</span><br><span class="line">public String capitalizeWithSendToSpel(String foo) &#123;</span><br><span class="line">    return foo.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@Bean</span><br><span class="line">public String spelReplyTo() &#123;</span><br><span class="line">    return &quot;test.sendTo.reply.spel&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于动态回复路由，消息发送者应包括reply_to消息属性或使用备用运行时SpEL表达式（在下一个示例之后进行描述）。</p><p>从版本1.6开始，@SendTo可以是SpEL表达式，在运行时将根据请求和答复对它进行评估，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;test.sendTo.spel&quot;)</span><br><span class="line">@SendTo(&quot;!&#123;&apos;some.reply.queue.with.&apos; + result.queueName&#125;&quot;)</span><br><span class="line">public Bar capitalizeWithSendToSpel(Foo foo) &#123;</span><br><span class="line">    return processTheFooAndReturnABar(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpEL表达式的运行时性质由！{…}分隔符指示。表达式的评估上下文#root对象具有三个属性：</p><ul><li><p>request：o.s.amqp.core.Message请求对象。</p></li><li><p>来源：转换后的o.s.messaging.Message &lt;？&gt;。</p></li><li><p>结果：方法结果。</p></li></ul><p>上下文具有一个map属性访问器，一个标准类型转换器和一个bean解析器，该解析器允许引用上下文中的其他bean（例如@ someBeanName.determineReplyQ（request，result））。</p><p>总而言之，＃{…}在初始化期间被初始化一次，其中#root对象是应用程序上下文。 Bean由其名称引用。在运行时为每条消息评估！{…}，根对象具有前面列出的属性。 Bean的名称以@开头。</p><p>从2.1版开始，还支持简单的属性占位符（例如$ {some.reply.to}）。对于早期版本，可以将以下内容用作替代方法，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;foo&quot;)</span><br><span class="line">@SendTo(&quot;#&#123;environment[&apos;my.send.to&apos;]&#125;&quot;)</span><br><span class="line">public String listen(Message in) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-16-多方法侦听器"><a href="#3-3-2-16-多方法侦听器" class="headerlink" title="3.3.2.16 多方法侦听器"></a>3.3.2.16 多方法侦听器</h4><p>从1.5.0版开始，您可以在类级别指定@RabbitListener注释。与新的@RabbitHandler批注一起，这使单个侦听器可以根据传入消息的有效负载类型调用不同的方法。最好用一个例子来描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(id=&quot;multi&quot;, queues = &quot;someQueue&quot;)</span><br><span class="line">@SendTo(&quot;my.reply.queue&quot;)</span><br><span class="line">public class MultiListenerBean &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public String thing2(Thing2 thing2) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public String cat(Cat cat) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public String hat(@Header(&quot;amqp_receivedRoutingKey&quot;) String rk, @Payload Hat hat) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler(isDefault = true)</span><br><span class="line">    public String defaultMethod(Object object) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Repeatable @RabbitListener<br>从版本1.6开始，@RabbitListener批注标记为@Repeatable。这意味着注释可以多次出现在相同的注释元素（方法或类）上。在这种情况下，将为每个注释创建一个单独的侦听器容器，每个注释容器都调用相同的侦听器@Bean。可重复的注释可以与Java 8或更高版本一起使用。使用Java 7或更早版本时，可以通过使用@RabbitListeners“容器”注释和@RabbitListener注释数组来达到相同的效果。</p><h4 id="3-3-2-17-代理-RabbitListener和泛型"><a href="#3-3-2-17-代理-RabbitListener和泛型" class="headerlink" title="3.3.2.17 代理@RabbitListener和泛型"></a>3.3.2.17 代理@RabbitListener和泛型</h4><p>如果要代理您的服务（例如，对于@Transactional），则在接口具有通用参数时，应牢记一些注意事项。考虑以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface TxService&lt;P&gt; &#123;</span><br><span class="line"></span><br><span class="line">   String handle(P payload, String header);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class TxServiceImpl implements TxService&lt;Foo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @RabbitListener(...)</span><br><span class="line">    public String handle(Foo foo, String rk) &#123;</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用通用接口和特定实现，您将不得不切换到CGLIB目标类代理，因为接口句柄方法的实际实现是桥接方法。在事务管理的情况下，通过使用注释选项来配置CGLIB的使用：@EnableTransactionManagement（proxyTargetClass = true）。在这种情况下，必须在实现中的目标方法上声明所有注释，如以下示例所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static class TxServiceImpl implements TxService&lt;Foo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Transactional</span><br><span class="line">    @RabbitListener(...)</span><br><span class="line">    public String handle(@Payload Foo foo, @Header(&quot;amqp_receivedRoutingKey&quot;) String rk) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-18-处理异常"><a href="#3-3-2-18-处理异常" class="headerlink" title="3.3.2.18 处理异常"></a>3.3.2.18 处理异常</h4><p>默认情况下，如果带注释的侦听器方法引发异常，则将其引发到容器中，并根据容器和代理的配置，将消息重新排队并重新传递，丢弃或路由到死信交换。什么也没有退还给发送者。</p><p>从2.0版开始，@RabbitListener批注具有两个新属性：errorHandler和returnExceptions。</p><p>这些默认情况下未配置。</p><p>您可以使用errorHandler来提供RabbitListenerErrorHandler实现的bean名称。此功能接口有一种方法，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface RabbitListenerErrorHandler &#123;</span><br><span class="line"></span><br><span class="line">    Object handleError(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt; message,</span><br><span class="line">              ListenerExecutionFailedException exception) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，您可以访问从容器接收的原始消息，由消息转换器生成的spring-messaging Message &lt;？&gt;对象以及由侦听器引发的异常（包装在ListenerExecutionFailedException中）。错误处理程序可以返回某些结果（作为答复发送），也可以引发原始异常或新异常（根据returnExceptions设置，将其抛出到容器中或返回给发送者）。</p><p>returnExceptions属性为true时，会将异常返回给发送方。异常包装在RemoteInvocationResult对象中。在发送方，有一个可用的RemoteInvocationAwareMessageConverterAdapter，如果将其配置到RabbitTemplate中，则会重新引发服务器端异常，并包装在AmqpRemoteException中。服务器异常的堆栈跟踪是通过合并服务器和客户端堆栈跟踪来综合的。</p><p>该机制通常仅适用于使用Java序列化的默认SimpleMessageConverter。异常通常不是“杰克逊友好的”，并且不能序列化为JSON。如果使用JSON，请考虑在引发异常时使用errorHandler返回其他一些Jackson友好的Error对象。</p><p>在版本2.1中，此接口从软件包o.s.amqp.rabbit.listener移至o.s.amqp.rabbit.listener.api。</p><p>从版本2.1.7开始，通道在消息头中可用。使用AcknowledgeMode.MANUAL时，这允许您确认或拒绝失败的消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object handleError(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt; message,</span><br><span class="line">          ListenerExecutionFailedException exception) &#123;</span><br><span class="line">              ...</span><br><span class="line">              message.getHeaders().get(AmqpHeaders.CHANNEL, Channel.class)</span><br><span class="line">                  .basicReject(message.getHeaders().get(AmqpHeaders.DELIVERY_TAG, Long.class),</span><br><span class="line">                               true);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-19-容器管理"><a href="#3-3-2-19-容器管理" class="headerlink" title="3.3.2.19 容器管理"></a>3.3.2.19 容器管理</h4><p>为注释创建的容器未在应用程序上下文中注册。您可以通过调用RabbitListenerEndpointRegistry bean上的getListenerContainers（）获得所有容器的集合。然后，您可以遍历此集合，例如，停止或启动所有容器，或在注册表本身上调用Lifecycle方法，这将在每个容器上调用操作。</p><p>您还可以通过使用单个容器的ID来获取对单个容器的引用，例如，使用上面的代码段创建的容器，使用getListenerContainer（String id）-例如，registry.getListenerContainer（“ multi”）。</p><p>从1.5.2版开始，您可以使用getListenerContainerIds（）获得已注册容器的ID值。</p><p>从1.5版开始，您现在可以将组分配给RabbitListener端点上的容器。这提供了一种获取对容器子集的引用的机制。添加组属性会导致将Collection 类型的Bean注册到具有组名的上下文中。</p><h4 id="3-3-2-20-批量接收消息-RabbitmqListener"><a href="#3-3-2-20-批量接收消息-RabbitmqListener" class="headerlink" title="3.3.2.20 批量接收消息 @RabbitmqListener"></a>3.3.2.20 批量接收消息 @RabbitmqListener</h4><p>当接收到一批消息时，通常由容器执行分批处理，并且一次仅用一条消息来调用侦听器。从2.2版开始，您可以将侦听器容器工厂和侦听器配置为在一个调用中接收整个批次，只需设置工厂的batchListener属性，并将方法有效负载参数设为List：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory());</span><br><span class="line">    factory.setBatchListener(true);</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.1&quot;)</span><br><span class="line">public void listen1(List&lt;Thing&gt; in) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.2&quot;)</span><br><span class="line">public void listen2(List&lt;Message&lt;Thing&gt;&gt; in) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将batchListener属性设置为true会自动关闭工厂创建的容器中的deBatchingEnabled容器属性（除非ConsumerBatchEnabled为true，请参见下文）。实际上，分批处理已从容器移动到侦听器适配器，并且适配器创建了传递到侦听器的列表。</p><p>启用批处理的工厂不能与多方法侦听器一起使用。</p><p>同样从2.2版开始。一次接收批处理的消息时，最后一条消息包含设置为true的布尔标头。可以通过将@Header（AmqpHeaders.LAST_IN_BATCH）布尔值last`参数添加到您的侦听器方法中来获取此标头。头是从MessageProperties.isLastInBatch（）映射的。此外，AmqpHeaders.BATCH_SIZE填充有每个消息片段中的批处理大小。</p><p>此外，新属性consumerBatchEnabled已添加到SimpleMessageListenerContainer。如果为真，则容器将创建一批消息，最大为batchSize；如果receiveTimeout过去了，但没有新消息到达，则将分批交付。如果收到生产者创建的批次，则将其分批并添加到消费者方批次；因此，实际传递的消息数可能超过batchSize，该大小代表从代理接收到的消息数。当ConsumerBatchEnabled为true时，deBatchingEnabled必须为true；否则为false。集装箱工厂将执行此要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory consumerBatchContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">    factory.setConsumerTagStrategy(consumerTagStrategy());</span><br><span class="line">    factory.setBatchListener(true); // configures a BatchMessageListenerAdapter</span><br><span class="line">    factory.setBatchSize(2);</span><br><span class="line">    factory.setConsumerBatchEnabled(true);</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当将consumerBatchEnabled与@RabbitListener一起使用时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;batch.1&quot;, containerFactory = &quot;consumerBatchContainerFactory&quot;)</span><br><span class="line">public void consumerBatch1(List&lt;Message&gt; amqpMessages) &#123;</span><br><span class="line">    this.amqpMessagesReceived = amqpMessages;</span><br><span class="line">    this.batch1Latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.2&quot;, containerFactory = &quot;consumerBatchContainerFactory&quot;)</span><br><span class="line">public void consumerBatch2(List&lt;org.springframework.messaging.Message&lt;Invoice&gt;&gt; messages) &#123;</span><br><span class="line">    this.messagingMessagesReceived = messages;</span><br><span class="line">    this.batch2Latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.3&quot;, containerFactory = &quot;consumerBatchContainerFactory&quot;)</span><br><span class="line">public void consumerBatch3(List&lt;Invoice&gt; strings) &#123;</span><br><span class="line">    this.batch3Strings = strings;</span><br><span class="line">    this.batch3Latch.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>第一个是使用未转换的原始org.springframework.amqp.core.Message调用的。</p></li><li><p>第二个是通过org.springframework.messaging.Message &lt;？&gt;调用的，其中包含转换后的有效负载和映射的标头/属性。</p></li><li><p>第三个调用是使用转换后的有效负载进行的，而无法访问标头/属性。</p></li></ul><p>您还可以添加一个通道参数，该参数通常在使用手动确认模式时使用。这对于第三个示例不是很有用，因为您无权访问delivery_tag属性。</p><h4 id="3-3-2-21-使用容器工厂"><a href="#3-3-2-21-使用容器工厂" class="headerlink" title="3.3.2.21 使用容器工厂"></a>3.3.2.21 使用容器工厂</h4><p>引入了侦听器容器工厂以支持@RabbitListener并向RabbitListenerEndpointRegistry注册容器，如“编程端点注册”中所述。</p><p>从2.1版开始，它们可用于创建任何侦听器容器-甚至是没有侦听器的容器（例如在Spring Integration中使用的容器）。当然，必须在启动容器之前添加侦听器。</p><p>有两种创建此类容器的方法：</p><ul><li><p>使用SimpleRabbitListenerEndpoint</p></li><li><p>创建后添加侦听器</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer factoryCreatedContainerSimpleListener(</span><br><span class="line">        SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) &#123;</span><br><span class="line">    SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();</span><br><span class="line">    endpoint.setQueueNames(&quot;queue.1&quot;);</span><br><span class="line">    endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    return rabbitListenerContainerFactory.createListenerContainer(endpoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer factoryCreatedContainerNoListener(</span><br><span class="line">        SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = rabbitListenerContainerFactory.createListenerContainer();</span><br><span class="line">    container.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    container.setQueueNames(&quot;test.no.listener.yet&quot;);</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论哪种情况，侦听器也可以是ChannelAwareMessageListener，因为它现在是MessageListener的子接口。</p><p>如果您希望创建多个具有相似属性的容器或使用预先配置的容器工厂（例如，Spring Boot自动配置提供的容器或同时使用两者），则这些技术很有用。</p><p>用这种方法创建的容器是普通的@Bean实例，并且未在RabbitListenerEndpointRegistry中注册。</p><h4 id="3-3-2-22-异步-RabbitListener返回类型"><a href="#3-3-2-22-异步-RabbitListener返回类型" class="headerlink" title="3.3.2.22 异步@RabbitListener返回类型"></a>3.3.2.22 异步@RabbitListener返回类型</h4><p>从2.1版开始，可以使用异步返回类型ListenableFuture &lt;？&gt;和Mono &lt;？&gt;指定@RabbitListener（和@RabbitHandler）方法，从而使答复以异步方式发送。</p><p>必须使用AcknowledgeMode.MANUAL配置侦听器容器工厂，以便消费者线程不会确认该消息。相反，异步完成将在异步操作完成时确认或拒绝消息。当异步结果有错误完成时，是否重新排队消息取决于抛出的异常类型，容器配置和容器错误处理程序。默认情况下，除非容器的defaultRequeueRejected属性设置为false（默认情况下为true），否则将重新排队该消息。如果异步结果是通过AmqpRejectAndDontRequeueException完成的，则不会重新排队该消息。如果容器的defaultRequeueRejected属性为false，则可以通过将Future的异常设置为InstantRequeueException来覆盖该值，然后将消息重新排队。如果在侦听器方法中发生了一些阻止创建异步结果对象的异常，则您必须捕获该异常并返回适当的返回对象，该对象将导致消息被确认或重新排队。</p><h4 id="3-3-2-23-线程和异步消费者"><a href="#3-3-2-23-线程和异步消费者" class="headerlink" title="3.3.2.23 线程和异步消费者"></a>3.3.2.23 线程和异步消费者</h4><p>当RabbitMQ Client传递新消息时，使用SimpleMessageListenerContainer中配置的TaskExecutor的线程来调用MessageListener。如果未配置，则使用SimpleAsyncTaskExecutor。如果使用池执行器，则需要确保池大小足以处理配置的并发。使用DirectMessageListenerContainer，可以直接在RabbitMQ客户端线程上调用MessageListener。在这种情况下，taskExecutor用于监视消费者的任务。</p><p>使用默认的SimpleAsyncTaskExecutor时，对于在其上调用侦听器的线程，在threadNamePrefix中使用侦听器容器beanName。这对于日志分析很有用。我们通常建议始终在日志记录附加程序配置中包括线程名称。通过容器上的taskExecutor属性专门提供TaskExecutor时，将按原样使用它，而无需进行修改。建议您使用类似的技术来命名由自定义TaskExecutor bean定义创建的线程，以帮助在日志消息中标识线程。</p><p>创建连接时，在CachingConnectionFactory中配置的Executor将传递到RabbitMQ Client中，并且其线程用于将新消息传递到侦听器容器。如果未配置，则客户端使用内部线程池执行程序，该执行程序的池大小为5。</p><p>使用DirectMessageListenerContainer，您需要确保连接工厂配置有任务执行程序，该任务执行程序具有足够的线程来支持使用该工厂的所有侦听器容器之间的所需并发。默认池大小只有五个。<br>RabbitMQ客户端使用ThreadFactory创建用于低级I / O（套接字）操作的线程。要修改此工厂，您需要配置基础RabbitMQ ConnectionFactory，如配置基础客户端连接工厂中所述。</p><h4 id="3-3-2-24-选择一个容器"><a href="#3-3-2-24-选择一个容器" class="headerlink" title="3.3.2.24 选择一个容器"></a>3.3.2.24 选择一个容器</h4><p>2.0版引入了DirectMessageListenerContainer（DMLC）。以前，只有SimpleMessageListenerContainer（SMLC）可用。 SMLC为每个消费者使用内部队列和专用线程。如果将一个容器配置为侦听多个队列，则使用相同的消费者线程来处理所有队列。并发是由并发消费和其他属性控制的。当消息从RabbitMQ客户端到达时，客户端线程将它们通过队列传递给使用方线程。之所以需要这种架构，是因为在RabbitMQ客户端的早期版本中，无法同时进行多个交付。较新版本的客户端具有修订的线程模型，现在可以支持并发。这允许引入DMLC，现在可以在RabbitMQ客户端线程上直接调用侦听器。因此，它的体系结构实际上比SMLC“简单”。但是，这种方法存在一些局限性，并且DMLC无法使用SMLC的某些功能。另外，并发由consumersPerQueue（和客户端库的线程池）控制。 parallelConsumers和关联的属性不适用于此容器。</p><p>以下功能可用于SMLC，但不可用于DMLC：</p><ul><li><p>batchSize：使用SMLC，您可以将其设置为控制在一个事务中传递多少消息或减少确认的数量，但是在失败后可能导致重复传递的数量增加。 （DMLC确实具有messagesPerAck，可用于减少确认，与batchSize和SMLC相同，但不能与事务一起使用-—每条消息都在单独的事务中传递和确认）。</p></li><li><p>ConsumerBatchEnabled：在消费者中批量处理离散消息；有关更多信息，请参见消息侦听器容器配置。</p></li><li><p>maxConcurrentConsumers和消费者缩放间隔或触发器-DMLC中没有自动缩放。但是，它确实允许您以编程方式更改consumersPerQueue属性，并相应地调整消费者。</p></li></ul><p>但是，DMLC比SMLC具有以下优点：</p><ul><li><p>在运行时添加和删除队列更加有效。使用SMLC，将重新启动整个消费者线程（取消并重新创建所有消费者）。使用DMLC，不会取消未受影响的消费者。</p></li><li><p>避免在RabbitMQ客户端线程和消费者线程之间进行上下文切换。</p></li><li><p>线程在消费者之间共享，而不是在SMLC中为每个消费者使用专用线程。但是，请参阅“线程和异步消费者”中有关连接工厂配置的重要说明。</p></li></ul><p>有关哪些配置属性适用于每个容器的信息，请参见消息侦听器容器配置。</p><h4 id="3-3-2-25-检测空闲的异步消费者"><a href="#3-3-2-25-检测空闲的异步消费者" class="headerlink" title="3.3.2.25 检测空闲的异步消费者"></a>3.3.2.25 检测空闲的异步消费者</h4><p>尽管效率很高，但异步消费者的一个问题是检测它们何时处于空闲状态—如果一段时间内没有消息到达，用户可能希望采取某些措施。</p><p>从1.6版开始，现在可以将侦听器容器配置为在一段时间没有消息传递的情况下发布ListenerContainerIdleEvent。当容器处于空闲状态时，每隔idleEventInterval毫秒发布一次事件。</p><p>要配置此功能，请在容器上设置idleEventInterval。以下示例显示了如何使用XML和Java（对于SimpleMessageListenerContainer和SimpleRabbitListenerContainerFactory）执行此操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">    ...</span><br><span class="line">    container.setIdleEventInterval(60000L);</span><br><span class="line">    ...</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">    factory.setIdleEventInterval(60000L);</span><br><span class="line">    ...</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-26-消费事件"><a href="#3-3-2-26-消费事件" class="headerlink" title="3.3.2.26 消费事件"></a>3.3.2.26 消费事件</h4><p>您可以通过实现ApplicationListener来捕获空闲事件-可以是常规侦听器，也可以是仅侦听仅接收此特定事件的侦听器。您还可以使用Spring Framework 4.2中引入的@EventListener。</p><p>以下示例将@RabbitListener和@EventListener组合到一个类中。您需要了解应用程序侦听器会获取所有容器的事件，因此，如果您要基于哪个容器处于空闲状态采取特定的操作，则可能需要检查侦听器ID。您也可以为此使用@EventListener条件。</p><p>事件具有四个属性：</p><ul><li><p>来源：侦听器容器实例</p></li><li><p>id：侦听器ID（或容器bean名称）</p></li><li><p>idleTime：事件发布时容器空闲的时间</p></li><li><p>queueNames：容器侦听的队列的名称</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Listener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(id=&quot;someId&quot;, queues=&quot;#&#123;queue.name&#125;&quot;)</span><br><span class="line">    public String listen(String foo) &#123;</span><br><span class="line">        return foo.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @EventListener(condition = &quot;event.listenerId == &apos;someId&apos;&quot;)</span><br><span class="line">    public void onApplicationEvent(ListenerContainerIdleEvent event) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件侦听器查看所有容器的事件。因此，在前面的示例中，我们根据侦听器ID缩小了接收到的事件的范围。</p><p>如果希望使用idle事件停止列表器容器，则不应在调用侦听器的线程上调用container.stop（）。这样做总是会导致延迟和不必要的日志消息。相反，您应该将事件移交给另一个线程，然后该线程可以停止容器。</p><h4 id="3-3-2-27-监视侦听器性能"><a href="#3-3-2-27-监视侦听器性能" class="headerlink" title="3.3.2.27 监视侦听器性能"></a>3.3.2.27 监视侦听器性能</h4><p>从2.2版开始，如果在类路径上检测到Micrometer且应用程序上下文中存在MeterRegistry，则侦听器容器将自动为侦听器创建和更新Micrometer Timer。可以通过将容器属性micrometerEnabled设置为false来禁用计时器。</p><p>维护两个计时器-一个用于成功调用侦听器，另一个用于失败。使用简单的MessageListener，每个配置的队列都有一对计时器。</p><p>这些计时器名为spring.rabbitmq.listener，具有以下标记：</p><ul><li><p>listenerId ：（侦听器ID或容器Bean名称）</p></li><li><p>queue ：（当consumerBatchEnabled为true时，一个简单侦听器的队列名称或已配置队列名称的列表-因为批处理可能包含来自多个队列的消息）</p></li><li><p>结果：成功或失败</p></li><li><p>异常：无或ListenerExecutionFailedException</p></li></ul><p>您可以使用micrometerTags容器属性添加其他标签。</p><h3 id="3-3-3-容器和broker命名的队列"><a href="#3-3-3-容器和broker命名的队列" class="headerlink" title="3.3.3 容器和broker命名的队列"></a>3.3.3 容器和broker命名的队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    return new Queue(&quot;&quot;, false, true, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer container() &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(cf());</span><br><span class="line">    container.setQueues(queue());</span><br><span class="line">    container.setMessageListener(m -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    container.setMissingQueuesFatal(false);</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重置连接并建立新连接后，新队列将获得新名称。由于在容器重启和重新声明队列之间存在竞争状态，因此将容器的missingQueuesFatal属性设置为false很重要，因为容器可能最初会尝试重新连接到旧队列。</p><h3 id="3-3-4-消息转换器"><a href="#3-3-4-消息转换器" class="headerlink" title="3.3.4 消息转换器"></a>3.3.4 消息转换器</h3><p>通常不建议依赖Java序列化。 JSON（JavaScript对象表示法）是一种更通用，更灵活且可跨不同语言和平台移植的替代方法。可以在任何RabbitTemplate实例上配置该转换器，以覆盖其对SimpleMessageConverter默认值的用法。 Jackson2JsonMessageConverter使用com.fasterxml.jackson 2.x库。以下示例配置了Jackson2JsonMessageConverter：</p><p>Jackson2JsonMessageConverter默认情况下使用DefaultClassMapper。类型信息将添加到MessageProperties（并从中检索）。如果入站邮件在MessageProperties中不包含类型信息，但是您知道期望的类型，则可以使用defaultType属性配置静态类型，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Jackson2JsonMessageConverter jsonMessageConverter() &#123;</span><br><span class="line">    Jackson2JsonMessageConverter jsonConverter = new Jackson2JsonMessageConverter();</span><br><span class="line">    jsonConverter.setClassMapper(classMapper());</span><br><span class="line">    return jsonConverter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public DefaultClassMapper classMapper() &#123;</span><br><span class="line">    DefaultClassMapper classMapper = new DefaultClassMapper();</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = new HashMap&lt;&gt;();</span><br><span class="line">    idClassMapping.put(&quot;thing1&quot;, Thing1.class);</span><br><span class="line">    idClassMapping.put(&quot;thing2&quot;, Thing2.class);</span><br><span class="line">    classMapper.setIdClassMapping(idClassMapping);</span><br><span class="line">    return classMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据发送系统添加到标头的类型信息，将入站消息转换为对象。</p><p>在1.6之前的版本中，如果不存在类型信息，则转换将失败。从版本1.6开始，如果缺少类型信息，则转换器将使用Jackson的默认值（通常是地图）来转换JSON。</p><p>同样，从版本1.6开始，当您使用@RabbitListener批注（在方法上）时，推断的类型信息将添加到MessageProperties。这使转换器可以转换为目标方法的参数类型。仅当存在一个没有注释的参数或带有@Payload注释的单个参数时，这才适用。在分析期间，将忽略Message类型的参数。</p><p>默认情况下，推断的类型信息将覆盖发送系统创建的入站TypeId和相关标头。这使接收系统可以自动转换为其他域对象。仅当参数类型是具体的（不是抽象或接口）或来自java.util包时才适用。在所有其他情况下，将使用TypeId和相关标头。在某些情况下，您可能希望覆盖默认行为并始终使用TypeId信息。例如，假设您有一个@RabbitListener，它带有Thing1参数，但消息中包含Thing2，它是Thing1的子类（具体）。推断的类型将不正确。要处理这种情况，请将Jackson2JsonMessageConverter的TypePrecedence属性设置为TYPE_ID，而不是默认的INFERRED。 （该属性实际上位于转换器的DefaultJackson2JavaTypeMapper上，但为方便起见，在转换器上提供了一个setter。）如果注入自定义类型映射器，则应改为在映射器上设置该属性。</p><p>从Message转换时，传入的MessageProperties.getContentType（）必须与JSON兼容（使用contentType.contains（“ json”）进行检查）。从2.2版开始，如果没有contentType属性，或者它具有默认值application / octet-stream，则假定为application / json。要恢复到以前的行为（返回未转换的字节[]），请将转换器的假定的SupportedContentType属性设置为false。如果不支持内容类型，则发出WARN日志消息“无法转换内容类型为[…]的传入消息”，并且按原样以字节[]形式返回message.getBody（）。因此，为了满足消费者方面的Jackson2JsonMessageConverter要求，生产者必须添加contentType消息属性，例如，作为application / json或text / x-json或通过使用Jackson2JsonMessageConverter自动设置标头。下面的清单显示了许多转换器调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(@Payload Thing1 thing1, @Header(&quot;amqp_consumerQueue&quot;) String queue) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, o.s.amqp.core.Message message) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, o.s.messaging.Message&lt;Foo&gt; message) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, String bar) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, o.s.messaging.Message&lt;?&gt; message) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>在上述清单的前四种情况下，转换器尝试转换为Thing1类型。第五个示例无效，因为我们无法确定哪个参数应接收消息有效负载。在第六个示例中，由于通用类型为通配符类型，因此应用了Jackson的默认值。</p><p>但是，您可以创建一个自定义转换器，并使用targetMethod消息属性来确定将JSON转换为哪种类型。</p><p>仅当在方法级别声明@RabbitListener批注时，才能实现此类型推断。对于类级别的@RabbitListener，转换后的类型用于选择要调用的@RabbitHandler方法。因此，基础结构提供了targetObject消息属性，您可以在自定义转换器中使用该属性来确定类型。</p><p>从1.6.11版本开始，Jackson2JsonMessageConverter以及DefaultJackson2JavaTypeMapper（DefaultClassMapper）提供了TrustedPackages选项来克服序列化小工具漏洞。默认情况下，为了实现向后兼容，Jackson2JsonMessageConverter信任所有软件包，即使用*作为选项。</p><h4 id="3-3-5-1-使用Spring-Data-映射接口"><a href="#3-3-5-1-使用Spring-Data-映射接口" class="headerlink" title="3.3.5.1 使用Spring Data 映射接口"></a>3.3.5.1 使用Spring Data 映射接口</h4><p>从2.2版开始，您可以将JSON转换为Spring Data Projection接口，而不是具体类型。这允许非常选择性和低耦合的数据绑定，包括从JSON文档中的多个位置查找值。例如，可以将以下接口定义为消息有效负载类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface SomeSample &#123;</span><br><span class="line"></span><br><span class="line">  @JsonPath(&#123; &quot;$.username&quot;, &quot;$.user.name&quot; &#125;)</span><br><span class="line">  String getUsername();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;projection&quot;)</span><br><span class="line">public void projection(SomeSample in) &#123;</span><br><span class="line">    String username = in.getUsername();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，访问器方法将用于在接收到的JSON文档中查找属性名称作为字段。 @JsonPath表达式允许自定义值查找，甚至定义多个JSON路径表达式，以便从多个位置查找值，直到表达式返回实际值为止。</p><p>要启用此功能，请在消息转换器上将useProjectionForInterfaces设置为true。您还必须将spring-data：spring-data-commons和com.jayway.jsonpath：json-path添加到类路径。</p><p>当用作@RabbitListener方法的参数时，接口类型将像往常一样自动传递给转换器。</p><h4 id="3-3-5-2-使用RabbitTemplate从消息转换"><a href="#3-3-5-2-使用RabbitTemplate从消息转换" class="headerlink" title="3.3.5.2 使用RabbitTemplate从消息转换"></a>3.3.5.2 使用RabbitTemplate从消息转换</h4><p>如前所述，类型信息在消息头中传送，以帮助从消息转换时的转换器。在大多数情况下，这可以正常工作。但是，使用泛型类型时，它只能转换简单对象和已知的“容器”对象（列表，数组和映射）。从2.0版开始，Jackson2JsonMessageConverter实现了SmartMessageConverter，它可以与带有ParameterizedTypeReference参数的新RabbitTemplate方法一起使用。这允许转换复杂的泛型类型，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thing1&lt;Thing2&lt;Cat, Hat&gt;&gt; thing1 =</span><br><span class="line">    rabbitTemplate.receiveAndConvert(new ParameterizedTypeReference&lt;Thing1&lt;Thing2&lt;Cat, Hat&gt;&gt;&gt;() &#123; &#125;);</span><br></pre></td></tr></table></figure><h4 id="3-3-5-3-MarshallingMessageConverter"><a href="#3-3-5-3-MarshallingMessageConverter" class="headerlink" title="3.3.5.3 MarshallingMessageConverter"></a>3.3.5.3 MarshallingMessageConverter</h4><p>另一个选项是MarshallingMessageConverter。它委托Spring OXM库实现Marshaller和Unmarshaller策略接口的实现。您可以在此处阅读有关该库的更多信息。就配置而言，最常见的是仅提供构造函数参数，因为Marshaller的大多数实现也实现了Unmarshaller。以下示例显示如何配置MarshallingMessageConverter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.amqp.rabbit.core.RabbitTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;rabbitConnectionFactory&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;messageConverter&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.springframework.amqp.support.converter.MarshallingMessageConverter&quot;&gt;</span><br><span class="line">            &lt;constructor-arg ref=&quot;someImplemenationOfMarshallerAndUnmarshaller&quot;/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-4-Jackson2XmlMessageConverter"><a href="#3-3-5-4-Jackson2XmlMessageConverter" class="headerlink" title="3.3.5.4 Jackson2XmlMessageConverter"></a>3.3.5.4 Jackson2XmlMessageConverter</h4><p>此类在版本2.1中引入，可用于在XML之间来回转换消息。</p><p>Jackson2XmlMessageConverter和Jackson2JsonMessageConverter具有相同的基类：AbstractJackson2MessageConverter。</p><p>引入AbstractJackson2MessageConverter类以替换已删除的类：AbstractJsonMessageConverter。</p><p>Jackson2XmlMessageConverter使用com.fasterxml.jackson 2.x库。</p><p>您可以使用它与Jackson2JsonMessageConverter相同的方式使用它，但是它支持XML而不是JSON。以下示例配置了Jackson2JsonMessageConverter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;xmlConverterWithDefaultType&quot;</span><br><span class="line">        class=&quot;org.springframework.amqp.support.converter.Jackson2XmlMessageConverter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;classMapper&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.springframework.amqp.support.converter.DefaultClassMapper&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;defaultType&quot; value=&quot;foo.PurchaseOrder&quot;/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-5-ContentTypeDelegatingMessageConverter"><a href="#3-3-5-5-ContentTypeDelegatingMessageConverter" class="headerlink" title="3.3.5.5 ContentTypeDelegatingMessageConverter"></a>3.3.5.5 ContentTypeDelegatingMessageConverter</h4><p>此类在版本1.4.2中引入，并允许基于MessageProperties中的内容类型属性委派到特定的MessageConverter。默认情况下，如果没有contentType属性或没有与配置的转换器匹配的值，它将委派给SimpleMessageConverter。以下示例配置ContentTypeDelegatingMessageConverter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;contentTypeConverter&quot; class=&quot;ContentTypeDelegatingMessageConverter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;delegates&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;application/json&quot; value-ref=&quot;jsonMessageConverter&quot; /&gt;</span><br><span class="line">            &lt;entry key=&quot;application/xml&quot; value-ref=&quot;xmlMessageConverter&quot; /&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-6-Java-反序列化"><a href="#3-3-5-6-Java-反序列化" class="headerlink" title="3.3.5.6 Java 反序列化"></a>3.3.5.6 Java 反序列化</h4><p>从不受信任的来源反序列化Java对象时，可能存在一个漏洞。</p><p>如果您接受内容类型为application / x-java-serialized-object的不受信任来源的消息，则应考虑配置允许反序列化哪些包和类。当它配置为隐式或通过配置使用DefaultDeserializer时，这对SimpleMessageConverter和SerializerMessageConverter均适用。</p><p>默认情况下，白名单为空，这意味着所有类都将反序列化。</p><p>您可以设置模式列表，例如thing1。，thing1.thing2.Cat或.MySafeClass。</p><p>顺序检查模式，直到找到匹配项。如果不匹配，则抛出SecurityException。</p><p>您可以使用这些转换器上的whiteListPatterns属性设置模式。</p><h4 id="3-3-5-7-消息属性转换"><a href="#3-3-5-7-消息属性转换" class="headerlink" title="3.3.5.7 消息属性转换"></a>3.3.5.7 消息属性转换</h4><p>MessagePropertiesConverter策略接口用于在Rabbit Client BasicProperties和Spring AMQP MessageProperties之间进行转换。默认实现（DefaultMessagePropertiesConverter）通常可以满足大多数目的，但是您可以根据需要实现自己的实现。当大小不大于1024字节时，默认属性转换器将LongString类型的BasicProperties元素转换为String实例。较大的LongString实例不会转换（请参阅下一段）。可以使用构造函数参数来覆盖此限制。</p><p>从1.6版开始，长于长字符串限制（默认值：1024）的标头现在默认情况下由DefaultMessagePropertiesConverter保留为LongString实例。您可以通过getBytes []，toString（）或getStream（）方法访问内容。</p><p>以前，DefaultMessagePropertiesConverter将此类标头“转换”为DataInputStream（实际上它只是引用了LongString实例的DataInputStream）。在输出时，未转换此标头（通过在流上调用toString（）转换为String除外，例如java.io.DataInputStream@1d057a39）。</p><p>现在，大型输入LongString标头现在也可以在输出中正确“转换”（默认情况下）。</p><p>提供了一个新的构造函数，使您可以配置转换器以像以前一样工作。以下清单显示了Javadoc注释和方法声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Construct an instance where LongStrings will be returned</span><br><span class="line"> * unconverted or as a java.io.DataInputStream when longer than this limit.</span><br><span class="line"> * Use this constructor with &apos;true&apos; to restore pre-1.6 behavior.</span><br><span class="line"> * @param longStringLimit the limit.</span><br><span class="line"> * @param convertLongLongStrings LongString when false,</span><br><span class="line"> * DataInputStream when true.</span><br><span class="line"> * @since 1.6</span><br><span class="line"> */</span><br><span class="line">public DefaultMessagePropertiesConverter(int longStringLimit, boolean convertLongLongStrings) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>同样从1.6版开始，已将一个名为correlationIdString的新属性添加到MessageProperties。以前，在RabbitMQ客户端使用的BasicProperties之间来回转换时，执行了不必要的byte [] &lt;→String转换，因为MessageProperties.correlationId是byte []，但是BasicProperties使用String。 （最终，RabbitMQ客户端使用UTF-8将String转换为字节以放入协议消息中）。</p><p>为了提供最大的向后兼容性，已将一个名为correlationIdPolicy的新属性添加到DefaultMessagePropertiesConverter。这需要一个DefaultMessagePropertiesConverter.CorrelationIdPolicy枚举参数。默认情况下，它设置为BYTES，它复制了以前的行为。</p><p>对于入站消息：</p><ul><li><p>STRING：仅映射relatedIdString属性</p></li><li><p>BYTES：仅关联ID属性被映射</p></li><li><p>BOTH：映射两个属性</p></li></ul><p>对于出站消息：</p><ul><li><p>STRING：仅映射relatedIdString属性</p></li><li><p>BYTES：仅关联ID属性被映射</p></li><li><p>BOTH：都考虑了这两个属性，其中String属性优先</p></li></ul><p>同样从1.6版开始，入站deliveryMode属性不再映射到MessageProperties.deliveryMode。而是将其映射到MessageProperties.receivedDeliveryMode。此外，入站userId属性不再映射到MessageProperties.userId。而是将其映射到MessageProperties.receivedUserId。如果将同一MessageProperties对象用于出站消息，则这些更改是为了避免这些属性的意外传播。</p><p>从2.2版开始，DefaultMessagePropertiesConverter使用getName（）而不是toString（）转换类型为Class &lt;？&gt;类型的任何自定义headers。这避免了使用应用程序必须从toString（）表示形式中解析类名称的麻烦。对于滚动升级，您可能需要更改消费者以了解两种格式，直到所有生产者都升级为止。</p><h3 id="3-3-6-修改消息-压缩等"><a href="#3-3-6-修改消息-压缩等" class="headerlink" title="3.3.6 修改消息-压缩等"></a>3.3.6 修改消息-压缩等</h3><p>存在许多扩展点。它们使您可以在将消息发送到RabbitMQ之前或在收到消息之后立即对其进行一些处理。</p><p>在消息转换器中可以看到，这样的扩展点之一是在AmqpTemplate convertAndReceive操作中，您可以在其中提供MessagePostProcessor。例如，在转换POJO之后，MessagePostProcessor允许您在Message上设置自定义标头或属性。</p><p>从版本1.4.2开始，已将其他扩展点添加到RabbitTemplate中-setBeforePublishPostPostors（）和setAfterReceivePostProcessors（）。第一个使后处理器能够在发送到RabbitMQ之前立即运行。使用批处理（请参阅批处理）时，将在组装批处理之后以及发送批处理之前调用此方法。收到消息后立即调用第二个。</p><p>这些扩展点用于压缩等功能，并为此提供了多个MessagePostProcessor实现。 GZipPostProcessor，ZipPostProcessor和DeflaterPostProcessor在发送前先压缩消息，而GUnzipPostProcessor，UnzipPostProcessor和InflaterPostProcessor则对收到的消息进行解压缩。</p><p>从版本2.1.5开始，可以使用copyProperties = true选项配置GZipPostProcessor，以复制原始消息属性。默认情况下，出于性能原因，将重用这些属性，并使用压缩内容编码和可选的MessageProperties.SPRING_AUTO_DECOMPRESS header对其进行修改。如果您保留对原始出站消息的引用，则其属性也会更改。因此，如果您的应用程序使用这些消息后处理器保留了出站消息的副本，请考虑打开copyProperties选项。<br>类似地，SimpleMessageListenerContainer也具有setAfterReceivePostProcessors（）方法，该方法允许在容器接收到消息之后执行解压缩。</p><p>从版本2.1.4开始，将addBeforePublishPostPostors（）和addAfterReceivePostProcessors（）添加到RabbitTemplate中，以允许将新的后处理器分别追加到发布前和接收后处理器的列表中。还提供了删除后处理器的方法。同样，AbstractMessageListenerContainer还添加了addAfterReceivePostProcessors（）和removeAfterReceivePostProcessor（）方法。有关更多详细信息，请参见RabbitTemplate和AbstractMessageListenerContainer的Javadoc。</p><h3 id="3-3-7-请求和回复消息"><a href="#3-3-7-请求和回复消息" class="headerlink" title="3.3.7 请求和回复消息"></a>3.3.7 请求和回复消息</h3><p>AmqpTemplate还提供了各种sendAndReceive方法，它们接受与前面针对单向发送操作（交换，routingKey和Message）所述的相同参数选项。这些方法对于请求-答复方案非常有用，因为它们在发送之前处理必需的答复属性的配置，并且可以在为此目的内部创建的排他队列上侦听答复消息。</p><p>将MessageConverter应用于请求和答复时，也可以使用类似的请求-答复方法。这些方法被称为convertSendAndReceive。有关更多详细信息，请参见AmqpTemplate的Javadoc。</p><p>从1.5.0版开始，每个sendAndReceive方法变体都有一个采用CorrelationData的重载版本。与正确配置的连接工厂一起，这可以使发布者收到操作的发送方确认。有关更多信息，请参见发布者确认和退货以及RabbitOperations的Javadoc。</p><p>从2.0版开始，这些方法有一些变体（convertSendAndReceiveAsType），它们带有一个附加的ParameterizedTypeReference参数来转换复杂的返回类型。模板必须配置有SmartMessageConverter。有关更多信息，请参见使用RabbitTemplate从消息转换。</p><p>从2.1版开始，您可以使用noLocalReplyConsumer选项配置RabbitTemplate来控制用于回复消费者的noLocal标志。默认情况下为false。</p><h4 id="3-3-7-1-回复超时"><a href="#3-3-7-1-回复超时" class="headerlink" title="3.3.7.1 回复超时"></a>3.3.7.1 回复超时</h4><p>默认情况下，发送和接收方法在五秒钟后超时并返回null。您可以通过设置replyTimeout属性来修改此行为。从版本1.5开始，如果将强制属性设置为true（或对于特定消息，则强制表达式的计算结果为true），如果无法将消息传递到队列，则会引发AmqpMessageReturnedException。此异常具有returnMessage，replyCode和replyText属性，以及用于发送的exchange和routingKey。</p><p>此功能使用发布者的退货。您可以通过在CachingConnectionFactory上将PublisherReturns设置为true来启用它（请参阅发布者确认和返回）。另外，您一定不能在RabbitTemplate中注册自己的ReturnCallback。<br>从版本2.1.2开始，添加了replyTimedOut方法，使超时可以通知子类，以便它们可以清除任何保留的状态。</p><p>从2.0.11和2.1.3版本开始，使用默认的DirectReplyToMessageListenerContainer时，可以通过设置模板的replyErrorHandler属性来添加错误处理程序。对于任何失败的传递，都会调用此错误处理程序，例如延迟答复和收到的没有相关标头的消息。传入的异常是ListenerExecutionFailedException，它具有failMessage属性。</p><h4 id="3-3-7-2-RabbitMQ直接回复"><a href="#3-3-7-2-RabbitMQ直接回复" class="headerlink" title="3.3.7.2 RabbitMQ直接回复"></a>3.3.7.2 RabbitMQ直接回复</h4><p>从3.4.0版本开始，RabbitMQ服务器支持直接回复。这消除了固定答复队列的主要原因（以避免为每个请求创建临时队列）。从Spring AMQP版本1.4.1开始，默认情况下使用直接回复（如果服务器支持），而不是创建临时回复队列。如果没有提供replyQueue（或者设置了名为amq.rabbitmq.reply-to的名称），RabbitTemplate会自动检测是否支持直接回复，然后使用直接回复还是使用临时回复队列。使用直接答复时，不需要答复侦听器，并且不应对其进行配置。<br>命名队列（amq.rabbitmq.reply-to除外）仍支持回复侦听器，从而允许控制回复并发等等。</p><p>从1.6版开始，如果您希望为每个答复使用一个临时的，排他的，自动删除队列，请将useTemporaryReplyQueues属性设置为true。如果设置了ReplyAddress，则将忽略此属性。</p><p>您可以通过将RabbitTemplate子类化并覆盖useDirectReplyTo（）来检查其他条件，从而更改指示是否使用直接答复的条件。发送第一个请求时，该方法仅被调用一次。</p><p>在2.0版之前，RabbitTemplate为每个请求创建一个新消费者，并在收到答复（或超时）时取消该消费者。现在，该模板改为使用DirectReplyToMessageListenerContainer，让消费者重新使用。模板仍然负责将回复相关联，因此没有延迟回复发送给其他发件人的危险。如果要还原为以前的行为，请将useDirectReplyToContainer（使用XML配置时直接回复到容器）属性设置为false。</p><p>AsyncRabbitTemplate没有此类选项。使用直接回复时，它始终使用DirectReplyToContainer进行回复。</p><h4 id="3-3-7-3-消息与回复队列的关联"><a href="#3-3-7-3-消息与回复队列的关联" class="headerlink" title="3.3.7.3 消息与回复队列的关联"></a>3.3.7.3 消息与回复队列的关联</h4><p>使用固定答复队列（amq.rabbitmq.reply-to除外）时，必须提供相关数据，以便将答复与请求相关。请参阅RabbitMQ远程过程调用（RPC）。默认情况下，标准的correlationId属性用于保存相关数据。但是，如果希望使用自定义属性来保存关联数据，则可以在上设置correlation-key属性。将该属性显式设置为correlationId与省略该属性相同。客户端和服务器必须将相同的标头用于关联数据。</p><p>Spring AMQP 1.1版对此数据使用了一个名为spring_reply_correlation的自定义属性。如果您希望使用当前版本恢复到此行为（可能是为了保持与使用1.1的其他应用程序的兼容性），则必须将属性设置为spring_reply_correlation。<br>默认情况下，模板会生成自己的关联ID（忽略任何用户提供的值）。如果您希望使用自己的关联ID，请将RabbitTemplate实例的userCorrelationId属性设置为true。</p><p>相关ID必须唯一，以避免针对请求返回错误回复的可能性。</p><h4 id="3-3-7-4-回复侦听容器"><a href="#3-3-7-4-回复侦听容器" class="headerlink" title="3.3.7.4 回复侦听容器"></a>3.3.7.4 回复侦听容器</h4><p>当使用3.4.0之前的RabbitMQ版本时，每个答复都会使用一个新的临时队列。但是，可以在模板上配置单个答复队列，这样可以提高效率，还可以在该队列上设置参数。但是，在这种情况下，您还必须提供一个子元素。此元素为答复队列提供一个侦听器容器，其中模板为侦听器。元素上允许上允许的所有消息侦听器容器配置属性，但从模板的配置继承的connection-factory和message-converter除外。</p><p>如果您运行应用程序的多个实例或使用多个RabbitTemplate实例，则必须为每个实例使用唯一的答复队列。 RabbitMQ无法从队列中选择消息，因此，如果它们都使用相同的队列，则每个实例都将争夺答复，而不一定会收到自己的消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:template id=&quot;amqpTemplate&quot;</span><br><span class="line">        connection-factory=&quot;connectionFactory&quot;</span><br><span class="line">        reply-queue=&quot;replies&quot;</span><br><span class="line">        reply-address=&quot;replyEx/routeReply&quot;&gt;</span><br><span class="line">    &lt;rabbit:reply-listener/&gt;</span><br><span class="line">&lt;/rabbit:template&gt;</span><br></pre></td></tr></table></figure><p>容器和模板共享连接工厂时，它们不共享通道。因此，请求和答复不在同一事务中执行（如果是事务性的）。<br>在1.5.0之前的版本中，reply-address属性不可用。始终使用默认交换和答复队列名称作为路由关键字来路由答复。这仍然是默认设置，但是您现在可以指定新的reply-address属性。回复地址可以包含格式为 / 的地址，并且回复被路由到指定的交换机，并被路由到与路由键绑定的队列。回复地址优先于回复队列。当仅使用回复地址时，必须将配置为单独的组件。回复地址和回复队列（或上的queues属性）必须在逻辑上引用同一队列。</p><p>通过这种配置，SimpleListenerContainer用于接收答复，其中RabbitTemplate为MessageListener。如上例所示，当使用命名空间元素定义模板时，解析器将模板中的容器和连线定义为侦听器。</p><p>当模板不使用固定的ReplyQueue时（或使用直接答复者-参见RabbitMQ直接答复者），则不需要侦听器容器。使用RabbitMQ 3.4.0或更高版本时，首选直接答复机制。</p><p>如果将RabbitTemplate定义为或使用@Configuration类将其定义为@Bean，或者在以编程方式创建模板时，则需要自己定义并连接答复侦听器容器。如果您无法执行此操作，则模板将永远不会收到答复，并最终超时并返回null作为对sendAndReceive方法的调用的答复。</p><p>从1.5版开始，RabbitTemplate会检测它是否已配置为MessageListener来接收回复。否则，尝试发送和接收带有回复地址的消息失败，并出现IllegalStateException（因为从未收到回复）。</p><p>此外，如果使用简单的ReplyAddress（队列名称），则回复侦听器容器将验证它正在侦听具有相同名称的队列。如果回复地址是交换和路由密钥，并且写入了调试日志消息，则无法执行此检查。</p><p>自己连接回复侦听器和模板时，务必确保模板的ReplyAddress和容器的队列（或queueNames）属性引用相同的队列。该模板将回复地址插入到出站邮件的ReplyTo属性中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;amqpTemplate&quot; class=&quot;org.springframework.amqp.rabbit.core.RabbitTemplate&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;exchange&quot; value=&quot;foo.exchange&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;routingKey&quot; value=&quot;foo&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;replyQueue&quot; ref=&quot;replyQ&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;replyTimeout&quot; value=&quot;600000&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;useDirectReplyToContainer&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean class=&quot;org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;queues&quot; ref=&quot;replyQ&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;messageListener&quot; ref=&quot;amqpTemplate&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;replyQ&quot; name=&quot;my.reply.queue&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RabbitTemplate amqpTemplate() &#123;</span><br><span class="line">   RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());</span><br><span class="line">   rabbitTemplate.setMessageConverter(msgConv());</span><br><span class="line">   rabbitTemplate.setReplyAddress(replyQueue().getName());</span><br><span class="line">   rabbitTemplate.setReplyTimeout(60000);</span><br><span class="line">   rabbitTemplate.setUseDirectReplyToContainer(false);</span><br><span class="line">   return rabbitTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer replyListenerContainer() &#123;</span><br><span class="line">   SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</span><br><span class="line">   container.setConnectionFactory(connectionFactory());</span><br><span class="line">   container.setQueues(replyQueue());</span><br><span class="line">   container.setMessageListener(amqpTemplate());</span><br><span class="line">   return container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue replyQueue() &#123;</span><br><span class="line">   return new Queue(&quot;my.reply.queue&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此测试用例中，显示了一个RabbitTemplate的完整示例，该示例连接了固定的答复队列以及处理请求并返回答复的“远程”侦听器容器。</p><p>当回复超时（replyTimeout）时，sendAndReceive（）方法将返回null。</p><p>在1.3.6版之前，仅记录对超时消息的最新答复。现在，如果收到延迟答复，则拒绝该答复（模板将引发AmqpRejectAndDontRequeueException）。如果将答复队列配置为将拒绝的邮件发送到死信交换，则可以检索答复以进行以后的分析。为此，请使用与回复队列名称相同的路由键将队列绑定到已配置的死信交换。</p><p>有关配置无效字母的更多信息，请参见RabbitMQ无效字母文档。您还可以查看FixedReplyQueueDeadLetterTests测试用例的示例。</p><h4 id="3-3-7-5-AsyncRabbitTemplate"><a href="#3-3-7-5-AsyncRabbitTemplate" class="headerlink" title="3.3.7.5 AsyncRabbitTemplate"></a>3.3.7.5 AsyncRabbitTemplate</h4><p>1.6版引入了AsyncRabbitTemplate。这具有与AmqpTemplate上相似的sendAndReceive（和convertSendAndReceive）方法。但是，它们不是阻塞而是返回一个ListenableFuture。</p><p>sendAndReceive方法返回RabbitMessageFuture。 convertSendAndReceive方法返回RabbitConverterFuture。</p><p>您可以稍后通过将来调用get（）来同步检索结果，也可以注册一个与结果异步调用的回调。下面的清单显示了两种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private AsyncRabbitTemplate template;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public void doSomeWorkAndGetResultLater() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ListenableFuture&lt;String&gt; future = this.template.convertSendAndReceive(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">    // do some more work</span><br><span class="line"></span><br><span class="line">    String reply = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        reply = future.get();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ExecutionException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doSomeWorkAndGetResultAsync() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    RabbitConverterFuture&lt;String&gt; future = this.template.convertSendAndReceive(&quot;foo&quot;);</span><br><span class="line">    future.addCallback(new ListenableFutureCallback&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(String result) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(Throwable ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了mandatory，并且消息无法传递，则将来会引发ExecutionException，其原因是AmqpMessageReturnedException，该异常封装了返回的消息和有关返回的信息。</p><p>如果设置了enableConfirms，则future将具有一个名为Confirm的属性，该属性本身是一个ListenableFuture ，其中true表示成功发布。如果确认未来为假，RabbitFuture具有另一个名为nackCause的属性，其中包含失败的原因（如果有）。</p><p>如果在回复后收到确认，则发布者确认将被丢弃，因为回复表示成功发布。<br>您可以在模板上设置receiveTimeout属性以使答复超时（默认为30000-30秒）。如果发生超时，则将来会通过AmqpReplyTimeoutException完成。</p><p>该模板实现SmartLifecycle。在有挂起的答复时停止模板会导致挂起的Future实例被取消。</p><p>从2.0版开始，异步模板现在支持直接答复而不是配置的答复队列。要启用此功能，请使用以下构造函数之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public AsyncRabbitTemplate(ConnectionFactory connectionFactory, String exchange, String routingKey)</span><br><span class="line"></span><br><span class="line">public AsyncRabbitTemplate(RabbitTemplate template)</span><br></pre></td></tr></table></figure><p>请参阅RabbitMQ直接答复以将直接答复与同步RabbitTemplate一起使用。</p><p>2.0版引入了这些方法的变体（convertSendAndReceiveAsType），这些变体采用附加的ParameterizedTypeReference参数来转换复杂的返回类型。您必须使用SmartMessageConverter配置基础RabbitTemplate。有关更多信息，请参见使用RabbitTemplate从消息转换。</p><h4 id="3-3-7-6-Spring-Remoting-with-AMQP"><a href="#3-3-7-6-Spring-Remoting-with-AMQP" class="headerlink" title="3.3.7.6 Spring Remoting with AMQP"></a>3.3.7.6 Spring Remoting with AMQP</h4><p>Spring框架具有常规的远程处理功能，允许使用各种传输方式的远程过程调用（RPC）。 Spring-AMQP通过客户端上的AmqpProxyFactoryBean和服务器上的AmqpInvokerServiceExporter支持类似的机制。这提供了基于AMQP的RPC。在客户端，如前所述使用RabbitTemplate。在服务器端，调用程序（配置为MessageListener）接收消息，调用配置的服务，并使用入站消息的ReplyTo信息返回答复。</p><p>您可以将客户端工厂bean注入任何bean（通过使用其serviceInterface）。然后，客户端可以调用代理上的方法，从而通过AMQP进行远程执行。</p><p>对于默认的MessageConverter实例，方法参数和返回值必须是Serializable实例。<br>在服务器端，AmqpInvokerServiceExporter同时具有AmqpTemplate和MessageConverter属性。当前，未使用模板的MessageConverter。如果需要提供自定义消息转换器，则应通过设置messageConverter属性来提供它。在客户端，您可以向AmqpTemplate添加自定义消息转换器，该转换器通过使用其amqpTemplate属性提供给AmqpProxyFactoryBean。</p><p>以下清单显示了示例客户端和服务器配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;client&quot;</span><br><span class="line">class=&quot;org.springframework.amqp.remoting.client.AmqpProxyFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name=&quot;amqpTemplate&quot; ref=&quot;template&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;serviceInterface&quot; value=&quot;foo.ServiceInterface&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:template id=&quot;template&quot; connection-factory=&quot;connectionFactory&quot; reply-timeout=&quot;2000&quot;</span><br><span class="line">routing-key=&quot;remoting.binding&quot; exchange=&quot;remoting.exchange&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:admin connection-factory=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue name=&quot;remoting.queue&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:direct-exchange name=&quot;remoting.exchange&quot;&gt;</span><br><span class="line">&lt;rabbit:bindings&gt;</span><br><span class="line">&lt;rabbit:binding queue=&quot;remoting.queue&quot; key=&quot;remoting.binding&quot; /&gt;</span><br><span class="line">&lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:direct-exchange&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;listener&quot;</span><br><span class="line">class=&quot;org.springframework.amqp.remoting.service.AmqpInvokerServiceExporter&quot;&gt;</span><br><span class="line">&lt;property name=&quot;serviceInterface&quot; value=&quot;foo.ServiceInterface&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;service&quot; ref=&quot;service&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;amqpTemplate&quot; ref=&quot;template&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;service&quot; class=&quot;foo.ServiceImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:template id=&quot;template&quot; connection-factory=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue name=&quot;remoting.queue&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot;&gt;</span><br><span class="line">&lt;rabbit:listener ref=&quot;listener&quot; queue-names=&quot;remoting.queue&quot; /&gt;</span><br><span class="line">&lt;/rabbit:listener-container&gt;</span><br></pre></td></tr></table></figure><p>AmqpInvokerServiceExporter只能处理格式正确的消息，例如从AmqpProxyFactoryBean发送的消息。如果收到无法解释的消息，则会发送序列化的RuntimeException作为答复。如果邮件没有replyToAddress属性，则如果未配置死信交换，则邮件将被拒绝并永久丢失。</p><p>默认情况下，如果无法传递请求消息，则调用线程最终超时，并引发RemoteProxyFailureException。默认情况下，超时为五秒。您可以通过在RabbitTemplate上设置ReplyTimeout属性来修改该持续时间。从版本1.5开始，将强制性属性设置为true并在连接工厂上启用返回（请参见发布者确认和返回），调用线程将引发AmqpMessageReturnedException。有关更多信息，请参见回复超时。</p><h3 id="3-3-8-配置Broker"><a href="#3-3-8-配置Broker" class="headerlink" title="3.3.8 配置Broker"></a>3.3.8 配置Broker</h3><p>AMQP规范描述了如何使用协议在代理上配置队列，交换和绑定。这些操作（可从0.8规范及更高版本移植）在org.springframework.amqp.core软件包的AmqpAdmin界面中。该类的RabbitMQ实现是RabbitAdmin，位于org.springframework.amqp.rabbit.core包中。</p><p>AmqpAdmin界面基于使用Spring AMQP域抽象，并在以下列表中显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface AmqpAdmin &#123;</span><br><span class="line"></span><br><span class="line">    // Exchange Operations</span><br><span class="line"></span><br><span class="line">    void declareExchange(Exchange exchange);</span><br><span class="line"></span><br><span class="line">    void deleteExchange(String exchangeName);</span><br><span class="line"></span><br><span class="line">    // Queue Operations</span><br><span class="line"></span><br><span class="line">    Queue declareQueue();</span><br><span class="line"></span><br><span class="line">    String declareQueue(Queue queue);</span><br><span class="line"></span><br><span class="line">    void deleteQueue(String queueName);</span><br><span class="line"></span><br><span class="line">    void deleteQueue(String queueName, boolean unused, boolean empty);</span><br><span class="line"></span><br><span class="line">    void purgeQueue(String queueName, boolean noWait);</span><br><span class="line"></span><br><span class="line">    // Binding Operations</span><br><span class="line"></span><br><span class="line">    void declareBinding(Binding binding);</span><br><span class="line"></span><br><span class="line">    void removeBinding(Binding binding);</span><br><span class="line"></span><br><span class="line">    Properties getQueueProperties(String queueName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getQueueProperties（）方法返回有关队列的一些有限信息（消息计数和消费者计数）。返回的属性的键在RabbitTemplate中可以作为常量使用（QUEUE_NAME，QUEUE_MESSAGE_COUNT和QUEUE_CONSUMER_COUNT）。 RabbitMQ REST API在QueueInfo对象中提供了更多信息。</p><p>no-argclarifyQueue（）方法使用自动生成的名称定义代理上的队列。此自动生成的队列的其他属性是Exclusive = true，autoDelete = true和持久= false。</p><p>defineQueue（Queue queue）方法接受一个Queue对象，并返回已声明队列的名称。如果提供的Queue的name属性为空字符串，则代理将使用生成的名称声明队列。该名称将返回给呼叫者。该名称也被添加到队列的actualName属性中。您只能通过直接调用RabbitAdmin来以编程方式使用此功能。在应用程序上下文中以声明方式定义队列时，当管理员使用自动声明时，可以将name属性设置为“”（空字符串）。然后，代理创建名称。从2.1版开始，侦听器容器可以使用这种类型的队列。有关更多信息，请参见以容器和代理命名的队列。</p><p>这与AnonymousQueue相反，在AnonymousQueue中，框架生成唯一（UUID）名称，并将持久性设置为false和Exclusive，将autoDelete设置为true。名称属性为空（或缺少）的始终会创建一个AnonymousQueue。</p><p>请参阅AnonymousQueue以了解为什么AnonymousQueue优先于代理生成的队列名称，以及如何控制名称格式。从版本2.1开始，默认情况下，匿名队列使用参数x-queue-master-locator声明为本地客户端声明。这样可以确保在与应用程序连接的节点上声明队列。声明性队列必须具有固定的名称，因为它们可能在上下文中的其他地方被引用，例如在以下示例中所示的侦听器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:listener-container&gt;</span><br><span class="line">    &lt;rabbit:listener ref=&quot;listener&quot; queue-names=&quot;#&#123;someQueue.name&#125;&quot; /&gt;</span><br><span class="line">&lt;/rabbit:listener-container&gt;</span><br></pre></td></tr></table></figure><p>该接口的RabbitMQ实现是RabbitAdmin，当使用Spring XML进行配置时，它类似于以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:admin id=&quot;amqpAdmin&quot; connection-factory=&quot;connectionFactory&quot;/&gt;</span><br></pre></td></tr></table></figure><p>当CachingConnectionFactory缓存模式为CHANNEL（默认）时，RabbitAdmin实现将自动延迟声明在同一ApplicationContext中声明的队列，交换和绑定。一旦向代理打开连接，便声明这些组件。有一些名称空间功能使此操作非常方便。例如，在Stocks示例应用程序中，我们具有以下功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;tradeQueue&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;marketDataQueue&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;fanout-exchange name=&quot;broadcast.responses&quot;</span><br><span class="line">                 xmlns=&quot;http://www.springframework.org/schema/rabbit&quot;&gt;</span><br><span class="line">    &lt;bindings&gt;</span><br><span class="line">        &lt;binding queue=&quot;tradeQueue&quot;/&gt;</span><br><span class="line">    &lt;/bindings&gt;</span><br><span class="line">&lt;/fanout-exchange&gt;</span><br><span class="line"></span><br><span class="line">&lt;topic-exchange name=&quot;app.stock.marketdata&quot;</span><br><span class="line">                xmlns=&quot;http://www.springframework.org/schema/rabbit&quot;&gt;</span><br><span class="line">    &lt;bindings&gt;</span><br><span class="line">        &lt;binding queue=&quot;marketDataQueue&quot; pattern=&quot;$&#123;stocks.quote.pattern&#125;&quot;/&gt;</span><br><span class="line">    &lt;/bindings&gt;</span><br><span class="line">&lt;/topic-exchange&gt;</span><br></pre></td></tr></table></figure><p>在前面的示例中，我们使用匿名队列（实际上，在内部，只是具有由框架而不是由代理生成的名称的队列），并通过ID引用它们。我们还可以使用显式名称声明队列，这些队列还用作上下文中其bean定义的标识符。以下示例使用明确的名称配置队列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;stocks.trade.queue&quot;/&gt;</span><br></pre></td></tr></table></figure><p>您可以提供id和name属性。这使您可以通过独立于队列名称的ID来引用队列（例如，在绑定中）。它还允许使用标准的Spring功能（例如队列名的属性占位符和SpEL表达式）。当您使用名称作为Bean标识符时，这些功能不可用。</p><p>默认情况下，当发生任何异常时，RabbitAdmin将立即停止处理所有声明。这可能会导致下游问题，例如侦听器容器无法初始化，因为未声明另一个队列（在错误的一个之后定义）。</p><p>可以通过在RabbitAdmin实例上将ignore-declaration-exceptions属性设置为true来修改此行为。该选项指示RabbitAdmin记录异常并继续声明其他元素。使用Java配置RabbitAdmin时，此属性称为ignoreDeclarationExceptions。这是适用于所有元素的全局设置。队列，交换和绑定具有类似的属性，仅适用于那些元素。</p><p>在1.6版之前的版本中，仅当通道上发生IOException时（例如，当前属性与所需属性不匹配时），此属性才生效。现在，此属性对任何异常（包括TimeoutException和其他异常）都生效。</p><p>另外，任何声明异常都会导致产生一个DeclarationExceptionEvent，这是一个ApplicationEvent，可以由上下文中的任何ApplicationListener消费。该事件包含对admin，已声明的元素和Throwable的引用。</p><h4 id="3-3-8-1-Header-交换器"><a href="#3-3-8-1-Header-交换器" class="headerlink" title="3.3.8.1 Header 交换器"></a>3.3.8.1 Header 交换器</h4><p>从版本1.3开始，您可以配置HeadersExchange以匹配多个Header。您也可以指定是否必须匹配任何Header。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:headers-exchange name=&quot;headers-test&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding queue=&quot;bucket&quot;&gt;</span><br><span class="line">            &lt;rabbit:binding-arguments&gt;</span><br><span class="line">                &lt;entry key=&quot;foo&quot; value=&quot;bar&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;baz&quot; value=&quot;qux&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;x-match&quot; value=&quot;all&quot;/&gt;</span><br><span class="line">            &lt;/rabbit:binding-arguments&gt;</span><br><span class="line">        &lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:headers-exchange&gt;</span><br></pre></td></tr></table></figure><p>从版本1.6开始，您可以使用内部标志（默认为false）配置Exchange，并且可以通过RabbitAdmin在Broker上正确配置这样的Exchange（如果应用程序上下文中存在Exchange）。如果内部标志适用于交换，则RabbitMQ不允许客户端使用交换。这对于无用信交换或交换对交换绑定很有用，在这种情况下，您不希望发行人直接使用交换。</p><p>要查看如何使用Java配置AMQP基础结构，请查看Stock示例应用程序，其中有@Configuration类AbstractStockRabbitConfiguration，该类又具有RabbitClientConfiguration和RabbitServerConfiguration子类。以下清单显示了AbstractStockRabbitConfiguration的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public abstract class AbstractStockAppRabbitConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConnectionFactory connectionFactory() &#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory =</span><br><span class="line">            new CachingConnectionFactory(&quot;localhost&quot;);</span><br><span class="line">        connectionFactory.setUsername(&quot;guest&quot;);</span><br><span class="line">        connectionFactory.setPassword(&quot;guest&quot;);</span><br><span class="line">        return connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitTemplate rabbitTemplate() &#123;</span><br><span class="line">        RabbitTemplate template = new RabbitTemplate(connectionFactory());</span><br><span class="line">        template.setMessageConverter(jsonMessageConverter());</span><br><span class="line">        configureRabbitTemplate(template);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MessageConverter jsonMessageConverter() &#123;</span><br><span class="line">        return new Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TopicExchange marketDataExchange() &#123;</span><br><span class="line">        return new TopicExchange(&quot;app.stock.marketdata&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // additional code omitted for brevity</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端通过AmqpAdmin上的clarifyQueue（）方法声明另一个队列。它使用属性文件中外部化的路由模式将该队列绑定到市场数据交换。</p><h4 id="3-3-8-2-Builder-API"><a href="#3-3-8-2-Builder-API" class="headerlink" title="3.3.8.2 Builder API"></a>3.3.8.2 Builder API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> @Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    return QueueBuilder.nonDurable(&quot;foo&quot;)</span><br><span class="line">        .autoDelete()</span><br><span class="line">        .exclusive()</span><br><span class="line">        .withArgument(&quot;foo&quot;, &quot;bar&quot;)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Exchange exchange() &#123;</span><br><span class="line">  return ExchangeBuilder.directExchange(&quot;foo&quot;)</span><br><span class="line">      .autoDelete()</span><br><span class="line">      .internal()</span><br><span class="line">      .withArgument(&quot;foo&quot;, &quot;bar&quot;)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-8-3-声明交换、队列、绑定的集合"><a href="#3-3-8-3-声明交换、队列、绑定的集合" class="headerlink" title="3.3.8.3 声明交换、队列、绑定的集合"></a>3.3.8.3 声明交换、队列、绑定的集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public static class Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConnectionFactory cf() &#123;</span><br><span class="line">        return new CachingConnectionFactory(&quot;localhost&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitAdmin admin(ConnectionFactory cf) &#123;</span><br><span class="line">        return new RabbitAdmin(cf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange e1() &#123;</span><br><span class="line">    return new DirectExchange(&quot;e1&quot;, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue q1() &#123;</span><br><span class="line">    return new Queue(&quot;q1&quot;, false, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Binding b1() &#123;</span><br><span class="line">    return BindingBuilder.bind(q1()).to(e1()).with(&quot;k1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables es() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new DirectExchange(&quot;e2&quot;, false, true),</span><br><span class="line">                new DirectExchange(&quot;e3&quot;, false, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables qs() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new Queue(&quot;q2&quot;, false, false, true),</span><br><span class="line">                new Queue(&quot;q3&quot;, false, false, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">    public Declarables prototypes() &#123;</span><br><span class="line">        return new Declarables(new Queue(this.prototypeQueueName, false, false, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables bs() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new Binding(&quot;q2&quot;, DestinationType.QUEUE, &quot;e2&quot;, &quot;k2&quot;, null),</span><br><span class="line">                new Binding(&quot;q3&quot;, DestinationType.QUEUE, &quot;e3&quot;, &quot;k3&quot;, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables ds() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new DirectExchange(&quot;e4&quot;, false, true),</span><br><span class="line">                new Queue(&quot;q4&quot;, false, false, true),</span><br><span class="line">                new Binding(&quot;q4&quot;, DestinationType.QUEUE, &quot;e4&quot;, &quot;k4&quot;, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2版将getDeclarablesByType方法添加到了Declarables中。例如，在声明一个或多个侦听器容器bean时，这可以方便使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public SimpleMessageListenerContainer container(ConnectionFactory connectionFactory,</span><br><span class="line">        Declarables mixedDeclarables, MessageListener listener) &#123;</span><br><span class="line"></span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">    container.setQueues(mixedDeclarables.getDeclarablesByType(Queue.class).toArray(new Queue[0]));</span><br><span class="line">    container.setMessageListener(listener);</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-8-4-条件声明"><a href="#3-3-8-4-条件声明" class="headerlink" title="3.3.8.4 条件声明"></a>3.3.8.4 条件声明</h4><p>默认情况下，所有队列，交换和绑定都由应用程序上下文中的所有RabbitAdmin实例声明（假设它们具有auto-startup =“ true”）。</p><p>从版本2.1.9开始，RabbitAdmin具有新的属性explicitDeclarationsOnly（默认情况下为false）。当将此设置为true时，管理员将仅声明显式配置为由该RabbitAdmin声明的Bean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RabbitAdmin admin1() &#123;</span><br><span class="line">    return new RabbitAdmin(cf1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RabbitAdmin admin2() &#123;</span><br><span class="line">    return new RabbitAdmin(cf2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    Queue queue = new Queue(&quot;foo&quot;);</span><br><span class="line">    queue.setAdminsThatShouldDeclare(admin1());</span><br><span class="line">    return queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Exchange exchange() &#123;</span><br><span class="line">    DirectExchange exchange = new DirectExchange(&quot;bar&quot;);</span><br><span class="line">    exchange.setAdminsThatShouldDeclare(admin1());</span><br><span class="line">    return exchange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Binding binding() &#123;</span><br><span class="line">    Binding binding = new Binding(&quot;foo&quot;, DestinationType.QUEUE, exchange().getName(), &quot;foo&quot;, null);</span><br><span class="line">    binding.setAdminsThatShouldDeclare(admin1());</span><br><span class="line">    return binding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-8-5-关于id和name属性的注释"><a href="#3-3-8-5-关于id和name属性的注释" class="headerlink" title="3.3.8.5 关于id和name属性的注释"></a>3.3.8.5 关于id和name属性的注释</h4><p>和元素上的name属性反映代理中实体的名称。对于队列，如果省略名称，则会创建一个匿名队列（请参阅AnonymousQueue）。</p><p>在2.0之前的版本中，该名称也被注册为Bean名称别名（类似于元素上的名称）。</p><p>这导致了两个问题：</p><ul><li><p>它阻止了队列的声明和相同名称的交换。</p></li><li><p>如果别名包含SpEL表达式（＃{…}），则无法解析。</p></li></ul><p>从2.0版开始，如果您同时使用id和name属性声明这些元素之一，则该名称不再声明为Bean名称别名。如果要声明队列并使用相同的名称进行交换，则必须提供一个ID。</p><p>如果元素只有name属性，则没有任何变化。仍然可以使用名称Bean来引用该Bean，例如在绑定声明中。但是，如果名称包含SpEL，您仍然无法引用它-您必须提供ID以供参考。</p><h4 id="3-3-8-6-AnonymousQueue"><a href="#3-3-8-6-AnonymousQueue" class="headerlink" title="3.3.8.6 AnonymousQueue"></a>3.3.8.6 AnonymousQueue</h4><p>通常，当您需要一个唯一命名的排他性自动删除队列时，建议您使用AnonymousQueue而不是broker定义的队列名称（使用“”作为队列名称会导致代理生成队列名称）。</p><p>这是因为：</p><p>建立与broker的连接时，实际上会声明队列。在创建和将bean连接在一起很长时间之后。使用队列的Bean需要知道其名称。实际上，启动应用程序时，broker甚至可能没有运行。</p><p>如果与broker的连接由于某种原因而丢失，则管理员将用相同的名称重新声明AnonymousQueue。如果使用broker声明的队列，则队列名称将更改。</p><p>您可以控制AnonymousQueue实例使用的队列名称的格式。</p><p>默认情况下，队列名称以spring.gen-为前缀，后跟UUID的base64表示形式，例如：spring.gen-MRBv9sqISkuCiPfOYfpo4g。</p><p>您可以在构造函数参数中提供AnonymousQueue.NamingStrategy实现。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue anon1() &#123;</span><br><span class="line">    return new AnonymousQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue anon2() &#123;</span><br><span class="line">    return new AnonymousQueue(new AnonymousQueue.Base64UrlNamingStrategy(&quot;something-&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue anon3() &#123;</span><br><span class="line">    return new AnonymousQueue(AnonymousQueue.UUIDNamingStrategy.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个bean生成一个队列名称，该队列名称以spring.gen-为前缀，后跟UUID的base64表示形式-例如：spring.gen-MRBv9sqISkuCiPfOYfpo4g。第二个bean生成一个以某些东西为前缀的队列名称，后跟UUID的base64表示形式。第三个bean仅通过使用UUID（不进行base64转换）来生成名称，例如f20c818a-006b-4416-bf91-643590fedb0e。</p><p>base64编码使用RFC 4648中的“ ​​URL和文件名安全字母”。尾随的填充字符（=）被删除。</p><p>您可以提供自己的命名策略，从而可以在队列名称中包括其他信息（例如应用程序名称或客户端主机）。</p><p>使用XML配置时，可以指定命名策略。 naming-strategy属性存在于实现AnonymousQueue.NamingStrategy的bean引用的元素上。以下示例显示如何以各种方式指定命名策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue id=&quot;uuidAnon&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;springAnon&quot; naming-strategy=&quot;uuidNamer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;customAnon&quot; naming-strategy=&quot;customNamer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;uuidNamer&quot; class=&quot;org.springframework.amqp.core.AnonymousQueue.UUIDNamingStrategy&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;customNamer&quot; class=&quot;org.springframework.amqp.core.AnonymousQueue.Base64UrlNamingStrategy&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;custom.gen-&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>第一个示例创建名称，例如spring.gen-MRBv9sqISkuCiPfOYfpo4g。第二个示例使用UUID的字符串表示形式创建名称。第三个示例创建名称，例如custom.gen-MRBv9sqISkuCiPfOYfpo4g。</p><p>您还可以提供自己的命名策略bean。</p><p>从版本2.1开始，默认情况下，匿名队列使用参数x-queue-master-locator声明为本地客户端声明。这样可以确保在与应用程序连接的节点上声明队列。构造实例后，可以通过调用queue.setMasterLocator（null）恢复到以前的行为。</p><h3 id="3-3-9-Broker事件监听"><a href="#3-3-9-Broker事件监听" class="headerlink" title="3.3.9 Broker事件监听"></a>3.3.9 Broker事件监听</h3><p>启用事件交换插件后，如果将类型为BrokerEventListener的bean添加到应用程序上下文中，它将发布选定的代理事件作为BrokerEvent实例，可以通过常规的Spring ApplicationListener或@EventListener方法使用它。代理将事件发布到主题交换amq.rabbitmq.event，每种事件类型具有不同的路由键。侦听器使用事件密钥，该事件密钥用于将AnonymousQueue绑定到交换，因此侦听器仅接收选定的事件。由于这是一个主题交换，因此可以使用通配符（以及显式请求特定事件），如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public BrokerEventListener eventListener() &#123;</span><br><span class="line">    return new BrokerEventListener(connectionFactory(), &quot;user.deleted&quot;, &quot;channel.#&quot;, &quot;queue.#&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用正常的Spring技术进一步缩小单个事件侦听器中接收到的事件的范围，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@EventListener(condition = &quot;event.eventType == &apos;queue.created&apos;&quot;)</span><br><span class="line">public void listener(BrokerEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-10-延迟消息交换器"><a href="#3-3-10-延迟消息交换器" class="headerlink" title="3.3.10 延迟消息交换器"></a>3.3.10 延迟消息交换器</h3><p>该插件目前被标记为实验性，但已经可用了一年多的时间（在撰写本文时）。如果需要更改插件，我们计划在可行的情况下尽快添加对此类更改的支持。因此，Spring AMQP中的这种支持也应视为试验性的。此功能已通过RabbitMQ 3.6.0和插件的0.0.1版进行了测试。</p><p>要使用RabbitAdmin将交换声明为延迟，可以将交换bean的delay属性设置为true。 RabbitAdmin使用交换类型（直接，扇出等）来设置x-delayed-type参数，并使用x-delayed-message类型声明交换。</p><p>使用XML配置交换bean时，delayed属性（默认值：false）也可用。以下示例显示了如何使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:topic-exchange name=&quot;topic&quot; delayed=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure><p>要发送延迟的消息，可以通过MessageProperties设置x-delay标头，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties properties = new MessageProperties();</span><br><span class="line">properties.setDelay(15000);</span><br><span class="line">template.send(exchange, routingKey,</span><br><span class="line">MessageBuilder.withBody(&quot;foo&quot;.getBytes()).andProperties(properties).build());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(exchange, routingKey, &quot;foo&quot;, new MessagePostProcessor() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">        message.getMessageProperties().setDelay(15000);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>若要检查消息是否延迟，请在MessageProperties上使用getReceivedDelay（）方法。这是一个单独的属性，可以避免意外传播到由输入消息生成的输出消息。</p><h3 id="3-3-11-RabbitMQ-Rest-API"><a href="#3-3-11-RabbitMQ-Rest-API" class="headerlink" title="3.3.11 RabbitMQ Rest API"></a>3.3.11 RabbitMQ Rest API</h3><p>启用管理插件后，RabbitMQ服务器将公开REST API来监视和配置代理。现在提供了API的Java绑定。 com.rabbitmq.http.client.Client是一个标准的，即时的并且因此是阻塞的API。它基于Spring Web模块及其RestTemplate实现。另一方面，com.rabbitmq.http.client.ReactorNettyClient是基于Reactor Netty项目的反应性，非阻塞实现。</p><p>跳相关性（com.rabbitmq：http-client）现在也是可选的。</p><p>有关更多信息，请参见其Javadoc。</p><h3 id="3-3-12-异常处理"><a href="#3-3-12-异常处理" class="headerlink" title="3.3.12 异常处理"></a>3.3.12 异常处理</h3><p>RabbitMQ Java客户端的许多操作都可能引发已检查的异常。例如，在很多情况下，可能会抛出IOException实例。 RabbitTemplate，SimpleMessageListenerContainer和其他Spring AMQP组件捕获这些异常，并将它们转换为AmqpException层次结构中的异常之一。这些在“ org.springframework.amqp”包中定义，AmqpException是层次结构的基础。</p><p>当侦听器引发异常时，它将包装在ListenerExecutionFailedException中。通常，消息被代理拒绝并重新排队。将defaultRequeueRejected设置为false会导致消息被丢弃（或路由到无效信件交换）。如消息侦听器和异步案例中所述，侦听器可以引发AmqpRejectAndDontRequeueException（或InstantRequeueAmqpException）来有条件地控制此行为。</p><p>但是，存在一类错误，侦听器无法控制该行为。当遇到无法转换的消息（例如，无效的content_encoding标头）时，在消息到达用户代码之前会引发一些异常。将defaultRequeueRejected设置为true（默认值）（或引发InstantRequeueAmqpException），此类消息将一遍又一遍地传递。在版本1.3.2之前，用户需要编写自定义ErrorHandler（如异常处理中所述），以避免这种情况。</p><p>从1.3.2版开始，默认的ErrorHandler现在是ConditionalRejectingErrorHandler，它拒绝（并且不重新排队）由于不可恢复的错误而失败的消息。具体来说，它拒绝失败并出现以下错误的消息：</p><p>o.s.amqp … MessageConversionException：使用MessageConverter转换传入消息有效负载时可以抛出此异常。</p><p>o.s.messaging … MessageConversionException：如果映射到@RabbitListener方法时需要额外的转换，则转换服务可以抛出该异常。</p><p>o.s.messaging … MethodArgumentNotValidException：如果在侦听器中使用了验证（例如@Valid），则可以引发此异常。</p><p>o.s.messaging … MethodArgumentTypeMismatchException：如果将入站消息转换为与目标方法不正确的类型，则可以引发该异常。例如，将该参数声明为Message ，但收到Message 。</p><p>java.lang.NoSuchMethodException：在版本1.6.3中添加。</p><p>java.lang.ClassCastException：在版本1.6.3中添加。</p><p>您可以使用FatalExceptionStrategy配置此错误处理程序的实例，以便用户可以提供自己的条件消息拒绝规则-例如，从Spring Retry（消息侦听器和异步案例）到BinaryExceptionClassifier的委托实现。另外，ListenerExecutionFailedException现在具有您可以在决策中使用的failedMessage属性。如果FatalExceptionStrategy.isFatal（）方法返回true，则错误处理程序将引发AmqpRejectAndDontRequeueException。当确定异常为致命时，默认的FatalExceptionStrategy会记录一条警告消息。</p><p>从1.6.3版开始，将用户异常添加到致命列表的便捷方法是子类ConditionalRejectingErrorHandler.DefaultExceptionStrategy并重写isUserCauseFatal（Throwable cause）方法以为致命异常返回true。</p><p>处理DLQ消息的常见模式是在这些消息以及其他DLQ配置上设置生存时间，以使这些消息过期并路由回主队列以重试。这种技术的问题在于，导致致命异常的消息会永远循环。从2.1版开始，ConditionalRejectingErrorHandler在消息上检测到x-death标头，该标头导致引发致命异常。该消息已记录并被丢弃。您可以通过将ConditionalRejectingErrorHandler上的rejectFatalsWithXDeath属性设置为false来还原为以前的行为。</p><p>从版本2.1.9开始，即使容器确认模式为MANUAL，默认情况下，具有这些致命异常的消息也将被拒绝并且不重新排队。这些异常通常在调用侦听器之前发生，因此侦听器没有机会确认或拒绝消息，因此消息以未确认状态保留在队列中。若要还原为以前的行为，请将ConditionalRejectingErrorHandler的rejectManual属性设置为false。</p><h3 id="3-3-13-事务"><a href="#3-3-13-事务" class="headerlink" title="3.3.13 事务"></a>3.3.13 事务</h3><p>Spring Rabbit框架支持同步和异步用例中的自动事务管理，具有许多不同的语义，可以通过声明方式选择这些语义，这是Spring事务的现有用户所熟悉的。这使许多（如果不是大多数）常见的消息传递模式易于实现。</p><p>有两种方法可以向框架发出所需的事务语义。在RabbitTemplate和SimpleMessageListenerContainer中，都有一个标志channelTransacted，如果为true，则告诉框架使用事务性通道并以提交或回滚（取决于结果）结束所有操作（发送或接收），但有例外表示回滚。另一个信号是使用Spring的PlatformTransactionManager实现之一提供外部事务，作为正在进行的操作的上下文。如果在框架发送或接收消息时已经有事务在进行中，并且channelTransacted标志为true，则将消息事务的提交或回滚推迟到当前事务结束为止。如果channelTransacted标志为false，则没有事务语义适用于消息传递操作（它是自动确认的）。</p><p>channelTransacted标志是配置时间设置。创建AMQP组件时，通常在应用程序启动时声明和处理一次。原则上，外部事务是动态的，因为系统在运行时响应当前线程状态。但是，实际上，当将事务以声明方式分层到应用程序时，它通常也是配置设置。</p><p>对于RabbitTemplate的同步用例，外部事务由调用方根据喜好以声明性或强制性方式提供（通常的Spring事务模型）。以下示例显示了一种声明性方法（通常首选，因为它是非侵入性的），其中已使用channelTransacted = true配置模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    String incoming = rabbitTemplate.receiveAndConvert();</span><br><span class="line">    // do some more database processing...</span><br><span class="line">    String outgoing = processInDatabaseAndExtractReply(incoming);</span><br><span class="line">    rabbitTemplate.convertAndSend(outgoing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的示例中，在标记为@Transactional的方法内，String有效负载作为消息正文被接收，转换和发送。如果数据库处理失败并发生异常，则将传入消息返回给代理，并且不发送传出消息。这适用于在交易方法链内使用RabbitTemplate进行的任何操作（例如，除非直接操纵Channel尽早提交交易）。</p><p>对于带有SimpleMessageListenerContainer的异步用例，如果需要外部事务，则容器在设置侦听器时必须请求它。为了表明需要外部事务，在配置容器时，用户向容器提供PlatformTransactionManager的实现。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ExampleExternalTransactionAmqpConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleMessageListenerContainer messageListenerContainer() &#123;</span><br><span class="line">        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">        container.setTransactionManager(transactionManager());</span><br><span class="line">        container.setChannelTransacted(true);</span><br><span class="line">        container.setQueueName(&quot;some.queue&quot;);</span><br><span class="line">        container.setMessageListener(exampleListener());</span><br><span class="line">        return container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的示例中，添加了事务管理器作为从另一个bean定义（未显示）注入的依赖项，并且channelTransacted标志也设置为true。效果是，如果侦听器因异常而失败，则事务将回滚，并且消息也将返回给代理。重要的是，如果事务提交失败（例如，由于数据库约束错误或连接性问题），则AMQP事务也会回滚，并将消息返回给代理。这有时被称为“尽力而为第一阶段提交”，并且是可靠消息传递的非常强大的模式。如果在前面的示例中将channelTransacted标志设置为false（默认值），则仍将为侦听器提供外部事务，但是所有消息传递操作将被自动确认，因此效果是即使在服务器上也提交消息传递操作。业务运营的回滚。</p><h4 id="3-3-13-1-条件退回"><a href="#3-3-13-1-条件退回" class="headerlink" title="3.3.13.1 条件退回"></a>3.3.13.1 条件退回</h4><p>在1.6.6版之前，使用外部事务管理器（例如JDBC）在容器的transactionAttribute中添加回滚规则无效。异常总是回滚事务。</p><p>另外，在容器的建议链中使用事务建议时，条件回滚并不是很有用，因为所有侦听器异常都包装在ListenerExecutionFailedException中。</p><p>第一个问题已得到纠正，现在可以正确应用规则。此外，现在提供了ListenerFailedRuleBasedTransactionAttribute。它是RuleBasedTransactionAttribute的子类，唯一的区别是它知道ListenerExecutionFailedException并将该异常的原因用于规则。该交易属性可以直接在容器中使用，也可以通过交易建议使用。</p><p>以下示例使用此规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public AbstractMessageListenerContainer container() &#123;</span><br><span class="line">    ...</span><br><span class="line">    container.setTransactionManager(transactionManager);</span><br><span class="line">    RuleBasedTransactionAttribute transactionAttribute =</span><br><span class="line">        new ListenerFailedRuleBasedTransactionAttribute();</span><br><span class="line">    transactionAttribute.setRollbackRules(Collections.singletonList(</span><br><span class="line">        new NoRollbackRuleAttribute(DontRollBackException.class)));</span><br><span class="line">    container.setTransactionAttribute(transactionAttribute);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-13-2-关于回滚收到消息的注意事项"><a href="#3-3-13-2-关于回滚收到消息的注意事项" class="headerlink" title="3.3.13.2 关于回滚收到消息的注意事项"></a>3.3.13.2 关于回滚收到消息的注意事项</h4><p>AMQP事务仅适用于发送给代理的消息和确认。因此，当发生Spring事务的回滚并且已经收到消息时，Spring AMQP不仅必须回滚该事务，而且还必须手动拒绝该消息（有点小问题，但这不是规范所称的）。拒绝消息时采取的操作与事务无关，并且取决于defaultRequeueRejected属性（默认值：true）。有关拒绝失败消息的更多信息，请参见消息侦听器和异步案例。</p><p>有关RabbitMQ事务及其限制的更多信息，请参见RabbitMQ Broker Semantics。</p><p>在RabbitMQ 2.7.0之前，此类消息（以及通道关闭或中止时未确认的消息）在Rabbit代理上进入队列的后面。从2.7.0版本开始，被拒绝的消息以与JMS回滚消息类似的方式进入队列的最前面。<br>以前，本地事务之间和提供TransactionManager时，事务回滚时的消息重新排队不一致。在前一种情况下，将应用常规的重新排队逻辑（AmqpRejectAndDontRequeueException或defaultRequeueRejected = false）（请参阅消息侦听器和异步情况）。使用事务管理器，该消息将在回滚时无条件重新排队。从版本2.0开始，行为是一致的，并且在两种情况下均采用常规的重新排队逻辑。要恢复以前的行为，可以将容器的alwaysRequeueWithTxManagerRollback属性设置为true。请参阅消息侦听器容器配置。</p><h4 id="3-3-13-3-使用RabbitTransactionManager"><a href="#3-3-13-3-使用RabbitTransactionManager" class="headerlink" title="3.3.13.3 使用RabbitTransactionManager"></a>3.3.13.3 使用RabbitTransactionManager</h4><p>RabbitTransactionManager是在外部事务中执行并与外部事务同步的Rabbit操作的替代方法。该事务管理器是PlatformTransactionManager接口的实现，应与单个Rabbit ConnectionFactory一起使用。</p><p>此策略不能提供XA事务，例如，以便在消息传递和数据库访问之间共享事务。<br>需要应用程序代码才能通过ConnectionFactoryUtils.getTransactionalResourceHolder（ConnectionFactory，boolean）（而不是带有后续通道创建的标准Connection.createChannel（））来检索事务型Rabbit资源。使用Spring AMQP的RabbitTemplate时，它将自动检测线程绑定的Channel并自动参与其事务。</p><p>使用Java配置，可以使用以下bean来设置新的RabbitTransactionManager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RabbitTransactionManager rabbitTransactionManager() &#123;</span><br><span class="line">    return new RabbitTransactionManager(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您喜欢XML配置，则可以在XML Application Context文件中声明以下bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;rabbitTxManager&quot;</span><br><span class="line">      class=&quot;org.springframework.amqp.rabbit.transaction.RabbitTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-14-消息监听容器配置"><a href="#3-3-14-消息监听容器配置" class="headerlink" title="3.3.14 消息监听容器配置"></a>3.3.14 消息监听容器配置</h3><p>用于配置与事务和服务质量相关的SimpleMessageListenerContainer（SMLC）和DirectMessageListenerContainer（DMLC）的选项很多，它们中的一些相互交互。适用于SMLC或DMLC的属性由相应列中的复选标记指示。请参阅选择容器，以获取帮助您确定哪个容器适合您的应用程序的信息。</p><p>下表显示了使用命名空间配置时的容器属性名称及其等效属性名称（在括号中）。该元素上的type属性可以是简单的（默认），也可以直接指定SMLC或DMLC。命名空间未公开某些属性。这些由属性的N / A表示。</p><h3 id="3-3-15-监听并发"><a href="#3-3-15-监听并发" class="headerlink" title="3.3.15 监听并发"></a>3.3.15 监听并发</h3><h4 id="3-3-15-1-SimpleMessageListenerContainer"><a href="#3-3-15-1-SimpleMessageListenerContainer" class="headerlink" title="3.3.15.1 SimpleMessageListenerContainer"></a>3.3.15.1 SimpleMessageListenerContainer</h4><p>默认情况下，侦听器容器启动一个消费者，该消费者从队列中接收消息。</p><p>检查上一节中的表时，您可以看到许多控制并发性的属性。最简单的是currentsconsumers，它创建并发处理消息的（固定）数量的消费者。</p><p>在1.3.0版之前，这是唯一可用的设置，必须停止容器并再次启动容器才能更改设置。</p><p>从1.3.0版开始，您现在可以动态调整parallelConsumers属性。如果在容器运行时更​​改了容器，则会根据需要添加或删除消费者，以适应新设置。</p><p>另外，添加了一个名为maxConcurrentConsumers的新属性，并且该容器根据工作负载动态调整了并发性。这与四个附加属性一起工作：ContinuousActiveTrigger，startConsumerMinInterval，continuousIdleTrigger和stopConsumerMinInterval。</p><hr><p>使用默认设置，增加使用方的算法如下：</p><p>如果尚未达到maxConcurrentConsumers且现有消费者处于连续十个周期的活动状态，并且自启动最后一个消费者以来至少经过了10秒钟，则将启动一个新消费者。如果消费者以batchSize * receiveTimeout毫秒接收至少一条消息，则认为该消费者是活动的。</p><hr><hr><p>在默认设置下，减少使用方的算法如下：</p><p>如果运行的并发消费者数量超过了，并且消费者检测到十个连续超时（空闲），并且最后一个消费者至少在60秒前停止，则该消费者将停止。超时取决于receiveTimeout和batchSize属性。如果消费者未接收到batchSize * receiveTimeout毫秒中的消息，则被视为空闲。因此，在默认超时（一秒）和batchSize为4的情况下，在40秒的空闲时间后考虑停止消费者（四个超时对应于一个空闲检测）。</p><hr><p>实际上，只有在整个容器闲置一段时间后才可以停止使用。这是因为broker在所有活跃的消费者中共享其工作。<br>每个消费者都使用一个通道，而不管配置的队列数量如何。</p><p>从2.0版开始，可以使用并发属性（例如2-4）设置parallelConsumers和maxConcurrentConsumers属性。</p><h4 id="3-3-15-2-使用-DirectMessageListenerContainer"><a href="#3-3-15-2-使用-DirectMessageListenerContainer" class="headerlink" title="3.3.15.2 使用 DirectMessageListenerContainer"></a>3.3.15.2 使用 DirectMessageListenerContainer</h4><p>使用此容器，并发性基于配置的队列和consumersPerQueue。每个队列的每个消费者都使用一个单独的通道，并发性由Rabbit客户端库控制。默认情况下，在编写本文时，它使用DEFAULT_NUM_THREADS = Runtime.getRuntime().availableProcessors()* 2个线程的池。</p><p>您可以配置taskExecutor以提供所需的最大并发性。</p><h3 id="3-3-16-排他消费者"><a href="#3-3-16-排他消费者" class="headerlink" title="3.3.16 排他消费者"></a>3.3.16 排他消费者</h3><p>从版本1.3开始，您可以使用单个独占消费者配置侦听器容器。这样可以防止其他容器从队列中使用，直到当前使用方被取消为止。这样的容器的并发性必须为1。</p><h3 id="3-3-17-监听容器队列"><a href="#3-3-17-监听容器队列" class="headerlink" title="3.3.17 监听容器队列"></a>3.3.17 监听容器队列</h3><p>1.3版引入了许多改进，用于处理侦听器容器中的多个队列。</p><p>必须将容器配置为侦听至少一个队列。以前也是如此，但是现在可以在运行时添加和删除队列。处理完任何预提取的消息后，容器将回收（取消并重新创建）消费者。有关addQueues，addQueueNames，removeQueues和removeQueueNames方法，请参见Javadoc。删除队列时，必须至少保留一个队列。</p><p>现在，如果消费者的任何队列可用，便会启动。以前，如果没有任何队列，容器将停止。现在，只有在没有可用队列的情况下才是这种情况。如果不是所有队列都可用，则容器会尝试每60秒被动声明（并消耗）丢失的队列。</p><p>同样，如果消费者从代理收到取消通知（例如，如果删除队列），则该消费者尝试恢复，并且恢复的消费者继续处理来自任何其他已配置队列的消息。以前，取消一个队列会取消整个消费者，最终，由于缺少队列，容器将停止。</p><p>如果要永久删除队列，则应在删除队列之前或之后更新容器，以避免将来尝试从中使用该容器。</p><h3 id="3-3-18-弹性：从错误和broker失败中恢复"><a href="#3-3-18-弹性：从错误和broker失败中恢复" class="headerlink" title="3.3.18 弹性：从错误和broker失败中恢复"></a>3.3.18 弹性：从错误和broker失败中恢复</h3><p>Spring AMQP提供的一些关键（也是最流行的）高级功能与协议错误或代理失败时的恢复和自动重新连接有关。我们已经在本指南中看到了所有相关组件，但是应该有助于将它们放在一起，并分别指出功能和恢复方案。</p><p>主要重新连接功能由CachingConnectionFactory本身启用。使用RabbitAdmin自动声明功能通常也很有益。另外，如果您关心保证传递，则可能还需要使用RabbitMessage和SimpleMessageListenerContainer中的channelTransacted标志以及SimpleMessageListenerContainer中的AcknowledgeMode.AUTO（如果您自己进行确认，则使用手册）。</p><h4 id="3-3-18-1-自动声明交换，队列和绑定"><a href="#3-3-18-1-自动声明交换，队列和绑定" class="headerlink" title="3.3.18.1 自动声明交换，队列和绑定"></a>3.3.18.1 自动声明交换，队列和绑定</h4><p>RabbitAdmin组件可以在启动时声明交换，队列和绑定。它通过ConnectionListener懒惰地执行此操作。因此，如果broker在启动时不存在，则没有关系。第一次使用Connection（例如，通过发送消息）时，将触发侦听器并应用管理功能。在侦听器中执行自动声明的另一个好处是，如果由于任何原因（例如，代理死亡，网络故障等）而断开连接，则在重新建立连接时会再次应用它们。</p><p>以这种方式声明的队列必须具有固定的名称-由AnonymousQueue实例的框架明确声明或生成。匿名队列是非持久的，排他的和自动删除的。<br>仅当CachingConnectionFactory缓存模式为CHANNEL（默认）时，才执行自动声明。存在此限制是因为排他队列和自动删除队列绑定到该连接。<br>从版本2.2.2开始，RabbitAdmin将检测类型为DeclarationCustomizer的bean，并在实际处理声明之前应用该函数。例如，这对于在框架内具有一流支持之前设置新参数（属性）很有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DeclarableCustomizer customizer() &#123;</span><br><span class="line">    return dec -&gt; &#123;</span><br><span class="line">        if (dec instanceof Queue &amp;&amp; ((Queue) dec).getName().equals(&quot;my.queue&quot;)) &#123;</span><br><span class="line">            dec.addArgument(&quot;some.new.queue.argument&quot;, true);</span><br><span class="line">        &#125;</span><br><span class="line">        return dec;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在不直接访问Declarable bean定义的项目中，它也很有用。</p><h4 id="3-3-18-2-同步操作失败和重试选项"><a href="#3-3-18-2-同步操作失败和重试选项" class="headerlink" title="3.3.18.2 同步操作失败和重试选项"></a>3.3.18.2 同步操作失败和重试选项</h4><p>如果您在使用RabbitTemplate时（例如）在同步序列中失去了与代理的连接，则Spring AMQP会引发AmqpException（通常但并非总是AmqpIOException）。我们不会试图掩盖存在问题的事实，因此您必须能够捕获并响应异常。如果您怀疑连接丢失（不是您的错），最简单的方法是再次尝试该操作。您可以手动执行此操作，也可以查看使用Spring Retry处理（命令式或声明式）重试。</p><p>Spring Retry提供了几个AOP拦截器，并提供了很大的灵活性来指定重试的参数（尝试次数，异常类型，退避算法等）。 Spring AMQP还为AMQP用例提供了一些方便的工厂bean，以方便的形式创建Spring Retry拦截器，并提供了可用于实现自定义恢复逻辑的强类型回调接口。有关更多详细信息，请参见Javadoc和StatefulRetryOperationsInterceptor和StatelessRetryOperationsInterceptor的属性。如果没有事务或在重试回调中启动了事务，则无状态重试是合适的。请注意，无状态重试比有状态重试更易于配置和分析，但是如果存在正在进行的事务必须回滚或肯定要回滚，则通常不适合使用。在事务中间断开连接应具有与回滚相同的效果。因此，对于在事务从堆栈开始的更高位置进行重新连接而言，有状态重试通常是最佳选择。有状态重试需要一种机制来唯一标识消息。最简单的方法是让发件人在MessageId消息属性中放置一个唯一值。提供的消息转换器提供了执行此操作的选项：您可以将createMessageIds设置为true。否则，您可以将MessageKeyGenerator实现注入到拦截器中。密钥生成器必须为每个消息返回唯一的密钥。在2.0版之前的版本中，提供了MissingMessageIdAdvice。它使没有messageId属性的消息仅被重试一次（忽略重试设置）。不再提供此建议，因为与spring-retry 1.2版一起，其功能已内置在拦截器和消息侦听器容器中。</p><p>为了向后兼容，默认情况下（在重试一次之后），具有空消息ID的消息被认为对消费者是致命的（消费者已停止）。若要复制MissingMessageIdAdvice提供的功能，可以在侦听器容器上将statefulRetryFatalWithNullMessageId属性设置为false。使用该设置，消费者继续运行，并且邮件被拒绝（在重试一次之后）。它被丢弃或路由到死信队列（如果已配置）。<br>从1.3版开始，提供了一个构建器API，以帮助使用Java（在@Configuration类中）组装这些拦截器。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public StatefulRetryOperationsInterceptor interceptor() &#123;</span><br><span class="line">return RetryInterceptorBuilder.stateful()</span><br><span class="line">.maxAttempts(5)</span><br><span class="line">.backOffOptions(1000, 2.0, 10000) // initialInterval, multiplier, maxInterval</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能以这种方式配置重试功能的子集。更多高级功能将需要将RetryTemplate配置为Spring bean。有关可用策略及其配置的完整信息，请参见Spring Retry Javadoc。</p><h4 id="3-3-18-3-使用批处理侦听器重试"><a href="#3-3-18-3-使用批处理侦听器重试" class="headerlink" title="3.3.18.3 使用批处理侦听器重试"></a>3.3.18.3 使用批处理侦听器重试</h4><p>不建议使用批处理侦听器配置重试，除非该批处理由生产者在单个记录中创建。有关消费者和生产者创建的批次的信息，请参阅批次消息。对于用户创建的批处理，框架不知道该批处理中的哪个消息导致了故障，因此无法在重试用完后进行恢复。对于生产者创建的批次，由于只有一条消息实际上是失败的，因此可以恢复整个消息。应用程序可能希望通过设置抛出的异常的index属性来通知自定义恢复程序在批次中发生故障的位置。</p><p>批处理侦听器的重试恢复器必须实现MessageBatchRecoverer。</p><h4 id="3-3-18-4-消息侦听器和异步情况"><a href="#3-3-18-4-消息侦听器和异步情况" class="headerlink" title="3.3.18.4 消息侦听器和异步情况"></a>3.3.18.4 消息侦听器和异步情况</h4><p>如果MessageListener因业务异常而失败，则由消息侦听器容器处理该异常，然后该容器将返回侦听另一条消息。如果故障是由断开的连接（不是业务异常）引起的，则必须取消并重新启动为侦听器收集消息的消费者。 SimpleMessageListenerContainer无缝处理此问题，并留下一条日志说正在重新启动侦听器。实际上，它无限循环，试图重新启动消费者。只有当消费者表现得很糟糕时，它才会放弃。副作用是，如果在容器启动时代理关闭，则它将继续尝试直到可以建立连接为止。</p><p>与协议错误和连接断开相反，业务异常处理可能需要更多考虑和一些自定义配置，尤其是在使用事务或容器确认的情况下。在2.8.x之前，RabbitMQ没有死信行为的定义。因此，默认情况下，由于业务异常而被拒绝或回滚的消息可以无限地重新发送。为了限制客户端的重传次数，一种选择是侦听器建议链中的StatefulRetryOperationsInterceptor。拦截器可以具有实现自定义死信操作的恢复回调-适用于您的特定环境的任何回调。</p><p>另一种选择是将容器的defaultRequeueRejected属性设置为false。这将导致所有失败的消息被丢弃。当使用RabbitMQ 2.8.x或更高版本时，这也有助于将消息传递给死信交换。</p><p>或者，可以引发AmqpRejectAndDontRequeueException。这样做可以防止消息重新排队，而不管defaultRequeueRejected属性的设置如何。</p><p>从2.1版开始，引入了InstantRequeueAmqpException以执行完全相反的逻辑：无​​论defaultRequeueRejected属性如何设置，都会重新排队消息。</p><p>通常，将两种技术结合使用。您可以将通知链中的StatefulRetryOperationsInterceptor与抛出AmqpRejectAndDontRequeueException的MessageRecoverer一起使用。当所有重试用尽后，将调用MessageRecover。 RejectAndDontRequeueRecoverer正是这样做的。默认的MessageRecoverer使用错误的消息并发出WARN消息。</p><p>从1.3版开始，提供了新的RepublishMessageRecoverer，以允许在重试用尽后发布失败的消息。</p><p>当恢复者使用了最后的例外时，该消息将被确认，并且不会发送到死信交换处（如果有的话）。</p><p>在消费者方使用RepublishMessageRecoverer时，接收到的消息在receiveDeliveryMode消息属性中具有deliveryMode。在这种情况下，deliveryMode为null。这意味着代理上的NON_PERSISTENT交付模式。从2.0版开始，您可以为deliveryMode配置RepublishMessageRecoverer，以将其设置为要重新发布的消息（如果为null）。默认情况下，它使用MessageProperties的默认值-MessageDeliveryMode.PERSISTENT。<br>以下示例显示如何将RepublishMessageRecoverer设置为恢复器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">RetryOperationsInterceptor interceptor() &#123;</span><br><span class="line">return RetryInterceptorBuilder.stateless()</span><br><span class="line">.maxAttempts(5)</span><br><span class="line">.recoverer(new RepublishMessageRecoverer(amqpTemplate(), &quot;something&quot;, &quot;somethingelse&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RepublishMessageRecoverer在消息头中发布消息以及其他信息，例如异常消息，堆栈跟踪，原始交换和路由键。可以通过创建子类并覆盖AdditionalHeaders（）来添加其他标头。也可以在additionalHeaders（）中更改deliveryMode（或任何其他属性），如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RepublishMessageRecoverer recoverer = new RepublishMessageRecoverer(amqpTemplate, &quot;error&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    protected Map&lt;? extends String, ? extends Object&gt; additionalHeaders(Message message, Throwable cause) &#123;</span><br><span class="line">        message.getMessageProperties()</span><br><span class="line">            .setDeliveryMode(message.getMessageProperties().getReceivedDeliveryMode());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从2.0.5版开始，如果堆栈跟踪太大，则可能会被截断；这是因为所有标头都必须放在一个框架中。默认情况下，如果堆栈跟踪将导致少于20,000字节（“余量”）可用于其他标头，则它将被截断。如果您需要更多或更少的空间放置其他标头，则可以通过设置恢复程序的frameMaxHeadroom属性进行调整。从版本2.1.13、2.2.3开始，此计算中包括异常消息，并且使用以下算法将最大化堆栈跟踪量：</p><p>如果仅堆栈跟踪将超出限制，则异常消息标头将被截断为97个字节加……且堆栈跟踪也将被截断。</p><p>如果堆栈跟踪很小，则消息将被截断（加……）以适合可用字节（但是堆栈跟踪本身内的消息将被截断为97字节加…）。</p><p>每当发生任何截断时，都会记录原始异常以保留完整的信息。</p><p>从2.1版开始，添加了InstantRequeueMessageRecoverer以引发InstantRequeueAmqpException，该异常通知侦听器容器重新排队当前失败的消息。</p><h4 id="3-3-18-5-Spring重试的异常分类"><a href="#3-3-18-5-Spring重试的异常分类" class="headerlink" title="3.3.18.5 Spring重试的异常分类"></a>3.3.18.5 Spring重试的异常分类</h4><p>Spring Retry在确定哪些异常可以调用重试方面具有很大的灵活性。默认配置将重试所有异常。鉴于用户异常被包装在ListenerExecutionFailedException中，我们需要确保分类检查异常原因。默认分类器仅查看顶级异常。</p><p>从Spring Retry 1.0.3开始，BinaryExceptionClassifier具有一个名为traverseCauses的属性（默认值：false）。为true时，它将遍历异常原因，直到找到匹配项或没有原因为止。</p><p>要使用此分类器进行重试，可以使用通过构造函数创建的SimpleRetryPolicy，该构造函数采用最大尝试次数，异常映射实例和布尔值（traverseCauses），然后将此策略注入RetryTemplate。</p><h3 id="3-3-19-Debugging"><a href="#3-3-19-Debugging" class="headerlink" title="3.3.19 Debugging"></a>3.3.19 Debugging</h3><p>Spring AMQP提供了广泛的日志记录，尤其是在DEBUG级别。</p><p>如果要监视应用程序和代理之间的AMQP协议，可以使用诸如WireShark之​​类的工具，该工具具有用于解码协议的插件。另外，RabbitMQ Java客户端带有一个非常有用的类，称为Tracer。默认情况下，作为主服务器运行时，它将侦听端口5673并连接到本地主机上的端口5672。您可以运行它并更改连接工厂配置以连接到本地主机上的端口5673。它在控制台上显示解码的协议。有关更多信息，请参考Tracer Javadoc。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>从2.2版开始，回调是在连接工厂的执行程序线程之一上调用的，在之前的版本中回调直接在amqp-client连接I / O线程上调用；如果执行某些RPC操作（例如打开新通道），则会死锁，因为I / O线程阻塞了等待结果，但是结果需要由I / O线程本身处理。对于那些版本，有必要将工作（例如发送消息）移交给回调中的另一个线程。由于框架现在将回调调用移交给了执行程序，因此不再需要此操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-ConnectionFactory&quot;&gt;&lt;a href=&quot;#1-ConnectionFactory&quot; class=&quot;headerlink&quot; title=&quot;1. ConnectionFactory&quot;&gt;&lt;/a&gt;1. ConnectionFactory&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.programer.group/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RabbitMQ" scheme="http://blog.programer.group/tags/RabbitMQ/"/>
    
      <category term="Spring AMQP" scheme="http://blog.programer.group/tags/Spring-AMQP/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Stream</title>
    <link href="http://blog.programer.group/java/2019-12-25-java8-stream/"/>
    <id>http://blog.programer.group/java/2019-12-25-java8-stream/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-01-07T13:18:10.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Java8-Stream"><a href="#什么是Java8-Stream" class="headerlink" title="什么是Java8 Stream"></a>什么是Java8 Stream</h2><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚集操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。</p><p>A pipeline is a sequence of aggregate operations. The following example prints the male members contained in the collection roster with a pipeline that consists of the aggregate operations filter and forEach:</p><p>管道是一个聚集操作的序列。下面的例子使用包含聚集操作filter和forEach的管道打印包含在roster集合中男性成员的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(e -&gt; e.getGender() == Person.Sex.MALE)</span><br><span class="line">    .forEach(e -&gt; System.out.println(e.getName()));</span><br></pre></td></tr></table></figure><p>管道包含如下的组件：</p><ul><li>一个源：可以是一个集合、数组、一个生成方法，或者I/O channel。</li><li>零个或者多个中间操作。一个中间操作，例如filter，生成一个流。</li><li>一个终止操作，一个终止操作例如forEach，产生一个非流结果。例如原始值（如double值），集合，或者在forEach的情况下根本没有任何值。 </li></ul><blockquote><p>流是一个元素的序列。不像一个集合，它不是一个数据结构存储元素。相反，一个流通过管道从一个源中提取值。filter操作返回一个包含匹配它断言的要素集的新流。</p></blockquote><h2 id="聚集操作相比于Iterator的不同"><a href="#聚集操作相比于Iterator的不同" class="headerlink" title="聚集操作相比于Iterator的不同"></a>聚集操作相比于Iterator的不同</h2><ul><li>使用内部遍历： 聚集操作不包含类似于指示处理集合内的下一个元素的next方法。使用内部委派，你的应用程序确定要迭代的集合，而JDK确定如何迭代该集合。使用外部迭代，你的应用决定它迭代什么集合和它怎样迭代。但是，外部迭代仅仅可以有序的迭代集合的元素。内部迭代没有这个限制，它可以更好的发挥并行计算的优势，它可以将问题分发为子问题，同时解决这些问题，然后将解决子问题方案的结果组合。</li><li>从流中处理元素：聚集操作从流中处理元素，不是直接从集合中。因此，它们也称作流操作。</li><li>他们支持行为作为参数：对于大多数聚集操作你可以指定lambda表达式作为参数，这允许你自定义一个特定的聚集操作的行为动作。</li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><code>boolean    allMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether all elements of this stream match the provided predicate.</li><li><code>boolean    anyMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether any elements of this stream match the provided predicate.</li><li><code>static &lt;T&gt; Stream.Builder&lt;T&gt; builder()</code><br>Returns a builder for a Stream.</li><li><code>&lt;R,A&gt; R    collect(Collector&lt;? super T,A,R&gt; collector)</code><br>Performs a mutable reduction operation on the elements of this stream using a Collector.</li><li><code>&lt;R&gt; R    collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code><br>Performs a mutable reduction operation on the elements of this stream.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code><br>Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.</li><li><code>long    count()</code><br>Returns the count of elements in this stream.</li><li><code>Stream&lt;T&gt;    distinct()</code><br>Returns a stream consisting of the distinct elements (according to Object.equals(Object)) of this stream.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    empty()</code><br>Returns an empty sequential Stream.</li><li><code>Stream&lt;T&gt;    filter(Predicate&lt;? super T&gt; predicate)</code><br>Returns a stream consisting of the elements of this stream that match the given predicate.</li><li><code>Optional&lt;T&gt;    findAny()</code><br>Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.</li><li><code>Optional&lt;T&gt;    findFirst()</code><br>Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty.</li><li><code>&lt;R&gt; Stream&lt;R&gt;    flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code><br>Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>DoubleStream    flatMapToDouble(Function&lt;? super T,? extends DoubleStream&gt; mapper)</code><br>Returns an DoubleStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>IntStream    flatMapToInt(Function&lt;? super T,? extends IntStream&gt; mapper)</code><br>Returns an IntStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>LongStream    flatMapToLong(Function&lt;? super T,? extends LongStream&gt; mapper)</code><br>Returns an LongStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>void    forEach(Consumer&lt;? super T&gt; action)</code><br>Performs an action for each element of this stream.</li><li><code>void    forEachOrdered(Consumer&lt;? super T&gt; action)</code><br>Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    generate(Supplier&lt;T&gt; s)</code><br>Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    iterate(T seed, UnaryOperator&lt;T&gt; f)</code><br>Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.</li><li><code>Stream&lt;T&gt;    limit(long maxSize)</code><br>Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.</li><li><code>&lt;R&gt; Stream&lt;R&gt;    map(Function&lt;? super T,? extends R&gt; mapper)</code><br>Returns a stream consisting of the results of applying the given function to the elements of this stream.</li><li><code>DoubleStream    mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code><br>Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>IntStream    mapToInt(ToIntFunction&lt;? super T&gt; mapper)</code><br>Returns an IntStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>LongStream    mapToLong(ToLongFunction&lt;? super T&gt; mapper)</code><br>Returns a LongStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>Optional&lt;T&gt;    max(Comparator&lt;? super T&gt; comparator)</code><br>Returns the maximum element of this stream according to the provided Comparator.</li><li><code>Optional&lt;T&gt;    min(Comparator&lt;? super T&gt; comparator)</code><br>Returns the minimum element of this stream according to the provided Comparator.</li><li><code>boolean    noneMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether no elements of this stream match the provided predicate.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    of(T... values)</code><br>Returns a sequential ordered stream whose elements are the specified values.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    of(T t)</code><br>Returns a sequential Stream containing a single element.</li><li><code>Stream&lt;T&gt;    peek(Consumer&lt;? super T&gt; action)</code><br>Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.</li><li><code>Optional&lt;T&gt;    reduce(BinaryOperator&lt;T&gt; accumulator)</code><br>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.</li><li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code><br>Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.</li><li><code>&lt;U&gt; U    reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</code><br>Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions.</li><li><code>Stream&lt;T&gt;    skip(long n)</code><br>Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream.</li><li><code>Stream&lt;T&gt;    sorted()</code><br>Returns a stream consisting of the elements of this stream, sorted according to natural order.</li><li><code>Stream&lt;T&gt;    sorted(Comparator&lt;? super T&gt; comparator)</code><br>Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.</li><li><code>Object[]    toArray()</code><br>Returns an array containing the elements of this stream.</li><li><code>&lt;A&gt; A[]    toArray(IntFunction&lt;A[]&gt; generator)</code><br>Returns an array containing the elements of this stream, using the provided generator function to allocate the returned array, as well as any additional arrays that might be required for a partitioned execution or for resizing.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">Java 8 中的 Streams API 详解-陈争云, 占宇剑, 和司磊</a></p><p><a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html#pipelines" target="_blank" rel="noopener">Pipelines and Streams</a></p><p><a href="https://docs.oracle.com/javase/10/index.html" target="_blank" rel="noopener">Java™ Platform Standard Ed. 8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Java8-Stream&quot;&gt;&lt;a href=&quot;#什么是Java8-Stream&quot; class=&quot;headerlink&quot; title=&quot;什么是Java8 Stream&quot;&gt;&lt;/a&gt;什么是Java8 Stream&lt;/h2&gt;&lt;p&gt;Java 8 中的 Stream 是
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.programer.group/tags/Java/"/>
    
      <category term="笔记" scheme="http://blog.programer.group/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统概念</title>
    <link href="http://blog.programer.group/mysql/2019-12-05-database/"/>
    <id>http://blog.programer.group/mysql/2019-12-05-database/</id>
    <published>2019-12-04T16:00:00.000Z</published>
    <updated>2020-05-21T14:33:43.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1. 什么是数据库？"></a>1. 什么是数据库？</h3><p>数据库管理系统（DataBase-Management System， DBMS）由一个互相关联的数据的集合和一组用以访问这些数据的程序组成。这个数据集通常称为数据库。</p><p>数据库结构的基础是数据模型（data model）。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。</p><p>数据模型可被划分为四类：</p><ul><li>关系模型（relational）：关系模型用表的集合来表示数据和数据间的联系。</li><li>实体-联系模型（entity-relationship model）：实体-联系（E-R）数据模型给予对现实世界的这样一种认识：现实世界由一组称作实体的基本对象以及这些对象间的联系构成。</li><li>基于对象的数据模型（object-based data model）：面向对象的数据模型可以看成是E-R模型增加封装、方法和对象标识等概念后的扩展。</li><li>半结构化数据模型（semistructured data model）：半结构化数据结构模型允许那些相同类型的数据项含有不同的属性集的数据定义。可扩展标记语言（eXtensible Markup Language， XML）被广泛的用来表示半结构化数据。</li></ul><h3 id="2-数据库语言"><a href="#2-数据库语言" class="headerlink" title="2. 数据库语言"></a>2. 数据库语言</h3><p>数据库操纵语言（Data-manipulationn Language）来表达数据的查询和更新。数据库定义语言（data-definition language）来定义数据库模型。</p><h3 id="3-关系数据库"><a href="#3-关系数据库" class="headerlink" title="3. 关系数据库"></a>3. 关系数据库</h3><p>关系数据库基于关系模型，使用一系列来表达数据以及这些数据之间的联系。</p><h4 id="3-1-关系数据库的结构"><a href="#3-1-关系数据库的结构" class="headerlink" title="3.1 关系数据库的结构"></a>3.1 关系数据库的结构</h4><p>关系数据库由表的集合构成，每个表有唯一的名字。</p><p>一般来说，表中一行代表了一组值之间的一种联系。由于一个表就是这种联系的一个集合，表这个概念和数学上的关系这个概念是密切相关的，这也正是关系数据模型名称的由来。</p><h3 id="4-数据库存储和查询"><a href="#4-数据库存储和查询" class="headerlink" title="4. 数据库存储和查询"></a>4. 数据库存储和查询</h3><p>存储管理器是数据库系统中负责在数据库中存储的低层数据与应用程序以及向系统提交的查询之间提供接口的部件。存储管理器负责与文件管理器交互。原始数据通过操作系统提供的文件系统存储在磁盘上。存储管理器将各种DML语句翻译为底层文件系统命令。</p><p>存储管理部件：</p><ul><li>权限及完整性管理器（authorization and integrity manager）,它检测是否满足完整性约束，并检查试图访问数据的用户的权限。</li><li>事务管理器（transaction manager），它保证即使发生了故障，数据库也保持在一致的状态，并保证并发事务的执行不发生冲突。</li><li>文件管理器（file manager），它管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构。</li><li>缓冲区管理器（buffer manager），它负责将数据从磁盘取到内存中来，并决定你哪些数据应被缓冲存储在内存中。缓冲区管理器 是数据库系统中的一个关键部分，因为它使用数据库可以处理比内存更大的数据。</li></ul><p>存储管理器实现了集中数据结构：</p><ul><li>数据文件（data files），存储数据库自身。</li><li>数据字典（data dictionary），存储关于数据库结构的元数据，尤其是数据库模式。</li><li>索引（index），提供对数据项的快速访问。</li></ul><p>查询处理器：</p><ul><li>DDL解释器（DDL interpreter），它解释DDL语句并将这些定义记录在数据字典中。</li><li>DML编译器（DML compiler），将查询语言中的 DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。</li></ul><p>一个查询通常可被翻译为多种等价的具有相同结果的执行方案的一种。DML编译器还进行查询优化（query optimization），也就是从几种选择中选出代价最小的一种。</p><ul><li>查询执行引擎（query evaluation engine），执行由DML编译器产生的低级指令。</li></ul><h3 id="5-事务管理"><a href="#5-事务管理" class="headerlink" title="5. 事务管理"></a>5. 事务管理</h3><p>事务（transaction）是数据库应用中完成单一逻辑功能的操作集合。每一个事务是一个既具有原子性又具有一致性的单元。</p><p>事务管理器（transaction manager）包括并发控制管理器和恢复管理器。</p><p>并发管理器（concurrency-control manager）控制并发事务间的相互影响，保证数据库一致性。</p><p>恢复管理器（recovery manager）负责保证原子性和持久性。</p><h3 id="6-数据库体系结构"><a href="#6-数据库体系结构" class="headerlink" title="6. 数据库体系结构"></a>6. 数据库体系结构</h3><p>数据库应用通常可分为两或三个部分。</p><p><img src="/media/article/database-structure.png" alt="database-structure"></p><h3 id="7-数据挖掘和信息检索"><a href="#7-数据挖掘和信息检索" class="headerlink" title="7. 数据挖掘和信息检索"></a>7. 数据挖掘和信息检索</h3><p>数据挖掘（data mining）这个术语指半自动地分析大型数据库并从中找出有用的模式的过程。</p><h2 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h2><h3 id="1-SQL查询语言预览"><a href="#1-SQL查询语言预览" class="headerlink" title="1. SQL查询语言预览"></a>1. SQL查询语言预览</h3><ul><li>数据定义语言 （Data-Definition Language， DDL）：SQL DDL提供定义关系模式、删除关系以及修改关系模式的命令。</li><li>数据操作语言（Data-Manipulation Language， DML）：SQL DML提供从数据库中查询信息，以及 在数据库中插入元组、删除元组、修改元组的能力。</li><li>完整性（integrity）：SQL DDL包括定义完整性约束的命令，保存在数据库中的数据必须满足所定义的完整性约束。破坏完整性约束的更新是不允许的。</li><li>视图定义 （view definition）：SQL DDL包括定义视图的命令。</li><li>事务控制（transaction control）：SQL 包括定义事务的开始和结束的命令。</li><li>嵌入式SQL和动态SQL（embedded SQL and dynamic SQL）：嵌入式和动态SQL定义SQL语句如何嵌入到通用编程语言，如C、C++和Java中。</li><li>授权（authorization）：SQL DDL包括定义对关系和视图的访问权限的命令。</li></ul><h4 id="1-1-SQL数据定义"><a href="#1-1-SQL数据定义" class="headerlink" title="1.1 SQL数据定义"></a>1.1 SQL数据定义</h4><p>基本类型：</p><ul><li>char(n)：固定长度的字符串，用户指定长度n。也可以使用全称character。</li><li>varchar(n)：可变长度的字符串，用户指定最大长度n，等价于全称character varying。</li><li>int：整数类型，等价于integer。</li><li>smallint：小整数类型。</li><li>numeric(p,d)：定点数，精度由用户指定。</li><li>real，double precision：浮点数与双精度浮点数，精度与机器相关。</li><li>float(n)：精度至少为n位的浮点数。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>两种基本的索引类型：</p><ul><li>顺序索引。基于值的顺序排序。</li><li>散列索引。介于将值平均分不到若干散列桶中。一个值所属的散列桶是由一个函数决定的，该函数称为散列函数。</li></ul><p>对于索引的考虑因素：</p><ul><li>访问类型（access type）：能有效支持的访问类型。访问类型可以包括找到具有特定属性值的记录，以及找到属性值落在某个特定范围内的记录。</li><li>访问时间（access time）：在查询中使用该技术找到一个特定数据项货数据项集所需的时间。</li><li>插入时间（insertion time）：插入一个新数据项所需的时间。该值包括找到待删除项所需的时间，以及更新索引结构所需的时间。</li><li>空间开销（space overhead）：索引结构所占用的额外存储空间。</li></ul><h3 id="1-顺序索引"><a href="#1-顺序索引" class="headerlink" title="1. 顺序索引"></a>1. 顺序索引</h3><p>顺序索引按照顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。<br>被索引的文件中的记录自身也可以按照某种排序顺序存储，正如图书馆中的书按某些属性顺序存放一样。一个文件可以有多个索引，分别基于不同的搜索码。<br><strong><em>如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为聚集索引（clustering index）</em></strong>。聚集索引也称为 主索引（primary index）；搜索码指定的顺序与文件中记录的物理顺序不同的索引称为非聚集索引（nonclustering index）或辅助索引（secondary index）。</p><h4 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h4><p>索引项（index entry）或索引记录（index record）由一个搜索码值和指向具有该搜索码值的一条或者多条记录的指针构成。指向记录的指针包括磁盘块的标识和标识磁盘块内记录的块内偏移量。<br>可以使用的顺序索引有两类：</p><ul><li>稠密索引（dense index）：在稠密索引中，文件中的每个搜索码值都有一个索引项。在稠密索引中，索引项包括搜索码值以及指向具有该搜索码的第一条数据记录的指针。具有相同搜索码值的其余记录顺序的存储在第一条数据记录之后，由于该索引是聚集索引，因此记录根据相同的索引码值排序。在稠密非聚集索引中，索引必须存储指向所有具有相同搜索码值的记录的指针列表。</li><li>稀疏索引（sparse index）：在稀疏索引中，只为搜索码的某些值建立索引项。只有当关系按搜索码排列顺序存储时才能使用稀疏索引，换句话说，只有索引是聚集索引时才能使用稀疏索引。和稠密索引一样，每个索引项也包括一个搜索码和指向具有该搜索码值的第一条记录的指针。为了定位一条记录，我们找到其最大搜索码值小于或等于所查找记录的搜索码值的索引项。然后从该索引项指向的记录开始，沿着文件的指针查找，直到找到记录为止。</li></ul><p><img src="/media/article/dense-sparse-index.png" alt="dennse-sparse"></p><h4 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h4><p>具有两级或者两级以上的索引称为多集（multilevel）索引。多级索引搜索记录于用二分法搜索记录相比需要的I/O操作要少得多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;1-什么是数据库？&quot;&gt;&lt;a href=&quot;#1-什么是数据库？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是数
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://blog.programer.group/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="http://blog.programer.group/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis空间优化</title>
    <link href="http://blog.programer.group/redis/2019-11-13-redis-space-optimization/"/>
    <id>http://blog.programer.group/redis/2019-11-13-redis-space-optimization/</id>
    <published>2019-11-12T16:00:00.000Z</published>
    <updated>2019-11-15T10:57:00.167Z</updated>
    
    <content type="html"><![CDATA[<p>我们项目使用Redis越来越多，可是Redis毕竟是基于内存的数据库，所以对于Redis的空间使用如果不加注意，很容易导致内存溢出。</p><h3 id="1-Redis数据结构"><a href="#1-Redis数据结构" class="headerlink" title="1. Redis数据结构"></a>1. Redis数据结构</h3><p>Redis使用了五种数据对象：字符串对象，列表对象，哈希对象，集合对象，有序集合对象。</p><p>Redis基于这五种对象也给出了优化：</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串中有int、embstr和raw（Simple Dynamic String）两种存储字符串的结构。如果只读且大小小于32字节，则使用embstr，否则使用raw，embstr只能转化为raw，raw不能转化为embstr。关于两者的区别详细了解<a href="/redis/2019-06-21-redis/#1-8-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1">Redis设计与实现</a></p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的底层数据结构在3.2版本之前可以是链表（linkedlist），也可以是压缩列表（ziplist），对于链表保存不需要连续的内存空间（是优点也是缺点，容易造成内存碎片），相比于压缩列表多了保存pre、next指针的空间，ziplist保存在连续内存空间上，不需要维护pre、next指针。当保存的字符串长度小于64字节且列表对象个数小于512时使用压缩列表。</p><p>在3.2版本之后唯一的数据结构是快表（quicklist），它是一个双向链表，而且是一个ziplist的双向链表。这是什么意思呢？我们知道，双向链表是由多个节点（Node）组成的。这个描述的意思是：quicklist的每个节点都是一个ziplist。</p><p>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</p><p>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象底层数据结构可以是ziplist和字典hashtable。ziplist存储字符串不超过32字节和总个数不超过512的数据。</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象底层数据结构是intset或者hashtable。</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合对象底层数据结构是ziplist或者是skiplist。当存储的字符串长度大于64时转为skiplist。<br>skiplist存储时使用skiplist和hashtabl两种结构进行存储，如果我们只是用字典hashtable来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p><p>需要注意的是<strong><em>字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p>使用上述对象时，需要考虑底层数据结构特性，是否会因为频繁删除增加修改，造成Redis的内存碎片化，频繁修改的数据不建议放入到Redis。不仅如此，考虑到Redis空间的复用性，对于不常用的key设置过期时间。</p><h3 id="2-Redis存储优化"><a href="#2-Redis存储优化" class="headerlink" title="2. Redis存储优化"></a>2. Redis存储优化</h3><p>本章节摘自《<a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a>》</p><ol><li><p>利用Redis内存分配器做第一层优化。例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p></li><li><p>尽量使用整型/长整型。如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。</p></li><li><p>利用共享对象，共享对象包括10000个整数，可以通过REDIS_SHARED_INTEGERS参数提高共享对象的个数。</p></li><li><p>关注内存碎片率，如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。</p></li><li><p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p></li><li><p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a></p><p><a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a></p><p><a href="/redis/2019-06-21-redis/#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8%E5%AD%98%E5%82%A8%E6%95%88%E7%8E%87">quicklist存储效率</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们项目使用Redis越来越多，可是Redis毕竟是基于内存的数据库，所以对于Redis的空间使用如果不加注意，很容易导致内存溢出。&lt;/p&gt;
&lt;h3 id=&quot;1-Redis数据结构&quot;&gt;&lt;a href=&quot;#1-Redis数据结构&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://blog.programer.group/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://blog.programer.group/concurrency/2019-11-07-threadpool/"/>
    <id>http://blog.programer.group/concurrency/2019-11-07-threadpool/</id>
    <published>2019-11-06T16:00:00.000Z</published>
    <updated>2020-05-21T14:33:54.550Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在生产环境中，应避免直接创建线程，线程数量必须得到控制。</p></blockquote><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>为了控制线程，JDK类库提供了一套Executor框架。</p><p><img src="/media/article/executor.png" alt="executor"></p><p>线程池是JDK用来管理线程的的静态工厂。上图中ThreadPoolExecutor表示一个线程池。<br>Executor是一个接口，接口中只有<code>void execute(Runnable command)</code>方法。<br>ExecutorService也是一个接口，继承ExecutorService，增加了许多使用线程池的公用方法定义。<br>AbstactExecutorService为ExecutorService接口提供了默认实现。<br>ThreadPoolExecutor继承AbstactExecutorService抽象类。<br>Executors类是JDK1.5版本时封装的线程池工厂和工具类，这个类提供了几种默认的<a href="/concurrency/2019-11-07-threadpool/#1-2-Executor%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90">线程池类型</a>和默认线程池工厂。<br>ForkJoinPool是Java7加入的一种用于并行执行任务的框架</p><h3 id="1-1-创建线程池"><a href="#1-1-创建线程池" class="headerlink" title="1.1 创建线程池"></a>1.1 创建线程池</h3><p>创建线程池的实现其实是实例化ThreadPoolExecutor的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>corePoolSize：指定线程池中的线程数量。<br>maximumPoolSize：线程池中的最大线程数量。<br>keepAliveTime：当线程池超过corePoolSize时，多余的空闲线程的空闲时间。<br>unit：keepAliveTime的时间单位。<br>workQueue：任务队列，被提交但未被执行的任务。<br>threadFactory工厂：创建线程的工厂，一般默认就可以。<br>handler：拒绝策略，当线程池满负荷运行，如何拒绝新的任务的策略。</p><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>keepAliveTime，unit，threadFactory几个参数可根据线程池的任务场景去做简单的变化，在此不再赘述，一般自定义线程池我们的关注点大都在corePoolSize，maximumPoolSize，workQueue，handler四个参数上。</p><p>corePoolSize，根据业务的通用场景确定即可。《Java并发编程实践》书中给出了一个估算线程池corePoolSize大小的经验公式：<br>Ncpu=cpu数量<br>Ucpu=希望cpu的使用率，0&lt;Ucpu&lt;1<br>W/C=等待时间与计算时间的比率， <a href="https://www.cnblogs.com/gatsby123/p/11127158.html" target="_blank" rel="noopener">CPU计算时间计算方式</a></p><p><code>Nthreads=Ncpu*Ucpu*(1+W/C)</code></p><p>如果你处理的是阻塞比较多的任务，你可以根据上述公式大致算出需要的线程数量（一般会远远超出当前实例所在服务器的cpu数量）；如果是阻塞比较少的任务即cpu计算比重较大的任务，线程的数量可能就会相应的减少一些，避免服务器的超负荷运行。总之线程数不是精确的一个数，只要符合你业务的场景的大概数量就可以。</p><p>workQueue任务队列分为有限、无限、同步移交三种阻塞队列，常用的有如下几个：</p><ul><li>ArrayBlockingQueue: 一个基于数组结构的有界阻塞队列，此队列按照FIFO原则排序。</li><li>LinkedBlockingQueue: 一个基于链表的阻塞队列，此队列按照FIFO原则排序，吞吐量高于ArrayBlockingQueue。</li><li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须阻塞到另一个线程的移除操作。</li><li>PriorityBlockingQueue: 具有优先级的无限阻塞队列。</li></ul><p>线程池的执行过程：</p><p><img alt="threadpool-processor" src="/media/article/threadpool-processor.png" width="75%"></p><p>–图摘自《Java并发编程艺术》9.1小节-线程池的实现原理。</p><p>队列的大小和maxmumPoolSize息息相关，如果使用无界队列，则maxmumPoolSize也就失效了，如果使用的是有界队列，则当有界队列满了，则新启动线程执行任务。直到最大线程也满了之后执行拒绝策略。</p><p>最后就是拒绝策略:</p><ul><li>AbortPolicy: 直接抛出异常。</li><li>CallerRunPolicy: 使用调用者的线程执行任务。</li><li>DiscardOldestPolicy: 丢弃队列里最老的任务，并执行当前任务。</li><li>DiscardPolicy: 不处理，丢弃。</li></ul><p>除此之外还可以实现RejectExecutionHandler接口，自定义拒绝策略。</p><h3 id="1-2-Executor提供的几种类型的线程池解析"><a href="#1-2-Executor提供的几种类型的线程池解析" class="headerlink" title="1.2 Executor提供的几种类型的线程池解析"></a>1.2 Executor提供的几种类型的线程池解析</h3><ol><li>Executors.newFixedThreadPool(1);</li></ol><p>Executors.newFixedThreadPool创建的线程池可以指定核心线程数，但是使用的是无界队列，如果是IO密集型任务，可能导致内存溢出。</p><ol start="2"><li>Executors.newSingleThreadExecutor();</li></ol><p>Executors.newSingleThreadExecutor()创建一个线程的线程池，同样使用无界队列，和newFixedThreadPool的差别仅限于核心线程数。</p><ol start="3"><li>Executors.newCachedThreadPool();</li></ol><p>Executors.newCachedThreadPool()创建的线程池是一个没有队列的存储任务的线程池，线程池最大数量为Integer.MAX_VALUE。所以这个线程池会一直创建新的线程执行任务，可能导致内存溢出。适用于中小数量级的任务，且任务非CPU密集型。</p><ol start="4"><li>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory());</li></ol><p>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory())创建可以定时或延时执行任务的线程池，与Timer相比，具有更多的弹性。<a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-add1.html" target="_blank" rel="noopener">详解Java定时任务—极客学院</a></p><ol start="5"><li>Executors.newWorkStealingPool();</li></ol><p>封装的ForkJoinPool线程池，线程数量为当前运行环境的cpu数量，不处理异常，异步模式。下一小节详细介绍。</p><h3 id="1-3-ForkJoinPool线程池初探"><a href="#1-3-ForkJoinPool线程池初探" class="headerlink" title="1.3 ForkJoinPool线程池初探"></a>1.3 ForkJoinPool线程池初探</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成小任务，最终汇总小任务结果后得到大任务结果的框架。</p><p><img src="/media/article/forkjoin.png" alt="forkjoin"></p><p>–图片摘自《Java并发编程的艺术》6.4.1 什么是Fork/Join框架 小节。</p><p>缺点：在某些情况下，该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。</p><h4 id="使用ForkJoinPool"><a href="#使用ForkJoinPool" class="headerlink" title="使用ForkJoinPool"></a>使用ForkJoinPool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private static final int THRESHOLD = 2;  // 阈值 private int start;</span><br><span class="line">private int end;</span><br><span class="line">public CountTask(int start, int end) &#123;</span><br><span class="line">    this.start = start; this.end = end;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected Integer compute() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    // 如果任务足够小就计算任务</span><br><span class="line">    boolean canCompute = (end - start) &lt;= THRESHOLD; </span><br><span class="line">    if (canCompute) &#123;</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">         sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">        int middle = (start + end) / 2;</span><br><span class="line">        CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end); // 执行子任务</span><br><span class="line">        leftTask.fork();</span><br><span class="line">        rightTask.fork();</span><br><span class="line">        // 等待子任务执行完，并得到其结果</span><br><span class="line">        int leftResult=leftTask.join();</span><br><span class="line">        int rightResult=rightTask.join();</span><br><span class="line">        // 合并子任务</span><br><span class="line">        sum = leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">    // 生成一个计算任务，负责计算1+2+3+4</span><br><span class="line">    CountTask task = new CountTask(1, 4);</span><br><span class="line">    // 执行一个任务</span><br><span class="line">    Future&lt;Integer&gt; result = forkJoinPool.submit(task); </span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–示例摘自《Java并发编程的艺术》6.4.4 使用Fork/Join框架 小节。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>ForkJoinTask提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被 取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(task.isCompletedAbnormally()) &#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>ForkJoinPool继承AbstractExecutorService。</p><p>ForkJoinPool参数：</p><ul><li>parallelism线程数量；</li><li>ForkJoinWorkerThreadFactory是ForkJoin线程工厂，创建ForkJoinWorkerThread的线程类实例；</li><li>mode是使用FIFO模式（true）还是LIFO模式（false）；</li><li>UncaughtExceptionHandler是异常处理；</li><li>workerNamePrefix工作线程的名称前缀；</li></ul><p>通常来说，我们使用ForkJoinPool时如果不指定线程数量时默认取2047和当前服务器cpu数量中的最小值。简单来说就是创建了一个fork/join线程的线程池。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">Effective Java 第二版 中文版 </a><br><a href="">实战Java高并发程序设计 葛一鸣，郭超编著</a><br><a href="">Java并发编程艺术 方腾飞，魏鹏，程晓明 著</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在生产环境中，应避免直接创建线程，线程数量必须得到控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-线程池&quot;&gt;&lt;a href=&quot;#1-线程池&quot; class=&quot;headerlink&quot; title=&quot;1. 线程池&quot;&gt;&lt;/a&gt;1. 线程池&lt;
      
    
    </summary>
    
    
      <category term="并发" scheme="http://blog.programer.group/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AspectJ</title>
    <link href="http://blog.programer.group/java/2019-10-04-aspectj/"/>
    <id>http://blog.programer.group/java/2019-10-04-aspectj/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-22T17:16:13.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文引用自<a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p></blockquote><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><blockquote><p>AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言。当然，AspectJ需要使用额外的编译器。</p></blockquote><blockquote><p>AspectJ可以通过多种方式实现，包括源码织入或字节码织入，并且可以直接在虚拟机（VM）中实现。在所有情况下，AspectJ程序都将成为在Java VM中运行的有效Java程序。受切面影响的类与不受影响的类具有二进制兼容性（以保持与不受影响的原始文件编译的类兼容）。支持多种实现方式使该语言可以随着技术的变化而发展，并且与Java兼容可确保平台可用性。<br>AspectJ采用编译期织入和类加载期织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<br>使用AspectJ LTW有两个主要步骤，第一，通过JVM的-javaagent参数设置LTW的织入器类包，以代理JVM默认的类加载器；第二，LTW织入器需要一个aop.xml文件，在该文件中指定切面类和需要进行切面织入的目标类。</p></blockquote><blockquote><p>设置-javaagent JVM参数的方法:<br>(1)在Eclipse下的设置:<br>运行类-&gt;右键单击-&gt;Run As-&gt;Run…，可以在弹出的Run设置窗口设置该类的各项运行属性，切换到Arguments Tab页，在VM arguments中通过-javaagent指定AspectJ 织入器类包。<br>-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar<br>(2)在Tomcat下的设置<br>打开&lt;Tomcat_Home&gt;\bin\catalina.bat，在该批处理文件头部添加以下的设置：<br>set JAVA_OPTS=-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文引用自&lt;a href=&quot;https://www.iteye.com/blog/log-cd-562056&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AspectJ LTW(Load Time Weaving)&lt;/a&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.programer.group/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="http://blog.programer.group/java/2019-10-04-reflection/"/>
    <id>http://blog.programer.group/java/2019-10-04-reflection/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2020-06-03T12:58:23.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这种动态获取信息以及动态创建/调用对象方法的功能称为Java语言的反射机制。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以在运行时动态的确定类型并创建实例，可以调用实例中的任意方法即是方法时private的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>相比于编译时确定类型的方式，运行时确定类型创建实例会带来一定的性能消耗。</li><li>反射需要运行时的权限，这种权限可能在安全管理器下运行时可能不存在。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。</li><li>由于反射允许代码执行非反射代码中非法的操作（例如访问私有字段和方法），因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射代码破坏了抽象，因此可能会随着平台的升级而改变行为。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><p>反射调用慢在哪里？</p></blockquote><p>相对于在编译时确定对象类型，反射是在运行时动态创建对象并确定对象类型，所以会比编译时确定对象类型多一些性能消耗即慢。<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  User user = new User();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在4.5ms左右</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  Class&lt;?&gt; clazz =  Class.forName(&quot;com.zhongyp.advanced.refect.User&quot;, true, ReflectDemo.class.getClassLoader());</span><br><span class="line">            User user = (User) clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在20ms左右</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;p&gt;在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.programer.group/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB浅析</title>
    <link href="http://blog.programer.group/java/2019-10-04-cglib/"/>
    <id>http://blog.programer.group/java/2019-10-04-cglib/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2020-05-21T14:33:49.684Z</updated>
    
    <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><p>本文打算从这几个方面来理解CGLIB怎样生成动态代理类的：</p><ol><li><a href="#1-使用Cglib动态代理">怎样使用CGLIB？</a></li><li><a href="#2-CGLIB原理解析">CGLIB怎样生成/缓存动态代理类实例的？</a></li><li><a href="#3-CGLIB代理类调用方法原理解析">CGLIB生成的动态代理类怎样调用的，过程是怎样的，这样有什么好处？</a></li><li>常见问题<a href="#FAQ">FAQ</a></li></ol><h2 id="1-使用Cglib动态代理"><a href="#1-使用Cglib动态代理" class="headerlink" title="1. 使用Cglib动态代理"></a>1. 使用Cglib动态代理</h2><p>CGLIB的使用和JDK Proxy类似，不同的是CGLIB既可以指定接口，也可以直接代理未实现接口的普通类。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">LogInterceptor logInterceptor = new LogInterceptor();</span><br><span class="line">// 设置超类，cglib是通过继承来实现的</span><br><span class="line">enhancer.setSuperclass(UserDao.class);</span><br><span class="line">enhancer.setCallback(logInterceptor);</span><br><span class="line">/**</span><br><span class="line"> * 如果是实现指定接口，可以使用setInterfaces方法设置接口</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// enhancer.setInterfaces(new Class[]&#123;Dao.class&#125;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果使用createClass方法返回值为代理类的Class对象，需要设置CallbackType参数；当使用create方法时，CallbackType和callback都不为空时，两者类型必须相等。</span><br><span class="line"> * create方法返回的是代理类实例</span><br><span class="line"> * enhancer.setCallbackType(LogInterceptor.class);</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 创建代理类</span><br><span class="line">Dao dao = (Dao)enhancer.create();</span><br><span class="line">dao.select();</span><br></pre></td></tr></table></figure></p><p>// 方法拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">//        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">//        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>// 实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao implements Dao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-CGLIB生成动态代理类的原理解析"><a href="#2-CGLIB生成动态代理类的原理解析" class="headerlink" title="2. CGLIB生成动态代理类的原理解析"></a>2. CGLIB生成动态代理类的原理解析</h2><p>CGLIB，JDK proxy生成过程上大同小异，都是使用弱引用缓存已生成的Class对象，如果缓存中没有，则使用字节码技术生成动态代理类字节码和Class对象，只不过使用的字节码技术不太一样罢了。<br>下图是CGLIB动态代理生成代理类Class对象的流程：<a href="/media/article/cglib-processor.png">点击看大图</a></p><p><img src="/media/article/cglib-processor.png"></p><p>CGLIB动态代理基于ASM技术，使用<a href="/java/2019-10-06-asm/">ASM</a>技术的部分就是图中标红的模块。</p><p>CGLIB动态代理如果没有特殊设置也会缓存已生成的动态代理类的Class对象。</p><p><img src="/media/article/cglib-cache.png" alt="cglib-cache"></p><p>上图是CGLIB缓存动态代理类的Class对象的结构。</p><p>CGLIB第一次生成动态代理类Class对象的方法调用流程：</p><p><img src="/media/article/cglib-method.png" alt="cglib-method"></p><h2 id="3-CGLIB代理类调用方法原理解析"><a href="#3-CGLIB代理类调用方法原理解析" class="headerlink" title="3. CGLIB代理类调用方法原理解析"></a>3. CGLIB代理类调用方法原理解析</h2><blockquote><p>使用<code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;./&quot;)</code>可以输出生成的代理类的class文件。这里由于篇幅问题，只展示文章需要的内容，想看完整的代理类的字节码文件可以自己输出查看。</p></blockquote><p>CGLIB针对一个目标类一般会生成3个动态代理类，1个<code>UserDao$$EnhancerByCGLIB$$c00e2e9b extends UserDao implements Factory</code>，还有2个和调用有关的FastClass代理类<code>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc extends FastClass</code>，<code>UserDao$$FastClassByCGLIB$$890e5f18 extends FastClass</code></p><p>UserDao$$EnhancerByCGLIB$$c00e2e9b类的静态初始化块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 当前线程的缓存</span><br><span class="line">CGLIB$THREAD_CALLBACKS = new ThreadLocal();</span><br><span class="line">// 空参数对象</span><br><span class="line">CGLIB$emptyArgs = new Object[0];</span><br><span class="line">// 动态代理类的Class对象</span><br><span class="line">Class var0 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao$$EnhancerByCGLIB$$c00e2e9b&quot;);</span><br><span class="line">Class var1;</span><br><span class="line">// 只获取update和select的方法对象</span><br><span class="line">Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;update&quot;, &quot;()V&quot;, &quot;select&quot;, &quot;()V&quot;&#125;, (var1 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao&quot;)).getDeclaredMethods());</span><br><span class="line">CGLIB$update$0$Method = var10000[0];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$update$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;update&quot;, &quot;CGLIB$update$0&quot;);</span><br><span class="line">CGLIB$select$1$Method = var10000[1];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$select$1$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;select&quot;, &quot;CGLIB$select$1&quot;);</span><br></pre></td></tr></table></figure><p>当动态代理类调用update()方法（update是DAO接口内的方法）时，首先调用下面这个动态生成的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * cglib使用Class对象创建对象实例(Enhancer.nextNewInstance())的时候，会反射调用CGLIB$SET_THREAD_CALLBACKS方法，将MethodInterceptor实例缓存在CGLIB$THREAD_CALLBACKS这个代理类的的ThreadLocal中，然后初始化动态代理类实例时，调用CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">public final void update() &#123;</span><br><span class="line">   // 初始化动态代理类实例时，已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">   MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">       CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">       var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (var10000 != null) &#123;</span><br><span class="line">       var10000.intercept(this, CGLIB$update$0$Method, CGLIB$emptyArgs, CGLIB$update$0$Proxy);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       super.update();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">   UserDao$$EnhancerByCGLIB$$c00e2e9b var1 = (UserDao$$EnhancerByCGLIB$$c00e2e9b)var0;</span><br><span class="line">   if (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">       var1.CGLIB$BOUND = true;</span><br><span class="line">       Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">       if (var10000 == null) &#123;</span><br><span class="line">           var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">           if (CGLIB$STATIC_CALLBACKS == null) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 也就是说，初始化动态代理类实例时，最后如果var1.CGLIB$BOUND = true，则说明已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">       var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在调用到了MethodInterceptor的intercept方法了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">   // methodProxy.invokeSuper</span><br><span class="line">   Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>methodProxy，还记得动态代理类的static代码块么，在那时就已经初始化好了methodProxy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) &#123;</span><br><span class="line">   MethodProxy proxy = new MethodProxy();</span><br><span class="line">   // 使用Signature对象封装方法名和返回值</span><br><span class="line">   proxy.sig1 = new Signature(name1, desc);</span><br><span class="line">   proxy.sig2 = new Signature(name2, desc);</span><br><span class="line">   // 将UserDAO和UserDAO的动态代理类的Class文件放入CreateInfo对象</span><br><span class="line">   proxy.createInfo = new MethodProxy.CreateInfo(c1, c2);</span><br><span class="line">   return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了知道methodProxy怎么来的，继续往下走，invokeSuper():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       this.init();</span><br><span class="line">       MethodProxy.FastClassInfo fci = this.fastClassInfo;</span><br><span class="line">       // 这里调用的实际是FastClass代理类中的invoke方法</span><br><span class="line">       return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">   &#125; catch (InvocationTargetException var4) &#123;</span><br><span class="line">       throw var4.getTargetException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void init() &#123;</span><br><span class="line">   if (this.fastClassInfo == null) &#123;</span><br><span class="line">       Object var1 = this.initLock;</span><br><span class="line">       synchronized(this.initLock) &#123;</span><br><span class="line">           if (this.fastClassInfo == null) &#123;</span><br><span class="line">               MethodProxy.CreateInfo ci = this.createInfo;</span><br><span class="line">               MethodProxy.FastClassInfo fci = new MethodProxy.FastClassInfo();</span><br><span class="line">               // UserDAO和UserDAO的代理类分别有自己的FastClassInfo，分别使用个字的ClassInfo生成FastClass代理类</span><br><span class="line">               // 生成UserDAO的FastClass代理类</span><br><span class="line">               fci.f1 = helper(ci, ci.c1);</span><br><span class="line">               // 生成UserDAO代理类的FastClass代理类</span><br><span class="line">               fci.f2 = helper(ci, ci.c2);</span><br><span class="line">               // 生成方法索引</span><br><span class="line">               fci.i1 = fci.f1.getIndex(this.sig1);</span><br><span class="line">               fci.i2 = fci.f2.getIndex(this.sig2);</span><br><span class="line">               this.fastClassInfo = fci;</span><br><span class="line">               this.createInfo = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据索引调用方法，fci.i2的值为12，调用索引12的方法。<br>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc动态代理类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123;</span><br><span class="line">   c00e2e9b var10000 = (c00e2e9b)var2;</span><br><span class="line">   int var10001 = var1;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">       switch(var10001) &#123;</span><br><span class="line">       case 0:</span><br><span class="line">           return new Boolean(var10000.equals(var3[0]));</span><br><span class="line">       case 1:</span><br><span class="line">           return var10000.toString();</span><br><span class="line">       case 2:</span><br><span class="line">           return new Integer(var10000.hashCode());</span><br><span class="line">       case 3:</span><br><span class="line">           return var10000.clone();</span><br><span class="line">       case 4:</span><br><span class="line">           var10000.update();</span><br><span class="line">           return null;</span><br><span class="line">       case 5:</span><br><span class="line">           return var10000.newInstance((Class[])var3[0], (Object[])var3[1], (Callback[])var3[2]);</span><br><span class="line">       case 6:</span><br><span class="line">           return var10000.newInstance((Callback)var3[0]);</span><br><span class="line">       case 7:</span><br><span class="line">           return var10000.newInstance((Callback[])var3[0]);</span><br><span class="line">       case 8:</span><br><span class="line">           var10000.select();</span><br><span class="line">           return null;</span><br><span class="line">       case 9:</span><br><span class="line">           var10000.setCallback(((Number)var3[0]).intValue(), (Callback)var3[1]);</span><br><span class="line">           return null;</span><br><span class="line">       case 10:</span><br><span class="line">           return c00e2e9b.CGLIB$findMethodProxy((Signature)var3[0]);</span><br><span class="line">       case 11:</span><br><span class="line">           c00e2e9b.CGLIB$STATICHOOK1();</span><br><span class="line">           return null;</span><br><span class="line">       case 12:</span><br><span class="line">           var10000.CGLIB$update$0();</span><br><span class="line">           return null;</span><br><span class="line">       case 13:</span><br><span class="line">           var10000.CGLIB$select$1();</span><br><span class="line">           return null;</span><br><span class="line">       case 14:</span><br><span class="line">           return new Boolean(var10000.CGLIB$equals$2(var3[0]));</span><br><span class="line">       case 15:</span><br><span class="line">           return var10000.CGLIB$toString$3();</span><br><span class="line">       case 16:</span><br><span class="line">           return new Integer(var10000.CGLIB$hashCode$4());</span><br><span class="line">       case 17:</span><br><span class="line">           return var10000.CGLIB$clone$5();</span><br><span class="line">       case 18:</span><br><span class="line">           var10000.setCallbacks((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 19:</span><br><span class="line">           c00e2e9b.CGLIB$SET_STATIC_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 20:</span><br><span class="line">           c00e2e9b.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 21:</span><br><span class="line">           return var10000.getCallback(((Number)var3[0]).intValue());</span><br><span class="line">       case 22:</span><br><span class="line">           return var10000.getCallbacks();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; catch (Throwable var4) &#123;</span><br><span class="line">       throw new InvocationTargetException(var4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问流程图：</p><p><img src="/media/article/cglib-invoke.png" alt="cglib-invoke"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是CGLIB还是JDK proxy都是为了控制对象的访问，但是怎样控制访问是CGLIB和JDK proxy思想上的最大区别，JDK proxy通过接口得到method对象后使用反射直接调用目标方法，CGLIB则是更复杂的多，CGLIB先是继承目标类，然后通过字节码技术生成代理方法（CGLIB$update$0）和update（上述例子中的方法，这里用来举例），然后通过方法代理（MethodProxy）和FastClass访问机制（通过方法名和返回值生成索引，调用时直接索引至目标方法）回调目标方法。</p><blockquote><p>TIPS:其实这里还有很多想说的，但是总也感觉表达的总是不是那么的到位，所以暂且先这样了，等着后续再继续完善。</p></blockquote><p>优点：</p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似CGLIB动态代理就没有这种限制。</li><li>只操作我们关心的类，不必为其他相关类增加工作量。</li><li>高性能，高性能体现方法的调用上，CGLIB的方法调用为FastClass机制，JDK Proxy为反射调用。</li></ul><h2 id="4-一些源码"><a href="#4-一些源码" class="headerlink" title="4. 一些源码"></a>4. 一些源码</h2><p>下面是一些比较核心的一些代码解析：</p><p>入口，AbstractGenerator中的create(key)方法，参数key=KeyFactory.newInstance()。KeyFactory也是CGLIB动态生成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 参数key是Enhancer.KeyFactory(superclassname)的实例，这个KeyFactory类也是cglib动态生成的，当你new Enhancer()时，Enhancer会动态的生成该实例对象，superclassname就是上面的UserDAO。</span><br><span class="line">protected Object create(Object key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ClassLoader loader = this.getClassLoader();</span><br><span class="line">        // CACHE时WeakHashMap 第一层缓存的容器</span><br><span class="line">        Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        // 第一层缓存 key是classLoader</span><br><span class="line">        AbstractClassGenerator.ClassLoaderData data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">        if (data == null) &#123;</span><br><span class="line">            Class var5 = AbstractClassGenerator.class;</span><br><span class="line">            // 加锁意义在于CACHE时静态变量，属于该类，不是该实例对象，所以线程安全需要加锁。</span><br><span class="line">            synchronized(AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">                if (data == null) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; newCache = new WeakHashMap(cache);</span><br><span class="line">                    // 创建第二层缓存容器</span><br><span class="line">                    data = new AbstractClassGenerator.ClassLoaderData(loader);</span><br><span class="line">                    // 将第二层缓存容器放入第一层容器内，key为classloader</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.key = key;</span><br><span class="line">        // 使用ClassLoaderData data获取Enhancer.EnhancerFactoryData对象，Enhancer.EnhancerFactoryData对象中是代理类的Class对象，也可以直接获取KeyFactory的Class对象</span><br><span class="line">        Object obj = data.get(this, this.getUseCache());</span><br><span class="line">        // firstInstance主要是针对KeyFactory生成的Class对象，例如接口方法生成的MethodWraper的代理类Class对象，nextInstance针对Enhancer实例生成的Enhancer.EnhancerFactoryData实例，实例中存储着真正的代理类的Class对象，如果生成的代理类中有接口方法，生成代理类时，会生成接口方法的MethodWrapper的代理类实例。</span><br><span class="line">        return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);</span><br><span class="line">    &#125; catch (Error | RuntimeException var9) &#123;</span><br><span class="line">        throw var9;</span><br><span class="line">    &#125; catch (Exception var10) &#123;</span><br><span class="line">        throw new CodeGenerationException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一级缓存中的value，ClassLoaderData的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoaderData(ClassLoader classLoader) &#123;</span><br><span class="line">  if (classLoader == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;classLoader == null is not yet supported&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // 首先用弱引用封装classLoader，垃圾回收时可以直接回收</span><br><span class="line">      this.classLoader = new WeakReference(classLoader);</span><br><span class="line">      Function&lt;AbstractClassGenerator, Object&gt; load = new Function&lt;AbstractClassGenerator, Object&gt;() &#123;</span><br><span class="line">          public Object apply(AbstractClassGenerator gen) &#123;</span><br><span class="line">              Class klass = gen.generate(ClassLoaderData.this);</span><br><span class="line">              // 这里需要注意gen是Enhancer实例，还是KeyFactory$Genertor实例，两者的wrapCachedClass完全不一样，使用的数据结构也不一样。Enhancer使用的数据结构是EnhancerFactoryData，KeyFactory$Genertor使用LoadingCache</span><br><span class="line">              return gen.wrapCachedClass(klass);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      // this.generatedClasses的key是KeyFactory根据superclassName生成的key实例，将load放入LoadingCache，等下如果LoadingCache的map获取代理类为null，需要回调这个load重新生成代理类</span><br><span class="line">      this.generatedClasses = new LoadingCache(GET_KEY, load);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二级缓存的对象LoadingCache中的核心方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// key是Enhancer实例，或者是KeyFactory$Generator实例</span><br><span class="line">public V get(K key) &#123;</span><br><span class="line">   KK cacheKey = this.keyMapper.apply(key);</span><br><span class="line">   Object v = this.map.get(cacheKey);</span><br><span class="line">   return v != null &amp;&amp; !(v instanceof FutureTask) ? v : this.createEntry(key, cacheKey, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected V createEntry(final K key, KK cacheKey, Object v) &#123;</span><br><span class="line">   boolean creator = false;</span><br><span class="line">   FutureTask task;</span><br><span class="line">   Object result;</span><br><span class="line">   if (v != null) &#123;</span><br><span class="line">       task = (FutureTask)v;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       task = new FutureTask(new Callable&lt;V&gt;() &#123;</span><br><span class="line">           public V call() throws Exception &#123;</span><br><span class="line">               // 回调AbstractGenerator.ClassLoaderData构造器中的load</span><br><span class="line">               return LoadingCache.this.loader.apply(key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 获取map中的value，如果是Enhancer.EnhancerFactoryData就直接返回，如果不是，继续往下获取Class对象</span><br><span class="line">       result = this.map.putIfAbsent(cacheKey, task);</span><br><span class="line">       // 如果等于null，需要重新生成</span><br><span class="line">       if (result == null) &#123;</span><br><span class="line">           creator = true;</span><br><span class="line">           task.run();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (!(result instanceof FutureTask)) &#123;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           task = (FutureTask)result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">       result = task.get();</span><br><span class="line">   &#125; catch (InterruptedException var9) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Interrupted while loading cache item&quot;, var9);</span><br><span class="line">   &#125; catch (ExecutionException var10) &#123;</span><br><span class="line">       Throwable cause = var10.getCause();</span><br><span class="line">       if (cause instanceof RuntimeException) &#123;</span><br><span class="line">           throw (RuntimeException)cause;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       throw new IllegalStateException(&quot;Unable to load cache item&quot;, cause);</span><br><span class="line">   &#125;</span><br><span class="line">   // 新建的Class对象或者Enhancer.EnhancerFactoryData需要存起来</span><br><span class="line">   if (creator) &#123;</span><br><span class="line">       this.map.put(cacheKey, result);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Enhancer中生成动态代理类的逻辑，使用了ASM技术：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public void generateClass(ClassVisitor v) throws Exception &#123;</span><br><span class="line">   Class sc = this.superclass == null ? Object.class : this.superclass;</span><br><span class="line">   if (TypeUtils.isFinal(sc.getModifiers())) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Cannot subclass final class &quot; + sc.getName());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">       this.filterConstructors(sc, constructors);</span><br><span class="line">       List actualMethods = new ArrayList();</span><br><span class="line">       List interfaceMethods = new ArrayList();</span><br><span class="line">       final Set forcePublic = new HashSet();</span><br><span class="line">       // 将接口中的方法获取放入到forcePublic中，获取的其实是KeyFactory生成的MethodWrapper实例 select,&#125;, void</span><br><span class="line">       // actualMethods是一个包含所有方法的数组，值类似public void com.zhongyp.advanced.proxy.cglib.UserDao.update()</span><br><span class="line">       getMethods(sc, this.interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line">       // 获取到所有的方法及访问标识</span><br><span class="line">       List methods = CollectionUtils.transform(actualMethods, new Transformer() &#123;</span><br><span class="line">           public Object transform(Object value) &#123;</span><br><span class="line">               Method method = (Method)value;</span><br><span class="line">               int modifiers = 16 | method.getModifiers() &amp; -1025 &amp; -257 &amp; -33;</span><br><span class="line">               if (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                   // 如果接口中有相同的方法，</span><br><span class="line">                   modifiers = modifiers &amp; -5 | 1;</span><br><span class="line">               &#125;</span><br><span class="line">               return ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 下面就是ASM的操作逻辑了</span><br><span class="line">       // 参数v是ClassVisitor</span><br><span class="line">       ClassEmitter e = new ClassEmitter(v);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), Type.getType(sc), this.useFactory ? TypeUtils.add(TypeUtils.getTypes(this.interfaces), FACTORY) : TypeUtils.getTypes(this.interfaces), &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), (Type)null, new Type[]&#123;FACTORY&#125;, &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       // 构造器信息</span><br><span class="line">       List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line">       e.declare_field(2, &quot;CGLIB$BOUND&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       e.declare_field(9, &quot;CGLIB$FACTORY_DATA&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (!this.interceptDuringConstruction) &#123;</span><br><span class="line">           e.declare_field(2, &quot;CGLIB$CONSTRUCTED&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(26, &quot;CGLIB$THREAD_CALLBACKS&quot;, THREAD_LOCAL, (Object)null);</span><br><span class="line">       e.declare_field(26, &quot;CGLIB$STATIC_CALLBACKS&quot;, CALLBACK_ARRAY, (Object)null);</span><br><span class="line">       if (this.serialVersionUID != null) &#123;</span><br><span class="line">           e.declare_field(26, &quot;serialVersionUID&quot;, Type.LONG_TYPE, this.serialVersionUID);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for(int i = 0; i &lt; this.callbackTypes.length; ++i) &#123;</span><br><span class="line">           e.declare_field(2, getCallbackField(i), this.callbackTypes[i], (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(10, &quot;CGLIB$CALLBACK_FILTER&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           this.emitMethods(e, methods, actualMethods);</span><br><span class="line">           this.emitConstructors(e, constructorInfo);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.emitDefaultConstructor(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       this.emitSetThreadCallbacks(e);</span><br><span class="line">       this.emitSetStaticCallbacks(e);</span><br><span class="line">       this.emitBindCallbacks(e);</span><br><span class="line">       if (this.useFactory || this.currentData != null) &#123;</span><br><span class="line">           int[] keys = this.getCallbackKeys();</span><br><span class="line">           this.emitNewInstanceCallbacks(e);</span><br><span class="line">           this.emitNewInstanceCallback(e);</span><br><span class="line">           this.emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">           this.emitGetCallback(e, keys);</span><br><span class="line">           this.emitSetCallback(e, keys);</span><br><span class="line">           this.emitGetCallbacks(e);</span><br><span class="line">           this.emitSetCallbacks(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.end_class();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>CGLIB针对final方法怎么处理的呢？</li></ol><p>不处理，因为继承了目标类，所以动态代理类实例可以直接调用目标类的final方法。</p><ol start="2"><li>CGLIB动态代理是通过字节码底层继承要代理类来实现，如果被代理类被final关键字所修饰，那么代理会失败么？</li></ol><p>代理不会失败，只会直接调用目标类的final方法。如update方法是final的，代理类不会做其他的处理，会直接调用UserDAO的update方法。   </p><ol start="3"><li>CGLIB到底比JDk Proxy快在哪里？</li></ol><p>测试环境JDK1.8，平台macOS Catalina。</p><p>一般意义上认为CGLIB在创建动态代理类比JDK Proxy慢，但是在方法调用上CGLIB比JDK Proxy快。<br>但是通过个人的测试，CGLIB在创建动态代理类确实比JDK Proxy慢一点，基本上CGLIB创建一个动态代理类实例需要30ms，JDK Proxy基本上也就10ms。<br>方法调用上100w次JDK proxy用时33233ms，CGLIB用时34259ms。两者差距并不是很明显。</p><ol start="4"><li>为什么CGLIB要使用fastclass机制？</li></ol><p>JDK之前的版本对于反射调用优化不是特别好，反射方法调用很慢，所以为了避免反射带来的性能消耗，采用fastclass机制，fastclass其实就是把需要需要调用的目标方法进行封装，获取到每个方法的索引值，调用时，通过调用方法获取索引值，直接调用到封装的目标方法。这种调用和直接调用性能差别不大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文承接自&lt;a href=&quot;/java/2019-09-09-java-proxy/&quot;&gt;动态代理浅析&lt;/a&gt;这篇文章，对代理没有什么概念的同学建议先读下这篇文章。&lt;/p&gt;
&lt;p&gt;本文打算从这几个方面来理解CGLIB怎样生成动态代理类的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.programer.group/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理浅析</title>
    <link href="http://blog.programer.group/java/2019-10-04-jdk-proxy/"/>
    <id>http://blog.programer.group/java/2019-10-04-jdk-proxy/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2020-05-21T14:33:49.165Z</updated>
    
    <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><h2 id="1-使用JDK动态代理"><a href="#1-使用JDK动态代理" class="headerlink" title="1. 使用JDK动态代理"></a>1. 使用JDK动态代理</h2><p>JDK动态代理使用起来很简单，如下：</p><p>TestService是一个业务接口，接口中有个test方法， TestServiceImpl是TestService的实现类。<br>InvocationHandler是JDK动态代理的调用代理方法处理接口，我们JDK使用动态代理时需要实现这个接口，在这个接口的处理方法中编写处理逻辑，你想怎样控制目标方法的访问都可以在这个方法中实现。然后调用Proxy类的静态方法newProxyInstance方法即可获得到代理类实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        TestServiceImpl testService = new TestServiceImpl();</span><br><span class="line">        // 声明自己的处理类</span><br><span class="line">        MyInvokeHandler myInvokeHandler = new MyInvokeHandler(testService);</span><br><span class="line">        // 第一次生成代理类</span><br><span class="line">        TestService proxy = (TestService) Proxy.newProxyInstance(TestService.class.getClassLoader(),new Class[]&#123;TestService.class&#125;,myInvokeHandler);</span><br><span class="line">        // 代理类调用接口方法</span><br><span class="line">        proxy.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestServiceImpl implements TestService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;我要开始测试啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyInvokeHandler implements InvocationHandler&#123;</span><br><span class="line">    Object obj;</span><br><span class="line">    public MyInvokeHandler(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        //在反射调用之前，可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        method.invoke(obj,args);</span><br><span class="line">        //在反射调用之后，也可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface TestService&#123;</span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java通过<code>Proxy</code>类和<code>InvocationHandler</code>接口生成动态代理类<code>$Proxy0</code>。<code>Proxy</code>类是JDK生成动态代理的核心类，包含了JDK动态代理生成代理类的大部分逻辑。</p><!--![java-proxy](/media/article/java-proxy.001.png)--><h2 id="2-Java动态代理源码解析"><a href="#2-Java动态代理源码解析" class="headerlink" title="2. Java动态代理源码解析"></a>2. Java动态代理源码解析</h2><blockquote><p>Class对象每个类只有一个（同一个类加载器的情况下），该Class对象在类加载阶段生成，存储在内存中，非Java虚拟机堆，是该类对外访问的唯一入口。<a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-12.html#jls-12.4" target="_blank" rel="noopener">Java Language Specification 12.4</a></p></blockquote><p>Java生成动态代理类的核心方法是：ProxyClassFactory的<code>Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>。</p><p>参数：<code>ClassLoader loader</code>接口类加载器，<code>Class&lt;?&gt;[] interfaces</code>接口类的Class。</p><p>下面代码主要作用就是通过遍历接口数组，校验接口数组中的数据是否合法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 遍历接口类的Class数组</span><br><span class="line">  for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">      </span><br><span class="line">      Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          // 反射获得接口类Class对象</span><br><span class="line">          interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      // 校验是否是同一个类加载器，如果是不同的类加载器，生成的接口Class对象是不同的</span><br><span class="line">      if (interfaceClass != intf) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // Java动态代理仅支持接口代理</span><br><span class="line">      if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 使用Set来验证传入的接口数组中是否存在相同的接口</span><br><span class="line">      if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>下面这么多代码是为了给下面生成的代理类找到一个合理的包名和类名，如果接口数组中有非public属性的接口，如果此接口的包名不为null，则使用这个接口的包名，否则使用默认的<code>com.sun.proxy</code>包名，类名则是“上述包名+$Proxy+自增数字”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String proxyPkg = null;     </span><br><span class="line">int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">    int flags = intf.getModifiers();</span><br><span class="line">    if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">        accessFlags = Modifier.FINAL;</span><br><span class="line">        String name = intf.getName();</span><br><span class="line">        int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">        String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            proxyPkg = pkg;</span><br><span class="line">        &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (proxyPkg == null) &#123;</span><br><span class="line">    // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">    proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用自增数字区分不同的类</span><br><span class="line">long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br></pre></td></tr></table></figure><p>下面就是整个动态代理最核心的代码。生成代理类class文件的字节码，根据这个文件的字节码生成代理类的Class对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成字节数组，这个字节数组是生成的Class文件的字节数组，将这个字节流输出到class文件，就是上面的$Proxy0代理类。  </span><br><span class="line">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line"> proxyName, interfaces, accessFlags);</span><br><span class="line">try &#123;</span><br><span class="line"> // 通过刚才生成的代理类文件，生成代理类的Class对象。</span><br><span class="line"> return defineClass0(loader, proxyName,</span><br><span class="line">                     proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">&#125; catch (ClassFormatError e) &#123;</span><br><span class="line"> throw new IllegalArgumentException(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码仅仅是生成动态代理类的逻辑，不是JDK Proxy生成动态代理类实例的流程。</p><p>建议下面跟着源码一点点看如下的流程图。</p><p><img src="/media/article/weakcache.png" alt="weakcache"></p><p>第一个结构图是WeakCache的缓存结构图，WeakCache是Proxy的一个实例，每次去创建代理时，都会先去访问WeakCache，WeakCache中没有才会去创建。WeakCache采用两级缓存机制，第一层使用classloader生成的弱引用key，map实例valueMap的value在ConcurrentHashMap map中，valueMap是ConcurrentHasshMap， valueMap中使用接口数组（创建代理类传入的接口数组参数）生成的subKey，这个subKey不是弱引用，valueMap的value即可能是WeakCache.Factory实例，也可能是实现Supplier接口和继承WeakReference类的CacheValue实例。CacheValue用于封装动态生成的代理类的Class对象，WeakCache.Factory中包含生成动态代理类字节码和Class对象的逻辑，这个逻辑就是上面源码分析中的apply方法。<br>第二个是流程图，使用Proxy.newProxyInnstance生成动态代理类时，读取缓存的流程，结合着结构图和代码，应该可以理解JDK Proxy的整个缓存存储结构及读取流程。</p><p>生成的<code>$Proxy0</code>代理类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zhongyp.advanced.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">// 这个地方有两个接口，是因为我之前做测试的时候多加了一个TestService1接口。</span><br><span class="line">final class $Proxy0 extends Proxy implements TestService, TestService1 &#123;</span><br><span class="line"></span><br><span class="line">    // TestSerivce，TestService1两个接口总共就4个方法，test()，test1()，test3()，test4()，这里有7个方法，其中三个是hashCode，toString，equals。</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    private static Method m6;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m5;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 接口中的所有方法都会在代理类中生成，然后将代理类中的方法对象与方法名匹配放到InvocaotionHandler实现类实例的方法参数中</span><br><span class="line">    public final void test() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test3() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m4, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test4() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m6, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test1() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m5, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 动态代理在初始化是会初始化所有的方法对象</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m3 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test&quot;);</span><br><span class="line">            m4 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test3&quot;);</span><br><span class="line">            m6 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test4&quot;);</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m5 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test1&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于JDK动态代理的调用很简单，上面是我们上面的例子输出的动态代理类反编译的代码，我们看到接口中的每个方法<code>super.h.invoke(this, m5, (Object[])null)</code>，super就是Proxy，h是Proxy中的InvocationnHandler实例，InvocationHandler实例反射调用你的方法。InvocationHandler是在生成动态代理类的class对象后，创建动态代理类实例作为构造参数传进去的，所以虽然当前接口参数相同时，可能返回同一个动态代理类Class对象，但是只要InvocationHandler不同，他们就是不同的实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">    super(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/jdk-proxy-invoke.png" alt="jdk-proxy-invoke"></p><p>优点：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比cglib更加可靠。</li><li>平滑进行JDK版本升级，而字节码类库通常需要进行更新来保证在新版Java上能够使用。</li><li>代码实现简单。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>为什么JDK动态代理仅支持实现接口类的动态代理？</li></ol><p>这个问题我觉得可以从JDK做动态代理的初衷来说，JDK动态代理类是在运行时实现指定的接口列表的类，这个是JDK在设计实现动态代理最初就已经确定了的，所以可以看到在生成代理类的过程中，基本上就把接口类当作一个已知条件在使用，包括在定义缓存使用的subKey，代理类包名的生成规则中，反射获取Method对象等等地方，所以不存在为什么只支持实现接口类，而是JDK动态代理类的设计就是这样子的。</p><ol start="2"><li>为什么WeakCache采用两级缓存接口？</li></ol><p>这个问题我们可以从两个缓存的不同点来看，第一层缓存map是一个弱引用key，非弱引用valueMap，第二层缓存valueMap使用的是非弱引用subKey，弱引用CacheValue。我们都知道弱引用只要有垃圾回收时就会被回收，主要是为了防止缓存太多导致服务频繁的FullGC，所以第一层的作用就是当垃圾回收时，将缓存的valueMap全部清空。还有一个原因是第一层缓存使用的是classloader生成的key，所以map其实缓存的是所有当前同一个classloader生成的代理类的class对象。再说第二层缓存，第二层缓存使用的是创建代理类时传入的接口数组生成的subKey，这个是为了区分实现不同接口的动态代理类Class对象，如果说两个类都实现了同一个接口，那岂不是获取的同样的Class对象，这么说也是对的，区别在于实现的InvocationHandler接口的子类h不同，而这个h才是生成代理类实例的最终区别。第二层缓存为什么CacheValue使用弱引用，原因在于第一层缓存虽然key时弱引用，但是value不是，所以垃圾回收时只会回收key，不会回收value，value只会在下一次调用Proxy.newProxyInstance方法时才会去清空无效key的value。所以为了value能及时清空，所以CacheValue也使用了弱引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文承接自&lt;a href=&quot;/java/2019-09-09-java-proxy/&quot;&gt;动态代理浅析&lt;/a&gt;这篇文章，对代理没有什么概念的同学建议先读下这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;1-使用JDK动态代理&quot;&gt;&lt;a href=&quot;#1-使用JDK动态代理&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.programer.group/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>知识结构图</title>
    <link href="http://blog.programer.group/java/2019-09-29-knowledge-structure/"/>
    <id>http://blog.programer.group/java/2019-09-29-knowledge-structure/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2020-05-21T14:33:50.114Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/article/knowledge-structure.png" alt="knowledge-structure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/article/knowledge-structure.png&quot; alt=&quot;knowledge-structure&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.programer.group/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>闲谈Java引用</title>
    <link href="http://blog.programer.group/java/2019-09-15-reference/"/>
    <id>http://blog.programer.group/java/2019-09-15-reference/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-23T11:33:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。</p><h2 id="1-强引用-StrongReference"><a href="#1-强引用-StrongReference" class="headerlink" title="1. 强引用(StrongReference)"></a>1. 强引用(StrongReference)</h2><p>Java中最常见的引用方式。当一个对象被一个或者一个以上的引用变量引用时，它处于激活状态，不可能被系统垃圾回收机制回收。</p><h2 id="2-软引用-SoftReference"><a href="#2-软引用-SoftReference" class="headerlink" title="2. 软引用(SoftReference)"></a>2. 软引用(SoftReference)</h2><p>软引用需要通过SoftRefrence类来实现，当一个对象只具有软引用时，可能被垃圾回收机制回收。当系统内存空间足够时，它不会被系统回收，当系统内存空间不够时，系统将会回收。</p><p>和弱引用的区别仅仅在于垃圾回收时， 是否根据空间大小回收的区别。</p><p>何时回收软引用的对象？</p><p>从1.3.1开始软可达对象将在最后被引用之后存活一段时间。默认值是堆中每MB空闲空间一秒的生存时间。这个值可以使用<code>-XX:SoftRefLRUPolicyMSPerMB</code>调整。<br>Java Hotspot服务端虚拟机使用最大可能的堆大小计算剩余可用空间。<br>Java Hotspot客户端虚拟机使用当前堆大小计算空闲空间。<br>这就意味着对于服务端虚拟机总体趋势是增长堆而不是清理软引用，因此在垃圾回收时<code>-Xmx</code>对软引用的回收有重要的影响。<br>相反，客户端虚拟机将很大趋势去清理软引用而不是增长堆。</p><p>上述行为对于1.3.1到Java SE 6版本的Java HotSpot VM都是正确的。但是，此行为不是VM规范的一部分，并且在将来的版本中可能会更改。同样，不保证-XX：SoftRefLRUPolicyMSPerMB标志在任何给定的发行版中均不存在。</p><p>在1.3.1版之前，Java HotSpot VM会在发现软引用时清除它们。</p><p>当我定期打开-verbose：gc时，我得到了很多完整的GC，已经调整了堆并且没有什么区别，这是怎么回事？</p><p>如果您使用的是RMI，则可能会遇到分布式GC。另外，某些应用程序添加了显式GC的思想，即它将使它们的应用程序更快。幸运的是，您可以在1.3及更高版本中使用命令行选项禁用此功能。尝试将-XX：+ DisableExplicitGC与-verbose：gc一起使用，看看是否有帮助。</p><h2 id="3-虚引用-PhantomReference"><a href="#3-虚引用-PhantomReference" class="headerlink" title="3. 虚引用(PhantomReference)"></a>3. 虚引用(PhantomReference)</h2><p>虚引用通过PhantomReference实现，虚引用类似于完全没有引用，虚引用对对象本身没有太大的影响。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列(ReferenceQueue)联合使用。</p><p>举例来说就是，如果垃圾回收时，发现一个实例对象除了虚引用外没有任何其他的引用，将会把这个引用放到<br><code>java.lang.ref.Reference.pending</code>队列里，GC完成时，通知ReferenceHandler这个守护线程做一些后续处理（如释放内存等等操作）。</p><h2 id="4-弱引用-WeakReference"><a href="#4-弱引用-WeakReference" class="headerlink" title="4. 弱引用(WeakReference)"></a>4. 弱引用(WeakReference)</h2><p>弱引用通过WeakReference类实现，对只有弱引用的对象而言，当系统垃圾回收机制运行时，不管内存是否足够，总会回收该对象所占用的内存。</p><h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue referenceQueue = new ReferenceQueue();</span><br><span class="line">WeakReference weakReference = new WeakReference(new TestEntity(), referenceQueue);</span><br><span class="line">((TestEntity) weakReference.get()).test();</span><br></pre></td></tr></table></figure><p>ReferenceQueue的作用是为了查看哪些WeakReference和SoftReferece被回收了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p><p><a href="https://www.jianshu.com/p/e66930caca9c" target="_blank" rel="noopener">Java PhantomReference详解</a></p><p><a href="oracle.com/technetwork/java/hotspotfaq-138619.html#gc_softrefs">Frequently Asked Questions About the Java HotSpot VM</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。&lt;/p&gt;
&lt;h2 id=&quot;1-强引用-StrongReference&quot;&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.programer.group/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机知识点架构图</title>
    <link href="http://blog.programer.group/jvm/2019-09-08-jvm-structure/"/>
    <id>http://blog.programer.group/jvm/2019-09-08-jvm-structure/</id>
    <published>2019-09-07T16:00:00.000Z</published>
    <updated>2020-11-14T09:13:32.184Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/article/jvm-structure.png" alt="jvm-structure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/article/jvm-structure.png&quot; alt=&quot;jvm-structure&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="http://blog.programer.group/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>动态代理浅析</title>
    <link href="http://blog.programer.group/java/2019-09-09-java-proxy/"/>
    <id>http://blog.programer.group/java/2019-09-09-java-proxy/</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2020-05-21T14:33:50.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是动态代理？"><a href="#1-什么是动态代理？" class="headerlink" title="1. 什么是动态代理？"></a>1. 什么是动态代理？</h2><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问，而不是增强目标对象的功能。</p><blockquote><p>访问控制包括同步，身份验证，远程访问（RPC），惰性实例化（休眠，Mybatis），AOP（事务）。</p></blockquote><p><img src="/media/article/proxy-invoke-method.png" alt="代理方法调用"></p><p>实现代理的技术有很多，如 CGLIB(ASM)、AspectJ、Javassist、JDK Proxy等。</p><ul><li>ASM: 针对<strong><em>运行时</em></strong>动态生成和转换类（class）的Java语言工具，旨在处理已编译的Java类（class）。<a href="/java/2019-10-04-cglib/">CGLIB浅析</a></li><li>AspectJ: AspectJ采用<strong><em>编译时</em></strong>织入和<strong><em>类加载时</em></strong>织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<a href="/java/2019-10-04-aspectj/">AspectJ</a></li><li>Javassist: Javassist在Java中是一个用来编辑字节码的扩展包，它允许Java程序在<strong><em>运行时</em></strong>定义一个新类或者在JVM<strong><em>加载class文件时</em></strong>修改class文件。<br><a href="/java/2019-09-04-javassist/">Javassist</a></li><li>JDK Proxy: JDK动态代理类是在<strong><em>运行时</em></strong>实现指定的接口列表的类，该类实例上的其中一个接口进行的方法调用时，将被通过统一的接口进行编码并调用到另一个对象。因此，动态代理类可用于为接口列表创建类型安全的代理对象，而无需诸如在编译时使用编译工具预生成代理类。动态代理类实例的代理方法调用将在该代理类实例中的处理程序中通过java.lang.reflect.Method对象进行调用，该对象标识了所调用的方法和包含参数的Object类型数组，翻译自<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a>。详情<a href="/java/2019-10-04-jdk-proxy/">《JDK 动态代理浅析》</a></li></ul><p>在Java语言中，从构建代理类的时期上来看，有三种：编译时、类加载时和运行时。从方式上来说有两种，一种是静态代理，一种是动态代理。<br>动态代理则是一种方便<strong><em>运行时</em></strong>动态构建代理、动态处理代理方法调用的机制。例如ASM，Javassist，Java Proxy。</p><p><strong><em>编译时</em></strong>和<strong><em>类加载时</em></strong>构建代理类则属于静态代理。例如AspectJ。</p><h2 id="2-常用代理方式"><a href="#2-常用代理方式" class="headerlink" title="2. 常用代理方式"></a>2. 常用代理方式</h2><p>由于篇幅问题，本文进行了拆分，详细了解常用的代理方式的原理，请点击下方链接。</p><p><a href="/java/2019-10-04-jdk-proxy/">JDK proxy</a></p><p><a href="/java/2019-10-04-cglib/">CGLIB浅析</a></p><p><a href="/java/2019-10-04-aspectj/">AspectJ</a></p><p><a href="/java/2019-09-04-javassist/">Javassist</a></p><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h2><p><img src="/media/article/15688575046625.png" alt="jclasslib"><br>图片引用自<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">《美团技术团队》-字节码增强技术探索</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>1.Java生成动态代理的时候，使用WeakCache缓存已经生成的动态代理工厂，疑问点在于，为什么缓存的key使用的是<a href="/java/2019-09-15-reference/">弱引用</a>？</p><p>答: 类中的静态变量，当它持有一个指向一个对象的引用时，它就作为GC Root，第一类被列为GC Root的元素就是静态成员变量。因此若缓存不再需要时，使用强引用会让GC进行标记分析时认为从GC Root可达，不太会去标记这块内存，反之能够有效地标记这些缓存，从而提高内存回收效率。引用自<a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a></p><p>个人分析: 既然缓存代理工厂类，为什么不使用SoftReference，这样只有内存空间不够时才会进行回收。这样可以最大限度的缓存生成的代理工厂？<br>如果使用SoftReference，当服务使用动态代理较多时，可能会导致频繁的FullGC。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html" target="_blank" rel="noopener">Java动态代理机制分析及扩展，第1部分</a><br><a href="https://www.cnblogs.com/whirly/p/10154887.html" target="_blank" rel="noopener">Java 动态代理详解</a><br><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a><br><a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a><br><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a><br><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是动态代理？&quot;&gt;&lt;a href=&quot;#1-什么是动态代理？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是动态代理？&quot;&gt;&lt;/a&gt;1. 什么是动态代理？&lt;/h2&gt;&lt;p&gt;代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.programer.group/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>了解ASM</title>
    <link href="http://blog.programer.group/java/2019-10-06-asm/"/>
    <id>http://blog.programer.group/java/2019-10-06-asm/</id>
    <published>2019-09-05T16:00:00.000Z</published>
    <updated>2019-10-21T11:34:13.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASM-是个啥"><a href="#ASM-是个啥" class="headerlink" title="ASM 是个啥"></a>ASM 是个啥</h2><blockquote><p><strong><a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a>技术是个啥？</strong><br>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br>ASM是一个通用的Java字节码操作和分析框架。它可以直接以二进制形式用于修改现有类或动态生成类。 ASM提供了一些常见的字节码转换和分析算法，可以从中构建定制的复杂转换和代码分析工具。 ASM提供与其他Java字节码框架类似的功能，但侧重于性能。因为它的设计和实现是尽可能的小和尽可能快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中使用）。<br>ASM应用广泛：OpenJDK lambda call sites，<a href="http://hg.openjdk.java.net/jdk8/jdk8/nashorn/file/096dc407d310/src/jdk/nashorn/internal/codegen/ClassEmitter.java" target="_blank" rel="noopener">Nashorn compiler</a><br>CGLIB，以动态生成代理类（用于其他项目，例如Mockito和EasyMock），Gradle，在运行时生成一些类。</p></blockquote><h2 id="ASM的原理解析"><a href="#ASM的原理解析" class="headerlink" title="ASM的原理解析"></a>ASM的原理解析</h2><p>ASM中最主要通过<a href="https://github.com/zhongyp/demo/tree/master/src/main/java/com/zhongyp/advanced/pattern/visitor" target="_blank" rel="noopener">访问模式</a>对字节码文件进行修改，读取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ASM-是个啥&quot;&gt;&lt;a href=&quot;#ASM-是个啥&quot; class=&quot;headerlink&quot; title=&quot;ASM 是个啥&quot;&gt;&lt;/a&gt;ASM 是个啥&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://asm.ow2.io/&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.programer.group/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机类加载机制</title>
    <link href="http://blog.programer.group/jvm/2019-08-18-jvm-classloading/"/>
    <id>http://blog.programer.group/jvm/2019-08-18-jvm-classloading/</id>
    <published>2019-08-17T16:00:00.000Z</published>
    <updated>2020-11-14T09:07:18.399Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p></blockquote><p>Java 虚拟机动态的加载，连接，初始化类或者接口。</p><p>加载是一个通过特殊符号查找类或者接口类型的二进制文件，同时使用二进制文件创建类或者接口的过程。</p><p>连接是一个加载类或者接口并结合它变为Java虚拟机的运行时状态的过程，以便于它可以被Java虚拟机执行。</p><p>一个类或者接口的初始化由执行类或者接口的初始化方法<code>&lt;clinit&gt;</code>组成(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener">§2.9</a>)。</p><p>下图是类或者接口动态加载、连接、初始化的过程：</p><p><img src="/media/article/jvm-classloading.png" alt="jvm-classloading"></p><p>图片摘自<a href="">深入理解Java虚拟机</a></p><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h2><p>加载阶段：</p><ul><li><ol><li>通过一个类的全限定名来获取定义此类二进制字节流。</li></ol></li><li><ol start="2"><li>将这个字节流代表的静态存储结构转换为方法区的运行时数据结构(运行时数据结构详见第四小节<a href="#4-运行时常量池"></a>)。</li></ol></li><li><ol start="3"><li>在<strong><em>内存(Class对象比较特殊，它虽然是对象，但是存储在方法区中)</em></strong>生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol></li></ul><p>对于数组类本身不通过类加载器创建，它由Java虚拟机直接创建。数组类型却由类加载器创建，创建过程遵循以下规则：</p><ul><li>如果数组组件类型是引用类型，则数组被标记为组件类型定义的类加载器定义。否则，数组被标记为引导类加载器定义。</li><li>如果数组的组件类型不是引用类型，Java虚拟机将会把数组标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认是public。</li></ul><p>加载和连接阶段是交叉进行的。</p><h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h2><p>如果需要连接类或接口涉及验证和准备该类或接口，直接超类，直接超接口及其元素类型（如果它是数组类型）。类或接口中符号引用的解析是连接的可选部分。</p><p>只要维护了以下所有属性，此规范允许实现灵活性，以便何时发生连接活动（以及由于递归，加载）。</p><ul><li><p>类或接口在连接之前已完全加载。</p></li><li><p>在初始化之前，类或接口已完全验证并准备好。</p></li></ul><p>在连接期间检测到的错误被抛出到程序中的某个点，程序可能会直接或间接地需要连接到错误中涉及的类或接口。</p><p>例如，Java虚拟机实现可以选择在使用它时分别解析类或接口中的每个符号引用，或者在验证类时立即解析它们。这意味着在一些实现中，在初始化类或接口之后，解析过程可以继续。无论采用哪种策略，在解析期间检测到的任何错误都必须抛出到程序中（直接或间接）使用对类或接口的符号引用的位置。</p><p>因为连接涉及新数据结构的分配，所以它可能会失败OutOfMemoryError。</p><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>验证阶段会完成4个阶段的验证动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置类变量<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。进行内存分配的仅包括<strong><em>类变量[static变量]</em></strong>，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><h3 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic，这些虚拟机指令对运行时常量池进行符号引用，执行任何这些指令都需要解析其符号引用。</p><p>解析是从运行时常量池中的符号引用动态确定具体值的过程。</p><p>对出现在invokedynamic指令的相同的符号引用被解析一次并不意味着被任何其他invokedynamic指令认为已解析。</p><p>对于上述提到的所有指令，如果其中一个指令对符号引用进行了解析，则意味着任何非invokedynamic指令认为这个符号引用已经解析。</p><p>如果在解析符号引用期间发生错误，则必须在程序中(直接或间接)使用符号引用时的某一点抛出IncompatibleClassChangeError(或子类)的实例。</p><p>如果Java虚拟机尝试解析符号引用失败，抛出的错误是LinkageError(或子类)的实例，后续尝试解析引用始终失败，并且和初始解析尝试而引发的错误相同。</p><p>在执行指令之前，不得解析特定invokedynamic指令对调用site说明符的符号引用。</p><p>在<code>invokedynamic</code>指令解析失败的情况下，后续解析尝试不会重新执行引导方法。</p><p>上述某些指令在解析符号引用时需要额外的连接检查。例如，为了使getfield指令成功解析对其运行的字段的符号引用，它不仅必须完成第<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2" target="_blank" rel="noopener">5.4.3.2</a>节中给出的字段解析步骤，还要检查字段是否为静态。如果它是静态字段，则必须抛出链接异常。</p><p>值得注意的是，为了使<code>invokedynamic</code>指令成功解析对调用site说明符的符号引用，其中指定的引导方法必须正常完成并返回合适的调用站点对象。如果引导方法突然完成或返回不合适的调用站点对象，则必须抛出连接异常。</p><p>连接由特定执行特定Java虚拟机指令检查生成的异常在该指令的描述中给出，并且在本解析的一般性讨论中未涉及。请注意，此类异常虽然被描述为Java虚拟机指令执行而非解析的一部分，但仍然被视为解析失败。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h2><p>一个类的加载过程中加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，解析阶段则不一定。解析可以在初始化完成后再开始，这时为了支持Java的运行时绑定。</p><p>Java虚拟机没有进行强制约束什么时候加载，只是严格规范了5中情况必须对类进行”初始化”。</p><ul><li>遇到new、getstatic、putstatic或invokestatic这4条指令时，如果类没有进行初始化，则需要先触发其初始化。4条指令的常见场景是:使用new 关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)、以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7及以上版本的动态语言(详细了解 <a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a>)支持时，如果一个java.lang.incoke.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。</li></ul><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有 <strong><em>类变量的赋值动作</em></strong>和<strong><em>静态语句块(static{}块)中的语句</em></strong>合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语义块之前的变量，定义在它之后的变量，可以赋值，但是不能访问。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test()&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>不需要执行其父接口的<code>&lt;clinit&gt;()</code>方法。<br>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待。</p></blockquote><h2 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4. 运行时常量池"></a>4. 运行时常量池</h2><p>Java虚拟机维护每种类型常量池，这是一种运行时数据结构，它服务于常规编程语言实现的符号表的许多目的。</p><p>类或接口的二进制表示形式中的constant_pool表用于在创建类或接口对象时构造运行时常量池。运行时常量池中的所有引用最初都是符号引用。运行时常量池中的符号引用是从类或接口的二进制表示中的结构派生的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">String str = &quot;str&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">// 基本类型</span><br><span class="line">int i = 1;</span><br><span class="line"></span><br><span class="line">// 基本类型数组</span><br><span class="line">int[] arrayI = new int[3];</span><br><span class="line"></span><br><span class="line">// 引用类型数组</span><br><span class="line">A [] arrayA = new A[3];</span><br><span class="line"></span><br><span class="line">// 引用类型</span><br><span class="line">A a = new A();</span><br><span class="line"></span><br><span class="line">// 引用方法</span><br><span class="line">a.test();</span><br><span class="line"></span><br><span class="line">// 接口声明</span><br><span class="line">C c = new B();</span><br><span class="line"></span><br><span class="line">// 接口方法</span><br><span class="line">c.test();</span><br><span class="line"></span><br><span class="line">// lambda</span><br><span class="line">Runnable x = ()-&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p><code>javap -v</code>编译如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #13.#42        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #25            // str</span><br><span class="line">   #3 = Fieldref           #43.#44        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #45.#46        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #47            // com/zhongyp/test/A</span><br><span class="line">   #6 = Methodref          #5.#42         // com/zhongyp/test/A.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #7 = Methodref          #5.#48         // com/zhongyp/test/A.test:()V</span><br><span class="line">   #8 = Class              #49            // com/zhongyp/test/B</span><br><span class="line">   #9 = Methodref          #8.#42         // com/zhongyp/test/B.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #10 = InterfaceMethodref #50.#48        // com/zhongyp/test/C.test:()V</span><br><span class="line">  #11 = InvokeDynamic      #0:#55         // #0:run:()Ljava/lang/Runnable;</span><br><span class="line">  #12 = Class              #56            // com/zhongyp/test/Test</span><br><span class="line">  #13 = Class              #57            // java/lang/Object</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               LocalVariableTable</span><br><span class="line">  #19 = Utf8               this</span><br><span class="line">  #20 = Utf8               Lcom/zhongyp/test/Test;</span><br><span class="line">  #21 = Utf8               main</span><br><span class="line">  #22 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               args</span><br><span class="line">  #24 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               str</span><br><span class="line">  #26 = Utf8               Ljava/lang/String;</span><br><span class="line">  #27 = Utf8               i</span><br><span class="line">  #28 = Utf8               I</span><br><span class="line">  #29 = Utf8               arrayI</span><br><span class="line">  #30 = Utf8               [I</span><br><span class="line">  #31 = Utf8               arrayA</span><br><span class="line">  #32 = Utf8               [Lcom/zhongyp/test/A;</span><br><span class="line">  #33 = Utf8               a</span><br><span class="line">  #34 = Utf8               Lcom/zhongyp/test/A;</span><br><span class="line">  #35 = Utf8               c</span><br><span class="line">  #36 = Utf8               Lcom/zhongyp/test/C;</span><br><span class="line">  #37 = Utf8               x</span><br><span class="line">  #38 = Utf8               Ljava/lang/Runnable;</span><br><span class="line">  #39 = Utf8               lambda$main$0</span><br><span class="line">  #40 = Utf8               SourceFile</span><br><span class="line">  #41 = Utf8               Test.java</span><br><span class="line">  #42 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #43 = Class              #58            // java/lang/System</span><br><span class="line">  #44 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #45 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #46 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #47 = Utf8               com/zhongyp/test/A</span><br><span class="line">  #48 = NameAndType        #64:#15        // test:()V</span><br><span class="line">  #49 = Utf8               com/zhongyp/test/B</span><br><span class="line">  #50 = Class              #65            // com/zhongyp/test/C</span><br><span class="line">  #51 = Utf8               BootstrapMethods</span><br><span class="line">  #52 = MethodHandle       #6:#66         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #53 = MethodType         #15            //  ()V</span><br><span class="line">  #54 = MethodHandle       #6:#67         // invokestatic com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #55 = NameAndType        #68:#69        // run:()Ljava/lang/Runnable;</span><br><span class="line">  #56 = Utf8               com/zhongyp/test/Test</span><br><span class="line">  #57 = Utf8               java/lang/Object</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #64 = Utf8               test</span><br><span class="line">  #65 = Utf8               com/zhongyp/test/C</span><br><span class="line">  #66 = Methodref          #70.#71        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #67 = Methodref          #12.#72        // com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #68 = Utf8               run</span><br><span class="line">  #69 = Utf8               ()Ljava/lang/Runnable;</span><br><span class="line">  #70 = Class              #73            // java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #71 = NameAndType        #74:#78        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #72 = NameAndType        #39:#15        // lambda$main$0:()V</span><br><span class="line">  #73 = Utf8               java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #74 = Utf8               metafactory</span><br><span class="line">  #75 = Class              #80            // java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #76 = Utf8               Lookup</span><br><span class="line">  #77 = Utf8               InnerClasses</span><br><span class="line">  #78 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #79 = Class              #81            // java/lang/invoke/MethodHandles</span><br><span class="line">  #80 = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #81 = Utf8               java/lang/invoke/MethodHandles</span><br></pre></td></tr></table></figure><h3 id="4-1-CONSTANT-Class-info结构"><a href="#4-1-CONSTANT-Class-info结构" class="headerlink" title="4.1 CONSTANT_Class_info结构"></a>4.1 CONSTANT_Class_info结构</h3><p>对类或接口的符号引用是从类或接口的二进制表示形式中的CONSTANT_Class_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1" target="_blank" rel="noopener">第4.4.1节</a>派生的。这样的引用给出了Class.getName方法返回的表单中的类或接口的名称。</p><p>对于非数组类或接口，名称是类或接口的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>。</p><p>对于n维的数组类，名称以n个出现的ASCII“[”字符开头，后跟元素类型的表示：</p><ul><li><p>如果元素类型是基本类型，则它由相应的字段描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">第4.3.2节</a>表示。</p></li><li><p>否则，如果元素类型是引用类型，则它由ASCII“L”字符后跟元素类型的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>后跟ASCII“;”符号表示。</p></li></ul><h3 id="4-2-CONSTANT-Fieldref-info结构"><a href="#4-2-CONSTANT-Fieldref-info结构" class="headerlink" title="4.2 CONSTANT_Fieldref_info结构"></a>4.2 CONSTANT_Fieldref_info结构</h3><p>对类或接口的字段的符号引用是从类或接口的二进制表示形式中的CONSTANT_Fieldref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了字段的名称和描述符，以及对要在其中找到字段的类或接口的符号引用。</p><h3 id="4-3-CONSTANT-Methodref-info结构"><a href="#4-3-CONSTANT-Methodref-info结构" class="headerlink" title="4.3 CONSTANT_Methodref_info结构"></a>4.3 CONSTANT_Methodref_info结构</h3><p>对类的方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_Methodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了方法的名称和描述符，以及对要在其中找到方法的类的符号引用。</p><h3 id="4-4-CONSTANT-InterfaceMethodref-info"><a href="#4-4-CONSTANT-InterfaceMethodref-info" class="headerlink" title="4.4 CONSTANT_InterfaceMethodref_info"></a>4.4 CONSTANT_InterfaceMethodref_info</h3><p>对接口方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_InterfaceMethodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了接口方法的名称和描述符，以及对要在其中找到方法的接口的符号引用。</p><h3 id="4-5-CONSTANT-MethodHandle-info结构"><a href="#4-5-CONSTANT-MethodHandle-info结构" class="headerlink" title="4.5 CONSTANT_MethodHandle_info结构"></a>4.5 CONSTANT_MethodHandle_info结构</h3><p>方法句柄的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodHandle_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.8" target="_blank" rel="noopener">第4.4.8节</a>派生的。这样的引用根据方法句柄的类型给出了类或接口的字段，类的方法或接口的方法的符号引用。</p><h3 id="4-6-CONSTANT-MethodType-info结构"><a href="#4-6-CONSTANT-MethodType-info结构" class="headerlink" title="4.6 CONSTANT_MethodType_info结构"></a>4.6 CONSTANT_MethodType_info结构</h3><p>方法类型的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodType_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.9" target="_blank" rel="noopener">第4.4.9节</a>派生的。这样的引用给出了方法描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">§4.3.3</a>。</p><h3 id="4-7-CONSTANT-InvokeDynamic-info结构"><a href="#4-7-CONSTANT-InvokeDynamic-info结构" class="headerlink" title="4.7 CONSTANT_InvokeDynamic_info结构"></a>4.7 CONSTANT_InvokeDynamic_info结构</h3><blockquote><h3 id="invokedynamic-instructions"><a href="#invokedynamic-instructions" class="headerlink" title="invokedynamic instructions"></a>invokedynamic instructions</h3><p>A dynamic call site is originally in an unlinked state. In this state, there is no target method for the call site to invoke.<br>动态的调用site起初处在未连接的状态。在这种状态下，调用site没有调用的目标方法。<br>Before the JVM can execute a dynamic call site (an invokedynamic instruction), the call site must first be linked. Linking is accomplished by calling a bootstrap method which is given the static information content of the call site, and which must produce a method handle that gives the behavior of the call site.<br>在JVM可以执行动态调用site（invokedynamic指令）之前，必须首先连接调用site。连接是通过调用一个bootstrap方法来完成的，该方法被赋予了调用站点的静态信息内容，并且必须产生一个方法句柄来给出调用站点的行为。<br>Each invokedynamic instruction statically specifies its own bootstrap method as a constant pool reference. The constant pool reference also specifies the call site’s name and type descriptor, just like invokevirtual and the other invoke instructions.<br>每个invokedynamic指令静态的将它自己的引导方法指定作为一个常量池引用。常量池引用也指定调用site的名称和类型描述，就像invokevirtual和其他的调用描述一样。<br>Linking starts with resolving the constant pool entry for the bootstrap method, and resolving a MethodType object for the type descriptor of the dynamic call site. This resolution process may trigger class loading. It may therefore throw an error if a class fails to load. This error becomes the abnormal termination of the dynamic call site execution. Linkage does not trigger class initialization.<br>连接从解析引导方法的常量池条目开始，并为动态调用site的类型描述符解析MethodType对象。这个解决的进程可能触发类加载。如果一个类加载失败，可能因此抛出一个error。这个error将成为动态调用site执行的异常终止。连接不能触发类的初始化。<br>The bootstrap method is invoked on at least three values:<br>引导方法至少使用3个值调用:</p><ul><li>a MethodHandles.Lookup, a lookup object on the caller class in which dynamic call site occurs</li><li>一个是MethodHandles.Lookup，发生动态调用site的调用类上的一个lookup对象。</li><li>a String, the method name mentioned in the call site</li><li>一个字符创，在调用site中提到的方法名称。</li><li>a MethodType, the resolved type descriptor of the call</li><li>一个MethodType，已解析的调用的类型描述。</li><li>optionally, between 1 and 251 additional static arguments taken from the constant pool。</li><li>可选地，从常量池中获取1到251个额外的静态参数。</li></ul></blockquote><p>对调用站点说明符的符号引用是从类或接口的二进制表示形式中的CONSTANT_InvokeDynamic_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.10" target="_blank" rel="noopener">第4.4.10节</a>派生的。这样的参考给出：</p><ul><li><p>方法句柄的符号引用，它将作为invokedynamic指令的引导方法<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic" target="_blank" rel="noopener">§invokedynamic</a>;</p></li><li><p>一系列符号引用(对类，方法类型和方法句柄)，字符串文字和运行时常量值，它们将作为引导方法的静态参数;</p></li><li><p>方法名称和方法描述符。</p></li></ul><h3 id="4-8-CONSTANT-String-info结构"><a href="#4-8-CONSTANT-String-info结构" class="headerlink" title="4.8 CONSTANT_String_info结构"></a>4.8 CONSTANT_String_info结构</h3><p>此外，某些不是符号引用的运行时值是从constant_pool表中找到的项派生的：</p><p>字符串文字是对类String实例的引用，它是从类或接口的二进制表示形式的CONSTANT_String_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3" target="_blank" rel="noopener">第4.4.3节</a>派生而来的。 CONSTANT_String_info结构给出了构成字符串文字的Unicode代码点序列。</p><p>Java编程语言要求相同的字符串文字[即包含相同代码点序列的文字]必须引用类String的相同实例(JLS§3.10.5)。此外，如果在任何字符串上调用String.intern方法，则结果是对该字符串显示为文字时将返回的同一类实例的引用。因此，以下表达式的值必须为true：</p><p><code>(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</code></p><p>为了派生字符串文字，Java虚拟机检查CONSTANT_String_info结构给出的代码点序列。</p><p>如果先前在类String的实例上调用了String.intern方法，该类包含与CONSTANT_String_info结构给出的Unicode代码点序列相同的Unicode代码点序列，则字符串文字派生的结果是对类String的同一实例的引用。</p><p>否则，将创建一个类String的新实例，其中包含CONSTANT_String_info结构给出的Unicode代码点序列;对该类实例的引用是字符串文字派生的结果。最后，调用新String实例的intern方法。</p><h3 id="4-9-其他结构"><a href="#4-9-其他结构" class="headerlink" title="4.9 其他结构"></a>4.9 其他结构</h3><p>运行时常量值是从类或接口的二进制表示形式中的CONSTANT_Integer_info，CONSTANT_Float_info，CONSTANT_Long_info或CONSTANT_Double_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">第4.4.4节，第4.4.5节</a>派生的。</p><p>请注意，CONSTANT_Float_info结构表示IEEE 754单一格式的值，CONSTANT_Double_info结构表示IEEE 754双格式<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">§4.4.4，§4.4.5</a>中的值。因此，从这些结构导出的运行时常数值必须是可以分别使用IEEE 754单格式和双格式表示的值。</p><p>类或接口的二进制表示的constant_pool表中的其余结构 - CONSTANT_NameAndType_info和CONSTANT_Utf8_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.6" target="_blank" rel="noopener">§4.4.6，§4.4.7</a> - 仅在派生对类，接口，方法，字段的符号引用时间接使用，方法类型和方法句柄，以及派生字符串文字和调用站点说明符时。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a></p><p><a href="">深入理解Java虚拟机</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/package-summary.html#package.description" target="_blank" rel="noopener">Package java.lang.invoke Description</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chapter 5. Loadin
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://blog.programer.group/tags/JVM/"/>
    
      <category term="翻译" scheme="http://blog.programer.group/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
