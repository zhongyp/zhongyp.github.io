<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DO IT</title>
  
  <subtitle>钟宇鹏的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhongyp.me/"/>
  <updated>2018-12-06T02:20:28.035Z</updated>
  <id>http://zhongyp.me/</id>
  
  <author>
    <name>zhongyp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程启动与终止</title>
    <link href="http://zhongyp.me/2018/12/04/concurrent/2018-12-04-thread-start-end/"/>
    <id>http://zhongyp.me/2018/12/04/concurrent/2018-12-04-thread-start-end/</id>
    <published>2018-12-03T16:00:00.000Z</published>
    <updated>2018-12-06T02:20:28.035Z</updated>
    
    <content type="html"><![CDATA[<p>上篇对<a href="https://zhongyp.me/2018/03/16/concurrent/2017-03-16-Thread-brief/">什么是线程</a>做了简单的介绍,本篇主要是从构造线程、中断线程、终止线程3个方面了解线程。</p><h3 id="1-构造线程"><a href="#1-构造线程" class="headerlink" title="1. 构造线程"></a>1. 构造线程</h3><h4 id="1-1-构造线程的方式"><a href="#1-1-构造线程的方式" class="headerlink" title="1.1 构造线程的方式"></a>1.1 构造线程的方式</h4><p>Java构造一个线程有两种方式：</p><p>一种直接new Thread()线程实例或者是声明子类继承Thread父类并重写父类的run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeThread extends Thread &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeThread(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeThread p = new PrimeThread(143);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure></p><p>另一种方式是声明子类实现Runnable接口，并实现run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeRun implements Runnable &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeRun(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeRun p = new PrimeRun(143);</span><br><span class="line">new Thread(p).start();</span><br></pre></td></tr></table></figure></p><p>两者其实在本质上是一致的，实现/重写Runable中的run方法，因为Thread类也继承了Runable接口。Java将线程的执行和执行对象抽象开来，JDK中执行的是Thread类，Executor框架，可执行目标有Runable，Callable。对于第一种方式并不推荐，因为继承Thread类限定了其基本行为，在设计上违反多用组合 少用继承的原则，所以一般构造线程使用第二种方式。</p><h4 id="1-2-构造线程的属性"><a href="#1-2-构造线程的属性" class="headerlink" title="1.2 构造线程的属性"></a>1.2 构造线程的属性</h4><p>构造线程时需要提供线程所需要的属性。一个新的（child）线程对象是由parent线程进行空间分配的，而child线程继承了parent是否为Daemon、优先级、和加载资源的contextClassLoader以及可继承的ThreadLocal，同时分配唯一的ID来表示这个child线程。如果创建线程实例后需要修改线程属性，则可以通过Thread提供的一些修改属性的方法进行修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setPriority()</span><br><span class="line">getPriority()</span><br><span class="line">setName()</span><br><span class="line">getName()</span><br><span class="line">setDaemon()</span><br><span class="line">isDaemon()</span><br><span class="line">getContextClassLoader()</span><br><span class="line">setContextClassLoader()</span><br><span class="line">getStackTrace()</span><br><span class="line">getAllStackTraces()</span><br><span class="line">checkAccess()</span><br><span class="line">isCCLOverridden()</span><br><span class="line">auditSubclass()</span><br><span class="line">dumpThreads()</span><br><span class="line">getThreads()</span><br><span class="line">getId()</span><br><span class="line">getState()</span><br><span class="line">setDefaultUncaughtExceptionHandler()</span><br><span class="line">getDefaultUncaughtExceptionHandler()</span><br><span class="line">getUncaughtExceptionHandler()</span><br><span class="line">setUncaughtExceptionHandler()</span><br><span class="line">dispatchUncaughtException()</span><br><span class="line">processQueue()</span><br></pre></td></tr></table></figure></p><p>当然构造线程属性有些属性还可以在创建线程实例时就设置，如下是一个线程初始化时的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @param g</span><br><span class="line"> * @param target</span><br><span class="line"> * @param name</span><br><span class="line"> * @param stackSize 线程的栈大小 根据参数传递过程可以看出默认大小为零，即使用默认的线程栈大小</span><br><span class="line"> * @param acc 访问控制权限</span><br><span class="line"> * @param inheritThreadLocals // 可继承的ThreadLocal</span><br><span class="line"> *</span><br><span class="line"> * ThreadGroup 线程组（ThreadGroup）就是由线程组成的管理线程的类，</span><br><span class="line"> *     这个类是java.lang.ThreadGroup类。</span><br><span class="line"> *     定义一个线程组，通过以下代码可以实现。</span><br><span class="line"> *     ThreadGroup group=new ThreadGroup(&quot;group&quot;);</span><br><span class="line"> *     Thread thread=new Thread(group,&quot;the first thread of group&quot;);</span><br><span class="line"> *     ThreadGroup类中的某些方法，可以对线程组中的线程产生作用。例如，setMaxPriority()方法可以设定线程组中的所有线程拥有最大的优先权。</span><br><span class="line"> */</span><br><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                  long stackSize, AccessControlContext acc,</span><br><span class="line">                  boolean inheritThreadLocals) &#123;</span><br><span class="line">    if (name == null) &#123;// 线程名，可相同</span><br><span class="line">        throw new NullPointerException(&quot;name cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();// 获取当前线程，并作为父线程。</span><br><span class="line">    SecurityManager security = System.getSecurityManager();// 获取安全策略</span><br><span class="line">    if (g == null) &#123;</span><br><span class="line">        /* Determine if it&apos;s an applet or not */</span><br><span class="line"></span><br><span class="line">        /* If there is a security manager, ask the security manager</span><br><span class="line">           what to do. */</span><br><span class="line">        if (security != null) &#123;//如果存在安全管理器，则获取它重写的线程组</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If the security doesn&apos;t have a strong opinion of the matter</span><br><span class="line">           use the parent thread group. */</span><br><span class="line">        if (g == null) &#123;</span><br><span class="line">            g = parent.getThreadGroup();//使用父线程组</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* checkAccess regardless of whether or not threadgroup is</span><br><span class="line">       explicitly passed in. */</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Do we have the required permissions?</span><br><span class="line">     */</span><br><span class="line">    if (security != null) &#123;</span><br><span class="line">        if (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    this.group = g;</span><br><span class="line">    this.daemon = parent.isDaemon();//继承父线程的守护属性</span><br><span class="line">    this.priority = parent.getPriority();//继承父线程的优先级</span><br><span class="line">    //继承父线程加载资源的contextClassLoader</span><br><span class="line">    if (security == null || isCCLOverridden(parent.getClass()))</span><br><span class="line">        this.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    else</span><br><span class="line">        this.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    this.inheritedAccessControlContext =</span><br><span class="line">            acc != null ? acc : AccessController.getContext();</span><br><span class="line">    this.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    // 继承父线程可继承的ThreadLocal</span><br><span class="line">    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">        this.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    /* Stash the specified stack size in case the VM cares */</span><br><span class="line">    this.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    /* Set thread ID */</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-启动线程"><a href="#1-3-启动线程" class="headerlink" title="1.3 启动线程"></a>1.3 启动线程</h4><p>线程对象在初始化完成后，调用start方法就可以启动线程。<br><strong><em>注意：启动一个线程，最好为这个线程设置线程名称，这行有助于分析或者排查问题</em></strong></p><h3 id="2-中断线程"><a href="#2-中断线程" class="headerlink" title="2. 中断线程"></a>2. 中断线程</h3><h4 id="2-1-中断的原理"><a href="#2-1-中断的原理" class="headerlink" title="2.1 中断的原理"></a>2.1 中断的原理</h4><p>中断，可以理解为运行中的线程，是否被其他线程进行了中断操作。中断操作有的情况下仅仅设置中断状态，有的<br>中断操作包含三个方法。interrupt(),interrupted(),isInterrupted()。下面我们将对这个方法进行详细了解。</p><h5 id="2-1-1-interrupt"><a href="#2-1-1-interrupt" class="headerlink" title="2.1.1 interrupt()"></a>2.1.1 interrupt()</h5><p>中断操作通过调用线程的interrupt()方法进行。例如线程A中断线程B，在线程A的代码中调用ThreadB.interrupt()即可。</p><p>interrupt()方法不是直接将线程终止，而是针对于不同情况的不同处理如下。翻译自<a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Java se7docs</a>：</p><ol><li>除非终止的是当前线程（始终被允许），否则调用checkAccess方法，可能会导致抛出SecurityException异常。</li><li>如果调用Object类的wait(),wait(long)或者wait(long, int)等方法，或者调用此线程的join(),join(long),join(long, int), sleep(long), sleep(long, int)方法，<strong><em>此线程的中断状态将被清除，同时将抛出InterruptedException异常</em></strong>。</li><li>如果此线程在可中断通道的IO操作上，通道将被关闭，线程被设置中断状态，同时将抛出ClosedByInterruptException异常。</li><li>如果线程在选择器(Selector)阻塞，线程将被设置中断状态，立即从选择操作中返回，可能带有非零值，就像选择器唤醒方法被调用一样。</li><li>如果以上的条件都不满足，此线程将被设置中断状态。</li><li>中断不存活的线程不会有任何影响。</li></ol><p>这里提供了上面的终止当前线程，sleep阻塞线程，IO阻塞线程例子，读者可根据上述要求测试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class InterruptCurrentThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        this.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class InterruptBlockedThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        SleepUtils.sleep(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class InterruptIOBlockedThread extends Thread&#123;</span><br><span class="line">    private LinkedBlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        try &#123;</span><br><span class="line">            queue.take();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注：Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。这个不太常用所以就没有给出测试用例。</p><p>注意：<strong><em>对于会抛出异常的情况，异常一定要处理，一般子线程异常不能抛出非运行时异常，所以子线程我们需要抛出运行时异常，用于给父线程捕获。</em></strong></p><h5 id="2-1-2-interrupted"><a href="#2-1-2-interrupted" class="headerlink" title="2.1.2 interrupted()"></a>2.1.2 interrupted()</h5><p>interrupted()主要有以下两个功能：</p><ol><li>测试<strong><em>当前线程</em></strong>是否被中断,线程中断状态将被清除。换句话说就是，如果当前方法被成功调用两次，则返回false（除非当前线程在第一次调用此方法后第二次调用此方法前被再次中断）。</li><li>线程中断被忽略，因为在中断时线程死掉将被此方法反映返回false。(我的理解)</li></ol><p>interrupted()不同于interrupt(),此方法用于测试当前线程是否被中断，并清除中断状态。代码示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread thread = new InterruptThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    SleepUtils.sleep(1);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">    static class InterruptThread extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int count = 0;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                if(interrupted())&#123;//此处仅仅是为了示例</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-1-3-isInterrupted"><a href="#2-1-3-isInterrupted" class="headerlink" title="2.1.3 isInterrupted()"></a>2.1.3 isInterrupted()</h5><p>isInterrupted虽然也是测试线程是否被中断，但是此方法不会更改线程的中断状态。</p><h3 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3. 终止线程"></a>3. 终止线程</h3><h4 id="3-1-过期的suspend-、resume-和stop"><a href="#3-1-过期的suspend-、resume-和stop" class="headerlink" title="3.1 过期的suspend()、resume()和stop()"></a>3.1 过期的suspend()、resume()和stop()</h4><p>在Java API中，suspend()、resume()和stop()三个方法是过期的，不建议使用的。<br>主要原因是：suspend()在调用后，线程不是放已经占有的资源比如说锁，而是占有着资源进入睡眠，这样容易引发死锁状态。stop()方法在终结一个线程时不会保证线程资源的释放，因此导致线程处于不确定的状态下。</p><p><strong><em>sleep和suspend区别：</em></strong><br>相同点：sleep和suspend都会持有占有的资源不释放。<br>不同点：sleep阻塞（TIMED_WAITING）后，经过一段时间自行恢复运行。而suspend必须使用resume()显示的恢复，如果不使用resume()或者resume()失败，很容易引起资源占用导致的死锁。</p><h4 id="3-2-安全的终止线程"><a href="#3-2-安全的终止线程" class="headerlink" title="3.2 安全的终止线程"></a>3.2 安全的终止线程</h4><p>在第2小节提到的中断是线程的一个标示位，中断操作是一种简便的线程间交互方式，这种交互方式适合用来取消和停止任务。除了中断，还可以使用同步变量来控制是否停止并终止该线程。<br><strong><em>线程的终止不是直接强制线程停止，而是引导线程运行结束。</em></strong></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" target="_blank" rel="noopener">Java 安全模型介绍</a><br><a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Class Thread</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程(1)-Thread类源码</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇对&lt;a href=&quot;https://zhongyp.me/2018/03/16/concurrent/2017-03-16-Thread-brief/&quot;&gt;什么是线程&lt;/a&gt;做了简单的介绍,本篇主要是从构造线程、中断线程、终止线程3个方面了解线程。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>我的博客</title>
    <link href="http://zhongyp.me/2018/11/28/life/2018-11-29-myblog/"/>
    <id>http://zhongyp.me/2018/11/28/life/2018-11-29-myblog/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2018-12-06T02:25:57.271Z</updated>
    
    <content type="html"><![CDATA[<p><strong>少年时代对未来生活的想象虽然朦胧，但实际上却有着极高的期待。你总觉得现在只是活着，等待着，等待着某一刻会金鼓齐鸣，光芒四射，然后，真正的生活开始了。但日常生活自有它自己缓慢而平静的节奏，它波澜不兴地向前弥漫，越过岁月。直到你骤然发现，大多数人的生活不会有金鼓齐鸣的开始，大多数人的生活，就是一种水滴石穿的单调和宁静。</strong></p><p>开始写博客一段时间了，只是想找个地方记录下自己的看过的、学过的知识，记录下学习的过程中自己的想法/感悟。thinking…🌝</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;少年时代对未来生活的想象虽然朦胧，但实际上却有着极高的期待。你总觉得现在只是活着，等待着，等待着某一刻会金鼓齐鸣，光芒四射，然后，真正的生活开始了。但日常生活自有它自己缓慢而平静的节奏，它波澜不兴地向前弥漫，越过岁月。直到你骤然发现，大多数人的生活不会有金鼓
      
    
    </summary>
    
    
      <category term="生活" scheme="http://zhongyp.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>博客声明</title>
    <link href="http://zhongyp.me/2018/11/28/life/2018-11-29-blog-announce/"/>
    <id>http://zhongyp.me/2018/11/28/life/2018-11-29-blog-announce/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2018-12-06T02:25:30.616Z</updated>
    
    <content type="html"><![CDATA[<p>博客中的文章，如果没有特殊说明，均为原创，欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任。<br>博客中可能有些内容摘录至别人的文章/博客/书，仅为个人收藏，分享知识，如有侵权，请联系博主进行删除。📧：<a href="mailto:zhongyp001@163.com" target="_blank" rel="noopener">zhongyp001@163.com</a>，收到后一定尽快删除与您的相关内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客中的文章，如果没有特殊说明，均为原创，欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任。&lt;br&gt;博客中可能有些内容摘录至别人的文章/博客/书，仅为个人收藏，分享知识，如有侵权，请联系博主进行删除。📧：&lt;a href=&quot;mailto
      
    
    </summary>
    
    
      <category term="生活" scheme="http://zhongyp.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>并发知识架构</title>
    <link href="http://zhongyp.me/2018/11/16/concurrent/2018-11-27-concurrency-structure/"/>
    <id>http://zhongyp.me/2018/11/16/concurrent/2018-11-27-concurrency-structure/</id>
    <published>2018-11-15T16:00:00.000Z</published>
    <updated>2018-12-04T06:03:49.953Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/concurrency.png" alt="Java并发架构图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/concurrency.png&quot; alt=&quot;Java并发架构图&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令总结</title>
    <link href="http://zhongyp.me/2018/10/23/utils/2018-10-23-git/"/>
    <id>http://zhongyp.me/2018/10/23/utils/2018-10-23-git/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-11-27T03:20:14.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>系统系统性的学习Git，请移步<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Git中文学习文档</a>，这篇文章只是分类记录一下git的常用命令。<br><img src="/media/15403035072735.png" alt="Git版本控制系统VCS基本操作流程图"></p><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><h3 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h3><p><code>git init</code> 将当前目录变为可管理的仓库<br><code>git clone</code> 克隆一个仓库到本地<br><code>git clone -b branch uri</code> 克隆指定branch分支到本地<br><code>git config user.name</code> 查看用户名<br><code>git config user.email</code> 查看邮箱</p><h3 id="设置与配置"><a href="#设置与配置" class="headerlink" title="设置与配置"></a>设置与配置</h3><p><code>git config -global user.name/email &quot;参数&quot;</code> git是分布式版本控制，所以添加用户名和邮箱作为一个标识<br><code>ssh -keygen -t rsa -C &quot;email&quot;</code> 生成本地ssh key</p><h3 id="本地版本库"><a href="#本地版本库" class="headerlink" title="本地版本库"></a>本地版本库</h3><p><code>git add &quot;filename.*&quot;</code> 添加到暂存区<br><code>git commit -m &quot;filename.*&quot;</code> 提交到仓库<br><code>git commit --amend</code> 尝试重新提交,这个操作需要组合操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add file1 // 将file1 添加至缓存区</span><br><span class="line">git commmit -m &quot;update files&quot; //提交file1到本地仓库,提交完发现忘记file2没有提交，则你可以使用如下命令，提交file2并覆盖之前的提交信息。</span><br><span class="line">git add file2 // 添加file2</span><br><span class="line">git commit -amend // 尝试重新提交commit信息，并覆盖掉之前的提交信息</span><br></pre></td></tr></table></figure><p><code>git status</code> 查看文件状态<br><code>git diff filename.*</code> 查看修改了什么<br><code>git log</code> 看看每次修改的日志<br><code>git log --pretty=oneline</code> 日志显示为缩略版<br>注：<code>git reset</code> 不加<code>--hard</code>参数对当前工作区文件不会有任何修改，只是对缓存区进行操作。一旦加了参数，操作一定要慎重，否则你当前工作区中的修改将会全部被清除。<br><code>git reset HEAD file</code> 将file退回到当前版本（仅仅是对缓存区进行操作）<br><code>git reset --hard HEAD^</code> 退回到上一版本<br><code>git reset --hard HEAD^^</code> 退回到前二的版本<br><code>git reset --hard HEAD~100</code> 退回到前100版本<br><code>git reset --hard 版本号</code> 退回到一个特定的版本<br><code>git reflog</code> 查看版本号和上一个命令一块用效果比较好<br><code>git reset --mixed</code> 将当前文件撤出缓存区，保留文件修改<br><code>git rm --cached file</code> 删除缓存区file<br><code>git checkout -- file</code> 恢复工作区file（取消工作区文件的修改）</p><h3 id="远程版本库"><a href="#远程版本库" class="headerlink" title="远程版本库"></a>远程版本库</h3><p><code>git remote add origin 远程git地址</code> 连接<br><code>git push -u origin master</code> 把本地库分支master内容推送到远程库（-u 命令在第一次关联本地库和远程库时使用）<br><code>git clone url</code> 克隆远程(url)库</p><h3 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h3><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p><code>git branch</code> 查看分支<br><code>git checkout</code> 切换分支<br><code>git checkout -b</code>  创建并切换分支<br><code>git merge</code> 合并到当前分支<br><code>git branch -d</code>删除某分支<br><code>git merge --no-ff -m &quot;注释&quot;</code>分支合并分支禁用fast forward<br><code>git stash</code> 将当前分支的工作现场保留下来<br><code>git stash list</code> 查看工作现场<br><code>git stash apply</code> 恢复内容但是你需要git stash drop删除stash<br><code>git stash pop</code> 恢复的同时把stash内容也删除<br><code>git remote</code> 查看远程库的信息<br><code>git remote -v</code> 查看远程库的详细信息<br><code>git push origin master</code> master为本地的分支名推送分支<br><code>git checkout -b dev origin/dev</code> dev为分支名，做完开发后<br><code>git push origin dev</code> 推送到远程库<br><code>git pull</code> 抓取最新的提交,并尝试自动合并到本地当前所在的分支<br><code>git fetch</code> 抓取最新的提交，不会自动合并，必须手动。<br><code>git rebase</code> 变基,将提交到某一分支上的所有修改都移至另一分支上<br><code>git rebase --continue</code> <strong><em>继续变基操作，一般用于第一次变基失败后，解决冲突文件，将冲突文件添加到缓存区，不要提交，然后再执行此命令。如果提交了，执行<code>git rebase --skip</code>命令取消rebase状态。</em></strong><br><code>git branch --set-upstream dev origin/dev</code> 指定本地dev分支（已经创建的）与远程origin/dev分支的连接<br><code>git branch -u origin/dev</code> 指定当前所在连接远程origin/dev分支的连接<br><code>git checkout --track origin/dev</code> 创建新的dev分支，制定远程连接origin/dev</p><p>注：如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ol><li>每开发一个新特性可以新建一个本地特性分支，开发完成后合并到本地主线。</li><li>如果不使用特性分支开发可以使用<code>git stash</code>保存当前的工作空间。</li><li>远程代码和本地代码合并有两种方式，<code>git pull</code>和<code>git fetch</code>，<code>git pull</code>命令会自动合并远程代码，冲突后需要解决冲突后提交。<code>git fetch</code>不自动和本地代码合并，需要手动merge。</li><li>在合并时，根据项目情况使用<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">变基</a>。一般情况下，远程库不保留本地操作历史。</li><li><strong><em>使用变基原则</em></strong>：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h2&gt;&lt;p&gt;系统系统性的学习Git，请移步&lt;a href=&quot;https://git-scm.com/book/zh/v2/%E8%B5%B7%E
      
    
    </summary>
    
    
      <category term="Utils" scheme="http://zhongyp.me/tags/Utils/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP</title>
    <link href="http://zhongyp.me/2018/10/03/spring/2018-09-28-AOP/"/>
    <id>http://zhongyp.me/2018/10/03/spring/2018-09-28-AOP/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2018-11-30T11:39:42.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>本篇文章翻译自<a href="https://www.tutorialspoint.com/spring/aop_with_spring.htm" target="_blank" rel="noopener">AOP with Spring</a>，主要介绍是关于AOP的概念。</p><h3 id="Brief-introduction-（简介）"><a href="#Brief-introduction-（简介）" class="headerlink" title="Brief introduction （简介）"></a>Brief introduction （简介）</h3><p>One of the key components of Spring Framework is the Aspect oriented programming (AOP) framework. Aspect-Oriented Programming entails breaking down program logic into distinct parts called so-called concerns. The functions that span multiple points of an application are called cross-cutting concerns and these cross-cutting concerns are conceptually separate from the application’s business logic. There are various common good examples of aspects like logging, auditing, declarative transactions, security, caching, etc.</p><p>The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Dependency Injection helps you decouple your application objects from each other and AOP helps you decouple cross-cutting concerns from the objects that they affect. AOP is like triggers in programming languages such as Perl, .NET, Java, and others.</p><p>Spring AOP module provides interceptors to intercept an application. For example, when a method is executed, you can add extra functionality before or after the method execution.</p><p>翻译：</p><p>AOP面向切面编程是Spring框架中的最关键的部分之一。面向切面编程需要拆分程序逻辑到被称为关注点的不同部分。一个在应用程序内跨越多个点的方法被称为横切点，这些横切点和应用的业务逻辑在概念上是分开的。目前已经有很多应用切面的例子，比如日志，审计，声明式事务，安全，缓存等。</p><p>在面向对象编程中，模块化的关键单元是类，但是在面向切面编程中，模块化单元是切面。依赖注入帮助你将应用中的对象相互解耦，AOP帮助你将横切点从它们作用的对象中解耦。AOP就像是Perl,.NET,Java或者其他编程语言中的触发器。</p><p>Spring AOP模块提供拦截应用的拦截器。举个🌰，你可以在你运行的方法之前或者之后添加额外的功能或者方法。</p><h3 id="AOP-Terminologies（AOP-术语）"><a href="#AOP-Terminologies（AOP-术语）" class="headerlink" title="AOP Terminologies（AOP 术语）"></a>AOP Terminologies（AOP 术语）</h3><h4 id="Aspect（切面）"><a href="#Aspect（切面）" class="headerlink" title="Aspect（切面）"></a>Aspect（切面）</h4><p>This is a module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement.</p><p>翻译： Aspect一个提供横切（cross-cutting）APIs的模块。举个例子，日志模块被称为AOP 日志切面。一个应用可以根据需求拥有任何数量的切面。</p><h4 id="Join-point（连接点）"><a href="#Join-point（连接点）" class="headerlink" title="Join point（连接点）"></a>Join point（连接点）</h4><p>This represents a point in your application where you can plug-in the AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.</p><p>翻译： 在应用中可以插入AOP切面的地方可被抽象为一个点。你也可以说，这是一个在应用中存在的地方，这个地方将被Spring AOP 框架执行一些动作。</p><p>Advice（通知）</p><p>This is the actual action to be taken either before or after the method execution. This is an actual piece of code that is invoked during the program execution by Spring AOP framework.</p><p>翻译：Advice是一个实际的动作，它将在方法执行前和方法执行后执行。这段代码通过Spring AOP框架在程序运行时被调用。</p><h4 id="Pointcut（切入点）"><a href="#Pointcut（切入点）" class="headerlink" title="Pointcut（切入点）"></a>Pointcut（切入点）</h4><p>This is a set of one or more join points where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples.</p><p>翻译：Pointcut是一个或者多个连接点的集合。正如我们将在AOP例子中看到的，你可以使用表达式或者正则表达式制定你的切入点。</p><h4 id="Introduction（引入）"><a href="#Introduction（引入）" class="headerlink" title="Introduction（引入）"></a>Introduction（引入）</h4><p>An introduction allows you to add new methods or attributes to the existing classes.</p><p>翻译：引入可以允许你添加新的方法或者属性到已经存在的类中。</p><h4 id="Target-object"><a href="#Target-object" class="headerlink" title="Target object"></a>Target object</h4><p>The object being advised by one or more aspects. This object will always be a proxied object, also referred to as the advised object.</p><p>翻译：这个对象被一个或者多个切面通知。这个对象一般是代理对象，作为被通知对象引用。</p><h4 id="Weaving（织入）"><a href="#Weaving（织入）" class="headerlink" title="Weaving（织入）"></a>Weaving（织入）</h4><p>Weaving is the process of linking aspects with other application types or objects to create an advised object. This can be done at compile time, load time, or at runtime.</p><p>翻译：织入是链接切面和其他应用类型或者对象来创建通知对象的过程。这个过程可以在编译、加载或者执行期间进行。</p><h3 id="Types-of-Advice"><a href="#Types-of-Advice" class="headerlink" title="Types of Advice"></a>Types of Advice</h3><p>Spring aspects can work with five kinds of advice mentioned as follows.<br>翻译：Spring 切面可以使用如下提到的五种advice</p><ul><li><p>before: Run advice before a method execution.</p></li><li><p>after: Run advice after a method execution.</p></li><li><p>after-returning: Run advice after the a method execution only if method completes successfully.</p></li><li><p>after-throwing: Run advice after the method execution only if method exits by throwing an exception.</p></li><li><p>around: Run advice before and after the advised method is invoked.</p></li></ul><h3 id="Custom-Aspects-Implementation-自定义接口实现"><a href="#Custom-Aspects-Implementation-自定义接口实现" class="headerlink" title="Custom Aspects Implementation(自定义接口实现)"></a>Custom Aspects Implementation(自定义接口实现)</h3><p>XML Schema based（基于XML模式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http:www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http:www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http:www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:tx=&quot;http:www.springframework.org/schema/tx&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http:www.springframework.org/schema/beans</span><br><span class="line">        http:www.springframework.org/schema/beans/spring-beans-4.2.xsd</span><br><span class="line">        http:www.springframework.org/schema/aop</span><br><span class="line">        http:www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 业务逻辑类--AOP连接点 --&gt;</span><br><span class="line">    &lt;bean id=&quot;aopTest&quot; class=&quot;com.zhongyp.zen.service.aop.AOPTestService&quot; /&gt;</span><br><span class="line">    &lt;!--AOP切面--&gt;</span><br><span class="line">    &lt;bean id=&quot;timeHandler&quot; class=&quot;com.zhongyp.zen.service.handler.TimeHandler&quot; /&gt;</span><br><span class="line">    &lt;!--AOP切面--&gt;</span><br><span class="line">    &lt;bean id=&quot;printHandler&quot; class=&quot;com.zhongyp.zen.service.handler.PrintHandler&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspectj-autoproxy /&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!-- pointcut切入点（AOP连接点的集合）--&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.zhongyp.zen.service.*.*.*(..))&quot; /&gt;</span><br><span class="line">        &lt;!-- 切面 --&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt;</span><br><span class="line">            &lt;!-- AOP Advice --&gt;</span><br><span class="line">            &lt;aop:before method=&quot;printStartTime&quot; pointcut-ref=&quot;pointcut&quot; /&gt;</span><br><span class="line">            &lt;aop:after method=&quot;printEndTime&quot; pointcut-ref=&quot;pointcut&quot; /&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;print&quot; ref=&quot;printHandler&quot;&gt;</span><br><span class="line">            &lt;aop:after-returning method=&quot;printString&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after-returning&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>@AspectJ based（基于切面注解）</p><p>注解方式可以将上述xml配置以注解的形式配置一下，我这里只是给出一个样例，其他的还需读者自己实践。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component(&quot;logHandler&quot;)</span><br><span class="line">public class LogHandler &#123;</span><br><span class="line">    @Pointcut(&quot;execution(* com.zhongyp.zen.service.*.*.*(..))&quot;)</span><br><span class="line">    private void hehe()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    @Before(&quot;hehe()&quot;)</span><br><span class="line">    public void doBefore()&#123;</span><br><span class="line">        System.out.println(&quot;为毛国庆要加班！！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-AOP&quot;&gt;&lt;a href=&quot;#Spring-AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring AOP&quot;&gt;&lt;/a&gt;Spring AOP&lt;/h2&gt;&lt;p&gt;本篇文章翻译自&lt;a href=&quot;https://www.tutorialsp
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zhongyp.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://zhongyp.me/2018/03/27/jvm/2018-03-27-JVM/"/>
    <id>http://zhongyp.me/2018/03/27/jvm/2018-03-27-JVM/</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-12-06T03:21:26.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JVM的自动内存管理机制"><a href="#1-JVM的自动内存管理机制" class="headerlink" title="1. JVM的自动内存管理机制"></a>1. JVM的自动内存管理机制</h2><h3 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h3><p><img src="/media/jvm-1.7-later.png" alt="jvm 1.7"></p><h4 id="1-1-1-程序计数器（PC-Register）"><a href="#1-1-1-程序计数器（PC-Register）" class="headerlink" title="1.1.1 程序计数器（PC Register）"></a>1.1.1 程序计数器（PC Register）</h4><ul><li>当前线程所执行字节码的行号指示器，字节码解释器的作用是通过改变计数器的值来选取下一条需要执行的字节码指令。</li><li>如果当前执行的是Native方法，则这个计数器为空。</li><li>Java虚拟机中<strong><em>唯一</em></strong>没有OOM的区域。</li></ul><h4 id="1-1-2-Java虚拟机栈-（JVM-Stack）"><a href="#1-1-2-Java虚拟机栈-（JVM-Stack）" class="headerlink" title="1.1.2 Java虚拟机栈 （JVM Stack）"></a>1.1.2 Java虚拟机栈 （JVM Stack）</h4><ul><li>虚拟机栈描述的是Java方法执行的内存模型，生命周期与线程相同。</li><li><strong><em>每个方法运行都会创建一个栈帧</em></strong>，存储局部变量表(Local Variable Table)，操作栈(Operation Stack)，方法出口等信息。</li><li><strong><em>在编译期分配</em></strong>局部变量表存放各种基本数据类型、对象引用类型和returnAddress(指向一条字节码指令的地址)。</li><li>如果请求的栈深度大于最大可用栈深度时，系统就会抛出StackOverflowError错误。</li><li>如果虚拟机动态扩展无法申请到足够的的内存时会抛出OOM异常。大部分虚拟机都可以动态扩展，当然也允许固定长度虚拟机栈。</li></ul><h4 id="1-1-3-本地方法栈（Native-Method-Stack）"><a href="#1-1-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="1.1.3 本地方法栈（Native Method Stack）"></a>1.1.3 本地方法栈（Native Method Stack）</h4><ul><li>虚拟机栈为执行Java方法服务，本地方法栈为Native方法服务。</li><li>会出现OOM或者StackOverflowError，原因和虚拟机栈类似。</li></ul><h4 id="1-1-4-Java堆（Heap）"><a href="#1-1-4-Java堆（Heap）" class="headerlink" title="1.1.4 Java堆（Heap）"></a>1.1.4 Java堆（Heap）</h4><ul><li>虚拟机启动时创建被所有线程共享的内存区域，为了存储所有对象实例和数组。垃圾回收的主要区域。</li></ul><h4 id="1-1-5-方法区（Method-Area）"><a href="#1-1-5-方法区（Method-Area）" class="headerlink" title="1.1.5 方法区（Method Area）"></a>1.1.5 方法区（Method Area）</h4><ul><li>别名：“永久代“、”非堆，各个线程共享的内存区域，<strong><em>存储虚拟机已加载的类信息，静态变量、常量、即时编译器编译后的代码数据</em></strong>。默认最小为16MB，最大为64MB，可以通过-XX:PermSize和-XX:MaxPermSize 参数限制方法区大小。</li><li>Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做元空间。</li></ul><h4 id="1-1-6-运行时常量池（Runtime-Constant-Pool）"><a href="#1-1-6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="1.1.6 运行时常量池（Runtime Constant Pool）"></a>1.1.6 运行时常量池（Runtime Constant Pool）</h4><ul><li>运行时常量池：jdk1.6及之前是方法区的一部分，其中的主要内容来自于JVM对Class的加载。Java7中已经将运行时常量池从方法区（永久代）移除，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。</li><li><strong><em>类加载后</em></strong>存储编译器生成的常量（各种字面量和符号引用）。基本数据类型不叫常量，可被修改，String和final修饰的才是。字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名、字段名称和描述符、方法名称和描述符。</li><li>由于运行时常量池从方法区移动到堆，所以jdk1.6和jdk1.7对于常量池的使用还是有些区别的，<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern</a></li></ul><h4 id="1-1-7-直接内存-Direct-Memory"><a href="#1-1-7-直接内存-Direct-Memory" class="headerlink" title="1.1.7 直接内存(Direct Memory)"></a>1.1.7 直接内存(Direct Memory)</h4><ul><li>堆外内存，JVM虚拟机各个区域内存总和大于机器物理内存可能会导致OOM。</li></ul><h3 id="1-2-对象状态算法"><a href="#1-2-对象状态算法" class="headerlink" title="1.2 对象状态算法"></a>1.2 对象状态算法</h3><ul><li><p>引用计数算法： 很难解决对象之间相互引用的问题，内存泄露。</p></li><li><p>跟搜索算法：通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索的路径成为引用链，当一个对象到GC Root没有一个引用时，则证明此对象是不可用的。</p></li></ul><p>注：1. GC对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI。2. 跟搜索算法中，没有引用的对象并非非死不可，还有经历两次标记，第一次发现没有引用，则进行标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或finalize()已经被调用过，虚拟机将这两种情况都视为没有必要执行。</p><h4 id="1-2-1-回收方法区"><a href="#1-2-1-回收方法区" class="headerlink" title="1.2.1 回收方法区"></a>1.2.1 回收方法区</h4><p>方法区主要回收废弃变量和无用的类。无用的类：该类所有实例都已被回收，加载该类的ClassLoader被回收，该类对应的java.lang.Class对象没有在任何地方被引用。只有同时满足无用的类的三个条件，才<strong><em>可以</em></strong>被回收。反射、动态代理、CGLib等bytecode框架场景以及频繁定义ClassLoader的场景都需要具备卸载功能，以保证永久代不会溢出。</p><h3 id="1-3-垃圾收集算法"><a href="#1-3-垃圾收集算法" class="headerlink" title="1.3 垃圾收集算法"></a>1.3 垃圾收集算法</h3><ul><li><p>标记清除算法： 标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。效率问题，空间问题（内存碎片）。</p></li><li><p>复制算法： 新生代使用复制算法回收，由于新生代98%的对象都是朝生夕死的，所以不需要1:1的比例划分内存空间（Hotspot默认8:1），而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一个Survivor。当回收时，将Eden和Survivor中还存活的对象一次性的拷贝到另一块的Survivor上。最后清理掉Eden和刚才使用过的Survivor。当Survivor空间不够用时，需要依赖其他的老年代进行分配担保（Handle Promotion）。分配担保：如果Survivor空间没有足够的空间存放上次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p></li><li><p>标记-整理算法：让所有存活的对象向一端移动，然后清理掉端边界以外的内存。老年代常用的算法。</p></li><li><p>分代收集算法： 根据对象的存活周期不同，将内存划分为几块，根据各个年代的特点进行垃圾回收。</p></li></ul><h3 id="1-4-垃圾收集器"><a href="#1-4-垃圾收集器" class="headerlink" title="1.4 垃圾收集器"></a>1.4 垃圾收集器</h3><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/gc.jpg?raw=true" alt="垃圾回收器"><br><a href="#垃圾收集器">图片来自《深入理解Java虚拟机》</a><br>如果两个收集器之间存在连线，就说明他们可以搭配使用。</p><ol><li><p>Serial</p><p> 复制算法，新生代的单线程收集器，简单高效，stop the world。</p></li><li><p>ParNew</p><p> 复制算法，Serial的多线程版本，stop the world。首选的新生代收集器。</p></li><li><p>Parallel Scavenge</p><p> 新生代收集器，使用复制算法，多线程并行, stop the world。目标达到可控制的吞吐量。运行用户代码时间/CPU消耗总时常=吞吐量。该收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMills参数及直接设置吞吐量大小的-XX:GCTimeRatio参数。MaxGCPauseMills参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。GCTimeRatio参数的值应该是一个大于0的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。除了这两个参数，还有一个-XX:+UseAdaptiveSizePolicy值得关注。打开这个参数后，不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大吞吐量这种方式称为GC自适应的调节策略（GC Ergonomics）</p></li><li><p>Serial Old</p><p> Serial收集器的老年代版本，单线程收集器，使用标记-整理算法，stop the world。主要有两个用途：1. 在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候用。</p></li><li><p>Parallel Old</p><p> Parallel Scavenge的老年代版本，标记-整理算法，stop the world。</p></li><li><p>CMS（Concurrent Mark Sweep）收集器</p></li></ol><p>最短回收停顿时间为目标的收集器，重视服务响应速度，标记-清除算法实现。第一款并发收集器，可与用户线程并发执行。执行过程分为4个步骤：初始标记(CMS initial mark)、并发标记(CMS concurrent mark)、重新标记(CMS remark)、并发清除(CMS concurrent sweep)。初始和重新stop the world。初始标记只是标记GCRoots能直接关联的对象，速度很快，并发标记进行GCROOTs Tracing的过程。重新标记为了修复并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。<br>优点：并发收集、低停顿。<br>缺点：1. 对CPU资源非常敏感，解决方案，减少GC线程的独占时间。2. 无法处理浮动垃圾。CMS运行期间，用户线程产生的垃圾为浮动垃圾，CMS无法在本次收集中个清理这些浮动垃圾。如果CMS运行期间，内存无法满足用户线程要求，就会出现Concurrent Mode Failure失败，可能导致另一个FullGC产生，启动预备方案 Serial Old。3. 产生大量的空间碎片。</p><ol start="7"><li><p>G1收集器</p><p> 标记整理算法实现，精确的控制停顿，指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。G1将整个Java堆（老年代，新生代）划分多个大小固定的独立区域（Region），并且追踪这些区域里面的垃圾堆积程度。在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ol><h3 id="1-5-内存分配与回收"><a href="#1-5-内存分配与回收" class="headerlink" title="1.5 内存分配与回收"></a>1.5 内存分配与回收</h3><p>对象在Eden中分配内存，没有足够的空间进行垃圾回收。MinorGC。</p><pre><code>MinorGC: 新生代垃圾回收的动作，频繁且速度快。MajorGC（FullGC）: 指发生在老年代的GC，慢，清理新生代和老年代，CMS</code></pre><p>大对象指需要大量连续空间的Java对象。典型就是很长的字符串和数组。直接进入老年代分配，避免在Eden及Survivor中大量复制拷贝。</p><p>长期生活的对象进入老年代。对象年龄计数器，每一次MinorGC增长1岁。默认15岁进入老年代。</p><p>动态对象年龄判断，如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄段的对象直接进入老年代。</p><p>空间担保分配，每次MinorGC,检测升级到老年代的大小是否大于老年代的空间，如果大于，则进行FullGC。</p><h2 id="2-JDK命令行工具-性能监控和故障处理"><a href="#2-JDK命令行工具-性能监控和故障处理" class="headerlink" title="2. JDK命令行工具 性能监控和故障处理"></a>2. JDK命令行工具 性能监控和故障处理</h2><h3 id="2-1-jps"><a href="#2-1-jps" class="headerlink" title="2.1 jps"></a>2.1 jps</h3><p>虚拟机进程状况工具。 显示当前所有java进程pid的命令。</p><p>-l 输出主类的全名，如果进程执行的是Jar包，输出Jar路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -l</span><br><span class="line">5696 com.intellij.rt.execution.application.AppMain</span><br><span class="line">944 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">4488</span><br><span class="line">1900 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">7244 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure><p>-v 输出虚拟机进程启动时JVM参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -v</span><br><span class="line">5696 AppMain -Didea.launcher.port=7534 -Didea.launcher.bin.path=F:\Program Files\intellij IDEA\bin -Dfile.encoding=UTF-8</span><br><span class="line">944 RemoteMavenServer -Djava.awt.headless=true -Didea.version==2016.2.5 -Xmx768m -Didea.maven.embedder.version=3.0.5 -Dfile.encoding=GBK</span><br><span class="line">1656 Jps -Denv.class.path=.;C:\Program Files\Java\jdk1.8.0_161\lib\dt.jar;C:\Program Files\Java\jdk1.8.0_161\lib\tools.jar; -Dapplication.home=C:\Program Files\Java\jdk1.8.0_161 -Xms8m</span><br><span class="line">4488  -Xms128m -Xmx750m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djb.vmOptionsFile=F:\Program Files\intellij IDEA\bin\idea64.exe.v</span><br><span class="line">moptions -Xbootclasspath/a:F:\Program Files\intellij IDEA\lib\boot.jar -Didea.paths.selector=IntelliJIdea2016.2 -Didea.jre.check=true -XX:ErrorFile=C:\Users\zhongyp\java_error_in_idea_%p.log -XX:HeapDumpPath=C:\Users\zhongyp\java_error_in_idea.hprof</span><br><span class="line">1900 Launcher -Xmx700m -Djava.awt.headless=true -Djava.endorsed.dirs=&quot;&quot; -Djdt.compiler.useSingleThread=true -Dpreload.project.path=E:/demo -Dpreload.config.path=C:/Users/zhongyp/.IntelliJIdea2016.2/config/options -Dcompile.parallel=false -Drebuild.on.dependency.change=true -Djava.net.preferIPv4Stack=true</span><br><span class="line"> -Dio.netty.initialSeedUniquifier=-1505227146882843300 -Dfile.encoding=GBK -Djps.file.types.component.name=FileTypeManager -Duser.language=zh -Duser.country=CN -Didea.paths.selector=IntelliJIdea2016.2 -Didea.home.path=F:\Program Files\intellij IDEA -Didea.config.path=C:\Users\zhongyp\.IntelliJIdea2016.2\</span><br><span class="line">config -Didea.plugins.path=C:\Users\zhongyp\.IntelliJIdea2016.2\config\plugins -Djps.log.dir=C:/Users/zhongyp/.IntelliJIdea2016.2/system/log/build-log -Djps.fallback.jdk.home=C:/Program Files/Java/jdk1.8.0_161/jre -Djps.fallback.jdk.version=1.8.0_161 -Djava.io.tmpdir=C:/Users/zhongyp/.IntelliJIdea2016.2/</span><br><span class="line">system/compile-server/_temp_ -Dkotlin.incremental.compilation.experimental=true -Dkotlin.daemon.enabled -Dkotlin.daemon.cli</span><br></pre></td></tr></table></figure><p>-q 只输出LVMID，省略主类的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -q</span><br><span class="line">5696</span><br><span class="line">8912</span><br><span class="line">944</span><br><span class="line">4488</span><br><span class="line">1900</span><br></pre></td></tr></table></figure><p>-m 输出虚拟机进程启动时传递给主类main()函数的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">5696 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">10484 Jps -m</span><br><span class="line">4488</span><br><span class="line">1900 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/intel</span><br><span class="line">lij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/id</span><br><span class="line">ea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.ja</span><br><span class="line">r;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br></pre></td></tr></table></figure><h3 id="2-2-jstat"><a href="#2-2-jstat" class="headerlink" title="2.2 jstat"></a>2.2 jstat</h3><p> 虚拟机统计信息监视工具，用于监视虚拟机各种运行状态信息的命令。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾回收、JIT编译等运行数据。运行期定位虚拟机性能问题的首选工具。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-class：监视类装载、卸载数量、总空间以及类装载所耗时间。</span><br><span class="line"></span><br><span class="line">-gc：监视JAVA堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间，GC已用时间合计等信息；</span><br><span class="line"></span><br><span class="line">-gccapacity：监视内容与-gc基本相同，但输出主要关注 java堆各个区域使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcutil：监视内容与-gc基本相同，便输出主要关注已使用空间占总空间的百分比；</span><br><span class="line"></span><br><span class="line">-gccause：与-gcutil功能一样，但是会额外输出导致 一次GC产生的原因；</span><br><span class="line"></span><br><span class="line">-gcnew：监视新生代GC状态；</span><br><span class="line"></span><br><span class="line">-gcnewcapacity：监视内容与-gcnew基本相同，输出最要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcold：监视老年代GC状况；</span><br><span class="line"></span><br><span class="line">-gcoldcapacity：监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcpermcapacity：监视永久代使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-compiler：输入JIT编译器编译过的方法，耗时等信息；</span><br><span class="line"></span><br><span class="line">-printcompilation：输出已经被JIT编译的方法；</span><br></pre></td></tr></table></figure><h3 id="2-3-jinfo"><a href="#2-3-jinfo" class="headerlink" title="2.3 jinfo"></a>2.3 jinfo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-flag &lt;name&gt; ：可查看虚拟机启动时显式指定的参数列表。</span><br><span class="line">-flag [+|-]&lt;name&gt;：设置或取消VM参数</span><br><span class="line">-flag &lt;name&gt;=&lt;value&gt;：给VM参数设置新值</span><br><span class="line">-flags：可查看所有VM参数；</span><br><span class="line">-sysprops：查看java系统参数;</span><br><span class="line">&lt;no option&gt;：表示在不给定任何选项时，打印出以上所有的VM参数</span><br></pre></td></tr></table></figure><p> 实时的查看和调整虚拟机的各项参数。</p><h3 id="2-4-jmap"><a href="#2-4-jmap" class="headerlink" title="2.4 jmap"></a>2.4 jmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-dump：生成java堆转储快照，格式为：-dump[live, ] format=b, file=&lt;filename&gt;,其中live子参数说明是否只dump出存活对象；</span><br><span class="line"></span><br><span class="line">-finalizerinfo：显示在F-QueuiK 等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-heap：显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-histo：显示堆中对象统计信息，包括类、实例数量、合计容量；</span><br><span class="line"></span><br><span class="line">-permstat：以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台有效；</span><br><span class="line"></span><br><span class="line">-F：当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，只在Linux/Solaris平台有效</span><br></pre></td></tr></table></figure><p> Java内存映像工具。用于生成堆转储快照，还可以查询finalize()执行队列，Java堆和永久代的详细信息，如空间使用率、当前使用的哪种收集器等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jmap -dump:format=b,file=D:\test.bin 2768</span><br><span class="line">Dumping heap to D:\test.bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h3 id="2-5-jhat"><a href="#2-5-jhat" class="headerlink" title="2.5 jhat"></a>2.5 jhat</h3><p><code>jhat D:\test.bin</code></p><p> 分析jmap生成的堆转储快照，在浏览器查看。</p><h3 id="2-6-jstack"><a href="#2-6-jstack" class="headerlink" title="2.6 jstack"></a>2.6 jstack</h3><p> 用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合，生成快照的目的是定位线程出现长时间停顿的原因。</p><p>-F    当正常输出的请求不被响应时，强制输出线程堆栈</p><p>-l    除堆栈外，显示关于锁的附加信息</p><p>-m    如果调用到本地方法的话，可以显示c/c++的堆栈</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">//        Thread t1 = new Worker(1);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        t1.start();</span><br><span class="line">        final A a = new A();</span><br><span class="line">        final B b = new B();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                a.getBLock(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                b.getALock(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getBLock(B b)&#123;</span><br><span class="line"></span><br><span class="line">        b.getALock(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getALock(A a)&#123;</span><br><span class="line">        a.getBLock(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">1904 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">11540 Jps -m</span><br><span class="line">13204 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/inte</span><br><span class="line">llij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/i</span><br><span class="line">dea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.j</span><br><span class="line">ar;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br><span class="line">4488</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jstack -F 1904</span><br><span class="line">Attaching to process ID 1904, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.161-b12</span><br><span class="line">Deadlock Detection:</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193ce108 (Object@0x00000000d6129700, a com/zhongyp/B),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193cb878 (Object@0x00000000d6127d20, a com/zhongyp/A),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line"></span><br><span class="line">Found a total of 1 deadlock.</span><br><span class="line"></span><br><span class="line">Thread 1: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 18: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=0, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=2, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$2.run() @bci=18, line=38 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 17: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=0, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=2, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$1.run() @bci=18, line=26 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 16: (state = IN_NATIVE)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.accept0(int, java.net.InetSocketAddress[]) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.socketAccept(java.net.SocketImpl) @bci=37, line=131 (Interpreted frame)</span><br><span class="line"> - java.net.AbstractPlainSocketImpl.accept(java.net.SocketImpl) @bci=7, line=409 (Interpreted frame)</span><br><span class="line"> - java.net.PlainSocketImpl.accept(java.net.SocketImpl) @bci=42, line=199 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.implAccept(java.net.Socket) @bci=60, line=545 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.accept() @bci=48, line=513 (Interpreted frame)</span><br><span class="line"> - com.intellij.rt.execution.application.AppMain$1.run() @bci=13, line=79 (Interpreted frame)</span><br><span class="line"> - java.lang.Thread.run() @bci=11, line=748 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 10: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 9: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 8: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 7: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.Object.wait() @bci=2, line=502 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference.tryHandlePending(boolean) @bci=54, line=191 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference$ReferenceHandler.run() @bci=1, line=153 (Interpreted frame)</span><br></pre></td></tr></table></figure><h2 id="3-JDK可视化工具"><a href="#3-JDK可视化工具" class="headerlink" title="3. JDK可视化工具"></a>3. JDK可视化工具</h2><p>JConsole: Java监视与管理控制台。基于JMX的可视化监视和管理工具。监视Java堆和永久代的的变化趋势。</p><p>VisualVM: 多合一故障处理工具。</p><h2 id="4-JVM调优案例"><a href="#4-JVM调优案例" class="headerlink" title="4. JVM调优案例"></a>4. JVM调优案例</h2><h3 id="4-1-高性能硬件上的程序部署策略"><a href="#4-1-高性能硬件上的程序部署策略" class="headerlink" title="4.1 高性能硬件上的程序部署策略"></a>4.1 高性能硬件上的程序部署策略</h3><p>使用64位JDK大内存。</p><p>问题：1.内存回收导致长时间停顿。2.64位JDK的性能测试结果普遍低于32位JDK。3.需要保证程序足够稳定，这种应用如果产生堆溢出几乎就无法产生堆转储快照。4. 相同程序64位JDK中消耗内存一般比32位大，这是由于指针膨胀和数据类型对其补白导致的。</p><p>使用若干个32位虚拟机建立逻辑集群来利用集群资源。</p><p>问题：1.尽量避免节点竞争全局资源，如并发写操作导致IO异常。2.很难高效率的利用某些资源池，比如连接池，导致一些节点满了，其他的还为零。3.各个节点仍然不可避免的受到32位的限制（2GB）。4.大量使用本地缓存的应用，改为集中式的缓存。</p><h3 id="4-2-集群间同步导致内存溢出"><a href="#4-2-集群间同步导致内存溢出" class="headerlink" title="4.2 集群间同步导致内存溢出"></a>4.2 集群间同步导致内存溢出</h3><h3 id="4-3-堆外内存导致的溢出错误"><a href="#4-3-堆外内存导致的溢出错误" class="headerlink" title="4.3 堆外内存导致的溢出错误"></a>4.3 堆外内存导致的溢出错误</h3><h3 id="4-4-外部命令导致系统缓慢"><a href="#4-4-外部命令导致系统缓慢" class="headerlink" title="4.4 外部命令导致系统缓慢"></a>4.4 外部命令导致系统缓慢</h3><h2 id="5-java内存模型和线程"><a href="#5-java内存模型和线程" class="headerlink" title="5. java内存模型和线程"></a>5. java内存模型和线程</h2><h3 id="5-1-java内存模型"><a href="#5-1-java内存模型" class="headerlink" title="5.1 java内存模型"></a>5.1 java内存模型</h3><h4 id="5-1-1-主内存和工作内存"><a href="#5-1-1-主内存和工作内存" class="headerlink" title="5.1.1 主内存和工作内存"></a>5.1.1 主内存和工作内存</h4><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p><p>注： 这里说的变量包括了实例变量、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有，不会被共享，自然就不存在竞争问题。</p><h2 id="6-线程安全与锁优化"><a href="#6-线程安全与锁优化" class="headerlink" title="6. 线程安全与锁优化"></a>6. 线程安全与锁优化</h2><p>线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象时线程安全的。</p><h3 id="6-1-线程安全的实现方法"><a href="#6-1-线程安全的实现方法" class="headerlink" title="6.1 线程安全的实现方法"></a>6.1 线程安全的实现方法</h3><h4 id="6-1-1-互斥同步（阻塞同步）"><a href="#6-1-1-互斥同步（阻塞同步）" class="headerlink" title="6.1.1 互斥同步（阻塞同步）"></a>6.1.1 互斥同步（阻塞同步）</h4><p>悲观锁。</p><p>sychronized 和 ReentrantLock。</p><h4 id="6-1-2-非阻塞同步"><a href="#6-1-2-非阻塞同步" class="headerlink" title="6.1.2 非阻塞同步"></a>6.1.2 非阻塞同步</h4><p>乐观锁，CAS。</p><p>AtomicInteger等</p><h4 id="6-1-3-无同步方案"><a href="#6-1-3-无同步方案" class="headerlink" title="6.1.3 无同步方案"></a>6.1.3 无同步方案</h4><ul><li><p>可重入代码：可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。判断代码是否具备可重入性：如果一个方法，他的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求。</p></li><li><p>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？ThreadLocal（不共享）。volatile(共享)。</p></li></ul><h3 id="6-2-锁优化"><a href="#6-2-锁优化" class="headerlink" title="6.2 锁优化"></a>6.2 锁优化</h3><h4 id="6-2-1-自旋锁和自适应锁"><a href="#6-2-1-自旋锁和自适应锁" class="headerlink" title="6.2.1 自旋锁和自适应锁"></a>6.2.1 自旋锁和自适应锁</h4><h4 id="6-2-2-锁消除"><a href="#6-2-2-锁消除" class="headerlink" title="6.2.2 锁消除"></a>6.2.2 锁消除</h4><h4 id="6-2-3-锁粗化"><a href="#6-2-3-锁粗化" class="headerlink" title="6.2.3 锁粗化"></a>6.2.3 锁粗化</h4><h4 id="6-2-4-轻量级锁"><a href="#6-2-4-轻量级锁" class="headerlink" title="6.2.4 轻量级锁"></a>6.2.4 轻量级锁</h4><h4 id="6-2-5-偏向锁"><a href="#6-2-5-偏向锁" class="headerlink" title="6.2.5 偏向锁"></a>6.2.5 偏向锁</h4><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-JVM的自动内存管理机制&quot;&gt;&lt;a href=&quot;#1-JVM的自动内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;1. JVM的自动内存管理机制&quot;&gt;&lt;/a&gt;1. JVM的自动内存管理机制&lt;/h2&gt;&lt;h3 id=&quot;1-1-运行时数据区域&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://zhongyp.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线程简介</title>
    <link href="http://zhongyp.me/2018/03/16/concurrent/2017-03-16-thread-brief/"/>
    <id>http://zhongyp.me/2018/03/16/concurrent/2017-03-16-thread-brief/</id>
    <published>2018-03-15T16:00:00.000Z</published>
    <updated>2018-12-04T11:05:36.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h3><p>现代操作系统在运行程序时，会为其创建一个进程。比如你现在用的浏览器，系统就会为其创建一个甚至多个进程。<strong><em>引入进程的目的是为了更好的使操作系统并发执行程序。来提高资源利用率和系统吞吐量，增加并发程度。</em></strong><br>线程是现代操作系统调度的基本单元，是运行在进程上下文中的逻辑流，是程序执行流的最小单元，也叫轻量级进程（Light Weight Process），也可以称之为CPU的执行单元。一个程序作为一个进程来运行，程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行一个处理器核心上。<strong><em>引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。线程不拥有系统资源（代码，数据、堆、共享库、文件），只拥有运行中必不可少的资源（线程ID, 栈，栈指针，程序计数器、通用目的寄存器和条件码）。</em></strong><br>线程是调度的抽象。<strong><em>Java中将线程的执行和执行对象抽象开来，JDK包中执行的有Thread类，Executor框架，可执行目标有Runaable，Callable。</em></strong></p><h4 id="1-1-线程的优点"><a href="#1-1-线程的优点" class="headerlink" title="1.1 线程的优点"></a>1.1 线程的优点</h4><ol><li>多处理器使用： 提高资源利用率和系统吞吐量。</li></ol><h4 id="1-2-线程的风险"><a href="#1-2-线程的风险" class="headerlink" title="1.2 线程的风险"></a>1.2 线程的风险</h4><ol><li>安全风险：对于共享变量的访问、操作容易造成安全风险。</li><li>活跃度风险：死锁引发活动度失败。</li><li>性能风险：线程之间频繁调度导致上下文切换导致巨大的系统开销。</li></ol><h3 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2. 线程的状态"></a>2. 线程的状态</h3><p><img src="/media/ThreadStatus.png" alt="ThreadStatus"><br><a href="#线程简介">图片来自：Java并发编程的艺术-</a></p><ul><li>新建(NEW)：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（READY）。</li></ul><p><strong><em>注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</em></strong></p><ul><li><p>运行状态(RUNNABLE)：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行中”。</p></li><li><p>就绪(READY)：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。</p></li><li><p>运行(RUNNING)：处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>等待状态(WAITING)：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程作出一些特定动作（通知或中断）。</p></li><li><p>超时等待状态(TIME_WAITING)：该状态不同于WAITING，它是可以在指定的时间自行返回的。</p></li><li><p>阻塞(BLOCKED)：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a>关于BLOCKED的描述：Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.翻译：阻塞线程是等待获取同步监视器锁的线程。线程等待获取同步监视器锁进入同步代码块/方法,或者调用Object.wait方法后,被唤醒后等待获取同步监视器锁,<strong><em>重入</em></strong>同步代码块/方法。</p></li><li><p>死亡(DEAD)：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ul><h3 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3. 线程优先级"></a>3. 线程优先级</h3><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。</p><p><strong><em>注：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</em></strong></p><h3 id="4-Daemon线程"><a href="#4-Daemon线程" class="headerlink" title="4. Daemon线程"></a>4. Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用做程序中后台调度及支持性工作。<br><strong><em> 注意：构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</em></strong></p><p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</span><br><span class="line">• Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">    * 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line">    * 该方法必须在启动线程前调用。</span><br><span class="line">    * 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。</span><br><span class="line">    * 这可能抛出 SecurityException（在当前线程中）。   </span><br><span class="line">    *   参数：</span><br><span class="line">    *      on - 如果为 true，则将该线程标记为守护线程。    </span><br><span class="line">    *   抛出：    </span><br><span class="line">    *     IllegalThreadStateException - 如果该线程处于活动状态。    </span><br><span class="line">    *     SecurityException - 如果当前线程无法修改该线程。</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">public final void setDaemon(boolean on)</span><br></pre></td></tr></table></figure><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p><a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">Java多线程详解</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程（1）-读Thread类源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程简介&quot;&gt;&lt;a href=&quot;#线程简介&quot; class=&quot;headerlink&quot; title=&quot;线程简介&quot;&gt;&lt;/a&gt;线程简介&lt;/h2&gt;&lt;h3 id=&quot;1-什么是线程&quot;&gt;&lt;a href=&quot;#1-什么是线程&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>经典面试题整理</title>
    <link href="http://zhongyp.me/2018/03/02/interfaceview/2018-03-02-Classic-Interview-Questions/"/>
    <id>http://zhongyp.me/2018/03/02/interfaceview/2018-03-02-Classic-Interview-Questions/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-10-02T01:27:53.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="corejava"><a href="#corejava" class="headerlink" title="corejava"></a>corejava</h2><ol><li><p>hashcode 相等两个类一定相等么？equals呢？相反呢？</p></li><li><p>介绍一下集合框架</p></li><li><p>hashmap hashtable 底层实现什么区别？hashtale和concurrenthashmap呢？</p></li><li><p>hashmap和treemap 什么区别？底层数据结构呢？</p></li><li><p>线程池用过么？都有什么参数？底层如何实现的？</p></li><li><p>sychnized和Lock什么区别？sychnize什么情况是对象锁，什么时候是全局锁？为什么？</p></li><li><p>ThreadLocal 是什么？底层如何实现？写一个例子？</p></li><li><p>volitile的工作原理？</p></li><li><p>cas知道么？如何实现的？</p></li><li><p>请用至少四种写法？写一个单例模式？</p></li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol><li><p>请介绍一下JVM内存模型？用过什么垃圾回收器，都说说？</p></li><li><p>线上发送频繁full gc如何处理？CPU使用率过高怎么办？如何定位问题？如何解决？说一下解决思路和处理方法。</p></li><li><p>知道字节码么？字节码都有那些？Integer * 5,int y=5, 比较x==y 都经过那些步骤？</p></li><li><p>讲讲类加载机制？都有哪些类加载器，这些类加载器都加载哪些文件？手写一下类加载Demo</p></li><li><p>知道osgi么？他是如何实现的？</p></li><li><p>请问你做过哪些JVM优化？使用什么方法？达到什么效果？</p></li></ol><ol start="7"><li>class.forName(“java.lang.String”)和String.class.getClassLoader.loadClass(“java.lang.String”)什么区别？</li></ol><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol><li><p>spring都有哪些机制？AOP底层如何实现的？IOC？</p></li><li><p>cglib知道么？它和JDK动态代理有什么区别？手写一个jdk动态代理？</p></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li><p>使用mysql索引都有哪些原则？索引什么数据结构？B+tree和B tree什么区别？</p></li><li><p>mysql有哪些存储引擎啊？都有啥区别？要详细？</p></li><li><p>设计高并发系统数据库层面该怎么设计？数据库锁有哪些类型？如何实现？</p></li><li><p>数据库事务有哪些？</p></li></ol><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ol><li><p>如何设计可以动态扩容缩容的分库分表方案？</p></li><li><p>用过哪些分库分表的中间件，有啥优点和缺点，讲一下你了解的分库分表中间件的底层实现原理。</p></li><li><p>我现在有一个未分库分表的系统，以后系统需要分库分表，如何设计，让未分库分表的系统动态切换到分库分表系统上？</p></li><li><p>分布式事务知道么？ 你们怎么解决的？ TCC?那若出现网络原因，网络连不通怎么办啊？</p></li><li><p>为什么分库分表？</p></li><li><p>分布式寻址方式都有哪些算法？知道一致hash么？手写一下Java实现代码？你若userId取模分片，那我要查一段连续时间里的数据怎么办？</p></li><li><p>如何解决分库分表主键问题？有什么实现方案？</p></li></ol><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><ol><li><p>redis和memched 什么区别？为什么单线程的redis比多线程的memched效率要高？</p></li><li><p>redis有什么数据类型？都在哪些场景下使用？</p></li><li><p>redis的主从复制是怎么实现的？redis的集群模式是如何实现的呢？redis的key是如何寻址的？</p></li><li><p>使用redis如何设计分布式锁？使用zk可以么？如何实现？这两种哪个效率更高？</p></li><li><p>知道redis的持久化么？有什么优点和缺点？具体底层实现呢？</p></li><li><p>redis过期策略都有哪些？LRU？写一下Java版本代码？</p></li></ol><h2 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h2><ol><li><p>说一下dubbo的实现过程，注册中心挂了可以继续通信么？</p></li><li><p>zk原理知道么？zk都可以干什么？paxos算法知道么？说一下原理和实现？</p></li><li><p>dubbo支持哪些序列化协议？hessian？说一下hessian的数据结构？PB知道么？为啥PB效率是最高的？</p></li><li><p>知道netty么？netty可以干嘛？NIO,BIO,AIO都是什么啊？有什么区别？</p></li><li><p>dubbo复制均衡策略和高可用策略都有哪些？动态代理策略呢？</p></li><li><p>为什么要进行系统拆分啊？拆分不用dubbo可以么？dubbo和thrift什么区别啊？</p></li></ol><h2 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h2><ol><li><p>为什么使用消息队列？消息队列有什么优点和缺点？</p></li><li><p>如何保证消息队列的高可用？如何保证消息不被重复消费？</p></li><li><p>kafka，activemq，rabbitmq，rocketmq都有什么优点和缺点？</p></li><li><p>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路？</p></li></ol><h2 id="分布式搜索引擎"><a href="#分布式搜索引擎" class="headerlink" title="分布式搜索引擎"></a>分布式搜索引擎</h2><ol><li><p>es的工作过程实现是如何的？如何实现分布式的啊？</p></li><li><p>es在数据量很大的情况下，如何提高查询效率？</p></li><li><p>es的查询是一个怎么的工作过程？底层的lucence介绍一下？倒排索引知道么？es和mongodb什么区别？都在什么场景下使用？</p></li></ol><h2 id="高并发高可用架构设计"><a href="#高并发高可用架构设计" class="headerlink" title="高并发高可用架构设计"></a>高并发高可用架构设计</h2><ol><li><p>如何设计一个高并发高可用系统？</p></li><li><p>如何限流？工程中怎么做的，说一下具体实现？</p></li><li><p>缓存如何使用的？缓存使用不会造成什么后果？</p></li><li><p>如何熔断？熔断框架都有哪些？具体实现原理知道么？</p></li><li><p>如何降级？ 如何进行系统拆分？如何数据库拆分？</p></li></ol><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><ol><li><p>说一下TCP/IP 四层？</p></li><li><p>http的工作流程？ http1.0 http1.1 http2.0具体哪些区别？</p></li><li><p>TCP三次握手，四层分手的工作流程？画一下流程图？为什么不是四次五次或者两次？</p></li><li><p>画一下https的工作流程？具体如何实现？如何防止被抓包？</p></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>45亿阿拉伯数字，如何进行去重？如何找出最大的那个数？</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>二叉树和红黑树</li></ol><p><a href="https://www.jianshu.com/p/a07d1d4004b0" target="_blank" rel="noopener">博文推荐</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;corejava&quot;&gt;&lt;a href=&quot;#corejava&quot; class=&quot;headerlink&quot; title=&quot;corejava&quot;&gt;&lt;/a&gt;corejava&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;hashcode 相等两个类一定相等么？equals呢？相反呢？&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhongyp.me/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://zhongyp.me/2018/01/04/concurrent/2018-03-04-JavaMemModel/"/>
    <id>http://zhongyp.me/2018/01/04/concurrent/2018-03-04-JavaMemModel/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-12-07T05:51:07.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型（简称：JMM），下文中如果没有特殊说明，JMM即代表“Java内存模型”。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在并发编程模型中，需要处理两个关键的问题：线程之间以何种机制交换信息（通信）及如何控制不同线程之间操作发生相对顺序的机制（同步）。<br>线程之间的通信机制有两种：共享内存和消息传递。<br>共享内存模型：线程之间通过读-写内存中的公共状态进行隐式通信。<br>消息传递模型：线程之间没有公共状态，线程之间必须通过发送消息来显示的进行通信。<br><strong><em>Java并发采用的是共享内存模型</em></strong>。<br>注：<br>同步：指程序中用于控制不同线程间操作发生相对顺序的机制，意味着某种形式的原子性或者互斥。<br>共享内存的并发模型中，同步是显式，程序员必须显示的指定某个方法或某段代码需要在线程之间互斥执行。消息传递的并发模型中，消息的发送必须在消息的接收之前，因此同步是隐式的。</p><h2 id="2-JMM的设计"><a href="#2-JMM的设计" class="headerlink" title="2. JMM的设计"></a>2. JMM的设计</h2><h3 id="2-1-Java内存模型的抽象结构"><a href="#2-1-Java内存模型的抽象结构" class="headerlink" title="2.1 Java内存模型的抽象结构"></a>2.1 Java内存模型的抽象结构</h3><p><img src="/media/jvm-1.8.png" alt="jmm抽象结构"><br>对于上图各个模块不太理解的可以看下<a href="https://zhongyp.me/2018/03/27/jvm/2018-03-27-JVM/">JVM</a>，里面有对各个模块的讲解。<br>Java线程之间的通信是由Java内存模型（Java Memory Model,简称：JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。JMM通过控制主内存与每个线程的本地内存之间的交互，提供内存可见性保证。JMM属于语言级别的内存模型，确保在不同的编译和不同处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，提供内存可见性保证。</p><h3 id="2-2-缓存一致性问题"><a href="#2-2-缓存一致性问题" class="headerlink" title="2.2 缓存一致性问题"></a>2.2 缓存一致性问题</h3><p>在JMM模型中，对象驻留在共享内存中，每个线程具有一个私有的内存工作区，其中存放着该线程已读/已写的域的cache拷贝。在没有显示同步的情况下，对一个域执行了写操作的线程可能没有将它的更新立即传送到内存中；对一个域执行读操作的线程，当内存中的域的值发生改变时，其相应的内存工作区可能还没有被修改。JVM不保持这种cache的一致性。</p><p>举个简单的例子：在java中，执行下面这个语句：</p><p><code>i  = 10++;</code></p><p>1) 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p><p>2) 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p><p>3) 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</p><p>4) 最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p><p>为了解决缓存一致性问题，需要各个处理器访问缓存时遵循一些协议（MSI、MESI、MOSI、Synapse等），在读写时要根据协议进行操作。<br><img src="/media/cache-consistency.png" alt="resort"><br>图片来自：<a href="#指令序列的重排序">《深入理解Java虚拟机》</a></p><h3 id="2-3-指令序列的重排序"><a href="#2-3-指令序列的重排序" class="headerlink" title="2.3 指令序列的重排序"></a>2.3 指令序列的重排序</h3><p>除了上述的缓存一致性问题外，在执行程序时，为了提高程序的性能，使得处理器内部的运算单元被充分利用，编译器和处理器常常会对指令做重排序。重排序也会导致多线程同步的问题。<br>重排序分类：</p><ol><li>编译器重排序。编译器不改变单线程语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级重排序。现代处理器采用指令级并行技术将多条指令重叠执行。<strong><em>如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</em></strong></li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>注：<br>数据依赖性：编译器和处理器不会改变存在数据以来关系的两个操作的执行顺序。数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。<br>as-if-serial：不管如何的重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p><img src="/media/resort.png" alt="resort"></p><p>图中的1、2、3重排序可能会导致多线程的内存可见性问题。这与现代处理器使用写缓冲区有关。我们知道cpu处理和内存读写的处理速度差距太大，为了减少cpu等待读/写内存产生的延迟，cpu使用了写缓存区。写缓冲区可以保证指令流水线持续运行，通过批处理的方式刷新写缓冲，以及合并写缓冲中对同一内存地址的多次写，减少对内存总线的占用。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这段代码用来校验cpu对内存的读/写操作，不一定与内存实际发生的读/写顺序一致。</span><br><span class="line"> */</span><br><span class="line">    //初始状态 a=b=0</span><br><span class="line">  </span><br><span class="line">    //线程1</span><br><span class="line">        a = 1; // A1</span><br><span class="line">        x = b; // A2</span><br><span class="line">   </span><br><span class="line">    // 线程2</span><br><span class="line">        b=2; // B1</span><br><span class="line">        y=a; // B2</span><br></pre></td></tr></table></figure></p><p>这个程序的结果是不确定的，有可能是x=y=0。线程1和线程2同时把共享变量a、b写入自己的写缓冲区，然后从内存中读取另一个共享变量a、b的值复制给x、y，最后再把所有的数据刷入内存。这种情况下x=y=0。<br><img src="/media/cpustore.png" alt="cpu-mem"><br>上述这种情况就是重排序对多线程的影响。</p><h3 id="2-4-happens-before"><a href="#2-4-happens-before" class="headerlink" title="2.4 happens-before"></a>2.4 happens-before</h3><p>Java虚拟机试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，且能够有足够的自由空间区利用硬件的各种特性来获取个好的执行速度，从JDK5开始，Java使用JSR-133内存模型。JSR-133使用happens-before概念保证内存的可见性。另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p><p>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ol><li><p><strong><em>程序次序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</em></strong></p></li><li><p><strong><em>监视器锁规则：一个unLock操作先行发生于后面对同一个锁的lock操作。</em></strong></p></li><li><p><strong><em>volatile变量规则：对一个volatile变量的写操作，happens-before于后续对这个volatile变量的读操作。</em></strong></p></li><li><p><strong><em>传递规则：如果操作A happens-before操作B，而操作B happens-before操作C，则可以得出操作A happens-before操作C。</em></strong></p></li><li><p>start()规则：Thread对象的start()方法happens-before此线程的每个一个动作</p></li><li><p>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p></li></ol><p>对于程序次序规则来说，就是一段程序代码的执行在单个线程中<strong><em>看起来</em></strong>是有序的。程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在<strong><em>单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</em></strong><br>注意：<strong><em>两个操作之间具有的happens-before关系，并不是意味着前一个操作必须在后一个操作之前执行，仅仅要求前一个操作执行结果对后一个操作可见。</em></strong></p><p><img src="/media/happens-before-design.png" alt="happens-before-design"><br>JMM设计图，图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><h2 id="JMM总结"><a href="#JMM总结" class="headerlink" title="JMM总结"></a>JMM总结</h2><p>JMM在设计上考虑两个关键因素：</p><ol><li>要为程序员提供足够强的内存可见性保证。</li><li>对编译器和处理器的限制尽可能的放松，提高程序的运行性能，同时解决重排序导致的多线程同步问题。<br>总的来说JMM在设计上完成了如下的结果：</li></ol><ul><li>单线程程序。<strong><em>单线程程序不会出现内存可见性问题。</em></strong>编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li>正确<strong><em>同步</em></strong>的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。<strong><em>JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。（这句话解决了本文中的两个问题，缓存一致性与重排序引起的多线程同步问题，我会在<a href="https://zhongyp.me/2018/12/06/concurrent/2018-12-06-thread-communication/">线程通信</a>的共享变量小节中讲解缓存一致性的解决方案，在<a href="https://zhongyp.me/2018/12/06/concurrent/2018-12-06-thread-security/">线程安全</a>一章中讲解重排序引起的多线程同步问题的解决方案）</em></strong></li><li>未同步/未正确同步的多线程程序。JMM为他们提供最小的安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么时默认值（0、null、false）。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://www.importnew.com/24082.html" target="_blank" rel="noopener">你真的了解volatile关键字吗？</a></p><p><a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">Java中Volatile关键字详解</a></p><p><a href="">Java并发编程艺术</a></p><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;p&gt;Java内存模型（简称：JMM），下文中如果没有特殊说明，JMM即代表“Java内存模型”。
      
    
    </summary>
    
    
      <category term="并发" scheme="http://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>旅行</title>
    <link href="http://zhongyp.me/2017/07/05/life/2017-7-5-Journey/"/>
    <id>http://zhongyp.me/2017/07/05/life/2017-7-5-Journey/</id>
    <published>2017-07-04T16:00:00.000Z</published>
    <updated>2018-10-27T03:29:27.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>旅行让我能望得辽远，想得细密，理解人生的遗憾，与这世界的好处。</p><h2 id="生活的城市"><a href="#生活的城市" class="headerlink" title="生活的城市"></a>生活的城市</h2><ul><li><p><a href="#滕州2013-9">滕州（~2013-9）</a></p></li><li><p><a href="#烟台2013-92016-7">烟台（2013-9~2016-7）</a></p></li><li><p><a href="#北京2016-7">北京（2016-7~）</a></p></li></ul><h2 id="那些值得纪念的地方"><a href="#那些值得纪念的地方" class="headerlink" title="那些值得纪念的地方"></a>那些值得纪念的地方</h2><ul><li><p><a href="#日照2010-8">日照（2010-8）</a></p></li><li><p><a href="#廊坊2012-7">廊坊（2012-7）</a></p></li><li><p><a href="#蓬莱2013-10">蓬莱（2013-10）</a></p></li><li><p><a href="#威海2015-10">威海（2015-10）</a></p></li><li><p><a href="#长岛2017-5">长岛（2017-5）</a></p></li><li><p><a href="#乌兰布统2017-7">乌兰布统（2017-7）</a></p></li></ul><h3 id="生活的城市-1"><a href="#生活的城市-1" class="headerlink" title="生活的城市"></a>生活的城市</h3><h3 id="滕州（-2013-9）"><a href="#滕州（-2013-9）" class="headerlink" title="滕州（~2013-9）"></a>滕州（~2013-9）</h3><h3 id="烟台（2013-9-2016-7）"><a href="#烟台（2013-9-2016-7）" class="headerlink" title="烟台（2013-9~2016-7）"></a>烟台（2013-9~2016-7）</h3><p>大学四年（其实只呆过三年）生活的地方。四年也没去过多少地方，大都时间都在瞎忙，等过了最闲暇的时光，才知道自己错过太多。</p><h3 id="北京（2016-7-）"><a href="#北京（2016-7-）" class="headerlink" title="北京（2016-7~）"></a>北京（2016-7~）</h3><h3 id="那些值得纪念的地方-1"><a href="#那些值得纪念的地方-1" class="headerlink" title="那些值得纪念的地方"></a>那些值得纪念的地方</h3><h3 id="日照（2010-8）"><a href="#日照（2010-8）" class="headerlink" title="日照（2010-8）"></a>日照（2010-8）</h3><h3 id="廊坊（2012-7）"><a href="#廊坊（2012-7）" class="headerlink" title="廊坊（2012-7）"></a>廊坊（2012-7）</h3><h3 id="蓬莱（2013-10）"><a href="#蓬莱（2013-10）" class="headerlink" title="蓬莱（2013-10）"></a>蓬莱（2013-10）</h3><h3 id="威海（2015-10）"><a href="#威海（2015-10）" class="headerlink" title="威海（2015-10）"></a>威海（2015-10）</h3><h3 id="长岛（2017-5）"><a href="#长岛（2017-5）" class="headerlink" title="长岛（2017-5）"></a>长岛（2017-5）</h3><h3 id="乌兰布统（2017-7）"><a href="#乌兰布统（2017-7）" class="headerlink" title="乌兰布统（2017-7）"></a>乌兰布统（2017-7）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;旅行&quot;&gt;&lt;a href=&quot;#旅行&quot; class=&quot;headerlink&quot; title=&quot;旅行&quot;&gt;&lt;/a&gt;旅行&lt;/h2&gt;&lt;p&gt;旅行让我能望得辽远，想得细密，理解人生的遗憾，与这世界的好处。&lt;/p&gt;
&lt;h2 id=&quot;生活的城市&quot;&gt;&lt;a href=&quot;#生活的城市&quot; cl
      
    
    </summary>
    
    
      <category term="生活" scheme="http://zhongyp.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>2017书单</title>
    <link href="http://zhongyp.me/2017/01/01/life/2017-1-1-books/"/>
    <id>http://zhongyp.me/2017/01/01/life/2017-1-1-books/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2018-10-27T03:29:23.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="书架"><a href="#书架" class="headerlink" title="书架"></a>书架</h2><p>–2017书单</p><h2 id="greate-minds：source"><a href="#greate-minds：source" class="headerlink" title="greate minds：source"></a>greate minds：<a href="https://github.com/camda/mybook/tree/master/minds" target="_blank" rel="noopener">source</a></h2><pre><code>+ 深入浅出设计模式+ 人月神话+ 代码整洁之道+ 程序员修炼之道+ 编程之美：微软技术面试心得+ 编程珠玑+ 编程珠玑（续）+ 设计模式+ Java程序员修炼之道+ 算法导论3</code></pre><h2 id="java：source"><a href="#java：source" class="headerlink" title="java：source"></a>java：<a href="https://github.com/camda/mybook/tree/master/java" target="_blank" rel="noopener">source</a></h2><pre><code>+ Java_TCPIP_Socket网络编程</code></pre><h2 id="smart：source"><a href="#smart：source" class="headerlink" title="smart：source"></a>smart：<a href="https://github.com/camda/mybook/tree/master/smart" target="_blank" rel="noopener">source</a></h2><pre><code>+ 周志华-机器学习+ 周志华-数据挖掘与机器学习</code></pre><h2 id="framework：source"><a href="#framework：source" class="headerlink" title="framework：source"></a>framework：<a href="https://github.com/camda/mybook/tree/master/framework" target="_blank" rel="noopener">source</a></h2><pre><code>+ Hibernate开发指南+ SpringGuide+ Spring源码深度解析+ dubbo源码解析2.0+ ZooKeeper</code></pre><h2 id="other-source"><a href="#other-source" class="headerlink" title="other: source"></a>other: <a href="https://github.com/camda/mybook/tree/master/other" target="_blank" rel="noopener">source</a></h2><pre><code>+ 产品经理手册+ 经济学原理+ 你要如何衡量你的人生+ 牛津通识精选+ 三体2 黑暗森林+ 手把手教你读财报+ More Effective C++</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;书架&quot;&gt;&lt;a href=&quot;#书架&quot; class=&quot;headerlink&quot; title=&quot;书架&quot;&gt;&lt;/a&gt;书架&lt;/h2&gt;&lt;p&gt;–2017书单&lt;/p&gt;
&lt;h2 id=&quot;greate-minds：source&quot;&gt;&lt;a href=&quot;#greate-minds：source
      
    
    </summary>
    
    
      <category term="书单" scheme="http://zhongyp.me/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
</feed>
