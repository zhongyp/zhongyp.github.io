<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhongyp&#39;blog</title>
  
  <subtitle>钟宇鹏的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhongyp.me/"/>
  <updated>2019-11-13T13:23:01.981Z</updated>
  <id>https://zhongyp.me/</id>
  
  <author>
    <name>zhongyp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Redis 空间使用的思考</title>
    <link href="https://zhongyp.me/redis/2019-11-13-redis-space-optimization/"/>
    <id>https://zhongyp.me/redis/2019-11-13-redis-space-optimization/</id>
    <published>2019-11-12T16:00:00.000Z</published>
    <updated>2019-11-13T13:23:01.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的存储优化"><a href="#Redis的存储优化" class="headerlink" title="Redis的存储优化"></a>Redis的存储优化</h2><p>我们项目使用Redis越来越多，可是Redis毕竟是基于内存的数据库，所以对于Redis的空间使用如果不加注意，很容易导致内存溢出。这里对于Redis存储优化的考虑主要考虑Redis数据结构和基于Redis内存模型上的优化。</p><h3 id="1-Redis数据结构"><a href="#1-Redis数据结构" class="headerlink" title="1. Redis数据结构"></a>1. Redis数据结构</h3><p>Redis使用了五种数据对象：字符串对象，列表对象，哈希对象，集合对象，有序集合对象。</p><p>Redis基于这五种对象也给出了优化：</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串中有int、embstr和raw（Simple Dynamic String）两种存储字符串的结构。如果只读且大小小于32字节，则使用embstr，否则使用raw，embstr只能转化为raw，raw不能转化为embstr。关于两者的区别详细了解<a href="/redis/2019-06-21-redis/#1-8-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1">Redis设计与实现</a></p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的底层数据结构在3.2版本之前可以是链表（linkedlist），也可以是压缩列表（ziplist），对于链表保存不需要连续的内存空间（是优点也是缺点，容易造成内存碎片），相比于压缩列表多了保存pre、next指针的空间，ziplist保存在连续内存空间上，不需要维护pre、next指针。当保存的字符串长度小于64字节且列表对象个数小于512时使用压缩列表。</p><p>在3.2版本之后唯一的数据结构是快表（quicklist），它是一个双向链表，而且是一个ziplist的双向链表。这是什么意思呢？我们知道，双向链表是由多个节点（Node）组成的。这个描述的意思是：quicklist的每个节点都是一个ziplist。</p><p>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</p><p>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象底层数据结构可以是ziplist和字典hashtable。ziplist存储字符串不超过32字节和总个数不超过512的数据。</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象底层数据结构是intset或者hashtable。</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合对象底层数据结构是ziplist或者是skiplist。当存储的字符串长度大于64时转为skiplist。<br>skiplist存储时使用skiplist和hashtabl两种结构进行存储，如果我们只是用字典hashtable来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p><p>需要注意的是<strong><em>字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p>使用上述对象时，需要考虑底层数据结构特性，是否会因为频繁删除增加修改，造成Redis的内存碎片化，频繁修改的数据不建议放入到Redis。不仅如此，考虑到Redis空间的复用性，对于不常用的key设置过期时间。</p><h3 id="2-Redis存储优化"><a href="#2-Redis存储优化" class="headerlink" title="2. Redis存储优化"></a>2. Redis存储优化</h3><p>本章节摘自《<a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a>》</p><ol><li><p>利用Redis内存分配器做第一层优化。例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p></li><li><p>尽量使用整型/长整型。如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。</p></li><li><p>利用共享对象，共享对象包括10000个整数，可以通过REDIS_SHARED_INTEGERS参数提高共享对象的个数。</p></li><li><p>关注内存碎片率，如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。</p></li><li><p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p></li><li><p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a></p><p><a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a></p><p><a href="/redis/2019-06-21-redis/#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8%E5%AD%98%E5%82%A8%E6%95%88%E7%8E%87">quicklist存储效率</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis的存储优化&quot;&gt;&lt;a href=&quot;#Redis的存储优化&quot; class=&quot;headerlink&quot; title=&quot;Redis的存储优化&quot;&gt;&lt;/a&gt;Redis的存储优化&lt;/h2&gt;&lt;p&gt;我们项目使用Redis越来越多，可是Redis毕竟是基于内存的数据库，所以对
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://zhongyp.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://zhongyp.me/concurrency/2019-11-07-threadpool/"/>
    <id>https://zhongyp.me/concurrency/2019-11-07-threadpool/</id>
    <published>2019-11-06T16:00:00.000Z</published>
    <updated>2019-11-13T13:24:54.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在生产环境中，应避免直接创建线程，线程数量必须得到控制。</p></blockquote><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>为了控制线程，JDK类库提供了一套Executor框架。</p><p><img src="/media/article/executor.png" alt="executor"></p><p>线程池是JDK用来管理线程的的静态工厂。上图中ThreadPoolExecutor表示一个线程池。<br>Executor是一个接口，接口中只有<code>void execute(Runnable command)</code>方法。<br>ExecutorService也是一个接口，继承ExecutorService，增加了许多使用线程池的公用方法定义。<br>AbstactExecutorService为ExecutorService接口提供了默认实现。<br>ThreadPoolExecutor继承AbstactExecutorService抽象类。<br>Executors类是JDK1.5版本时封装的线程池工厂和工具类，这个类提供了几种默认的<a href="/concurrency/2019-11-07-threadpool/#1-2-Executor%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90">线程池类型</a>和默认线程池工厂。</p><h3 id="1-1-创建线程池"><a href="#1-1-创建线程池" class="headerlink" title="1.1 创建线程池"></a>1.1 创建线程池</h3><p>创建线程池的实现其实是实例化ThreadPoolExecutor的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>corePoolSize：指定线程池中的线程数量。<br>maximumPoolSize：线程池中的最大线程数量。<br>keepAliveTime：当线程池超过corePoolSize时，多余的空闲线程的空闲时间。<br>unit：keepAliveTime的时间单位。<br>workQueue：任务队列，被提交但未被执行的任务。<br>threadFactory工厂：创建线程的工厂，一般默认就可以。<br>handler：拒绝策略，当线程池满负荷运行，如何拒绝新的任务的策略。</p><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>keepAliveTime，unit，threadFactory几个参数可根据线程池的任务场景去做简单的变化，在此不再赘述，一般自定义线程池我们的关注点大都在corePoolSize，maximumPoolSize，workQueue，handler四个参数上。</p><p>corePoolSize，根据业务的通用场景确定即可。《Java并发编程实践》书中给出了一个估算线程池corePoolSize大小的经验公式：<br>Ncpu=cpu数量<br>Ucpu=希望cpu的使用率，0&lt;Ucpu&lt;1<br>W/C=等待时间与计算时间的比率， <a href="https://www.cnblogs.com/gatsby123/p/11127158.html" target="_blank" rel="noopener">CPU计算时间计算方式</a></p><p><code>Nthreads=Ncpu*Ucpu*(1+W/C)</code></p><p>如果你处理的是阻塞比较多的任务，你可以根据上述公式大致算出需要的线程数量（一般会远远超出当前实例所在服务器的cpu数量）；如果是阻塞比较少的任务即cpu计算比重较大的任务，线程的数量可能就会相应的减少一些，避免服务器的超负荷运行。总之线程数不是精确的一个数，只要符合你业务的场景的大概数量就可以。</p><p>workQueue任务队列分为有限、无限、同步移交三种阻塞队列，常用的有如下几个：</p><ul><li>ArrayBlockingQueue: 一个基于数组结构的有界阻塞队列，此队列按照FIFO原则排序。</li><li>LinkedBlockingQueue: 一个基于链表的阻塞队列，此队列按照FIFO原则排序，吞吐量高于ArrayBlockingQueue。</li><li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须阻塞到另一个线程的移除操作。</li><li>PriorityBlockingQueue: 具有优先级的无限阻塞队列。</li></ul><p>线程池的执行过程：</p><p><img alt="threadpool-processor" src="/media/article/threadpool-processor.png" width="75%"></p><p>–图摘自《Java并发编程艺术》9.1小节-线程池的实现原理。</p><p>队列的大小和maxmumPoolSize息息相关，如果使用无界队列，则maxmumPoolSize也就失效了，如果使用的是有界队列，则当有界队列满了，则新启动线程执行任务。直到最大线程也满了之后执行拒绝策略。</p><p>最后就是拒绝策略:</p><ul><li>AbortPolicy: 直接抛出异常。</li><li>CallerRunPolicy: 使用调用者的线程执行任务。</li><li>DiscardOldestPolicy: 丢弃队列里最老的任务，并执行当前任务。</li><li>DiscardPolicy: 不处理，不丢弃。</li></ul><p>除此之外还可以实现RejectExecutionHandler接口，自定义拒绝策略。</p><h3 id="1-2-Executor提供的几种类型的线程池解析"><a href="#1-2-Executor提供的几种类型的线程池解析" class="headerlink" title="1.2 Executor提供的几种类型的线程池解析"></a>1.2 Executor提供的几种类型的线程池解析</h3><ol><li>Executors.newFixedThreadPool(1);</li></ol><p>Executors.newFixedThreadPool创建的线程池可以指定核心线程数，但是使用的是无界队列，如果是IO密集型任务，可能导致内存溢出。</p><ol start="2"><li>Executors.newSingleThreadExecutor();</li></ol><p>Executors.newSingleThreadExecutor()创建一个线程的线程池，同样使用无界队列，和newFixedThreadPool的差别仅限于核心线程数。</p><ol start="3"><li>Executors.newCachedThreadPool();</li></ol><p>Executors.newCachedThreadPool()创建的线程池是一个没有队列的存储任务的线程池，线程池最大数量为Integer.MAX_VALUE。所以这个线程池会一直创建新的线程执行任务，可能导致内存溢出。适用于中小数量级的任务，且任务非CPU密集型。</p><ol start="4"><li>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory());</li></ol><p>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory())创建可以定时或延时执行任务的线程池，与Timer相比，具有更多的弹性。<a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-add1.html" target="_blank" rel="noopener">详解Java定时任务—极客学院</a></p><ol start="5"><li>Executors.newWorkStealingPool();</li></ol><p>封装的ForkJoinPool线程池，线程数量为当前运行环境的cpu数量，不处理异常，异步模式。下一小节详细介绍。</p><h3 id="1-3-ForkJoinPool线程池初探"><a href="#1-3-ForkJoinPool线程池初探" class="headerlink" title="1.3 ForkJoinPool线程池初探"></a>1.3 ForkJoinPool线程池初探</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成小任务，最终汇总小任务结果后得到大任务结果的框架。</p><p><img src="/media/article/forkjoin.png" alt="forkjoin"></p><p>–图片摘自《Java并发编程的艺术》6.4.1 什么是Fork/Join框架 小节。</p><p>缺点：在某些情况下，该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。</p><h4 id="使用ForkJoinPool"><a href="#使用ForkJoinPool" class="headerlink" title="使用ForkJoinPool"></a>使用ForkJoinPool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private static final int THRESHOLD = 2;  // 阈值 private int start;</span><br><span class="line">private int end;</span><br><span class="line">public CountTask(int start, int end) &#123;</span><br><span class="line">    this.start = start; this.end = end;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected Integer compute() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    // 如果任务足够小就计算任务</span><br><span class="line">    boolean canCompute = (end - start) &lt;= THRESHOLD; </span><br><span class="line">    if (canCompute) &#123;</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">         sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">        int middle = (start + end) / 2;</span><br><span class="line">        CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end); // 执行子任务</span><br><span class="line">        leftTask.fork();</span><br><span class="line">        rightTask.fork();</span><br><span class="line">        // 等待子任务执行完，并得到其结果</span><br><span class="line">        int leftResult=leftTask.join();</span><br><span class="line">        int rightResult=rightTask.join();</span><br><span class="line">        // 合并子任务</span><br><span class="line">        sum = leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">    // 生成一个计算任务，负责计算1+2+3+4</span><br><span class="line">    CountTask task = new CountTask(1, 4);</span><br><span class="line">    // 执行一个任务</span><br><span class="line">    Future&lt;Integer&gt; result = forkJoinPool.submit(task); </span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–示例摘自《Java并发编程的艺术》6.4.4 使用Fork/Join框架 小节。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>ForkJoinTask提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被 取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(task.isCompletedAbnormally()) &#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h4 id="使用原理"><a href="#使用原理" class="headerlink" title="使用原理"></a>使用原理</h4><p>ForkJoinPool继承AbstractExecutorService。</p><p>ForkJoinPool参数：</p><ul><li>parallelism线程数量；</li><li>ForkJoinWorkerThreadFactory是ForkJoin线程工厂，创建ForkJoinWorkerThread的线程类实例；</li><li>mode是使用FIFO模式（true）还是LIFO模式（false）；</li><li>UncaughtExceptionHandler是异常处理；</li><li>workerNamePrefix工作线程的名称前缀；</li></ul><p>通常来说，我们使用ForkJoinPool时如果不指定线程数量时默认取2047和当前服务器cpu数量中的最小值。简单来说就是创建了一个fork/join线程的线程池。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">Effective Java 第二版 中文版 </a><br><a href="">实战Java高并发程序设计 葛一鸣，郭超编著</a><br><a href="">Java并发编程艺术 方腾飞，魏鹏，程晓明 著</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在生产环境中，应避免直接创建线程，线程数量必须得到控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-线程池&quot;&gt;&lt;a href=&quot;#1-线程池&quot; class=&quot;headerlink&quot; title=&quot;1. 线程池&quot;&gt;&lt;/a&gt;1. 线程池&lt;
      
    
    </summary>
    
    
      <category term="并发" scheme="https://zhongyp.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="https://zhongyp.me/utils/2019-11-02-docker-command/"/>
    <id>https://zhongyp.me/utils/2019-11-02-docker-command/</id>
    <published>2019-11-01T16:00:00.000Z</published>
    <updated>2019-11-12T06:32:13.574Z</updated>
    
    <content type="html"><![CDATA[<p><code>docker -images</code> 查看本地镜像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;docker -images&lt;/code&gt; 查看本地镜像。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Utils" scheme="https://zhongyp.me/tags/Utils/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB浅析</title>
    <link href="https://zhongyp.me/java/2019-10-04-cglib/"/>
    <id>https://zhongyp.me/java/2019-10-04-cglib/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-11-13T13:27:57.595Z</updated>
    
    <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><p>本文打算从这几个方面来理解CGLIB怎样生成动态代理类的：</p><ol><li><a href="#1-使用Cglib动态代理">怎样使用CGLIB？</a></li><li><a href="#2-CGLIB原理解析">CGLIB怎样生成/缓存动态代理类实例的？</a></li><li><a href="#3-CGLIB代理类调用方法原理解析">CGLIB生成的动态代理类怎样调用的，过程是怎样的，这样有什么好处？</a></li><li>常见问题<a href="#FAQ">FAQ</a></li></ol><h2 id="1-使用Cglib动态代理"><a href="#1-使用Cglib动态代理" class="headerlink" title="1. 使用Cglib动态代理"></a>1. 使用Cglib动态代理</h2><p>CGLIB的使用和JDK Proxy类似，不同的是CGLIB既可以指定接口，也可以直接代理未实现接口的普通类。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">LogInterceptor logInterceptor = new LogInterceptor();</span><br><span class="line">// 设置超类，cglib是通过继承来实现的</span><br><span class="line">enhancer.setSuperclass(UserDao.class);</span><br><span class="line">enhancer.setCallback(logInterceptor);</span><br><span class="line">/**</span><br><span class="line"> * 如果是实现指定接口，可以使用setInterfaces方法设置接口</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// enhancer.setInterfaces(new Class[]&#123;Dao.class&#125;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果使用createClass方法返回值为代理类的Class对象，需要设置CallbackType参数；当使用create方法时，CallbackType和callback都不为空时，两者类型必须相等。</span><br><span class="line"> * create方法返回的是代理类实例</span><br><span class="line"> * enhancer.setCallbackType(LogInterceptor.class);</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 创建代理类</span><br><span class="line">Dao dao = (Dao)enhancer.create();</span><br><span class="line">dao.select();</span><br></pre></td></tr></table></figure></p><p>// 方法拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">//        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">//        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>// 实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao implements Dao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-CGLIB生成动态代理类的原理解析"><a href="#2-CGLIB生成动态代理类的原理解析" class="headerlink" title="2. CGLIB生成动态代理类的原理解析"></a>2. CGLIB生成动态代理类的原理解析</h2><p>CGLIB，JDK proxy生成过程上大同小异，都是使用弱引用缓存已生成的Class对象，如果缓存中没有，则使用字节码技术生成动态代理类字节码和Class对象，只不过使用的字节码技术不太一样罢了。<br>下图是CGLIB动态代理生成代理类Class对象的流程：<a href="/media/article/cglib-processor.png">点击看大图</a></p><p><img src="/media/article/cglib-processor.png"></p><p>CGLIB动态代理基于ASM技术，使用<a href="/java/2019-10-06-asm/">ASM</a>技术的部分就是图中标红的模块。</p><p>CGLIB动态代理如果没有特殊设置也会缓存已生成的动态代理类的Class对象。</p><p><img src="/media/article/cglib-cache.png" alt="cglib-cache"></p><p>上图是CGLIB缓存动态代理类的Class对象的结构。</p><p>CGLIB第一次生成动态代理类Class对象的方法调用流程：</p><p><img src="/media/article/cglib-method.png" alt="cglib-method"></p><h2 id="3-CGLIB代理类调用方法原理解析"><a href="#3-CGLIB代理类调用方法原理解析" class="headerlink" title="3. CGLIB代理类调用方法原理解析"></a>3. CGLIB代理类调用方法原理解析</h2><blockquote><p>使用<code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;./&quot;)</code>可以输出生成的代理类的class文件。这里由于篇幅问题，只展示文章需要的内容，想看完整的代理类的字节码文件可以自己输出查看。</p></blockquote><p>CGLIB针对一个目标类一般会生成3个动态代理类，1个<code>UserDao$$EnhancerByCGLIB$$c00e2e9b extends UserDao implements Factory</code>，还有2个和调用有关的FastClass代理类<code>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc extends FastClass</code>，<code>UserDao$$FastClassByCGLIB$$890e5f18 extends FastClass</code></p><p>UserDao$$EnhancerByCGLIB$$c00e2e9b类的静态初始化块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 当前线程的缓存</span><br><span class="line">CGLIB$THREAD_CALLBACKS = new ThreadLocal();</span><br><span class="line">// 空参数对象</span><br><span class="line">CGLIB$emptyArgs = new Object[0];</span><br><span class="line">// 动态代理类的Class对象</span><br><span class="line">Class var0 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao$$EnhancerByCGLIB$$c00e2e9b&quot;);</span><br><span class="line">Class var1;</span><br><span class="line">// 只获取update和select的方法对象</span><br><span class="line">Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;update&quot;, &quot;()V&quot;, &quot;select&quot;, &quot;()V&quot;&#125;, (var1 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao&quot;)).getDeclaredMethods());</span><br><span class="line">CGLIB$update$0$Method = var10000[0];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$update$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;update&quot;, &quot;CGLIB$update$0&quot;);</span><br><span class="line">CGLIB$select$1$Method = var10000[1];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$select$1$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;select&quot;, &quot;CGLIB$select$1&quot;);</span><br></pre></td></tr></table></figure><p>当动态代理类调用update()方法（update是DAO接口内的方法）时，首先调用下面这个动态生成的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * cglib使用Class对象创建对象实例(Enhancer.nextNewInstance())的时候，会反射调用CGLIB$SET_THREAD_CALLBACKS方法，将MethodInterceptor实例缓存在CGLIB$THREAD_CALLBACKS这个代理类的的ThreadLocal中，然后初始化动态代理类实例时，调用CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">public final void update() &#123;</span><br><span class="line">   // 初始化动态代理类实例时，已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">   MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">       CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">       var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (var10000 != null) &#123;</span><br><span class="line">       var10000.intercept(this, CGLIB$update$0$Method, CGLIB$emptyArgs, CGLIB$update$0$Proxy);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       super.update();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">   UserDao$$EnhancerByCGLIB$$c00e2e9b var1 = (UserDao$$EnhancerByCGLIB$$c00e2e9b)var0;</span><br><span class="line">   if (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">       var1.CGLIB$BOUND = true;</span><br><span class="line">       Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">       if (var10000 == null) &#123;</span><br><span class="line">           var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">           if (CGLIB$STATIC_CALLBACKS == null) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 也就是说，初始化动态代理类实例时，最后如果var1.CGLIB$BOUND = true，则说明已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">       var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在调用到了MethodInterceptor的intercept方法了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">   // methodProxy.invokeSuper</span><br><span class="line">   Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>methodProxy，还记得动态代理类的static代码块么，在那时就已经初始化好了methodProxy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) &#123;</span><br><span class="line">   MethodProxy proxy = new MethodProxy();</span><br><span class="line">   // 使用Signature对象封装方法名和返回值</span><br><span class="line">   proxy.sig1 = new Signature(name1, desc);</span><br><span class="line">   proxy.sig2 = new Signature(name2, desc);</span><br><span class="line">   // 将UserDAO和UserDAO的动态代理类的Class文件放入CreateInfo对象</span><br><span class="line">   proxy.createInfo = new MethodProxy.CreateInfo(c1, c2);</span><br><span class="line">   return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了知道methodProxy怎么来的，继续往下走，invokeSuper():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       this.init();</span><br><span class="line">       MethodProxy.FastClassInfo fci = this.fastClassInfo;</span><br><span class="line">       // 这里调用的实际是FastClass代理类中的invoke方法</span><br><span class="line">       return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">   &#125; catch (InvocationTargetException var4) &#123;</span><br><span class="line">       throw var4.getTargetException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void init() &#123;</span><br><span class="line">   if (this.fastClassInfo == null) &#123;</span><br><span class="line">       Object var1 = this.initLock;</span><br><span class="line">       synchronized(this.initLock) &#123;</span><br><span class="line">           if (this.fastClassInfo == null) &#123;</span><br><span class="line">               MethodProxy.CreateInfo ci = this.createInfo;</span><br><span class="line">               MethodProxy.FastClassInfo fci = new MethodProxy.FastClassInfo();</span><br><span class="line">               // UserDAO和UserDAO的代理类分别有自己的FastClassInfo，分别使用个字的ClassInfo生成FastClass代理类</span><br><span class="line">               // 生成UserDAO的FastClass代理类</span><br><span class="line">               fci.f1 = helper(ci, ci.c1);</span><br><span class="line">               // 生成UserDAO代理类的FastClass代理类</span><br><span class="line">               fci.f2 = helper(ci, ci.c2);</span><br><span class="line">               // 生成方法索引</span><br><span class="line">               fci.i1 = fci.f1.getIndex(this.sig1);</span><br><span class="line">               fci.i2 = fci.f2.getIndex(this.sig2);</span><br><span class="line">               this.fastClassInfo = fci;</span><br><span class="line">               this.createInfo = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据索引调用方法，fci.i2的值为12，调用索引12的方法。<br>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc动态代理类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123;</span><br><span class="line">   c00e2e9b var10000 = (c00e2e9b)var2;</span><br><span class="line">   int var10001 = var1;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">       switch(var10001) &#123;</span><br><span class="line">       case 0:</span><br><span class="line">           return new Boolean(var10000.equals(var3[0]));</span><br><span class="line">       case 1:</span><br><span class="line">           return var10000.toString();</span><br><span class="line">       case 2:</span><br><span class="line">           return new Integer(var10000.hashCode());</span><br><span class="line">       case 3:</span><br><span class="line">           return var10000.clone();</span><br><span class="line">       case 4:</span><br><span class="line">           var10000.update();</span><br><span class="line">           return null;</span><br><span class="line">       case 5:</span><br><span class="line">           return var10000.newInstance((Class[])var3[0], (Object[])var3[1], (Callback[])var3[2]);</span><br><span class="line">       case 6:</span><br><span class="line">           return var10000.newInstance((Callback)var3[0]);</span><br><span class="line">       case 7:</span><br><span class="line">           return var10000.newInstance((Callback[])var3[0]);</span><br><span class="line">       case 8:</span><br><span class="line">           var10000.select();</span><br><span class="line">           return null;</span><br><span class="line">       case 9:</span><br><span class="line">           var10000.setCallback(((Number)var3[0]).intValue(), (Callback)var3[1]);</span><br><span class="line">           return null;</span><br><span class="line">       case 10:</span><br><span class="line">           return c00e2e9b.CGLIB$findMethodProxy((Signature)var3[0]);</span><br><span class="line">       case 11:</span><br><span class="line">           c00e2e9b.CGLIB$STATICHOOK1();</span><br><span class="line">           return null;</span><br><span class="line">       case 12:</span><br><span class="line">           var10000.CGLIB$update$0();</span><br><span class="line">           return null;</span><br><span class="line">       case 13:</span><br><span class="line">           var10000.CGLIB$select$1();</span><br><span class="line">           return null;</span><br><span class="line">       case 14:</span><br><span class="line">           return new Boolean(var10000.CGLIB$equals$2(var3[0]));</span><br><span class="line">       case 15:</span><br><span class="line">           return var10000.CGLIB$toString$3();</span><br><span class="line">       case 16:</span><br><span class="line">           return new Integer(var10000.CGLIB$hashCode$4());</span><br><span class="line">       case 17:</span><br><span class="line">           return var10000.CGLIB$clone$5();</span><br><span class="line">       case 18:</span><br><span class="line">           var10000.setCallbacks((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 19:</span><br><span class="line">           c00e2e9b.CGLIB$SET_STATIC_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 20:</span><br><span class="line">           c00e2e9b.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 21:</span><br><span class="line">           return var10000.getCallback(((Number)var3[0]).intValue());</span><br><span class="line">       case 22:</span><br><span class="line">           return var10000.getCallbacks();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; catch (Throwable var4) &#123;</span><br><span class="line">       throw new InvocationTargetException(var4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问流程图：</p><p><img src="/media/article/cglib-invoke.png" alt="cglib-invoke"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是CGLIB还是JDK proxy都是为了控制对象的访问，但是怎样控制访问是CGLIB和JDK proxy思想上的最大区别，JDK proxy通过接口得到method对象后使用反射直接调用目标方法，CGLIB则是更复杂的多，CGLIB先是继承目标类，然后通过字节码技术生成代理方法（CGLIB$update$0）和update（上述例子中的方法，这里用来举例），然后通过方法代理（MethodProxy）和FastClass访问机制（通过方法名和返回值生成索引，调用时直接索引至目标方法）回调目标方法。</p><blockquote><p>TIPS:其实这里还有很多想说的，但是总也感觉表达的总是不是那么的到位，所以暂且先这样了，等着后续再继续完善。</p></blockquote><p>优点：</p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似CGLIB动态代理就没有这种限制。</li><li>只操作我们关心的类，不必为其他相关类增加工作量。</li><li>高性能，高性能体现方法的调用上，CGLIB的方法调用为FastClass机制，JDK Proxy为反射调用。</li></ul><h2 id="4-一些源码"><a href="#4-一些源码" class="headerlink" title="4. 一些源码"></a>4. 一些源码</h2><p>下面是一些比较核心的一些代码解析：</p><p>入口，AbstractGenerator中的create(key)方法，参数key=KeyFactory.newInstance()。KeyFactory也是CGLIB动态生成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 参数key是Enhancer.KeyFactory(superclassname)的实例，这个KeyFactory类也是cglib动态生成的，当你new Enhancer()时，Enhancer会动态的生成该实例对象，superclassname就是上面的UserDAO。</span><br><span class="line">protected Object create(Object key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ClassLoader loader = this.getClassLoader();</span><br><span class="line">        // CACHE时WeakHashMap 第一层缓存的容器</span><br><span class="line">        Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        // 第一层缓存 key是classLoader</span><br><span class="line">        AbstractClassGenerator.ClassLoaderData data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">        if (data == null) &#123;</span><br><span class="line">            Class var5 = AbstractClassGenerator.class;</span><br><span class="line">            // 加锁意义在于CACHE时静态变量，属于该类，不是该实例对象，所以线程安全需要加锁。</span><br><span class="line">            synchronized(AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">                if (data == null) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; newCache = new WeakHashMap(cache);</span><br><span class="line">                    // 创建第二层缓存容器</span><br><span class="line">                    data = new AbstractClassGenerator.ClassLoaderData(loader);</span><br><span class="line">                    // 将第二层缓存容器放入第一层容器内，key为classloader</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.key = key;</span><br><span class="line">        // 使用ClassLoaderData data获取Enhancer.EnhancerFactoryData对象，Enhancer.EnhancerFactoryData对象中是代理类的Class对象，也可以直接获取KeyFactory的Class对象</span><br><span class="line">        Object obj = data.get(this, this.getUseCache());</span><br><span class="line">        // firstInstance主要是针对KeyFactory生成的Class对象，例如接口方法生成的MethodWraper的代理类Class对象，nextInstance针对Enhancer实例生成的Enhancer.EnhancerFactoryData实例，实例中存储着真正的代理类的Class对象，如果生成的代理类中有接口方法，生成代理类时，会生成接口方法的MethodWrapper的代理类实例。</span><br><span class="line">        return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);</span><br><span class="line">    &#125; catch (Error | RuntimeException var9) &#123;</span><br><span class="line">        throw var9;</span><br><span class="line">    &#125; catch (Exception var10) &#123;</span><br><span class="line">        throw new CodeGenerationException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一级缓存中的value，ClassLoaderData的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoaderData(ClassLoader classLoader) &#123;</span><br><span class="line">  if (classLoader == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;classLoader == null is not yet supported&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // 首先用弱引用封装classLoader，垃圾回收时可以直接回收</span><br><span class="line">      this.classLoader = new WeakReference(classLoader);</span><br><span class="line">      Function&lt;AbstractClassGenerator, Object&gt; load = new Function&lt;AbstractClassGenerator, Object&gt;() &#123;</span><br><span class="line">          public Object apply(AbstractClassGenerator gen) &#123;</span><br><span class="line">              Class klass = gen.generate(ClassLoaderData.this);</span><br><span class="line">              // 这里需要注意gen是Enhancer实例，还是KeyFactory$Genertor实例，两者的wrapCachedClass完全不一样，使用的数据结构也不一样。Enhancer使用的数据结构是EnhancerFactoryData，KeyFactory$Genertor使用LoadingCache</span><br><span class="line">              return gen.wrapCachedClass(klass);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      // this.generatedClasses的key是KeyFactory根据superclassName生成的key实例，将load放入LoadingCache，等下如果LoadingCache的map获取代理类为null，需要回调这个load重新生成代理类</span><br><span class="line">      this.generatedClasses = new LoadingCache(GET_KEY, load);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二级缓存的对象LoadingCache中的核心方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// key是Enhancer实例，或者是KeyFactory$Generator实例</span><br><span class="line">public V get(K key) &#123;</span><br><span class="line">   KK cacheKey = this.keyMapper.apply(key);</span><br><span class="line">   Object v = this.map.get(cacheKey);</span><br><span class="line">   return v != null &amp;&amp; !(v instanceof FutureTask) ? v : this.createEntry(key, cacheKey, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected V createEntry(final K key, KK cacheKey, Object v) &#123;</span><br><span class="line">   boolean creator = false;</span><br><span class="line">   FutureTask task;</span><br><span class="line">   Object result;</span><br><span class="line">   if (v != null) &#123;</span><br><span class="line">       task = (FutureTask)v;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       task = new FutureTask(new Callable&lt;V&gt;() &#123;</span><br><span class="line">           public V call() throws Exception &#123;</span><br><span class="line">               // 回调AbstractGenerator.ClassLoaderData构造器中的load</span><br><span class="line">               return LoadingCache.this.loader.apply(key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 获取map中的value，如果是Enhancer.EnhancerFactoryData就直接返回，如果不是，继续往下获取Class对象</span><br><span class="line">       result = this.map.putIfAbsent(cacheKey, task);</span><br><span class="line">       // 如果等于null，需要重新生成</span><br><span class="line">       if (result == null) &#123;</span><br><span class="line">           creator = true;</span><br><span class="line">           task.run();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (!(result instanceof FutureTask)) &#123;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           task = (FutureTask)result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">       result = task.get();</span><br><span class="line">   &#125; catch (InterruptedException var9) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Interrupted while loading cache item&quot;, var9);</span><br><span class="line">   &#125; catch (ExecutionException var10) &#123;</span><br><span class="line">       Throwable cause = var10.getCause();</span><br><span class="line">       if (cause instanceof RuntimeException) &#123;</span><br><span class="line">           throw (RuntimeException)cause;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       throw new IllegalStateException(&quot;Unable to load cache item&quot;, cause);</span><br><span class="line">   &#125;</span><br><span class="line">   // 新建的Class对象或者Enhancer.EnhancerFactoryData需要存起来</span><br><span class="line">   if (creator) &#123;</span><br><span class="line">       this.map.put(cacheKey, result);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Enhancer中生成动态代理类的逻辑，使用了ASM技术：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public void generateClass(ClassVisitor v) throws Exception &#123;</span><br><span class="line">   Class sc = this.superclass == null ? Object.class : this.superclass;</span><br><span class="line">   if (TypeUtils.isFinal(sc.getModifiers())) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Cannot subclass final class &quot; + sc.getName());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">       this.filterConstructors(sc, constructors);</span><br><span class="line">       List actualMethods = new ArrayList();</span><br><span class="line">       List interfaceMethods = new ArrayList();</span><br><span class="line">       final Set forcePublic = new HashSet();</span><br><span class="line">       // 将接口中的方法获取放入到forcePublic中，获取的其实是KeyFactory生成的MethodWrapper实例 select,&#125;, void</span><br><span class="line">       // actualMethods是一个包含所有方法的数组，值类似public void com.zhongyp.advanced.proxy.cglib.UserDao.update()</span><br><span class="line">       getMethods(sc, this.interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line">       // 获取到所有的方法及访问标识</span><br><span class="line">       List methods = CollectionUtils.transform(actualMethods, new Transformer() &#123;</span><br><span class="line">           public Object transform(Object value) &#123;</span><br><span class="line">               Method method = (Method)value;</span><br><span class="line">               int modifiers = 16 | method.getModifiers() &amp; -1025 &amp; -257 &amp; -33;</span><br><span class="line">               if (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                   // 如果接口中有相同的方法，</span><br><span class="line">                   modifiers = modifiers &amp; -5 | 1;</span><br><span class="line">               &#125;</span><br><span class="line">               return ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 下面就是ASM的操作逻辑了</span><br><span class="line">       // 参数v是ClassVisitor</span><br><span class="line">       ClassEmitter e = new ClassEmitter(v);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), Type.getType(sc), this.useFactory ? TypeUtils.add(TypeUtils.getTypes(this.interfaces), FACTORY) : TypeUtils.getTypes(this.interfaces), &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), (Type)null, new Type[]&#123;FACTORY&#125;, &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       // 构造器信息</span><br><span class="line">       List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line">       e.declare_field(2, &quot;CGLIB$BOUND&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       e.declare_field(9, &quot;CGLIB$FACTORY_DATA&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (!this.interceptDuringConstruction) &#123;</span><br><span class="line">           e.declare_field(2, &quot;CGLIB$CONSTRUCTED&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(26, &quot;CGLIB$THREAD_CALLBACKS&quot;, THREAD_LOCAL, (Object)null);</span><br><span class="line">       e.declare_field(26, &quot;CGLIB$STATIC_CALLBACKS&quot;, CALLBACK_ARRAY, (Object)null);</span><br><span class="line">       if (this.serialVersionUID != null) &#123;</span><br><span class="line">           e.declare_field(26, &quot;serialVersionUID&quot;, Type.LONG_TYPE, this.serialVersionUID);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for(int i = 0; i &lt; this.callbackTypes.length; ++i) &#123;</span><br><span class="line">           e.declare_field(2, getCallbackField(i), this.callbackTypes[i], (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(10, &quot;CGLIB$CALLBACK_FILTER&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           this.emitMethods(e, methods, actualMethods);</span><br><span class="line">           this.emitConstructors(e, constructorInfo);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.emitDefaultConstructor(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       this.emitSetThreadCallbacks(e);</span><br><span class="line">       this.emitSetStaticCallbacks(e);</span><br><span class="line">       this.emitBindCallbacks(e);</span><br><span class="line">       if (this.useFactory || this.currentData != null) &#123;</span><br><span class="line">           int[] keys = this.getCallbackKeys();</span><br><span class="line">           this.emitNewInstanceCallbacks(e);</span><br><span class="line">           this.emitNewInstanceCallback(e);</span><br><span class="line">           this.emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">           this.emitGetCallback(e, keys);</span><br><span class="line">           this.emitSetCallback(e, keys);</span><br><span class="line">           this.emitGetCallbacks(e);</span><br><span class="line">           this.emitSetCallbacks(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.end_class();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>CGLIB针对final方法怎么处理的呢？</li></ol><p>不处理，因为继承了目标类，所以动态代理类实例可以直接调用目标类的final方法。</p><ol start="2"><li>CGLIB动态代理是通过字节码底层继承要代理类来实现，如果被代理类被final关键字所修饰，那么代理会失败么？</li></ol><p>代理不会失败，只会直接调用目标类的final方法。如update方法是final的，代理类不会做其他的处理，会直接调用UserDAO的update方法。   </p><ol start="3"><li>CGLIB到底比JDk Proxy快在哪里？</li></ol><p>测试环境JDK1.8，平台macOS Catalina。</p><p>一般意义上认为CGLIB在创建动态代理类比JDK Proxy慢，但是在方法调用上CGLIB比JDK Proxy快。<br>但是通过个人的测试，CGLIB在创建动态代理类确实比JDK Proxy慢一点，基本上CGLIB创建一个动态代理类实例需要30ms，JDK Proxy基本上也就10ms。<br>方法调用上100w次JDK proxy用时33233ms，CGLIB用时34259ms。两者差距并不是很明显。</p><ol start="4"><li>为什么CGLIB要使用fastclass机制？</li></ol><p>JDK之前的版本对于反射调用优化不是特别好，反射方法调用很慢，所以为了避免反射带来的性能消耗，采用fastclass机制，fastclass其实就是把需要需要调用的目标方法进行封装，获取到每个方法的索引值，调用时，通过调用方法获取索引值，直接调用到封装的目标方法。这种调用和直接调用性能差别不大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文承接自&lt;a href=&quot;/java/2019-09-09-java-proxy/&quot;&gt;动态代理浅析&lt;/a&gt;这篇文章，对代理没有什么概念的同学建议先读下这篇文章。&lt;/p&gt;
&lt;p&gt;本文打算从这几个方面来理解CGLIB怎样生成动态代理类的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理浅析</title>
    <link href="https://zhongyp.me/java/2019-10-04-jdk-proxy/"/>
    <id>https://zhongyp.me/java/2019-10-04-jdk-proxy/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-12T13:02:30.637Z</updated>
    
    <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><h2 id="1-使用JDK动态代理"><a href="#1-使用JDK动态代理" class="headerlink" title="1. 使用JDK动态代理"></a>1. 使用JDK动态代理</h2><p>JDK动态代理使用起来很简单，如下：</p><p>TestService是一个业务接口，接口中有个test方法， TestServiceImpl是TestService的实现类。<br>InvocationHandler是JDK动态代理的调用代理方法处理接口，我们JDK使用动态代理时需要实现这个接口，在这个接口的处理方法中编写处理逻辑，你想怎样控制目标方法的访问都可以在这个方法中实现。然后调用Proxy类的静态方法newProxyInstance方法即可获得到代理类实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        TestServiceImpl testService = new TestServiceImpl();</span><br><span class="line">        // 声明自己的处理类</span><br><span class="line">        MyInvokeHandler myInvokeHandler = new MyInvokeHandler(testService);</span><br><span class="line">        // 第一次生成代理类</span><br><span class="line">        TestService proxy = (TestService) Proxy.newProxyInstance(TestService.class.getClassLoader(),new Class[]&#123;TestService.class&#125;,myInvokeHandler);</span><br><span class="line">        // 代理类调用接口方法</span><br><span class="line">        proxy.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestServiceImpl implements TestService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;我要开始测试啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyInvokeHandler implements InvocationHandler&#123;</span><br><span class="line">    Object obj;</span><br><span class="line">    public MyInvokeHandler(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        //在反射调用之前，可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        method.invoke(obj,args);</span><br><span class="line">        //在反射调用之后，也可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface TestService&#123;</span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java通过<code>Proxy</code>类和<code>InvocationHandler</code>接口生成动态代理类<code>$Proxy0</code>。<code>Proxy</code>类是JDK生成动态代理的核心类，包含了JDK动态代理生成代理类的大部分逻辑。</p><!--![java-proxy](/media/article/java-proxy.001.png)--><h2 id="2-Java动态代理源码解析"><a href="#2-Java动态代理源码解析" class="headerlink" title="2. Java动态代理源码解析"></a>2. Java动态代理源码解析</h2><blockquote><p>Class对象每个类只有一个（同一个类加载器的情况下），该Class对象在类加载阶段生成，存储在内存中，非Java虚拟机堆，是该类对外访问的唯一入口。<a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-12.html#jls-12.4" target="_blank" rel="noopener">Java Language Specification 12.4</a></p></blockquote><p>Java生成动态代理类的核心方法是：ProxyClassFactory的<code>Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>。</p><p>参数：<code>ClassLoader loader</code>接口类加载器，<code>Class&lt;?&gt;[] interfaces</code>接口类的Class。</p><p>下面代码主要作用就是通过遍历接口数组，校验接口数组中的数据是否合法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 遍历接口类的Class数组</span><br><span class="line">  for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">      </span><br><span class="line">      Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          // 反射获得接口类Class对象</span><br><span class="line">          interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      // 校验是否是同一个类加载器，如果是不同的类加载器，生成的接口Class对象是不同的</span><br><span class="line">      if (interfaceClass != intf) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // Java动态代理仅支持接口代理</span><br><span class="line">      if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 使用Set来验证传入的接口数组中是否存在相同的接口</span><br><span class="line">      if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>下面这么多代码是为了给下面生成的代理类找到一个合理的包名和类名，如果接口数组中有非public属性的接口，如果此接口的包名不为null，则使用这个接口的包名，否则使用默认的<code>com.sun.proxy</code>包名，类名则是“上述包名+$Proxy+自增数字”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String proxyPkg = null;     </span><br><span class="line">int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">    int flags = intf.getModifiers();</span><br><span class="line">    if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">        accessFlags = Modifier.FINAL;</span><br><span class="line">        String name = intf.getName();</span><br><span class="line">        int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">        String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            proxyPkg = pkg;</span><br><span class="line">        &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (proxyPkg == null) &#123;</span><br><span class="line">    // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">    proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用自增数字区分不同的类</span><br><span class="line">long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br></pre></td></tr></table></figure><p>下面就是整个动态代理最核心的代码。生成代理类class文件的字节码，根据这个文件的字节码生成代理类的Class对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成字节数组，这个字节数组是生成的Class文件的字节数组，将这个字节流输出到class文件，就是上面的$Proxy0代理类。  </span><br><span class="line">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line"> proxyName, interfaces, accessFlags);</span><br><span class="line">try &#123;</span><br><span class="line"> // 通过刚才生成的代理类文件，生成代理类的Class对象。</span><br><span class="line"> return defineClass0(loader, proxyName,</span><br><span class="line">                     proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">&#125; catch (ClassFormatError e) &#123;</span><br><span class="line"> throw new IllegalArgumentException(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码仅仅是生成动态代理类的逻辑，不是JDK Proxy生成动态代理类实例的流程。</p><p>建议下面跟着源码一点点看如下的流程图。</p><p><img src="/media/article/weakcache.png" alt="weakcache"></p><p>第一个结构图是WeakCache的缓存结构图，WeakCache是Proxy的一个实例，每次去创建代理时，都会先去访问WeakCache，WeakCache中没有才会去创建。WeakCache采用两级缓存机制，第一层使用classloader生成的弱引用key，map实例valueMap的value在ConcurrentHashMap map中，valueMap是ConcurrentHasshMap， valueMap中使用接口数组（创建代理类传入的接口数组参数）生成的subKey，这个subKey不是弱引用，valueMap的value即可能是WeakCache.Factory实例，也可能是实现Supplier接口和继承WeakReference类的CacheValue实例。CacheValue用于封装动态生成的代理类的Class对象，WeakCache.Factory中包含生成动态代理类字节码和Class对象的逻辑，这个逻辑就是上面源码分析中的apply方法。<br>第二个是流程图，使用Proxy.newProxyInnstance生成动态代理类时，读取缓存的流程，结合着结构图和代码，应该可以理解JDK Proxy的整个缓存存储结构及读取流程。</p><p>生成的<code>$Proxy0</code>代理类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zhongyp.advanced.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">// 这个地方有两个接口，是因为我之前做测试的时候多加了一个TestService1接口。</span><br><span class="line">final class $Proxy0 extends Proxy implements TestService, TestService1 &#123;</span><br><span class="line"></span><br><span class="line">    // TestSerivce，TestService1两个接口总共就4个方法，test()，test1()，test3()，test4()，这里有7个方法，其中三个是hashCode，toString，equals。</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    private static Method m6;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m5;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 接口中的所有方法都会在代理类中生成，然后将代理类中的方法对象与方法名匹配放到InvocaotionHandler实现类实例的方法参数中</span><br><span class="line">    public final void test() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test3() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m4, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test4() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m6, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test1() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m5, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 动态代理在初始化是会初始化所有的方法对象</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m3 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test&quot;);</span><br><span class="line">            m4 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test3&quot;);</span><br><span class="line">            m6 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test4&quot;);</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m5 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test1&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于JDK动态代理的调用很简单，上面是我们上面的例子输出的动态代理类反编译的代码，我们看到接口中的每个方法<code>super.h.invoke(this, m5, (Object[])null)</code>，super就是Proxy，h是Proxy中的InvocationnHandler实例，InvocationHandler实例反射调用你的方法。InvocationHandler是在生成动态代理类的class对象后，创建动态代理类实例作为构造参数传进去的，所以虽然当前接口参数相同时，可能返回同一个动态代理类Class对象，但是只要InvocationHandler不同，他们就是不同的实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">    super(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/jdk-proxy-invoke.png" alt="jdk-proxy-invoke"></p><p>优点：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比cglib更加可靠。</li><li>平滑进行JDK版本升级，而字节码类库通常需要进行更新来保证在新版Java上能够使用。</li><li>代码实现简单。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>为什么JDK动态代理仅支持实现接口类的动态代理？</li></ol><p>这个问题我觉得可以从JDK做动态代理的初衷来说，JDK动态代理类是在运行时实现指定的接口列表的类，这个是JDK在设计实现动态代理最初就已经确定了的，所以可以看到在生成代理类的过程中，基本上就把接口类当作一个已知条件在使用，包括在定义缓存使用的subKey，代理类包名的生成规则中，反射获取Method对象等等地方，所以不存在为什么只支持实现接口类，而是JDK动态代理类的设计就是这样子的。</p><ol start="2"><li>为什么WeakCache采用两级缓存接口？</li></ol><p>这个问题我们可以从两个缓存的不同点来看，第一层缓存map是一个弱引用key，非弱引用valueMap，第二层缓存valueMap使用的是非弱引用subKey，弱引用CacheValue。我们都知道弱引用只要有垃圾回收时就会被回收，主要是为了防止缓存太多导致服务频繁的FullGC，所以第一层的作用就是当垃圾回收时，将缓存的valueMap全部清空。还有一个原因是第一层缓存使用的是classloader生成的key，所以map其实缓存的是所有当前同一个classloader生成的代理类的class对象。再说第二层缓存，第二层缓存使用的是创建代理类时传入的接口数组生成的subKey，这个是为了区分实现不同接口的动态代理类Class对象，如果说两个类都实现了同一个接口，那岂不是获取的同样的Class对象，这么说也是对的，区别在于实现的InvocationHandler接口的子类h不同，而这个h才是生成代理类实例的最终区别。第二层缓存为什么CacheValue使用弱引用，原因在于第一层缓存虽然key时弱引用，但是value不是，所以垃圾回收时只会回收key，不会回收value，value只会在下一次调用Proxy.newProxyInstance方法时才会去清空无效key的value。所以为了value能及时清空，所以CacheValue也使用了弱引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文承接自&lt;a href=&quot;/java/2019-09-09-java-proxy/&quot;&gt;动态代理浅析&lt;/a&gt;这篇文章，对代理没有什么概念的同学建议先读下这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;1-使用JDK动态代理&quot;&gt;&lt;a href=&quot;#1-使用JDK动态代理&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://zhongyp.me/java/2019-10-04-reflection/"/>
    <id>https://zhongyp.me/java/2019-10-04-reflection/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-22T17:11:01.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这种动态获取信息以及动态创建/调用对象方法的功能称为Java语言的反射机制。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以在运行时动态的确定类型并创建实例，可以调用实例中的任意方法即是方法时private的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>相比于编译时确定类型的方式，运行时确定类型创建实例会带来一定的性能消耗。</li><li>反射需要运行时的权限在安全管理器下运行时可能不存在。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。</li><li>由于反射允许代码执行非反射代码中非法的操作（例如访问私有字段和方法），因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射代码破坏了抽象，因此可能会随着平台的升级而改变行为。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><p>反射调用慢在哪里？</p></blockquote><p>相对于在编译时确定对象类型，反射是在运行时动态创建对象并确定对象类型，所以会比编译时确定对象类型多一些性能消耗即慢。<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  User user = new User();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在4.5ms左右</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  Class&lt;?&gt; clazz =  Class.forName(&quot;com.zhongyp.advanced.refect.User&quot;, true, ReflectDemo.class.getClassLoader());</span><br><span class="line">            User user = (User) clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在20ms左右</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;p&gt;在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AspectJ</title>
    <link href="https://zhongyp.me/java/2019-10-04-aspectj/"/>
    <id>https://zhongyp.me/java/2019-10-04-aspectj/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-22T17:16:13.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文引用自<a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p></blockquote><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><blockquote><p>AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言。当然，AspectJ需要使用额外的编译器。</p></blockquote><blockquote><p>AspectJ可以通过多种方式实现，包括源码织入或字节码织入，并且可以直接在虚拟机（VM）中实现。在所有情况下，AspectJ程序都将成为在Java VM中运行的有效Java程序。受切面影响的类与不受影响的类具有二进制兼容性（以保持与不受影响的原始文件编译的类兼容）。支持多种实现方式使该语言可以随着技术的变化而发展，并且与Java兼容可确保平台可用性。<br>AspectJ采用编译期织入和类加载期织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<br>使用AspectJ LTW有两个主要步骤，第一，通过JVM的-javaagent参数设置LTW的织入器类包，以代理JVM默认的类加载器；第二，LTW织入器需要一个aop.xml文件，在该文件中指定切面类和需要进行切面织入的目标类。</p></blockquote><blockquote><p>设置-javaagent JVM参数的方法:<br>(1)在Eclipse下的设置:<br>运行类-&gt;右键单击-&gt;Run As-&gt;Run…，可以在弹出的Run设置窗口设置该类的各项运行属性，切换到Arguments Tab页，在VM arguments中通过-javaagent指定AspectJ 织入器类包。<br>-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar<br>(2)在Tomcat下的设置<br>打开&lt;Tomcat_Home&gt;\bin\catalina.bat，在该批处理文件头部添加以下的设置：<br>set JAVA_OPTS=-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文引用自&lt;a href=&quot;https://www.iteye.com/blog/log-cd-562056&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AspectJ LTW(Load Time Weaving)&lt;/a&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>知识结构图</title>
    <link href="https://zhongyp.me/java/2019-09-29-knowledge-structure/"/>
    <id>https://zhongyp.me/java/2019-09-29-knowledge-structure/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2019-09-29T01:51:10.571Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/article/knowledge-structure.png" alt="knowledge-structure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/article/knowledge-structure.png&quot; alt=&quot;knowledge-structure&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>闲谈Java引用</title>
    <link href="https://zhongyp.me/java/2019-09-15-reference/"/>
    <id>https://zhongyp.me/java/2019-09-15-reference/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-23T11:33:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。</p><h2 id="1-强引用-StrongReference"><a href="#1-强引用-StrongReference" class="headerlink" title="1. 强引用(StrongReference)"></a>1. 强引用(StrongReference)</h2><p>Java中最常见的引用方式。当一个对象被一个或者一个以上的引用变量引用时，它处于激活状态，不可能被系统垃圾回收机制回收。</p><h2 id="2-软引用-SoftReference"><a href="#2-软引用-SoftReference" class="headerlink" title="2. 软引用(SoftReference)"></a>2. 软引用(SoftReference)</h2><p>软引用需要通过SoftRefrence类来实现，当一个对象只具有软引用时，可能被垃圾回收机制回收。当系统内存空间足够时，它不会被系统回收，当系统内存空间不够时，系统将会回收。</p><p>和弱引用的区别仅仅在于垃圾回收时， 是否根据空间大小回收的区别。</p><p>何时回收软引用的对象？</p><p>从1.3.1开始软可达对象将在最后被引用之后存活一段时间。默认值是堆中每MB空闲空间一秒的生存时间。这个值可以使用<code>-XX:SoftRefLRUPolicyMSPerMB</code>调整。<br>Java Hotspot服务端虚拟机使用最大可能的堆大小计算剩余可用空间。<br>Java Hotspot客户端虚拟机使用当前堆大小计算空闲空间。<br>这就意味着对于服务端虚拟机总体趋势是增长堆而不是清理软引用，因此在垃圾回收时<code>-Xmx</code>对软引用的回收有重要的影响。<br>相反，客户端虚拟机将很大趋势去清理软引用而不是增长堆。</p><p>上述行为对于1.3.1到Java SE 6版本的Java HotSpot VM都是正确的。但是，此行为不是VM规范的一部分，并且在将来的版本中可能会更改。同样，不保证-XX：SoftRefLRUPolicyMSPerMB标志在任何给定的发行版中均不存在。</p><p>在1.3.1版之前，Java HotSpot VM会在发现软引用时清除它们。</p><p>当我定期打开-verbose：gc时，我得到了很多完整的GC，已经调整了堆并且没有什么区别，这是怎么回事？</p><p>如果您使用的是RMI，则可能会遇到分布式GC。另外，某些应用程序添加了显式GC的思想，即它将使它们的应用程序更快。幸运的是，您可以在1.3及更高版本中使用命令行选项禁用此功能。尝试将-XX：+ DisableExplicitGC与-verbose：gc一起使用，看看是否有帮助。</p><h2 id="3-虚引用-PhantomReference"><a href="#3-虚引用-PhantomReference" class="headerlink" title="3. 虚引用(PhantomReference)"></a>3. 虚引用(PhantomReference)</h2><p>虚引用通过PhantomReference实现，虚引用类似于完全没有引用，虚引用对对象本身没有太大的影响。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列(ReferenceQueue)联合使用。</p><p>举例来说就是，如果垃圾回收时，发现一个实例对象除了虚引用外没有任何其他的引用，将会把这个引用放到<br><code>java.lang.ref.Reference.pending</code>队列里，GC完成时，通知ReferenceHandler这个守护线程做一些后续处理（如释放内存等等操作）。</p><h2 id="4-弱引用-WeakReference"><a href="#4-弱引用-WeakReference" class="headerlink" title="4. 弱引用(WeakReference)"></a>4. 弱引用(WeakReference)</h2><p>弱引用通过WeakReference类实现，对只有弱引用的对象而言，当系统垃圾回收机制运行时，不管内存是否足够，总会回收该对象所占用的内存。</p><h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue referenceQueue = new ReferenceQueue();</span><br><span class="line">WeakReference weakReference = new WeakReference(new TestEntity(), referenceQueue);</span><br><span class="line">((TestEntity) weakReference.get()).test();</span><br></pre></td></tr></table></figure><p>ReferenceQueue的作用是为了查看哪些WeakReference和SoftReferece被回收了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p><p><a href="https://www.jianshu.com/p/e66930caca9c" target="_blank" rel="noopener">Java PhantomReference详解</a></p><p><a href="oracle.com/technetwork/java/hotspotfaq-138619.html#gc_softrefs">Frequently Asked Questions About the Java HotSpot VM</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。&lt;/p&gt;
&lt;h2 id=&quot;1-强引用-StrongReference&quot;&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机知识点架构图</title>
    <link href="https://zhongyp.me/jvm/2019-09-08-jvm-structure/"/>
    <id>https://zhongyp.me/jvm/2019-09-08-jvm-structure/</id>
    <published>2019-09-07T16:00:00.000Z</published>
    <updated>2019-09-08T12:59:18.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/article/jvm-structure.png" alt="jvm-structure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/article/jvm-structure.png&quot; alt=&quot;jvm-structure&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhongyp.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>动态代理浅析</title>
    <link href="https://zhongyp.me/java/2019-09-09-java-proxy/"/>
    <id>https://zhongyp.me/java/2019-09-09-java-proxy/</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2019-10-09T12:25:46.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是动态代理？"><a href="#1-什么是动态代理？" class="headerlink" title="1. 什么是动态代理？"></a>1. 什么是动态代理？</h2><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问，而不是增强目标对象的功能。</p><blockquote><p>访问控制包括同步，身份验证，远程访问（RPC），惰性实例化（休眠，Mybatis），AOP（事务）。</p></blockquote><p><img src="/media/article/proxy-invoke-method.png" alt="代理方法调用"></p><p>实现代理的技术有很多，如 CGLIB(ASM)、AspectJ、Javassist、JDK Proxy等。</p><ul><li>ASM: 针对<strong><em>运行时</em></strong>动态生成和转换类（class）的Java语言工具，旨在处理已编译的Java类（class）。<a href="/java/2019-10-04-cglib/">CGLIB浅析</a></li><li>AspectJ: AspectJ采用<strong><em>编译时</em></strong>织入和<strong><em>类加载时</em></strong>织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<a href="/java/2019-10-04-aspectj/">AspectJ</a></li><li>Javassist: Javassist在Java中是一个用来编辑字节码的扩展包，它允许Java程序在<strong><em>运行时</em></strong>定义一个新类或者在JVM<strong><em>加载class文件时</em></strong>修改class文件。<br><a href="/java/2019-09-04-javassist/">Javassist</a></li><li>JDK Proxy: JDK动态代理类是在<strong><em>运行时</em></strong>实现指定的接口列表的类，该类实例上的其中一个接口进行的方法调用时，将被通过统一的接口进行编码并调用到另一个对象。因此，动态代理类可用于为接口列表创建类型安全的代理对象，而无需诸如在编译时使用编译工具预生成代理类。动态代理类实例的代理方法调用将在该代理类实例中的处理程序中通过java.lang.reflect.Method对象进行调用，该对象标识了所调用的方法和包含参数的Object类型数组，翻译自<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a>。详情<a href="/java/2019-10-04-jdk-proxy/">《JDK 动态代理浅析》</a></li></ul><p>在Java语言中，从构建代理类的时期上来看，有三种：编译时、类加载时和运行时。从方式上来说有两种，一种是静态代理，一种是动态代理。<br>动态代理则是一种方便<strong><em>运行时</em></strong>动态构建代理、动态处理代理方法调用的机制。例如ASM，Javassist，Java Proxy。</p><p><strong><em>编译时</em></strong>和<strong><em>类加载时</em></strong>构建代理类则属于静态代理。例如AspectJ。</p><h2 id="2-常用代理方式"><a href="#2-常用代理方式" class="headerlink" title="2. 常用代理方式"></a>2. 常用代理方式</h2><p>由于篇幅问题，本文进行了拆分，详细了解常用的代理方式的原理，请点击下方链接。</p><p><a href="/java/2019-10-04-jdk-proxy/">JDK proxy</a></p><p><a href="/java/2019-10-04-cglib/">CGLIB浅析</a></p><p><a href="/java/2019-10-04-aspectj/">AspectJ</a></p><p><a href="/java/2019-09-04-javassist/">Javassist</a></p><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h2><p><img src="/media/article/15688575046625.png" alt="jclasslib"><br>图片引用自<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">《美团技术团队》-字节码增强技术探索</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>1.Java生成动态代理的时候，使用WeakCache缓存已经生成的动态代理工厂，疑问点在于，为什么缓存的key使用的是<a href="/java/2019-09-15-reference/">弱引用</a>？</p><p>答: 类中的静态变量，当它持有一个指向一个对象的引用时，它就作为GC Root，第一类被列为GC Root的元素就是静态成员变量。因此若缓存不再需要时，使用强引用会让GC进行标记分析时认为从GC Root可达，不太会去标记这块内存，反之能够有效地标记这些缓存，从而提高内存回收效率。引用自<a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a></p><p>个人分析: 既然缓存代理工厂类，为什么不使用SoftReference，这样只有内存空间不够时才会进行回收。这样可以最大限度的缓存生成的代理工厂？<br>如果使用SoftReference，当服务使用动态代理较多时，可能会导致频繁的FullGC。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html" target="_blank" rel="noopener">Java动态代理机制分析及扩展，第1部分</a><br><a href="https://www.cnblogs.com/whirly/p/10154887.html" target="_blank" rel="noopener">Java 动态代理详解</a><br><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a><br><a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a><br><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a><br><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是动态代理？&quot;&gt;&lt;a href=&quot;#1-什么是动态代理？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是动态代理？&quot;&gt;&lt;/a&gt;1. 什么是动态代理？&lt;/h2&gt;&lt;p&gt;代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>了解ASM</title>
    <link href="https://zhongyp.me/java/2019-10-06-asm/"/>
    <id>https://zhongyp.me/java/2019-10-06-asm/</id>
    <published>2019-09-05T16:00:00.000Z</published>
    <updated>2019-10-21T11:34:13.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASM-是个啥"><a href="#ASM-是个啥" class="headerlink" title="ASM 是个啥"></a>ASM 是个啥</h2><blockquote><p><strong><a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a>技术是个啥？</strong><br>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br>ASM是一个通用的Java字节码操作和分析框架。它可以直接以二进制形式用于修改现有类或动态生成类。 ASM提供了一些常见的字节码转换和分析算法，可以从中构建定制的复杂转换和代码分析工具。 ASM提供与其他Java字节码框架类似的功能，但侧重于性能。因为它的设计和实现是尽可能的小和尽可能快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中使用）。<br>ASM应用广泛：OpenJDK lambda call sites，<a href="http://hg.openjdk.java.net/jdk8/jdk8/nashorn/file/096dc407d310/src/jdk/nashorn/internal/codegen/ClassEmitter.java" target="_blank" rel="noopener">Nashorn compiler</a><br>CGLIB，以动态生成代理类（用于其他项目，例如Mockito和EasyMock），Gradle，在运行时生成一些类。</p></blockquote><h2 id="ASM的原理解析"><a href="#ASM的原理解析" class="headerlink" title="ASM的原理解析"></a>ASM的原理解析</h2><p>ASM中最主要通过<a href="https://github.com/zhongyp/demo/tree/master/src/main/java/com/zhongyp/advanced/pattern/visitor" target="_blank" rel="noopener">访问模式</a>对字节码文件进行修改，读取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ASM-是个啥&quot;&gt;&lt;a href=&quot;#ASM-是个啥&quot; class=&quot;headerlink&quot; title=&quot;ASM 是个啥&quot;&gt;&lt;/a&gt;ASM 是个啥&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://asm.ow2.io/&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机类加载机制</title>
    <link href="https://zhongyp.me/jvm/2019-08-18-jvm-classloading/"/>
    <id>https://zhongyp.me/jvm/2019-08-18-jvm-classloading/</id>
    <published>2019-08-17T16:00:00.000Z</published>
    <updated>2019-09-10T08:44:34.872Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p></blockquote><p>Java 虚拟机动态的加载，连接，初始化类或者接口。</p><p>加载是一个通过特殊符号查找类或者接口类型的二进制文件，同时使用二进制文件创建类或者接口的过程。</p><p>连接是一个加载类或者接口并结合它变为Java虚拟机的运行时状态的过程，以便于它可以被Java虚拟机执行。</p><p>一个类或者接口的初始化由执行类或者接口的初始化方法<code>&lt;clinit&gt;</code>组成(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener">§2.9</a>)。</p><p>下图是类或者接口动态加载、连接、初始化的过程：</p><p><img src="/media/article/jvm-classloading.png" alt="jvm-classloading"></p><p>图片摘自<a href="">深入理解Java虚拟机</a></p><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h2><p>加载阶段：</p><ul><li><ol><li>通过一个类的全限定名来获取定义此类二进制字节流。</li></ol></li><li><ol start="2"><li>将这个字节流代表的静态存储结构转换为方法区的运行时数据结构(运行时数据结构详见第四小节<a href="#4-运行时常量池"></a>)。</li></ol></li><li><ol start="3"><li>在<strong><em>内存(Class对象比较特殊，它虽然是对象，但是存储在方法区中)</em></strong>生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol></li></ul><p>对于数组类本身不通过类加载器创建，它由Java虚拟机直接创建。数组类型却由类加载器创建，创建过程遵循以下规则：</p><ul><li>如果数组组件类型是引用类型，则数组被标记为组件类型定义的类加载器定义。否则，数组被标记为引导类加载器定义。</li><li>如果数组的组件类型不是引用类型，Java虚拟机将会把数组标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认是public。</li></ul><p>加载和连接阶段是交叉进行的。</p><h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h2><p>如果需要连接类或接口涉及验证和准备该类或接口，直接超类，直接超接口及其元素类型（如果它是数组类型）。类或接口中符号引用的解析是连接的可选部分。</p><p>只要维护了以下所有属性，此规范允许实现灵活性，以便何时发生连接活动（以及由于递归，加载）。</p><ul><li><p>类或接口在连接之前已完全加载。</p></li><li><p>在初始化之前，类或接口已完全验证并准备好。</p></li></ul><p>在连接期间检测到的错误被抛出到程序中的某个点，程序可能会直接或间接地需要连接到错误中涉及的类或接口。</p><p>例如，Java虚拟机实现可以选择在使用它时分别解析类或接口中的每个符号引用，或者在验证类时立即解析它们。这意味着在一些实现中，在初始化类或接口之后，解析过程可以继续。无论采用哪种策略，在解析期间检测到的任何错误都必须抛出到程序中（直接或间接）使用对类或接口的符号引用的位置。</p><p>因为连接涉及新数据结构的分配，所以它可能会失败OutOfMemoryError。</p><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>验证阶段会完成4个阶段的验证动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置类变量<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。进行内存分配的仅包括<strong><em>类变量[static变量]</em></strong>，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><h3 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic，这些虚拟机指令对运行时常量池进行符号引用，执行任何这些指令都需要解析其符号引用。</p><p>解析是从运行时常量池中的符号引用动态确定具体值的过程。</p><p>对出现在invokedynamic指令的相同的符号引用被解析一次并不意味着被任何其他invokedynamic指令认为已解析。</p><p>对于上述提到的所有指令，如果其中一个指令对符号引用进行了解析，则意味着任何非invokedynamic指令认为这个符号引用已经解析。</p><p>如果在解析符号引用期间发生错误，则必须在程序中(直接或间接)使用符号引用时的某一点抛出IncompatibleClassChangeError(或子类)的实例。</p><p>如果Java虚拟机尝试解析符号引用失败，抛出的错误是LinkageError(或子类)的实例，后续尝试解析引用始终失败，并且和初始解析尝试而引发的错误相同。</p><p>在执行指令之前，不得解析特定invokedynamic指令对调用site说明符的符号引用。</p><p>在<code>invokedynamic</code>指令解析失败的情况下，后续解析尝试不会重新执行引导方法。</p><p>上述某些指令在解析符号引用时需要额外的连接检查。例如，为了使getfield指令成功解析对其运行的字段的符号引用，它不仅必须完成第<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2" target="_blank" rel="noopener">5.4.3.2</a>节中给出的字段解析步骤，还要检查字段是否为静态。如果它是静态字段，则必须抛出链接异常。</p><p>值得注意的是，为了使<code>invokedynamic</code>指令成功解析对调用site说明符的符号引用，其中指定的引导方法必须正常完成并返回合适的调用站点对象。如果引导方法突然完成或返回不合适的调用站点对象，则必须抛出连接异常。</p><p>连接由特定执行特定Java虚拟机指令检查生成的异常在该指令的描述中给出，并且在本解析的一般性讨论中未涉及。请注意，此类异常虽然被描述为Java虚拟机指令执行而非解析的一部分，但仍然被视为解析失败。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h2><p>一个类的加载过程中加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，解析阶段则不一定。解析可以在初始化完成后再开始，这时为了支持Java的运行时绑定。</p><p>Java虚拟机没有进行强制约束什么时候加载，只是严格规范了5中情况必须对类进行”初始化”。</p><ul><li>遇到new、getstatic、putstatic或invokestatic这4条指令时，如果类没有进行初始化，则需要先触发其初始化。4条指令的常见场景是:使用new 关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)、以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7及以上版本的动态语言(详细了解 <a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a>)支持时，如果一个java.lang.incoke.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。</li></ul><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有 <strong><em>类变量的赋值动作</em></strong>和<strong><em>静态语句块(static{}块)中的语句</em></strong>合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语义块之前的变量，定义在它之后的变量，可以赋值，但是不能访问。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test()&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>不需要执行其父接口的<code>&lt;clinit&gt;()</code>方法。<br>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待。</p></blockquote><h2 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4. 运行时常量池"></a>4. 运行时常量池</h2><p>Java虚拟机维护每种类型常量池，这是一种运行时数据结构，它服务于常规编程语言实现的符号表的许多目的。</p><p>类或接口的二进制表示形式中的constant_pool表用于在创建类或接口对象时构造运行时常量池。运行时常量池中的所有引用最初都是符号引用。运行时常量池中的符号引用是从类或接口的二进制表示中的结构派生的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">String str = &quot;str&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">// 基本类型</span><br><span class="line">int i = 1;</span><br><span class="line"></span><br><span class="line">// 基本类型数组</span><br><span class="line">int[] arrayI = new int[3];</span><br><span class="line"></span><br><span class="line">// 引用类型数组</span><br><span class="line">A [] arrayA = new A[3];</span><br><span class="line"></span><br><span class="line">// 引用类型</span><br><span class="line">A a = new A();</span><br><span class="line"></span><br><span class="line">// 引用方法</span><br><span class="line">a.test();</span><br><span class="line"></span><br><span class="line">// 接口声明</span><br><span class="line">C c = new B();</span><br><span class="line"></span><br><span class="line">// 接口方法</span><br><span class="line">c.test();</span><br><span class="line"></span><br><span class="line">// lambda</span><br><span class="line">Runnable x = ()-&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p><code>javap -v</code>编译如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #13.#42        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #25            // str</span><br><span class="line">   #3 = Fieldref           #43.#44        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #45.#46        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #47            // com/zhongyp/test/A</span><br><span class="line">   #6 = Methodref          #5.#42         // com/zhongyp/test/A.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #7 = Methodref          #5.#48         // com/zhongyp/test/A.test:()V</span><br><span class="line">   #8 = Class              #49            // com/zhongyp/test/B</span><br><span class="line">   #9 = Methodref          #8.#42         // com/zhongyp/test/B.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #10 = InterfaceMethodref #50.#48        // com/zhongyp/test/C.test:()V</span><br><span class="line">  #11 = InvokeDynamic      #0:#55         // #0:run:()Ljava/lang/Runnable;</span><br><span class="line">  #12 = Class              #56            // com/zhongyp/test/Test</span><br><span class="line">  #13 = Class              #57            // java/lang/Object</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               LocalVariableTable</span><br><span class="line">  #19 = Utf8               this</span><br><span class="line">  #20 = Utf8               Lcom/zhongyp/test/Test;</span><br><span class="line">  #21 = Utf8               main</span><br><span class="line">  #22 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               args</span><br><span class="line">  #24 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               str</span><br><span class="line">  #26 = Utf8               Ljava/lang/String;</span><br><span class="line">  #27 = Utf8               i</span><br><span class="line">  #28 = Utf8               I</span><br><span class="line">  #29 = Utf8               arrayI</span><br><span class="line">  #30 = Utf8               [I</span><br><span class="line">  #31 = Utf8               arrayA</span><br><span class="line">  #32 = Utf8               [Lcom/zhongyp/test/A;</span><br><span class="line">  #33 = Utf8               a</span><br><span class="line">  #34 = Utf8               Lcom/zhongyp/test/A;</span><br><span class="line">  #35 = Utf8               c</span><br><span class="line">  #36 = Utf8               Lcom/zhongyp/test/C;</span><br><span class="line">  #37 = Utf8               x</span><br><span class="line">  #38 = Utf8               Ljava/lang/Runnable;</span><br><span class="line">  #39 = Utf8               lambda$main$0</span><br><span class="line">  #40 = Utf8               SourceFile</span><br><span class="line">  #41 = Utf8               Test.java</span><br><span class="line">  #42 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #43 = Class              #58            // java/lang/System</span><br><span class="line">  #44 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #45 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #46 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #47 = Utf8               com/zhongyp/test/A</span><br><span class="line">  #48 = NameAndType        #64:#15        // test:()V</span><br><span class="line">  #49 = Utf8               com/zhongyp/test/B</span><br><span class="line">  #50 = Class              #65            // com/zhongyp/test/C</span><br><span class="line">  #51 = Utf8               BootstrapMethods</span><br><span class="line">  #52 = MethodHandle       #6:#66         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #53 = MethodType         #15            //  ()V</span><br><span class="line">  #54 = MethodHandle       #6:#67         // invokestatic com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #55 = NameAndType        #68:#69        // run:()Ljava/lang/Runnable;</span><br><span class="line">  #56 = Utf8               com/zhongyp/test/Test</span><br><span class="line">  #57 = Utf8               java/lang/Object</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #64 = Utf8               test</span><br><span class="line">  #65 = Utf8               com/zhongyp/test/C</span><br><span class="line">  #66 = Methodref          #70.#71        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #67 = Methodref          #12.#72        // com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #68 = Utf8               run</span><br><span class="line">  #69 = Utf8               ()Ljava/lang/Runnable;</span><br><span class="line">  #70 = Class              #73            // java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #71 = NameAndType        #74:#78        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #72 = NameAndType        #39:#15        // lambda$main$0:()V</span><br><span class="line">  #73 = Utf8               java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #74 = Utf8               metafactory</span><br><span class="line">  #75 = Class              #80            // java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #76 = Utf8               Lookup</span><br><span class="line">  #77 = Utf8               InnerClasses</span><br><span class="line">  #78 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #79 = Class              #81            // java/lang/invoke/MethodHandles</span><br><span class="line">  #80 = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #81 = Utf8               java/lang/invoke/MethodHandles</span><br></pre></td></tr></table></figure><h3 id="4-1-CONSTANT-Class-info结构"><a href="#4-1-CONSTANT-Class-info结构" class="headerlink" title="4.1 CONSTANT_Class_info结构"></a>4.1 CONSTANT_Class_info结构</h3><p>对类或接口的符号引用是从类或接口的二进制表示形式中的CONSTANT_Class_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1" target="_blank" rel="noopener">第4.4.1节</a>派生的。这样的引用给出了Class.getName方法返回的表单中的类或接口的名称。</p><p>对于非数组类或接口，名称是类或接口的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>。</p><p>对于n维的数组类，名称以n个出现的ASCII“[”字符开头，后跟元素类型的表示：</p><ul><li><p>如果元素类型是基本类型，则它由相应的字段描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">第4.3.2节</a>表示。</p></li><li><p>否则，如果元素类型是引用类型，则它由ASCII“L”字符后跟元素类型的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>后跟ASCII“;”符号表示。</p></li></ul><h3 id="4-2-CONSTANT-Fieldref-info结构"><a href="#4-2-CONSTANT-Fieldref-info结构" class="headerlink" title="4.2 CONSTANT_Fieldref_info结构"></a>4.2 CONSTANT_Fieldref_info结构</h3><p>对类或接口的字段的符号引用是从类或接口的二进制表示形式中的CONSTANT_Fieldref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了字段的名称和描述符，以及对要在其中找到字段的类或接口的符号引用。</p><h3 id="4-3-CONSTANT-Methodref-info结构"><a href="#4-3-CONSTANT-Methodref-info结构" class="headerlink" title="4.3 CONSTANT_Methodref_info结构"></a>4.3 CONSTANT_Methodref_info结构</h3><p>对类的方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_Methodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了方法的名称和描述符，以及对要在其中找到方法的类的符号引用。</p><h3 id="4-4-CONSTANT-InterfaceMethodref-info"><a href="#4-4-CONSTANT-InterfaceMethodref-info" class="headerlink" title="4.4 CONSTANT_InterfaceMethodref_info"></a>4.4 CONSTANT_InterfaceMethodref_info</h3><p>对接口方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_InterfaceMethodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了接口方法的名称和描述符，以及对要在其中找到方法的接口的符号引用。</p><h3 id="4-5-CONSTANT-MethodHandle-info结构"><a href="#4-5-CONSTANT-MethodHandle-info结构" class="headerlink" title="4.5 CONSTANT_MethodHandle_info结构"></a>4.5 CONSTANT_MethodHandle_info结构</h3><p>方法句柄的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodHandle_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.8" target="_blank" rel="noopener">第4.4.8节</a>派生的。这样的引用根据方法句柄的类型给出了类或接口的字段，类的方法或接口的方法的符号引用。</p><h3 id="4-6-CONSTANT-MethodType-info结构"><a href="#4-6-CONSTANT-MethodType-info结构" class="headerlink" title="4.6 CONSTANT_MethodType_info结构"></a>4.6 CONSTANT_MethodType_info结构</h3><p>方法类型的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodType_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.9" target="_blank" rel="noopener">第4.4.9节</a>派生的。这样的引用给出了方法描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">§4.3.3</a>。</p><h3 id="4-7-CONSTANT-InvokeDynamic-info结构"><a href="#4-7-CONSTANT-InvokeDynamic-info结构" class="headerlink" title="4.7 CONSTANT_InvokeDynamic_info结构"></a>4.7 CONSTANT_InvokeDynamic_info结构</h3><blockquote><h3 id="invokedynamic-instructions"><a href="#invokedynamic-instructions" class="headerlink" title="invokedynamic instructions"></a>invokedynamic instructions</h3><p>A dynamic call site is originally in an unlinked state. In this state, there is no target method for the call site to invoke.<br>动态的调用site起初处在未连接的状态。在这种状态下，调用site没有调用的目标方法。<br>Before the JVM can execute a dynamic call site (an invokedynamic instruction), the call site must first be linked. Linking is accomplished by calling a bootstrap method which is given the static information content of the call site, and which must produce a method handle that gives the behavior of the call site.<br>在JVM可以执行动态调用site（invokedynamic指令）之前，必须首先连接调用site。连接是通过调用一个bootstrap方法来完成的，该方法被赋予了调用站点的静态信息内容，并且必须产生一个方法句柄来给出调用站点的行为。<br>Each invokedynamic instruction statically specifies its own bootstrap method as a constant pool reference. The constant pool reference also specifies the call site’s name and type descriptor, just like invokevirtual and the other invoke instructions.<br>每个invokedynamic指令静态的将它自己的引导方法指定作为一个常量池引用。常量池引用也指定调用site的名称和类型描述，就像invokevirtual和其他的调用描述一样。<br>Linking starts with resolving the constant pool entry for the bootstrap method, and resolving a MethodType object for the type descriptor of the dynamic call site. This resolution process may trigger class loading. It may therefore throw an error if a class fails to load. This error becomes the abnormal termination of the dynamic call site execution. Linkage does not trigger class initialization.<br>连接从解析引导方法的常量池条目开始，并为动态调用site的类型描述符解析MethodType对象。这个解决的进程可能触发类加载。如果一个类加载失败，可能因此抛出一个error。这个error将成为动态调用site执行的异常终止。连接不能触发类的初始化。<br>The bootstrap method is invoked on at least three values:<br>引导方法至少使用3个值调用:</p><ul><li>a MethodHandles.Lookup, a lookup object on the caller class in which dynamic call site occurs</li><li>一个是MethodHandles.Lookup，发生动态调用site的调用类上的一个lookup对象。</li><li>a String, the method name mentioned in the call site</li><li>一个字符创，在调用site中提到的方法名称。</li><li>a MethodType, the resolved type descriptor of the call</li><li>一个MethodType，已解析的调用的类型描述。</li><li>optionally, between 1 and 251 additional static arguments taken from the constant pool。</li><li>可选地，从常量池中获取1到251个额外的静态参数。</li></ul></blockquote><p>对调用站点说明符的符号引用是从类或接口的二进制表示形式中的CONSTANT_InvokeDynamic_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.10" target="_blank" rel="noopener">第4.4.10节</a>派生的。这样的参考给出：</p><ul><li><p>方法句柄的符号引用，它将作为invokedynamic指令的引导方法<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic" target="_blank" rel="noopener">§invokedynamic</a>;</p></li><li><p>一系列符号引用(对类，方法类型和方法句柄)，字符串文字和运行时常量值，它们将作为引导方法的静态参数;</p></li><li><p>方法名称和方法描述符。</p></li></ul><h3 id="4-8-CONSTANT-String-info结构"><a href="#4-8-CONSTANT-String-info结构" class="headerlink" title="4.8 CONSTANT_String_info结构"></a>4.8 CONSTANT_String_info结构</h3><p>此外，某些不是符号引用的运行时值是从constant_pool表中找到的项派生的：</p><p>字符串文字是对类String实例的引用，它是从类或接口的二进制表示形式的CONSTANT_String_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3" target="_blank" rel="noopener">第4.4.3节</a>派生而来的。 CONSTANT_String_info结构给出了构成字符串文字的Unicode代码点序列。</p><p>Java编程语言要求相同的字符串文字[即包含相同代码点序列的文字]必须引用类String的相同实例(JLS§3.10.5)。此外，如果在任何字符串上调用String.intern方法，则结果是对该字符串显示为文字时将返回的同一类实例的引用。因此，以下表达式的值必须为true：</p><p><code>(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</code></p><p>为了派生字符串文字，Java虚拟机检查CONSTANT_String_info结构给出的代码点序列。</p><p>如果先前在类String的实例上调用了String.intern方法，该类包含与CONSTANT_String_info结构给出的Unicode代码点序列相同的Unicode代码点序列，则字符串文字派生的结果是对类String的同一实例的引用。</p><p>否则，将创建一个类String的新实例，其中包含CONSTANT_String_info结构给出的Unicode代码点序列;对该类实例的引用是字符串文字派生的结果。最后，调用新String实例的intern方法。</p><h3 id="4-9-其他结构"><a href="#4-9-其他结构" class="headerlink" title="4.9 其他结构"></a>4.9 其他结构</h3><p>运行时常量值是从类或接口的二进制表示形式中的CONSTANT_Integer_info，CONSTANT_Float_info，CONSTANT_Long_info或CONSTANT_Double_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">第4.4.4节，第4.4.5节</a>派生的。</p><p>请注意，CONSTANT_Float_info结构表示IEEE 754单一格式的值，CONSTANT_Double_info结构表示IEEE 754双格式<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">§4.4.4，§4.4.5</a>中的值。因此，从这些结构导出的运行时常数值必须是可以分别使用IEEE 754单格式和双格式表示的值。</p><p>类或接口的二进制表示的constant_pool表中的其余结构 - CONSTANT_NameAndType_info和CONSTANT_Utf8_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.6" target="_blank" rel="noopener">§4.4.6，§4.4.7</a> - 仅在派生对类，接口，方法，字段的符号引用时间接使用，方法类型和方法句柄，以及派生字符串文字和调用站点说明符时。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a></p><p><a href="">深入理解Java虚拟机</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/package-summary.html#package.description" target="_blank" rel="noopener">Package java.lang.invoke Description</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chapter 5. Loadin
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhongyp.me/tags/JVM/"/>
    
      <category term="翻译" scheme="https://zhongyp.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM官方文档指南</title>
    <link href="https://zhongyp.me/jvm/2019-08-08-offical-document/"/>
    <id>https://zhongyp.me/jvm/2019-08-08-offical-document/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-11T11:01:42.708Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">Java虚拟机规范</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java虚拟机规范&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhongyp.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data Redis的execute和executePipelined的区别</title>
    <link href="https://zhongyp.me/redis/2019-08-06-execute-executePipelined/"/>
    <id>https://zhongyp.me/redis/2019-08-06-execute-executePipelined/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-11-13T08:27:03.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring-data-redis 2.0.7.RELEASE</p></blockquote><h2 id="executePipelined方法说明"><a href="#executePipelined方法说明" class="headerlink" title="executePipelined方法说明"></a>executePipelined方法说明</h2><p>executePipelined方法基于Redis的pipelining。关于pipelining官方解释如下: </p><p>A Request/Response server can be implemented so that it is able to process new requests even if the client didn’t already read the old responses. This way it is possible to send multiple commands to the server without waiting for the replies at all, and finally read the replies in a single step.<br>—摘自<a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">Redis Piplining</a></p><p>上面的意思大概是Redis服务器可以实现即使没有读取旧响应的情况下也可以发送新的请求，以这种方式可以发送多个命令到服务器而不用等待回复，最后一次获取全部的回复。这就是Redis Pipelining。</p><p>executePipelined的官方注释:</p><p>Executes the given action object on a pipelined connection, returning the results. Note that the callback cannot return a non-null value as it gets overwritten by the pipeline. This method will use the default serializers to deserialize results.</p><p>上面这句话的意思在一个<strong><em>管道连接</em></strong>中执行给定的动作对象，并返回结果。但是需要注意的是callback不能返回一个非null的值，callback的值将被pipeline覆盖。这个方法将使用默认的序列化和反序列化方式处理结果集。</p><p>例举executePipelined(SessionCallback&lt;?&gt; session, @Nullable RedisSerializer&lt;?&gt; resultSerializer) 方法源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt; executePipelined(SessionCallback&lt;?&gt; session, @Nullable RedisSerializer&lt;?&gt; resultSerializer) &#123;</span><br><span class="line">        Assert.isTrue(this.initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);</span><br><span class="line">        Assert.notNull(session, &quot;Callback object must not be null&quot;);</span><br><span class="line">        RedisConnectionFactory factory = this.getRequiredConnectionFactory();</span><br><span class="line">        // 是否开启事务管理，将当前连接注册到事务管理器</span><br><span class="line">        RedisConnectionUtils.bindConnection(factory, this.enableTransactionSupport);</span><br><span class="line"></span><br><span class="line">        List var4;</span><br><span class="line">        try &#123;</span><br><span class="line">            // this.execute其实就是execute，所以本质上来说，两个方法的区别在于executePipeline方法开启了pipeline</span><br><span class="line">            var4 = (List)this.execute((connection) -&gt; &#123;</span><br><span class="line">                // 开启管道</span><br><span class="line">                connection.openPipeline();</span><br><span class="line">                boolean pipelinedClosed = false;</span><br><span class="line"></span><br><span class="line">                List var7;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 在连接中执行SessionCallback中的动作，并获取结果集</span><br><span class="line">                    Object result = this.executeSession(session);</span><br><span class="line">                    // 如果结果集不为空，抛出InvalidDataAccessApiUsageException</span><br><span class="line">                    if (result != null) &#123;</span><br><span class="line">                        throw new InvalidDataAccessApiUsageException(&quot;Callback cannot return a non-null value as it gets overwritten by the pipeline&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    List&lt;Object&gt; closePipeline = connection.closePipeline();</span><br><span class="line">                    pipelinedClosed = true;</span><br><span class="line">                    // 获取管道返回的结果集并序列化</span><br><span class="line">                    var7 = this.deserializeMixedResults(closePipeline, resultSerializer, this.hashKeySerializer, this.hashValueSerializer);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (!pipelinedClosed) &#123;</span><br><span class="line">                        connection.closePipeline();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                // 返回管道的结果集</span><br><span class="line">                return var7;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码中<code>this.execute((connection)...</code>其实就是execute(RedisCallback&lt;?&gt; session)方法。所以executePipelined方法只是在execute内中开启了pipeline而已。</p><h2 id="execute方法说明"><a href="#execute方法说明" class="headerlink" title="execute方法说明"></a>execute方法说明</h2><p>execute相对于<code>executePipelined(SessionCallback&lt;?&gt; session)</code>比较简单，没有过多的处理，而是直接执行SessionCallback中的动作，官方注释如下:</p><p>Executes a Redis session. Allows multiple operations to be executed in the same session enabling ‘transactional’ capabilities through RedisOperations.multi() and RedisOperations.watch(Collection) operations.</p><p>大概意思是执行一个Redis会话。允许在<strong><em>同一会话</em></strong>中执行多个操作，通过RedisOperations.multi()和RedisOperations.watch(Collection)操作启用“事务”功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public &lt;T&gt; T execute(SessionCallback&lt;T&gt; session) &#123;</span><br><span class="line">        Assert.isTrue(this.initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);</span><br><span class="line">        Assert.notNull(session, &quot;Callback object must not be null&quot;);</span><br><span class="line">        RedisConnectionFactory factory = this.getRequiredConnectionFactory();</span><br><span class="line">        RedisConnectionUtils.bindConnection(factory, this.enableTransactionSupport);</span><br><span class="line"></span><br><span class="line">        Object var3;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 执行SessionCallback并获取执行SessionCallback返回的结果集</span><br><span class="line">            var3 = session.execute(this);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接返回结果集</span><br><span class="line">        return var3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="execute和executePipelined区别"><a href="#execute和executePipelined区别" class="headerlink" title="execute和executePipelined区别"></a>execute和executePipelined区别</h2><p>从上面两段源码示例可以看出，execute和executePipelined的最主要区别是executePipelined开启了pipeline。pipline与execute正常的请求/响应的区别主要在于请求/响应模式上，execute是串行化的命令请求，executePipelined请求与响应则是穿插进行。两者区别如图所示:<br>串行:<br><img src="/media/article/redis-execute.png" alt="redis-execute"></p><p>execute方法是串行的，命令请求发出后，必须得到响应数据，才能发送下一条命令请求。所以在一次Redis会话中，一次会话可能包含多次请求，即多次RTT。</p><p>穿插:</p><p><img src="/media/article/redis-executepipeline.png" alt="redis-executepipeline.png"></p><p>executePipelined是穿插的，可以批量发送命令到服务器，也可以批量获取响应数据。即可能使用一次RTT就能完成批量操作。</p><p>除了网络协议上的区别外，execute和executePipelined都支持事务管理器，支持multi，watch，exec，discard等事务操作，不过execute与executePipelined的这些操作还是有些区别的。</p><p>例如 JedisConnection开启multi:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void multi() &#123;</span><br><span class="line">   if (!this.isQueueing()) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           if (this.isPipelined()) &#123;</span><br><span class="line">               // 如果开启了pipeline，则使用Pipeline内部的multi</span><br><span class="line">               // Pipeline绑定的是client</span><br><span class="line">               this.getRequiredPipeline().multi();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // 没有开启pipeline使用jedis的multi</span><br><span class="line">               // jedis的multi绑定的是connection</span><br><span class="line">               this.transaction = this.jedis.multi();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception var2) &#123;</span><br><span class="line">           throw this.convertJedisAccessException(var2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jedis与Pipeline的命令绑定的对象不一样，前者绑定的是connection，后者绑定client。这和上面提到的请求/响应模式有关。<br>watch，exec，discard等操作也是如此。</p><p>除此之外，executePipelined的SessionCallback是不能有返回值的，executePipelined需要返回Pipleline的返回值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wuxian90/article/details/81322536" target="_blank" rel="noopener">Redis客户端与服务端交互详解</a></p><p><a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">pipelining</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Spring-data-redis 2.0.7.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;executePipelined方法说明&quot;&gt;&lt;a href=&quot;#executePipelined方法说明&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="FAQ" scheme="https://zhongyp.me/tags/FAQ/"/>
    
      <category term="Redis" scheme="https://zhongyp.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 设计与实现</title>
    <link href="https://zhongyp.me/redis/2019-06-21-redis/"/>
    <id>https://zhongyp.me/redis/2019-06-21-redis/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2019-11-13T10:58:04.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据结构与对象"><a href="#1-数据结构与对象" class="headerlink" title="1. 数据结构与对象"></a>1. 数据结构与对象</h2><h3 id="1-1-简单动态字符串（SDS）"><a href="#1-1-简单动态字符串（SDS）" class="headerlink" title="1.1 简单动态字符串（SDS）"></a>1.1 简单动态字符串（SDS）</h3><p>Redis没有使用C语言传统的字符串表示，而是构建了一种简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。Redis只会使用C字符串作为字面量。<br>除了用来保存数据库中的字符串值之外，SDS还被用做缓冲区(buffer): AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是SDS实现的。</p><blockquote><p>在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。</p></blockquote><h4 id="1-1-1-SDS的定义"><a href="#1-1-1-SDS的定义" class="headerlink" title="1.1.1 SDS的定义"></a>1.1.1 SDS的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    // 记录buf数组中已使用字节的数量</span><br><span class="line">    // 等于SDS所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    // 记录buf数组中未使用字节的数量</span><br><span class="line">    int free;</span><br><span class="line">    // 字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/15611092689335.jpg" alt="SDS示例"></p><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。</p><h4 id="1-1-2-与C字符串的区别"><a href="#1-1-2-与C字符串的区别" class="headerlink" title="1.1.2 与C字符串的区别"></a>1.1.2 与C字符串的区别</h4><ol><li>获取字符串长度复杂度：C字符串不记录长度信息，所以获取字符串长度复杂度为O(N)，SDS为O(1)。</li><li>杜绝缓冲区溢出：<code>strcat</code>函数可以将src字符串中的内容拼接到dest字符串的末尾:<br><code>char *strcat(char *dest, const char *src)</code><br>因为C字符创不记录自身的长度，所以<code>strcat</code>假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立，就会产生缓冲区溢出。SDS在执行拼接操作之前检查s的长度是否足够，在发现s目前的空间不足以拼接时，sdscat就会扩展s的空间，然后执行拼接操作。</li><li>减少修改字符串时带来的内存重分配次数：b中说道每次拼接字符串时，C字符串都要对C字符串进行一次内存重分配操作（即：在拼接操作，需要扩展空间大小，否则缓冲区溢出；在截断操作，需要释放多余空间，否则内存泄漏），因为重分配是比较耗时的操作，所以为了避免频繁修改字符串对性能造成的影响，SDS通过未使用空间接触了字符串长度和底层数组长度之间的关联：SDS中，buf的长度不一定是字符数量+1，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</li></ol><blockquote><p>空间预分配</p><ul><li>如果对SDS进行修改之后，SDS的长度小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。</li><li>如果对SDS修改之后，SDS的长度大于1MB，那么程序会分配1MB的未使用空间。</li></ul><p>惰性空间释放</p><ul><li>当 SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录下来，并等待将来使用。同时SDS提供了相应的API，在有需要时，释放SDS未使用的空间，这样就可以避免惰性空间释放策略会造成内存浪费。</li></ul></blockquote><h4 id="1-1-3-二进制安全"><a href="#1-1-3-二进制安全" class="headerlink" title="1.1.3 二进制安全"></a>1.1.3 二进制安全</h4><p>C语言字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符串，所以C字符串只能保存文本数据，不能保存二进制数据。<br>SDS的API都是二进制安全(binary-safe)的。</p><h4 id="1-1-4-兼容部分C字符串的函数"><a href="#1-1-4-兼容部分C字符串的函数" class="headerlink" title="1.1.4 兼容部分C字符串的函数"></a>1.1.4 兼容部分C字符串的函数</h4><p>虽然SDS的API都是二进制安全的，但是API总会将SDS保存的数据的末尾设置为空字符串，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数。</p><h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><p>当一个列表键包含数量比较多的元素，又或者包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区(output buffer)。</p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li><li>带链表长度的计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h3 id="1-3-字典"><a href="#1-3-字典" class="headerlink" title="1.3 字典"></a>1.3 字典</h3><h4 id="1-3-1-结构"><a href="#1-3-1-结构" class="headerlink" title="1.3.1 结构"></a>1.3.1 结构</h4><p>字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair)的抽象数据结构。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><p>字典结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">    // 类型特定函数</span><br><span class="line">    dicType *type;</span><br><span class="line">    </span><br><span class="line">    // 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line">    </span><br><span class="line">    // 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    </span><br><span class="line">    // rehash索引</span><br><span class="line">    // 当rehash不在进行时，值为-1</span><br><span class="line">    in threhash; /* rehashing not in progress if rehashidx == -1 */</span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。<br>privdata属性则保存了需要传给那些类型特定函数的可选参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dicType&#123;</span><br><span class="line"></span><br><span class="line">// 计算哈希值的函数</span><br><span class="line">unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">// 复制键的函数</span><br><span class="line">void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">// 对比键的函数</span><br><span class="line">int (*keyCompare)(void *privdata,const void *key1,const void *key);</span><br><span class="line"></span><br><span class="line">// 销毁键</span><br><span class="line">(*keyDestructor)(void *privdata,void *key);</span><br><span class="line"></span><br><span class="line">// 复制值</span><br><span class="line">void(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">// 销毁值</span><br><span class="line">void(*valDestructor)(void *privdata,void *obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ht属性是一个包含两个项的数组，数组的每项都是dictht哈希表，一般情况下只是用ht[0]，ht[1]只会在对ht[0]哈希表进行rehash时使用。<br>除ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有进行rehash，那么它的值为-1。<br><img src="/media/article/dicht.png" alt="dic"></p><h4 id="1-3-2-哈希算法"><a href="#1-3-2-哈希算法" class="headerlink" title="1.3.2 哈希算法"></a>1.3.2 哈希算法</h4><p>Redis使用的是<a href="http://code.google.com/p/smhasher/" target="_blank" rel="noopener">MurmurHash2</a>算法。</p><ol><li>算出hash值：hash=dict-&gt;type-&gt;hashFunction(key);</li><li>根据hash值计算索引值：index = hash &amp; dict-&gt;ht[x].sizemask;//x是0或1</li></ol><h4 id="1-3-4-键冲突"><a href="#1-3-4-键冲突" class="headerlink" title="1.3.4 键冲突"></a>1.3.4 键冲突</h4><p>Redis的哈希表使用链地址法(separate chaining)来解决冲突，每个哈希表节点都有一个next指针，多个哈希表节点就可以用next指针构成一个单项链表。速度考虑，最新节点添加到表头位置，复杂度O(1)。</p><h4 id="1-3-5-rehash"><a href="#1-3-5-rehash" class="headerlink" title="1.3.5 rehash"></a>1.3.5 rehash</h4><blockquote><p><strong>为什么无论是HashMap还是Redis，扩容/收缩时容量大小都是2的幂？</strong></p><ul><li>减少碰撞次数，比如1111&amp;1110=1110，1110&amp;1110=1110；</li><li>容量*2不至于分配空间过大造成浪费；</li></ul></blockquote><p>Redis对字典的rehash步骤如下：</p><ol><li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量：</li></ol><ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n；</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n；</li></ul><ol start="2"><li>将保存在ht[0]中的所有键值对rehash到ht[1]上:rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li></ol><p><strong> 哈希表的扩展与收缩 </strong></p><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p><ul><li>服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子=哈希表已保存节点数量/哈希表大小</span><br><span class="line">load_factor = ht[0].used/ht[0].size</span><br></pre></td></tr></table></figure><p>执行BGSAVE或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，大多数操作系统都采用写时复制(copy-on-write)技术优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子。<br>当哈希表的负载因子小于0.1时，程序自动开始执行收缩操作。</p><h4 id="1-3-6-渐进式rehash"><a href="#1-3-6-渐进式rehash" class="headerlink" title="1.3.6 渐进式rehash"></a>1.3.6 渐进式rehash</h4><p>rehash动作不是一次性、集中式的完成，而是分多次、渐进式的完成。<br>渐进式rehash步骤:</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash值ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作完成。</li></ol><p>在渐进式rehash期间，字典的删除、查找、更新等操作会在两个哈希表上进行。如果新加到字典的键值对一律被保存到ht[1]里面。</p><h3 id="1-4-跳跃表"><a href="#1-4-跳跃表" class="headerlink" title="1.4 跳跃表"></a>1.4 跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p><h4 id="1-4-1-结构"><a href="#1-4-1-结构" class="headerlink" title="1.4.1 结构"></a>1.4.1 结构</h4><p><img src="/media/article/skiplist.png" alt="skiplist"><br>上图展示了一个跳跃表示例，左边是zskiplist结构：</p><ul><li>header: 指向跳跃表的表头节点</li><li>tail: 指向跳跃表的结尾节点</li><li>level: 记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length: 记录跳跃表的长度，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>右侧是zskiplistNode结构：</p><ul><li>level: 节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，以此类推。每层两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，跨度则记录了前进指针所指向节点和当前节点的距离。</li><li>backward: 节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>score: 各个节点中的1.0、2.0、和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排序。</li><li>obj: 各个节点中的o1、o2和o3时节点所保存的成员对象。</li></ul><h3 id="1-5-整数集合"><a href="#1-5-整数集合" class="headerlink" title="1.5 整数集合"></a>1.5 整数集合</h3><p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。<br>整数集合是Redis用于保存整数值的集合抽象数据结构，他可以保存集合类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    // 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    // 集合包含的元素</span><br><span class="line">    uint32_t length;</span><br><span class="line">    // 保存元素的数据</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现:整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小从小打到有序的排列，并且数组中不包含任何重复项。</p><h4 id="1-5-1-整数集合升级"><a href="#1-5-1-整数集合升级" class="headerlink" title="1.5.1 整数集合升级"></a>1.5.1 整数集合升级</h4><p>每当我们将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合先进行升级，然后添加到整数集合里面。</p><p>升级步骤：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，放置元素过程中，需要维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><h3 id="1-6-压缩列表"><a href="#1-6-压缩列表" class="headerlink" title="1.6 压缩列表"></a>1.6 压缩列表</h3><p>当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><p>压缩列表是为了节约内存开发的，是由一系列特殊编码的连续内存块组织的顺序(sequential)数据结构。</p><p><img src="/media/article/ziplist.png" alt="ziplist"><br><img src="/media/article/ziplistintroduce.png" alt="ziplistintroduce"></p><p>节点content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><h4 id="1-6-1-连锁更新"><a href="#1-6-1-连锁更新" class="headerlink" title="1.6.1 连锁更新"></a>1.6.1 连锁更新</h4><p>连锁更新最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最快复杂度为O(N)，所以更新的最快复杂度为O(N^2)。</p><h3 id="1-7-快速列表-quicklist"><a href="#1-7-快速列表-quicklist" class="headerlink" title="1.7 快速列表(quicklist)"></a>1.7 快速列表(quicklist)</h3><p>quicklist是一个ziplist的双向链表（双向链表是由多个节点Node组成的）。也就是说quicklist的每个节点都是一个ziplist。ziplist本身也是一个能维持数据项先后顺序的列表（按插入位置），而且是一个各个数据项在内存上前后相邻的列表。<br>结构如下:</p><p><img src="/media/article/quicklist.png" alt="quicklist"><br>图片来自<a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a></p><p>quicklist基于空间和时间的考虑，结合双向链表和ziplist的优点。</p><blockquote><p>双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。<br>ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。<br>摘自<a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau Redis源码剖析–quicklist</a></p></blockquote><h4 id="快速列表存储效率"><a href="#快速列表存储效率" class="headerlink" title="快速列表存储效率"></a>快速列表存储效率</h4><p>本小节引用自《<a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a>》</p><blockquote><p>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。<br>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。</p></blockquote><p>实际上，Redis提供了一个配置参数<code>list-max-ziplist-size</code>，就是为了让使用者可以来根据自己的情况进行调整。</p><p>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。</p><p>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：</p><ul><li>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）</li><li>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</li><li>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。</li><li>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</li><li>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</li></ul><p>当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数list-compress-depth就是用来完成这个设置的。</p><p><code>list-compress-depth 0</code><br>这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。</p><p>参数list-compress-depth的取值含义如下：</p><ul><li>0: 是个特殊值，表示都不压缩。这是Redis的默认值。</li><li>1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。</li><li>2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。</li><li>3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</li></ul><p>依此类推…<br>由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p><p>Redis对于quicklist内部节点的压缩算法，采用的<a href="http://oldhome.schmorp.de/marc/liblzf.html" target="_blank" rel="noopener">LZF</a>——一种无损压缩算法。</p><h3 id="1-8-对象"><a href="#1-8-对象" class="headerlink" title="1.8 对象"></a>1.8 对象</h3><p>Redis并没有 直接使用SDS、双端链表、字典、压缩列表、整数集合这些数据结构实现键值对数据库，而是基于这些数据结构创建了一个对象系统。对象系统包含：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。<br>Redis的对象系统实现了基于引用计数计数的内存回收机制，当程序 不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外Redis还通过引用计数技术实现了对象共享机制，这种机制在适当情况下，通过让多个数据库键共享同一个对象来节约内存。<br>Redis对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能情况下，空转时长较大的那些键可能会优先被服务器删除。</p><h4 id="1-8-1-对象的类型与编码"><a href="#1-8-1-对象的类型与编码" class="headerlink" title="1.8.1 对象的类型与编码"></a>1.8.1 对象的类型与编码</h4><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，一个对象用作键值对的值。</p><p>Redis中的每个对象都由一个RedisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    </span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    </span><br><span class="line">    // 指向底层实现数据结构的指针</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>type记录了对象的类型：</p><ul><li>REDIS_STRING:字符串对象</li><li>REDIS_LIST:列表对象</li><li>REDIS_HASH:哈希对象</li><li>REDIS_SET:集合对象</li><li>REDIS_ZSET:有序集合对象</li></ul><blockquote><p>字符串键指的是这个数据库键所对应的值得字符串对象<br>列表键指的是数据库键所对应的值为列表对象</p></blockquote><p>ptr指针指向对象的底层实现数据结构，这些数据结构由对象的encoding属性决定。encoding记录对象使用的编码：</p><p><img src="/media/article/encoding-type.png" alt="encoding"><br>除上述列表外，还有一个是REDIS_ENCODING_QUICKLIST编码，快速列表。</p><p>每种类型的对象都至少使用了两种不同编码，下表列出了每种类型的对象可以使用的编码。</p><p><img src="/media/article/type-encoding.png" alt="type-encoding"></p><p>除上述列表外，还有一个是REDIS_LIST对应REDIS_ENCODING_QUICKLIST。</p><h4 id="1-8-2-字符串对象"><a href="#1-8-2-字符串对象" class="headerlink" title="1.8.2 字符串对象"></a>1.8.2 字符串对象</h4><p>字符串对象的编码可以是int、raw或者embstr。<br>如果字符串对象保存的是整数值，将字符串对象的编码设置为int。<br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度大于32字节，字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为raw。<br>raw结构：<br><img src="/media/article/raw.png" alt="raw"><br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度小于32字节，字符串对象将使用embstr编码的方式保存这个字符串值。<br>embstr内存块结构：<br><img src="/media/article/embstr.png" alt="embstr"><br><strong>raw和embstr区别：</strong></p><ul><li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li><li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码字符串对象比起来raw编码的字符串能够更好地利用缓存带来的优势。</li></ul><p>字符串对象保存各类型值得编码方式:</p><p><img src="/media/article/string-type-value.png" alt="string"></p><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。<br>Redis没有为embstr编码的字符串对象编写任何响应的修改程序，所以embstr编码的字符串对象实际上是只读的。</p><p><img src="/media/article/string-order-implement.png" alt="string"></p><h4 id="1-8-3-列表对象"><a href="#1-8-3-列表对象" class="headerlink" title="1.8.3 列表对象"></a>1.8.3 列表对象</h4><p>3.2版本之前列表对象的编码可以使ziplist或者linkedlist。<br>ziplist结构如下：<br><img src="/media/article/ziplist-store.png" alt="ziplist"></p><p>linkedlist结构如下：</p><p><img src="/media/article/linkedlist-store.png" alt="linkedlist"></p><p>StringObject结构：</p><p><img src="/media/article/string-obj-store.png" alt="string-object"></p><p>当列表对象满足如下条件时，使用ziplist编码：<br>列表对象保存的所有字符串元素的长度都小于64字节；<br>列表对象保存的元素数量小于512个；</p><p><strong>列表命令的实现：</strong><br><img src="/media/article/list-order-implement.png" alt="list-order"></p><p>在3.2版本之后唯一的数据结构是快表（quicklist），它是一个双向链表，而且是一个ziplist的双向链表。</p><h4 id="1-8-4-哈希对象"><a href="#1-8-4-哈希对象" class="headerlink" title="1.8.4 哈希对象"></a>1.8.4 哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值得压缩列表节点推入到压缩列表表尾：</p><ul><li>因此保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;HSET profile name &quot;Tom&quot;</span><br><span class="line">&gt;HSET profile age 25</span><br><span class="line">&gt;HSET profile career &quot;Programmer&quot;</span><br></pre></td></tr></table></figure></p><p>哈希对象的压缩列表底层实现：</p><p><img src="/media/article/hash-ziplist-implement.png" alt="hash-ziplist-implement"></p><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><p>如果上述例子不是ziplist而是hashtable，则结构如下：</p><p><img src="/media/article/hashtable-implement.png" alt="hashtable-implement"></p><p>如果哈希对象满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值得字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；</li></ul><p><strong>hash命令：</strong></p><p><img src="/media/article/hash-order.png" alt="hash-order"></p><h4 id="1-8-5-集合对象"><a href="#1-8-5-集合对象" class="headerlink" title="1.8.5 集合对象"></a>1.8.5 集合对象</h4><p>集合对象编码可以是intset或者hashtable。</p><p><strong>集合命令：</strong></p><p><img src="/media/article/set-order.png" alt="set-order"><br><img src="/media/article/set-order1.png" alt="set-order"></p><h4 id="1-8-6-有序集合对象"><a href="#1-8-6-有序集合对象" class="headerlink" title="1.8.6 有序集合对象"></a>1.8.6 有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist。</p><p><strong>ziplist的的存储结构：</strong></p><p><img src="/media/article/sorted-set-ziplist.png" alt="sorted-set-ziplist"><br><img src="/media/article/sorted-set-ziplist1.png" alt="sorted-set-ziplist"></p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset&#123;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点保存了一个集合元素:跳跃表节点的Object属性保存了元素的成员，而跳跃表的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，如<code>ZRANK</code>、<code>ZRANGE</code>等命令就是基于跳跃表API来实现的。</p><p>除此之外，zset结构中的dict字典为有序集合创建了一个从成员的分值的映射，字典中的每个键值对都保存了一个集合元素:字典的键保存了元素的成员，而字典的值保存了元素的分值。通过这个字典，程序可以O(1)复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的。</p><p>虽然zset结构同时使用跳跃表和字典来保存有序集合元素，而这两种数据机构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或分值，也不会浪费额外内存。</p><blockquote><p><strong>为什么有序集合需要同时使用跳跃表和字典来实现？</strong><br>如果我们只是用字典来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p></blockquote><p><strong>skiplist结构：</strong></p><p><img src="/media/article/sorted-set-skiplist.png" alt="sorted-set-skiplist"></p><p><strong><em>注意：字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p><strong>命令实现：</strong></p><p><img src="/media/article/sorted-set-order.png" alt="sorted-set-order"></p><h4 id="1-8-7-类型检查与命令多态"><a href="#1-8-7-类型检查与命令多态" class="headerlink" title="1.8.7 类型检查与命令多态"></a>1.8.7 类型检查与命令多态</h4><p>Redis中用于操作键的命令基本上可以分为两种类型。<br>一种可以对任何类型键执行；另一种只能对特定类型的键执行。</p><p>Redis在执行一个类型特定的命令之前，会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。<br>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的:</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需类型，如果是的话执行。</li><li>否则，拒绝执行，返回类型错误。</li></ul><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。如llen：</p><p><img src="/media/article/llen-order.png" alt="llen-order"></p><h4 id="1-8-8-内存回收"><a href="#1-8-8-内存回收" class="headerlink" title="1.8.8 内存回收"></a>1.8.8 内存回收</h4><p>因为C不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数(reference counting)技术实现的内存回收机制。</p><h4 id="1-8-9-对象共享"><a href="#1-8-9-对象共享" class="headerlink" title="1.8.9 对象共享"></a>1.8.9 对象共享</h4><p>Redis对象的引用计数属性还带有对象共享的作用（多个键共享同一个值对象）。<br>这些共享对象不单单只有字符串键可以使用，那些数据结构中嵌套了字符串对象的对象都可以使用这些共享对象。</p><p>Redis只对包含整数值的字符串对象进行共享。</p><h4 id="1-8-10-对象的空转时长"><a href="#1-8-10-对象的空转时长" class="headerlink" title="1.8.10 对象的空转时长"></a>1.8.10 对象的空转时长</h4><p>除了type、encoding、ptr和refcount四个属性外，redisObject结构包含的最后一个属性为lru属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    unsigned lru:22;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>OBJECT IDLETIME命令可以打印出键的空转时长，计算方式：当前时间-lru。</p><h2 id="2-单机数据库实现"><a href="#2-单机数据库实现" class="headerlink" title="2. 单机数据库实现"></a>2. 单机数据库实现</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p><p><strong>数据库结构示例：</strong><br><img src="/media/article/redis-db.png" alt="db"></p><p>redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典成为键空间：</p><p><strong>数据库键空间示例：</strong><br><img src="/media/article/redis-db-keyspace.png" alt="db"></p><p>键空间的键也就是数据库的键，每个键都是一个字符串对象。<br>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。<br>数据库的键空间是一个字典。</p><p><strong> 读写空间时的维护操作</strong></p><ul><li>读取一个键后，服务器会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>读取一个键后，服务器会更新键的LRU时间，可以使用OBJECT idletime <key> 命令查看键key的闲置时间。</key></li><li>如果服务器在读取一个键时发现该键过期，服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果客户端使用watch命令监视了某个键，那么服务器在对被监视的键进行修改后，会将这个键标记为脏(dirty)。</li><li>服务器每次修改一个键后，都会对(dirty)键计数器的值增1，这个计数器会触发服务器的持久化及复制操作。</li><li>如果服务器开启了数据库通知功能，那么对键进行修改之后，服务器将按配置发送响应的数据库通知。</li></ul><h3 id="2-1-过期时间"><a href="#2-1-过期时间" class="headerlink" title="2.1 过期时间"></a>2.1 过期时间</h3><p>Redis有四种不同的命令可以用于设置键的生存时间或过期时间:</p><ul><li><code>EXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl秒。</li><li><code>PEXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl毫秒。</li><li><code>EXPIREAT&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp秒数时间戳。</li><li><code>PEXPIRE&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp毫秒数时间戳。</li></ul><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典:</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><p>PERSIST命令可以移除一个键的过期时间。</p><p>TTL命令以秒级单位返回键的剩余生存时间，PTTL命令以毫秒为单位返回键的剩余生存时间。</p><h3 id="2-2-过期键删除策略"><a href="#2-2-过期键删除策略" class="headerlink" title="2.2 过期键删除策略"></a>2.2 过期键删除策略</h3><p>定时删除: 在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作。<br>惰性删除: 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。<br>定期删除: 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><h4 id="2-2-1-定时删除"><a href="#2-2-1-定时删除" class="headerlink" title="2.2.1 定时删除"></a>2.2.1 定时删除</h4><p>定时删除对内存友好，对CPU时间不友好，在过期键比较多的情况下，删除过期键这一行为可能会占用相同一部分CPU时间。</p><h4 id="2-2-2-惰性删除"><a href="#2-2-2-惰性删除" class="headerlink" title="2.2.2 惰性删除"></a>2.2.2 惰性删除</h4><p>惰性删除策略对CPU友好，对内存不友好。有内存泄漏的风险。</p><h4 id="2-2-3-定期删除"><a href="#2-2-3-定期删除" class="headerlink" title="2.2.3 定期删除"></a>2.2.3 定期删除</h4><p>定期删除操作的难点在于如果确定删除操作的时长和频率。</p><h4 id="2-2-4-Redis的过期删除策略"><a href="#2-2-4-Redis的过期删除策略" class="headerlink" title="2.2.4 Redis的过期删除策略"></a>2.2.4 Redis的过期删除策略</h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略。</p><h4 id="2-2-5-AOF、RDB和复制功能对过期键的处理"><a href="#2-2-5-AOF、RDB和复制功能对过期键的处理" class="headerlink" title="2.2.5 AOF、RDB和复制功能对过期键的处理"></a>2.2.5 AOF、RDB和复制功能对过期键的处理</h4><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件是，程序会对数据库中的键进行检查，已过期的键不会保存到新建的RDB文件中。</p><p><strong>RDB文件载入：</strong></p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模型运行，那么载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过主从服务器在进行数据同步时，从服务器的数据库会被清空。</li></ul><p>AOF重写的过程中，会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><p>当服务器在复制模式下时，从服务器的过期键删除动作有主服务器控制:</p><ul><li>主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告诉从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，及时碰到过期键也不会将过期键删除，而继续像处理未过期的键一样处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令后，才会删除过期键。</li></ul><h4 id="2-2-6-数据库通知"><a href="#2-2-6-数据库通知" class="headerlink" title="2.2.6 数据库通知"></a>2.2.6 数据库通知</h4><p>数据库通知时Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>监听索引为0的键空间key为message所有操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SUBSCRIBE __keyspace@0__:message</span><br></pre></td></tr></table></figure></p><h3 id="2-3-RDB持久化"><a href="#2-3-RDB持久化" class="headerlink" title="2.3 RDB持久化"></a>2.3 RDB持久化</h3><h4 id="2-3-1-RDB文件的创建与载入"><a href="#2-3-1-RDB文件的创建与载入" class="headerlink" title="2.3.1 RDB文件的创建与载入"></a>2.3.1 RDB文件的创建与载入</h4><p>Redis命令可用于生成RDB文件，一个是SAVE，另一个是BGSAVE。<br>SAVE会阻塞Redis服务进程，知道RDB文件创建完毕，阻塞期间，服务器不能处理任何命令请求。<br>BGSAVE命令会派生除一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求。<br>BGSAVE命令正在执行，客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕后执行。<br>BGREWRITEAOF正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</p><blockquote><p>如果开启了AOF持久化功能，服务器会优先使用AOF文件还原数据库状态。<br>只有AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</p></blockquote><h4 id="2-3-2-自动间隔性保存"><a href="#2-3-2-自动间隔性保存" class="headerlink" title="2.3.2 自动间隔性保存"></a>2.3.2 自动间隔性保存</h4><h4 id="2-3-3-RDB文件结构"><a href="#2-3-3-RDB文件结构" class="headerlink" title="2.3.3 RDB文件结构"></a>2.3.3 RDB文件结构</h4><p><img src="/media/article/rdb-structure.png" alt="rdb"></p><p>REDIS部分用来校验是否为RDB文件。<br>db_version长度为4字节，记录RDB文件的版本号。<br>databases部分包含着两个或者任意多个数据库，以及各个数据库中的键值对数据。<br>EOF标志着RDB文件的正文结束。<br>check_sum保存着一个校验和，由REDIS、db_version、databases、EOF计算得出。校验RDB文件是否出错或者损坏。</p><p>database部分保存任意多个非空数据库，如下图所示，每个非空数据库可以保存SELECTDB、db_number、key_value_pairs:</p><p><img src="/media/article/rdb-structure1.png" alt="rdb"><br><img src="/media/article/rdb-database.png" alt="rdb"></p><p>SELEECT表示数据库号码。<br>db_number保存一个数据库号码。<br>key_value_pairs保存数据库中的所有键值对数据。</p><p><img src="/media/article/rdb-file-structure.png" alt="rdb"></p><p>key_values_pairs保存了一个以上的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。<br>不过期时间的键值对由TYPE、key、value组成。<br>TYPE:</p><ul><li>REDIS_RDB_TYPE_STRING</li><li>REDIS_RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_ZIPLIST</li></ul><p>过期时间的键值对在RDB文件中结构:<br><img src="/media/article/rdb-expire-structure.png" alt="rdb"></p><h3 id="2-4-AOF持久化"><a href="#2-4-AOF持久化" class="headerlink" title="2.4 AOF持久化"></a>2.4 AOF持久化</h3><p>AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤。</p><h4 id="2-4-1-命令追加"><a href="#2-4-1-命令追加" class="headerlink" title="2.4.1 命令追加"></a>2.4.1 命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-2-文件写入与同步"><a href="#2-4-2-文件写入与同步" class="headerlink" title="2.4.2 文件写入与同步"></a>2.4.2 文件写入与同步</h4><p>Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def eventLoop():</span><br><span class="line">    while True:</span><br><span class="line">        # 处理文件事件，接收命令请求以及发送命令回复</span><br><span class="line">        # 处理命令请求时可能会有新内容被追加到aof_buf缓冲区中</span><br><span class="line">        processFileEvents()</span><br><span class="line">        </span><br><span class="line">        # 处理时间事件</span><br><span class="line">        processTimeEvents()</span><br><span class="line">        </span><br><span class="line">        # 考虑是否将aof_buf中的内容写入和保存到AOF文件里面</span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定，各个不同值产生的行为如表:<br><img src="/media/article/appendfsycn.png" alt="appendfsync"></p><h4 id="2-4-3-AOF重写"><a href="#2-4-3-AOF重写" class="headerlink" title="2.4.3 AOF重写"></a>2.4.3 AOF重写</h4><p>因为AOF通过保存执行的写命令来记录数据库状态，所以可能造成AOF文件过大。为了解决这个问题，Redis提供了AOF文件重写功能。通过创建一个新的AOF文件替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF通常比旧AOF小得多。<br>重写功能通过读取服务器当前的数据状态来实现的。因为aof——rewirte函数生成的新的AOF只包含还原当前数据库状态所必需的的命令，所以新AOF文件不会浪费任何硬盘空间。</p><p><strong>注意:</strong><br>在实际中，为了避免执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查所包含的元素数量，如果元素数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值。</p><p>aof_rewrite会长时间阻塞，所以Redis将AOF重写程序放到子进程里执行:</p><ul><li>子进程进行AOF重写期间，服务器进程可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>AOF重写期间，客户端命令可能对现有数据库状态修改，造成当前数据库状态和AOF文件不一致的情况。</p><p>为了解决不一致的情况，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令后，它同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>AOF完成重写后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作:</p><ul><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子的覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ul><p>AOF后台重写过程中，只有信号处理函数执行时会对服务器进程造成阻塞，其他时候，AOF不会阻塞父进程。</p><h3 id="2-5-事件"><a href="#2-5-事件" class="headerlink" title="2.5 事件"></a>2.5 事件</h3><p>Redis服务器是一个事件驱动程序:</p><ul><li>文件事件: Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信产生响应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件: Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h4 id="2-5-1-文件事件"><a href="#2-5-1-文件事件" class="headerlink" title="2.5.1 文件事件"></a>2.5.1 文件事件</h4><p>Redis基于Reactor模式开发了自己的网络事件处理器: 这个处理器被称为文件事件处理器:</p><ul><li>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><h4 id="2-5-2-时间事件"><a href="#2-5-2-时间事件" class="headerlink" title="2.5.2 时间事件"></a>2.5.2 时间事件</h4><p>Redis的时间事件分为以下两类:</p><ul><li>定时事件: 让一段程序在指定的时间之后执行一次。</li><li>周期性时间: 让一段程序每隔指定时间执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成:</p><ul><li>id: 服务器为时间事件创建的全局唯一ID。从小到大递增。</li><li>when: 毫秒级精度的UNIX时间戳，记录了时间事件的到达时间。</li><li>timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件: 该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性事件: 当一个时间事件到达之后，服务器会根据事件处理器返回的值，对事件事件的when属性进行更新，这个事件在一段时间之后再次到达，并以这种方式一致更新并运行下去。</li></ul><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行，这些定期操作由redis.c/serverCron函数负责执行，主要工作包括:</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF和RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><h4 id="2-5-3-事件调度与执行"><a href="#2-5-3-事件调度与执行" class="headerlink" title="2.5.3 事件调度与执行"></a>2.5.3 事件调度与执行</h4><p>事件调度和执行由ae.c/aeProcessEvents函数负责。</p><blockquote><p>processFileEvent这个函数并不存在，在实际中，处理已产生文件事件的代码是直接写在aeProcessEvents函数里面。</p></blockquote><p>事件调度和执行规则:</p><ol><li>aeApiPoll函数的最大阻塞时间由到达时间最近当前时间的时间事件决定，这个方法既可以避免服务器对事件事件进行频繁的轮询，也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何事件事件到达，那么服务器将再次等待处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件。</li><li>对文件事件和时间事件的处理都是同步、有序、原子的执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此不管是文件事件的处理器，还是时间事件的处理器，也不会对事件进行抢占，一次不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可的减少程序阻塞时间，并在有需要时主动让出执行权，从而降低造成时间饥饿的可能性。另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li><li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间晚一些。</li></ol><h2 id="3-多机数据库实现"><a href="#3-多机数据库实现" class="headerlink" title="3. 多机数据库实现"></a>3. 多机数据库实现</h2><h3 id="3-1-复制"><a href="#3-1-复制" class="headerlink" title="3.1 复制"></a>3.1 复制</h3><p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制(replicate)另一个服务器。</p><p>Redis复制功能分为同步和命令传播两个操作：</p><ul><li>同步操作用于将服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致的状态。</li></ul><p>Redis复制实现：</p><ol><li>客户端发送命令(此命令是异步的)：<code>&gt;SLAVEOF master-ip master-port</code>。</li><li>1命令在从服务上完成masterhost和masterport属性的设置之后，从服务器返回OK。</li><li>从服务器根据masterhost和masterport建立socket连接。</li><li>发送PING命令，检查socket连接的读写状态，检查主服务器的命令处理，如果主服务器返回非PONG，则断开并重连主服务器。</li><li>从服务器发送身份验证信息。</li><li>发送从服务器的端口信息。</li><li>同步PSYNC。</li><li>最后命令传播。</li></ol><p>Redis复制流程图：</p><p><img src="/media/article/redis-replicate.png" alt="redis-replicate"></p><p>从Redis 2.8版本开始，Redis使用PSYNC代替SYNC命令执行复制操作。<br>PSYNC命令执行：</p><p><img src="/media/article/psync.png" alt="PSYNC"></p><p>PSYNC与SYNC最显著的区别是PSYNC支持部分重同步。</p><h3 id="3-2-Sentinel"><a href="#3-2-Sentinel" class="headerlink" title="3.2 Sentinel"></a>3.2 Sentinel</h3><p>Sentinel是Redis的高可用解决方案。</p><p>启动Sentinel时，执行<code>redis-server /path/sentinel.conf --sentinel</code>或者<code>redis-sentinel /path/sentinel.conf</code>命令即可。</p><p>Sentinel启动时，需要执行以下步骤：</p><ol><li>初始化服务器</li><li>将普通Redis服务器使用的代码替换成Sentinel专用代码</li><li>初始化Sentinel状态</li><li>根据给定配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连向主服务器的网络连接</li></ol><p>Sentinel状态图：<br><img src="/media/article/redis-sentinel-state.png" alt="redis-sentinel-state"></p><h4 id="3-2-1-获取主从、Sentinel的信息"><a href="#3-2-1-获取主从、Sentinel的信息" class="headerlink" title="3.2.1 获取主从、Sentinel的信息"></a>3.2.1 获取主从、Sentinel的信息</h4><p>初始化Sentinel最后一步是创建连向主服务器的网络连接，Sentinel将成为主服务器的客户端。</p><p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络：</p><ul><li>命令连接，这个连接专门向主服务器发送命令，并接收命令回复。</li><li>订阅连接，这个连接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道。 </li></ul><p>Sentinel默认以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，通过INFO获取主服务器的当前信息。<br>Sentinel通过主服务器发现从服务器时，也会建立上述的两个连接，每10秒发送INFO命令，获取从服务器的当前信息。<br>默认情况下，Sentinel每2秒通过命令连接向所有主从服务器发送如下命令：<br><code>PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_id&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;</code>“</p><p>s开头的是sentinel的信息，m开头的是主服务器的信息，如果发送的是从服务器，则m为从服务器正在复制的主服务器的信息。<br>Sentinel与一个主或从服务器建立订阅连接后，Sentinel就会通过订阅连接，向服务器发送以下命令:<br><code>SUBSCRIBE __sentinel__:hello</code></p><p>Sentinel通过频道信息发现一个新的Sentinel时，不仅会为新的Sentinel创建相应的实例结构，还会创建一个连向新Sentinel的命令连接。</p><h4 id="3-2-1-下线状态"><a href="#3-2-1-下线状态" class="headerlink" title="3.2.1 下线状态"></a>3.2.1 下线状态</h4><p>Sentinel每1秒一次的频率向所有与它建立命令连接的实例发送PING命令，判断是否在线。<br>实例在down-after-milliseconds内返回+PONG、-LOADING、-MASTERDOWN以外的回复，Sentinel将修改该实例的flags属性:SRI_S_DOWN标识，标识进入主观下线状态。<br>超时也会被置为主观下线状态。</p><p>当主服务器被判定为主观下线后，为确认是否真的下线了，Sentinel会询问监视此服务器的其他Sentinel，如果从其他Sentinel得到足够数量的已下线判断后，Sentinel将此服务器置为客观下线。</p><p>Redis下线状态及Sentinel领头选举：<br><img src="/media/article/redis-down.png" alt="redis-down"><br>上图中，1. master代表一个主服务器，2. 监视master的sentinel代表其中一个监视master的sentinel(所有监视master的sentinel都会这样去操作，这个地方只是列出来一个作为示例)，3. 监视master的sentinel代表监视master的sentinel的集合。</p><h4 id="3-2-2-故障转移"><a href="#3-2-2-故障转移" class="headerlink" title="3.2.2 故障转移"></a>3.2.2 故障转移</h4><p>故障转移步骤：</p><ul><li><ol><li>在已下线的主服务器的从服务器中，选一个作为主服务器。</li></ol></li><li><ol start="2"><li>让其他没有作为主服务器的从服务器复制新的主服务器。</li></ol></li><li><ol start="3"><li>将已下线的主服务器置为新主服务器的从服务器，当下线的主服务器再上线时，它就会成为新主服务器的从服务器。</li></ol></li></ul><h3 id="3-3-集群"><a href="#3-3-集群" class="headerlink" title="3.3 集群"></a>3.3 集群</h3><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。</p><h4 id="3-3-1-节点"><a href="#3-3-1-节点" class="headerlink" title="3.3.1 节点"></a>3.3.1 节点</h4><p>当一个节点node发送<code>CLUSTER MEET &lt;IP&gt; &lt;PORT&gt;</code>命令，可以让node节点与ip和port所指定的节点进行握手(handshake)，当握手成功后，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。<br>集群数据结构示例:<br><img src="/media/article/redis-cluster.png" alt="cluster"></p><h4 id="3-3-2-槽"><a href="#3-3-2-槽" class="headerlink" title="3.3.2 槽"></a>3.3.2 槽</h4><p>Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为16384个槽(slot)，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理0个或者最多16384个槽。</p><p>如果16384个槽都有节点在处理时，集群处于上线状态(ok)，相反如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态(fail)。</p><p>槽分配命令<code>CLUSTER ADSLOTS &lt;slot&gt; [slot ...]</code>，例如<code>127.0.0.1:6379&gt;cluster addslots 0 1 2 ... 1000</code>将0到1000的槽分配给本地的6379节点负责。</p><p>槽分配后节点的ClusterState结构:</p><p><img src="/media/article/redis-clusterstate.png" alt="clusterstate"></p><p>集群节点数据库存储结构:</p><p><img src="/media/article/redis-clusterstate1.png" alt="clusterstate"></p><p>集群节点保存key对应槽的跳跃表:</p><p><img src="/media/article/redis-slots-to-key.png" alt="clusterstate"></p><h4 id="3-3-3-分片"><a href="#3-3-3-分片" class="headerlink" title="3.3.3 分片"></a>3.3.3 分片</h4><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的减值对也会从源节点被移动到目标节点。</p><p>Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重分配分片所需要的所有命令。</p><p>Redis重分片迁移过程:</p><p><img src="/media/article/redis-migrate.png" alt="migrate"></p><p>迁移过程中，查询key的命令过程如下:</p><p><img src="/media/article/redis-ask.png" alt="redis-ask"></p><p><img src="/media/article/redis-asking.png" alt="redis-asking"></p><h4 id="3-3-4-故障检测"><a href="#3-3-4-故障检测" class="headerlink" title="3.3.4 故障检测"></a>3.3.4 故障检测</h4><p>集群中的每个节点都会定期的向集群中的其他节点发送PING消息，以此来检测对方是否在线。</p><h4 id="3-3-5-消息"><a href="#3-3-5-消息" class="headerlink" title="3.3.5 消息"></a>3.3.5 消息</h4><p>集群中的各个节点通过发送和接收消息(message)来进行通信。消息主要以下五种:</p><ul><li>MEET消息:当发送者接收客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</li><li>PING消息:集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对五个节点中最长时间没有发送过PING消息的节点发送PING消息。</li><li>PONG消息:当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。</li><li>FAIL消息:当一个主节点A判断另一个主节点B进入FAIL状态时，节点A会向集群广播一条关于B的FAIL消息，所有接收到这条消息的节点都会立即将B标记为已下线。</li><li>PUBLISH消息:当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收者都会执行相同的PUBLISH命令。</li></ul><p>Redis集群中的各个节点通过Gossip协议来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG是三种消息实现。三种消息使用相同的消息正文，通过消息头type区分消息。</p><h2 id="4-独立功能的实现"><a href="#4-独立功能的实现" class="headerlink" title="4. 独立功能的实现"></a>4. 独立功能的实现</h2><h3 id="4-1-事务"><a href="#4-1-事务" class="headerlink" title="4.1 事务"></a>4.1 事务</h3><p>Redis 通过MULTI、EXEC、WATCH等命令来说实现事务。<br>事务在执行期间，服务器不会中断事务处理其他请求。</p><h4 id="4-1-1-事务的实现"><a href="#4-1-1-事务的实现" class="headerlink" title="4.1.1 事务的实现"></a>4.1.1 事务的实现</h4><p>一个事务从开始时到结束通常经历3个阶段:</p><ol><li>事务开始: MULTI</li><li>命令入队: <command></li><li>事务执行: EXEC</li></ol><h4 id="4-1-2-WATCH-命令的实现"><a href="#4-1-2-WATCH-命令的实现" class="headerlink" title="4.1.2 WATCH 命令的实现"></a>4.1.2 WATCH 命令的实现</h4><p>WATCH命令是一个乐观锁(optimistic locking)，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少少有一个已经被修改过了，如果是，则拒绝执行事务，并向客户端返回代表事务执行失败的空回复。<br>每个Redis数据库都保存着一个watched_keys字典，这个字典的键时某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。<br>如果有修改命令对数据库键修改过，那么touchWatchKey函数将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，标识该客户端的事务安全性被破坏。</p><p><img src="/media/article/watch-transaction.png" alt="watch"></p><h4 id="4-1-3-事务的ACID性质"><a href="#4-1-3-事务的ACID性质" class="headerlink" title="4.1.3 事务的ACID性质"></a>4.1.3 事务的ACID性质</h4><p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕。</p><p>Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性，从而确保事务的一致性。以下介绍Redis事务可能出错的地方，并说明Redis是如何妥善处理这些错误。</p><ol><li>入队错误：服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被带有入队错误的事务影响。</li><li>执行错误：</li></ol><ul><li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时触发。</li><li>即使在事务的执行过程中发生错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令不会被出错的命令影响。</li></ul><ol start="3"><li>服务器停机：</li></ol><ul><li>如果Redis服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。</li><li>如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，空白的总是一致的。</li><li>如果服务器运行在AOF模式下，那么事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>BGSAVE 是否会存执行BGSAVE命令后客户端请求的命令？</li><li>假如说每秒执行一次AOF持久化，那么Redis从aof缓冲区写入AOF文件时，服务端处理的命令是否会存入缓冲区，是否会进入AOF文件？</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong><em>文中的列表和图片大都引用自<a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a></em></strong></p><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a><br><a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau-Redis源码解析-quicklist</a><br><a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a><br><a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数据结构与对象&quot;&gt;&lt;a href=&quot;#1-数据结构与对象&quot; class=&quot;headerlink&quot; title=&quot;1. 数据结构与对象&quot;&gt;&lt;/a&gt;1. 数据结构与对象&lt;/h2&gt;&lt;h3 id=&quot;1-1-简单动态字符串（SDS）&quot;&gt;&lt;a href=&quot;#1-1-简单动
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Redis" scheme="https://zhongyp.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>How to Write Doc Comments for the Javadoc Tool</title>
    <link href="https://zhongyp.me/java/2019-05-19-javadoc-guide/"/>
    <id>https://zhongyp.me/java/2019-05-19-javadoc-guide/</id>
    <published>2019-05-18T16:00:00.000Z</published>
    <updated>2019-05-19T12:28:11.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.oracle.com/technetwork/articles/javase/index-137868.html" target="_blank" rel="noopener">How to Write Doc Comments for the Javadoc Tool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/articles/javase/index-1378
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型</title>
    <link href="https://zhongyp.me/java/2019-05-06-java-generics/"/>
    <id>https://zhongyp.me/java/2019-05-06-java-generics/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-06-05T11:29:39.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote><p><strong>其他参数术语：</strong><br>参数化的类型(parameterized type)：<code>List&lt;String&gt;</code><br>实际类型参数(type arguments)：<code>String</code><br>泛型(generic type)：<code>List&lt;E&gt;</code><br>形式类型参数(formal parameter types)：<code>E</code><br>无限制通配符类型(unbounded wildcards)：<code>List&lt;?&gt;</code><br>原生态类型(raw type)：<code>List</code><br>有限制类型参数(bounded type parameter)：<code>&lt;E extends Number&gt;</code><br>递归类型限制(recursive type restriction)：<code>&lt;T extends Comparable&lt;T&gt;&gt;</code><br>有限制通配符类型(bounded wildcards)：<code>List&lt;? extends Number&gt;</code><br>泛型方法(generic method)：<code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code><br>类型令牌(type token)：<code>String.class</code></p><p>– 摘自《Effective Java》</p></blockquote><p>Java集合有个缺点：集合对元素类型没有任何限制，这样就会引发一些问题，例如：创建一个只保存Dog对象的集合，但是程序也能将Cat对象放进去。由于把对象放进集合时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此去除集合元素后通常还需要进行强制类型转换。</p><p>为了解决上述问题，从JDK1.5之后，Java引入了“参数化类型（parameterized type）”的概念，Java的参数化类型被称为泛型（Generic）。</p><p>所谓泛型：就是允许在定义类、接口时指定类型形参（type parameters），这个类型形参将在声明变量、创建对象时确定。泛型的作用就是在编译时保证类型安全。</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>定义泛型接口、类示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义接口时指定一个类型形参</span><br><span class="line">public interface List&lt;E&gt;&#123;</span><br><span class="line">    //在接口里，E可以作为类型使用</span><br><span class="line">    void add(E x);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    E asList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>注意：</em></strong></p><ul><li>包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参(type arguments)，从而可以动态生成无数多个逻辑上的子类，但这种子类在物理上并不存在。</li><li>当创建泛型声明的自定义类，为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明。例如：为<code>Apple&lt;T&gt;</code>类定义构造器，其构造器名依然是<code>Apple</code>，而不是<code>Apple&lt;T&gt;</code>，但调用构造器时可以使用<code>Apple&lt;T&gt;</code>，此时T应该为实参类型。</li></ul><h3 id="2-1-从泛型类派生子类"><a href="#2-1-从泛型类派生子类" class="headerlink" title="2.1 从泛型类派生子类"></a>2.1 从泛型类派生子类</h3><p>当创建子类使用泛型接口或类时，不能再包含类型形参。如下代码时错误的：<br><code>public class A extends Apple&lt;T&gt;{}</code><br>正确方式如下：<br><code>public class A extends Apple&lt;String&gt;{}</code></p><p>类的静态变量和方法在所有的实例间共享，所以在静态方法、静态初始化或者静态变量的声明和初始化中不允许使用类型形参。原因见<a href="#4-3-不能声明静态字段的类型为类型参数">4.3 不能声明静态字段的类型为类型参数</a></p><p>由于系统对于泛型类或接口并不会生成真正的泛型类或接口（即逻辑上的子类，并不是生成真正的子类），所以instanceof运算符后不能使用泛型类。（具体原因见<a href="#4-4-不能使用参数化类型强制类型转换或者instanceof">4.4 不能使用参数化类型强制类型转换或者instanceof</a>）如下的代码时错误的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = new ArrayList&lt;String&gt;();</span><br><span class="line">if(cs instanceof List&lt;String&gt;)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-类型通配符"><a href="#2-2-类型通配符" class="headerlink" title="2.2 类型通配符"></a>2.2 类型通配符</h3><p>类型通配符既可以在方法签名中定义形参的类型，也可以用于定义变量的类型。使用通配符比显式声明通配符声明类型形参更加清晰准确，所以在可能的情况下，使用通配符更好。</p><h4 id="2-2-1-不受约束的通配符"><a href="#2-2-1-不受约束的通配符" class="headerlink" title="2.2.1 不受约束的通配符"></a>2.2.1 不受约束的通配符</h4><p>通配符可用于各种情况：作为参数，字段或局部变量的类型;有时作为返回类型（虽然更好的编程实践更具体）。通配符从不用作泛型方法调用，泛型类实例创建或超类型的类型参数。</p><p>如果满足下面的条件任意一个，就可以使用不受约束通配符：</p><ul><li>如果你正在编写可以<strong>使用Object类中提供的方法实现</strong>的方法。</li><li>当代码使用在泛型类中不依赖类型参数方法时。例如：List.size 或者 List.clear。 事实上，Class&lt;?&gt;经常被使用，因为Class<t>中的大多数方法不依赖T。</t></li></ul><p>使用通配符时，不能将元素放入未知类型的集合中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aaa&quot;);//这行代码引起编译时错误。因为不知道list的类型，所以不能往里面放任何元素，除了null。</span><br></pre></td></tr></table></figure><h4 id="2-2-2-上限通配符"><a href="#2-2-2-上限通配符" class="headerlink" title="2.2.2 上限通配符"></a>2.2.2 上限通配符</h4><p>使用<code>? extend type</code>表示所有type泛型类的子类（包含type本身）。</p><h4 id="2-2-3-下限通配符"><a href="#2-2-3-下限通配符" class="headerlink" title="2.2.3 下限通配符"></a>2.2.3 下限通配符</h4><p>使用<code>? super type</code>表示所有type泛型类的父类（包含type本身）。<del>只能用于泛型方法（有待验证）。</del></p><h4 id="2-2-4-通配符捕获和Helper方法"><a href="#2-2-4-通配符捕获和Helper方法" class="headerlink" title="2.2.4 通配符捕获和Helper方法"></a>2.2.4 通配符捕获和Helper方法</h4><p>在一些情况下，编译器会推断一个通配符的类型。例如，一个列表可以被定义为<code>List&lt;?&gt;</code>，当评估一个表达式时，编译器会从代码中推断一个特定类型。此方案称为通配符捕获。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardError &#123;</span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.set(0, i.get(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>i.set</code>方法编译异常，类型参数<code>List&lt;?&gt;</code>为不确定类型参数，所以<code>i.get(0)</code>获取的类型参数不确定，因此<code>i.set</code>方法不能将未知类型放入<code>i</code>中。（其中i.set默认是i.set(Integer,Object)，因为不确定i.get(0)的类型，所以产生编译问题）解决方案如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardFixed &#123;</span><br><span class="line"></span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // Helper method created so that the wildcard can be captured</span><br><span class="line">    // through type inference.</span><br><span class="line">    private &lt;T&gt; void fooHelper(List&lt;T&gt; l) &#123;</span><br><span class="line">        l.set(0, l.get(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-通配符和子类型"><a href="#2-2-5-通配符和子类型" class="headerlink" title="2.2.5 通配符和子类型"></a>2.2.5 通配符和子类型</h4><p>如泛型，继承和子类型中所述，泛型类或接口仅仅因为它们的类型不同而无关。但是，您可以使用通配符在泛型类或接口之间创建关系。下图是Number和Integer之间的继承关系：<br><img src="/media/article/15579245029350.jpg" alt=""></p><h3 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c)&#123;</span><br><span class="line">    for(T o:a)&#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面示例中，定义了一个泛型方法，该泛型方法中定义了一个T类型形参，这个T类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型形参不同的是，方法声明中定义的形参只能在该方法里使用，而接口、类声明中的定义的类型形参则可以在整个接口、类中使用。<br>与类、接口中使用泛型参数不同的是，方法中的泛型参数无需显式传入实际类型参数，根据实参推断类型形参的值。如果编译器不能推断你希望它拥有的类型，可以通过一个显示的类型参数（explicit type parameter）来告诉它要使用哪种类型。<br>泛型方法的用法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,S&gt; 返回值类型 方法名（形参列表）&#123;</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><em>提示：</em></strong><br>如果某个方法中一个形参（a）的类型或返回值类型依赖于另一个形参（b）的类型，则形参（b）的类型声明不应该使用通配符，因为形参（a）、或返回值与该形参（b）的类型，如果形参（b）的类型无法确定，程序无法定义形参（a）的类型。在这种情况下，<strong><em>只能考虑使用在方法签名中声明类型形参</em></strong>。</p></blockquote><p>类型通配符与显式声明类型形参区别：</p><ul><li>类型通配符即可在方法签名中定义形参的类型，也可以用于定义变量的类型。但泛型方法中类型形参必须在对应方法中显式声明。</li><li><strong><em>泛型方法允许类型形参用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系。如果没有这样的依赖关系，不应该使用泛型方法。</em></strong></li></ul><h3 id="2-4-泛型使用准则"><a href="#2-4-泛型使用准则" class="headerlink" title="2.4 泛型使用准则"></a>2.4 泛型使用准则</h3><blockquote><p>“in”变量：in变量向代码提供数据。想象复制方法有两个参数：<code>copy(src, dest)</code>。<code>src</code>参数提供复制数据，因此时”in”参数。<br>“out”变量：out变量保存数据以供其他地方使用。在复制的例子中，<code>copy(src, dest)</code>，<code>dest</code>参数接受数据，因此时”out”参数。</p></blockquote><ul><li>使用<code>extends</code>关键字定义带有上限通配符的“in”变量。</li><li>使用<code>super</code>关键字定义带有下限通配符的“out”变量。</li><li>在可以使用Object类中定义的方法访问“in”变量的情况下，使用无界通配符。</li><li>在代码需要作为“in”和“out”变量访问的情况下，不要使用通配符。</li></ul><h2 id="3-泛型的擦除与转换"><a href="#3-泛型的擦除与转换" class="headerlink" title="3. 泛型的擦除与转换"></a>3. 泛型的擦除与转换</h2><p>泛型被引入Java语言，以便在编译时提供更严格的类型检查并支持通用编程（向上兼容）。为了实现泛型，Java编译器将类型擦除应用于：</p><ul><li>使用边界替换所有在泛型中的类型参数或者如果类型参数是无界的则使用<code>Object</code>替换。因此生成的字节码只包含通用的类，接口和方法。</li><li>如果必要，插入类型强制转换来保证类型安全。</li><li>生成桥接方法以保留扩展泛型类型中的多态性。</li></ul><p>对于以上3点，1和3可能在<a href="#3-1-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E6%93%A6%E9%99%A4">3.1</a>和<a href="#3-2-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E6%A1%A5%E6%96%B9%E6%B3%95">3.2</a>中会详细说明，但是第二点可能不是那么清楚，如果有必要，类型擦除时，会进行强制类型转换。一般这种情况包括：</p><ul><li>方法的返回类型是类型参数；</li><li>在访问数据域时，域的类型是一个类型参数。</li></ul><p>例如：<br>项目中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println(list1.get(0));</span><br></pre></td></tr></table></figure></p><p>编译后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list1 = new ArrayList();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println((String)list1.get(0));</span><br></pre></td></tr></table></figure></p><p>字节码，字节码命令请参阅<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Chapter 6. The Java Virtual Machine Instruction Set</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">       0: new           #3                  // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #4                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #5                  // String Hell</span><br><span class="line">      11: invokeinterface #6,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      16: pop</span><br><span class="line">      17: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: iconst_0</span><br><span class="line">      22: invokeinterface #8,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">      27: checkcast     #9                  // class java/lang/String 强制类型转换校验是否为String类型</span><br><span class="line">      30: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      33: return</span><br></pre></td></tr></table></figure></p><p>上面的例子说明，编译器在擦除泛型代码时，确实保留了List<string>的相关信息，但是你无法找到列表对象本身的T=String，参阅自<a href="https://stackoverflow.com/questions/339699/java-generics-type-erasure-when-and-what-happens/339708#339708" target="_blank" rel="noopener">Java generics type erasure: when and what happens?</a>Jon Skeet的answer。</string></p><p>详细了解请参阅<a href="https://stackoverflow.com/questions/55084504/insert-type-casts-if-necessary-to-preserve-type-safety" target="_blank" rel="noopener">Insert type casts if necessary to preserve type safety</a></p><h3 id="3-1-泛型方法的擦除"><a href="#3-1-泛型方法的擦除" class="headerlink" title="3.1 泛型方法的擦除"></a>3.1 泛型方法的擦除</h3><p>Java编译器也会擦除泛型方法中的类型参数。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static &lt;T&gt; int count(T[] anArray, T elem)&#123;</span><br><span class="line"></span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(T e : anArray)&#123;</span><br><span class="line">        if(e.equals(elem))&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为T是无限制的，所以Java编译器会使用Object代替它，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int count(Object[] anArray, Object elem) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (Object e : anArray)</span><br><span class="line">        if (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-类型擦除的影响和桥方法"><a href="#3-2-类型擦除的影响和桥方法" class="headerlink" title="3.2 类型擦除的影响和桥方法"></a>3.2 类型擦除的影响和桥方法</h3><p>在编译扩展参数化类或实现参数化接口的类或接口时，编译器可能需要创建一个称为桥接方法的合成方法，作为类型擦除过程的一部分。您通常不需要担心桥接方法，但如果出现在堆栈跟踪中，您可能会感到困惑。</p><p>生成桥接方法以保留扩展泛型类型中的多态性。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T data;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = mn;            // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);     </span><br><span class="line">Integer x = mn.data;    // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>类型擦除后, 代码变成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);</span><br><span class="line">Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>代码执行逻辑如下：</p><p><code>n.setData(&quot;Hello&quot;)</code>使得MyNode类对象中的<code>setData(Object)</code>被执行。<br>在<code>setData(Object)</code>方法体内，对象的数据字段引用被分配为String。<br>通过mn引用的相同对象数据字段，可以访问、且期望是Interger类型。<br>尝试分配String到Integer造成ClassCastException。</p><p>类型擦除后代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    public Object data;</span><br><span class="line"></span><br><span class="line">    public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类型擦除之后，方法签名不匹配。 Node方法变为setData（Object），MyNode方法变为setData（Integer）。因此，MyNode setData方法不会覆盖Node setData方法。 为了解决这个问题并在类型擦除后保留泛型类型的多态性，Java编译器会生成一个桥接方法，以确保子类型按预期工作。对于MyNode类，编译器为setData生成以下桥接方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    // Bridge method generated by the compiler</span><br><span class="line">    //</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>桥接方法与类型擦除后的Node类的setData方法具有相同的方法签名，委托给原始的setData方法(桥接方法在字节码中可见，<code>javap -c class</code>)。</p><h3 id="3-3-不可具体化类型"><a href="#3-3-不可具体化类型" class="headerlink" title="3.3 不可具体化类型"></a>3.3 不可具体化类型</h3><p>可具体化类型是在运行时类型信息完全可用的一种类型。包括基本类型，非泛型类型，原始类型，无界的通配符调用。唯一可具体化参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<br>不可具体化类型是类型信息在编译时通过类型擦除被删除————调用未定义为无界通配符的泛型类型。不可具体化的类型在运行时不是所有信息都可用。不可具体化类型的示例是<code>List &lt;String&gt;</code>和<code>List &lt;Number&gt;</code>; JVM无法在运行时区分这些类型。如<a href="#4-泛型的限制">4 泛型的限制</a>中所示，在某些情况下，不能使用不可具体化的类型：例如，在<code>instanceof</code>表达式的实例中，或作为数组中的元素。</p><h3 id="3-4-堆污染"><a href="#3-4-堆污染" class="headerlink" title="3.4 堆污染"></a>3.4 堆污染</h3><p>堆污染发生在当参数化类型的变量引用不是该参数化类型的对象时。如果程序执行某些操作，在编译时产生未经检查的警告，则会出现这种情况。如果在编译时（在编译时类型检查规则的限制内）或在运行时，一个包含参数化类型操作的正确性不能被验证，则会生成未经检查的警告。例如，在混合原始类型和参数化类型时，或者在执行未经检查的强制转换时，会发生堆污染。</p><p>在通常情况下，当所有代码在相同时间被编译，编译器为潜在的堆污染产生一个未经检查警告来引起你的注意。如果你分开编译代码的各个部分，很难检查出堆污染的潜在风险。如果你确保你的代码编译没有警告，则不会有堆污染可以发生。</p><h3 id="3-5-使用不可具体化形参的可变参数方法的潜在漏洞"><a href="#3-5-使用不可具体化形参的可变参数方法的潜在漏洞" class="headerlink" title="3.5 使用不可具体化形参的可变参数方法的潜在漏洞"></a>3.5 使用不可具体化形参的可变参数方法的潜在漏洞</h3><p>包含可变输入参数泛型方法可以造成堆污染。<br>考虑如下class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBuilder &#123;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) &#123;</span><br><span class="line">    for (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void faultyMethod(List&lt;String&gt;... l) &#123;</span><br><span class="line">    Object[] objectArray = l;     // Valid</span><br><span class="line">    objectArray[0] = Arrays.asList(42);</span><br><span class="line">    String s = l[0].get(0);       // ClassCastException thrown here</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下例子，<code>HeapPollutionExample</code>使用<code>ArrayBuilder</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HeapPollutionExample &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stringListA = new ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; stringListB = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.addToList(stringListA, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;);</span><br><span class="line">    ArrayBuilder.addToList(stringListB, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listOfStringLists =</span><br><span class="line">      new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    ArrayBuilder.addToList(listOfStringLists,</span><br><span class="line">      stringListA, stringListB);</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译时，如下<code>ArrayBuilder.addToList</code>方法的定义将产生warning：<br><code>warning: [varargs] Possible heap pollution from parameterized vararg type T</code><br>当编译器遇到一个可变参数方法，它转换可变形参为数组。然而，Java编程语言不允许参数化类型数组的创建。在<code>ArrrayBuilder.addToList</code>方法中，编译器转换可变形参<code>T...</code>要素为<code>T[]</code>要素。因为类型擦除，编译器转换可变形参为<code>Object[]</code>要素。所以，有堆污染的可能性。<br>如下声明分配可变形参给对象数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray = l;</span><br></pre></td></tr></table></figure></p><p>这种声明可能引起堆污染。可以将与可变形参<code>l</code>的参数化类型匹配的值分配给变量objectArray，因此可以分配给<code>l</code>。然而，在此声明中，编译器不能生成一个未经检查警告。编译器早已在转换可变形参<code>List&lt;String&gt;...l</code> 到形参<code>List[] l</code>时生成警告。这个声明是有效的；<code>l</code>变量的类型是<code>List[]</code>，是<code>Object[]</code>的子类型。</p><p>因此，如果将任何类型的List对象分配给objectArray数组的任何数组组件，编译器不会发出警告或错误，如下所示：<br><code>ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</code><br>在运行时，JVM在以下语句中抛出<code>ClassCastException</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ClassCastException thrown here</span><br><span class="line">String s = l[0].get(0);</span><br></pre></td></tr></table></figure></p><p>存储在变量<code>l</code>的第一个数组组件中的对象具有<code>List&lt;Integer&gt;</code>类型，但此语句需要一个<code>List &lt;String&gt;</code>类型的对象。</p><h3 id="3-6-使用不可具体化的形参防止可变参数方法发出警告"><a href="#3-6-使用不可具体化的形参防止可变参数方法发出警告" class="headerlink" title="3.6 使用不可具体化的形参防止可变参数方法发出警告"></a>3.6 使用不可具体化的形参防止可变参数方法发出警告</h3><p>如果声明具有参数化类型参数的可变参数方法，并确保方法体不会因可变参数形参处理不当而抛出<code>ClassCastException</code>或其他类似异常，你可以通过给静态和非构造方法声明添加如下的注解防止编译器给这些可变参数方法生成警告：<br><code>@SafeVarargs</code><br><code>@SafeVarargs</code>注解是方法约定的记录部分;这个注释断言该方法的实现不会不正确地处理可变形参。<br> 尽管不太可取，但通过在方法声明中添加以下内容来消除此类警告也是可以的：<br><code>@SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})</code><br>但是，此方法不会消除从方法的调用点生成的警告。如果您不熟悉<code>@SuppressWarnings</code>语法，请参阅注释。</p><h2 id="4-泛型的限制"><a href="#4-泛型的限制" class="headerlink" title="4 泛型的限制"></a>4 泛型的限制</h2><h3 id="4-1-不能使用基本类型实例化通用类型"><a href="#4-1-不能使用基本类型实例化通用类型" class="headerlink" title="4.1 不能使用基本类型实例化通用类型"></a>4.1 不能使用基本类型实例化通用类型</h3><p>考虑如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public Pair(K key, V value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当创建一个<code>Pair</code>对象，你不能为类型参数<code>K</code>或者<code>V</code>替换成基本类型：<br><code>Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);  // compile-time error</code><br>你仅可以为类型参数<code>K</code>或者<code>V</code>替换非基本类型：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);</code><br>Java编译器自动装箱<code>8</code>为<code>Integer.valueOf(8)</code>和<code>a</code>为<code>Character(&#39;a&#39;)</code>：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character(&#39;a&#39;));</code></p><h3 id="4-2-不能创建类型参数实例"><a href="#4-2-不能创建类型参数实例" class="headerlink" title="4.2 不能创建类型参数实例"></a>4.2 不能创建类型参数实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">    E elem = new E();  // compile-time error</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种解决方案，你可以创建一个类型参数对象通过反射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">    E elem = cls.newInstance();   // OK</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以调用<code>append</code>方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = new ArrayList&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure></p><h3 id="4-3-不能声明静态字段的类型为类型参数"><a href="#4-3-不能声明静态字段的类型为类型参数" class="headerlink" title="4.3 不能声明静态字段的类型为类型参数"></a>4.3 不能声明静态字段的类型为类型参数</h3><p>类的静态字段是类等级变量，被当前类的所有非静态对象共享。因此，类型参数的静态字段是不允许的。考虑如下类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MobileDevice&lt;T&gt; &#123;</span><br><span class="line">    private static T os;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类型参数的静态字段被允许，如下的代码将会混乱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MobileDevice&lt;Smartphone&gt; phone = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;Pager&gt; pager = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;TabletPC&gt; pc = new MobileDevice&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>因为静态字段<code>os</code>被<code>phone</code>,<code>pager</code>和<code>pc</code>共享，什么是<code>os</code>的真实类型？在相同的时间它不可能是<code>Smartphone</code>，<code>Pager</code>，和<code>TablePc</code>。因此你不能创建类型参数静态字段。</p><h3 id="4-4-不能使用参数化类型强制类型转换或者instanceof"><a href="#4-4-不能使用参数化类型强制类型转换或者instanceof" class="headerlink" title="4.4 不能使用参数化类型强制类型转换或者instanceof"></a>4.4 不能使用参数化类型强制类型转换或者<code>instanceof</code></h3><p>因为Java编译器在泛型代码中擦除所有类型参数，您无法验证在运行时使用泛型类型的参数化类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>传递到<code>rtti</code>方法的参数化类型集合是：<br><code>S = { ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, ... }</code><br>运行时不保持对类型参数的跟踪，因此它不能告诉<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>之间的不同。你最多是使用无限通配符来验证列表是否为ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;?&gt;) &#123;  // OK; instanceof requires a reifiable type</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通常，你不能强制转换参数化类型，除非它通过无限制通配符参数化。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  // compile-time error</span><br></pre></td></tr></table></figure></p><p>但是，在一些情况下，编译器知道类型参数总是有效的，允许强制类型转换。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  // OK</span><br></pre></td></tr></table></figure></p><h3 id="4-5-不能创建参数化类型的数组"><a href="#4-5-不能创建参数化类型的数组" class="headerlink" title="4.5 不能创建参数化类型的数组"></a>4.5 不能创建参数化类型的数组</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</span><br></pre></td></tr></table></figure></p><p>如下代码说明在不同类型插入列表是发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] strings = new String[2];</span><br><span class="line">strings[0] = &quot;hi&quot;;   // OK</span><br><span class="line">strings[1] = 100;    // An ArrayStoreException is thrown.</span><br></pre></td></tr></table></figure></p><p>如果你使用泛型列表尝试相同的事情，将会有如下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&apos;s allowed</span><br><span class="line">stringLists[0] = new ArrayList&lt;String&gt;();   // OK</span><br><span class="line">stringLists[1] = new ArrayList&lt;Integer&gt;();  // An ArrayStoreException should be thrown,</span><br><span class="line">                                            // but the runtime can&apos;t detect it.</span><br></pre></td></tr></table></figure></p><p> 如果参数化列表数组是允许的，之前的代码将失败抛出<code>ArrayStoreException</code>。</p><h3 id="4-6-不能创建、捕获或者抛出参数化类型对象"><a href="#4-6-不能创建、捕获或者抛出参数化类型对象" class="headerlink" title="4.6 不能创建、捕获或者抛出参数化类型对象"></a>4.6 不能创建、捕获或者抛出参数化类型对象</h3><p>泛型类也不能直接或间接继承自Throwable。原因是因为在编译期和运行时都必须知道异常的确切类型。例如如下类将不编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Extends Throwable indirectly</span><br><span class="line">class MathException&lt;T&gt; extends Exception &#123; /* ... */ &#125;    // compile-time error</span><br><span class="line"></span><br><span class="line">// Extends Throwable directly</span><br><span class="line">class QueueFullException&lt;T&gt; extends Throwable &#123; /* ... */ // compile-time error</span><br></pre></td></tr></table></figure></p><p>一个方法不能捕获一个类型参数的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (J job : jobs)</span><br><span class="line">            // ...</span><br><span class="line">    &#125; catch (T e) &#123;   // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，你可以在一个<code>throws</code>子句中使用类型参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parser&lt;T extends Exception&gt; &#123;</span><br><span class="line">    public void parse(File file) throws T &#123;     // OK</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出上述泛化的代码。</p><h3 id="4-7-不能重载形式类型参数擦除后相同原始类型的方法"><a href="#4-7-不能重载形式类型参数擦除后相同原始类型的方法" class="headerlink" title="4.7 不能重载形式类型参数擦除后相同原始类型的方法"></a>4.7 不能重载形式类型参数擦除后相同原始类型的方法</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public void print(Set&lt;String&gt; strSet) &#123; &#125;</span><br><span class="line">    public void print(Set&lt;Integer&gt; intSet) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重载将共享相同的类文件表示，并将生成编译时错误。</p><h2 id="5-泛型与数组"><a href="#5-泛型与数组" class="headerlink" title="5. 泛型与数组"></a>5. 泛型与数组</h2><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型<code>Sub[]</code>就是<code>Super[]</code>的子类型。<br>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h2 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h2><p>如果以上都看完了，可以访问<a href="https://docs.oracle.com/javase/tutorial/java/generics/QandE/generics-questions.html" target="_blank" rel="noopener">Questions</a>试试自己是否真的懂了。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a><br><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">Effective Java</a><br><a href="https://docs.oracle.com/javase/tutorial/java/generics/" target="_blank" rel="noopener">Java Document Generic</a><br><a href="http://www.jiangjun.name/thinking-in-java/chapter15" target="_blank" rel="noopener">第十五章 泛型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他参数术语：&lt;/strong&gt;&lt;br&gt;参数化的类型(parameterize
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java</title>
    <link href="https://zhongyp.me/java/2019-05-02-effective-java/"/>
    <id>https://zhongyp.me/java/2019-05-02-effective-java/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-06-26T02:44:53.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘自《Effective Java》</p></blockquote><h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><h2 id="一、创建和销毁对象"><a href="#一、创建和销毁对象" class="headerlink" title="一、创建和销毁对象"></a>一、创建和销毁对象</h2><h3 id="1-考虑使用静态工厂方法替代构造器"><a href="#1-考虑使用静态工厂方法替代构造器" class="headerlink" title="1.考虑使用静态工厂方法替代构造器"></a>1.考虑使用静态工厂方法替代构造器</h3><ul><li>静态工厂方法与构造器不同的第一大优势在于，它们有名称，不必和类名相同。</li><li>静态工厂方法与构造器不同的第二大优势在于不必在每次调用他们的时候都创建一个新的对象。</li><li>静态工厂方法与构造器不同的第三大优势在于他们可以返回原类型的任何子类型对象。</li><li>静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们是代码变得更加简洁。</li><li>静态工厂方法的主要缺点在于类如果不含公有的活着受保护的构造器，就不能被子类化。</li><li>静态工厂方法第二个缺点在于它们与其他的静态方法实际上没有任何区别。</li></ul><h3 id="2-遇到多个构造器参数时要考虑用构建器"><a href="#2-遇到多个构造器参数时要考虑用构建器" class="headerlink" title="2.遇到多个构造器参数时要考虑用构建器"></a>2.遇到多个构造器参数时要考虑用构建器</h3><h3 id="3-用私有构造器或着枚举类强化Singleton属性"><a href="#3-用私有构造器或着枚举类强化Singleton属性" class="headerlink" title="3.用私有构造器或着枚举类强化Singleton属性"></a>3.用私有构造器或着枚举类强化Singleton属性</h3><h3 id="4-通过私有构造器强化不可实例化的能力"><a href="#4-通过私有构造器强化不可实例化的能力" class="headerlink" title="4.通过私有构造器强化不可实例化的能力"></a>4.通过私有构造器强化不可实例化的能力</h3><h3 id="5-避免创建不必要的对象"><a href="#5-避免创建不必要的对象" class="headerlink" title="5.避免创建不必要的对象"></a>5.避免创建不必要的对象</h3><h3 id="6-消除过期的对象引用"><a href="#6-消除过期的对象引用" class="headerlink" title="6.消除过期的对象引用"></a>6.消除过期的对象引用</h3><ul><li>只要类是自己管理内存，程序员就应该警惕内存泄露问题。</li><li>内存泄漏的另一个常见来源是缓存。</li><li>内存的第三个常见来源是监听器和其他回调。确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用。</li></ul><h3 id="7-避免使用终结方法"><a href="#7-避免使用终结方法" class="headerlink" title="7.避免使用终结方法"></a>7.避免使用终结方法</h3><ul><li>终结方法（finalizer）通常是不可预测的，也是危险的，一般情况下是不必要的。</li><li>使用终结方法有非常严重的（Severe）性能损失。</li></ul><h2 id="二、对于所有对象都通用的方法"><a href="#二、对于所有对象都通用的方法" class="headerlink" title="二、对于所有对象都通用的方法"></a>二、对于所有对象都通用的方法</h2><h3 id="8-覆盖equals时请遵守通用约定"><a href="#8-覆盖equals时请遵守通用约定" class="headerlink" title="8.覆盖equals时请遵守通用约定"></a>8.覆盖equals时请遵守通用约定</h3><ul><li>类的每个实例本质都是唯一的。</li><li>不关心类是否提供了“逻辑相等（logical equality）“的测试功能。</li><li>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。</li><li>类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用。</li><li>在覆盖equals方法时，必须遵守：<strong>自反性（reflexive）、对称性（symmetric）、传递性（transitive）、一致性（consistent）和对于任何非null的引用，equals(null)必须返回false</strong>。</li></ul><blockquote><p>里氏替换原则（Liskov substitution principle）认为，一个类型的任何重要属性也将适用它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行的很好。</p></blockquote><ul><li>覆盖equals时总要覆盖hashCode。</li><li>不要企图让equals方法过于智能。</li><li>不要将equals声明中的Object对象替换为其他的类型。</li></ul><h3 id="9-覆盖equals总要覆盖hashCode"><a href="#9-覆盖equals总要覆盖hashCode" class="headerlink" title="9.覆盖equals总要覆盖hashCode"></a>9.覆盖equals总要覆盖hashCode</h3><ul><li>在应用程序的执行期间，只要对象的equals方法比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li><li>如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。<strong>（违反第二条）</strong></li><li>如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定产生不同的整数结果。但是程序猿应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列（hash table）的性能。</li></ul><h3 id="10-始终要覆盖toString"><a href="#10-始终要覆盖toString" class="headerlink" title="10.始终要覆盖toString()"></a>10.始终要覆盖toString()</h3><h3 id="11-谨慎覆盖clone"><a href="#11-谨慎覆盖clone" class="headerlink" title="11.谨慎覆盖clone()"></a>11.谨慎覆盖clone()</h3><ul><li>如果专门为了继承而设计的类，覆盖了clone方法，覆盖版本的clone方法就应该模拟Object.clone的行为：他应该声明为protected、抛出CloneNotSupportedException异常，并且该类不应该实现Cloneable接口。</li><li>如果用线程安全的类实现Cloneable接口，要记得它的clone方法必须得到同步。</li><li>任何实现Cloneable接口的类都应该用一个公有的方法覆盖clone，首先调用super.clone，再修正任何需要修正的域。</li><li>另一种实现对象拷贝的好方法是提供一个拷贝构造器(copy constructor)或者拷贝工厂(copy factory)。</li></ul><h3 id="12-考虑实现Comparable接口"><a href="#12-考虑实现Comparable接口" class="headerlink" title="12.考虑实现Comparable接口"></a>12.考虑实现Comparable接口</h3><h2 id="三、类和接口"><a href="#三、类和接口" class="headerlink" title="三、类和接口"></a>三、类和接口</h2><h3 id="13-使类和成员的可访问性最小化"><a href="#13-使类和成员的可访问性最小化" class="headerlink" title="13.使类和成员的可访问性最小化"></a>13.使类和成员的可访问性最小化</h3><ul><li>尽可能的使每个类或者成员不被外界访问。</li><li>实例域绝不能使公有的。</li><li>类具有共有的静态final数组域，或者返回这种域的访问方法，这种几乎总是错误的。</li><li>公有类都不应该包含公有域，除了公有静态final域的特殊情形外。</li><li>确保公有静态final域所引用的对象都是不可变的。</li></ul><h3 id="14-在公有类中使用访问方法而非公有域"><a href="#14-在公有类中使用访问方法而非公有域" class="headerlink" title="14.在公有类中使用访问方法而非公有域"></a>14.在公有类中使用访问方法而非公有域</h3><ul><li>如果类可以在它所在的包的外部进行访问，就提供访问方法。</li><li>如果类是包级私有的，或者私有的嵌套类，直接暴露它的数据域并没有本质的错误。</li></ul><h3 id="15-使可变性最小化"><a href="#15-使可变性最小化" class="headerlink" title="15.使可变性最小化"></a>15.使可变性最小化</h3><p>不可变类只是实例不能被修改的类。每个实例中包含的信息都必须在创建该实例的时候提供，并在对象的整个生命周期固定不变。</p><ul><li>不要提供任何会修改对象状态的方法。</li><li>保证类不被扩展。</li><li>使所有的域都是final的。</li><li>使所有的域都成为私有的。</li><li>确保对于任何可变组件的互斥访问。</li></ul><h3 id="16-复合优先于继承"><a href="#16-复合优先于继承" class="headerlink" title="16.复合优先于继承"></a>16.复合优先于继承</h3><ul><li>与方法调用不同的是，继承打破了封装性。</li></ul><h3 id="17-要么为继承而设计，并提供文档说明，要么就禁止继承。"><a href="#17-要么为继承而设计，并提供文档说明，要么就禁止继承。" class="headerlink" title="17.要么为继承而设计，并提供文档说明，要么就禁止继承。"></a>17.要么为继承而设计，并提供文档说明，要么就禁止继承。</h3><ul><li>构造器绝不能调用可被覆盖的方法。</li><li>无论是clone还是readObject，都不可以调用可覆盖的方法，不管是以直接还是间接的方式。</li></ul><h3 id="18-接口优于抽象类"><a href="#18-接口优于抽象类" class="headerlink" title="18.接口优于抽象类"></a>18.接口优于抽象类</h3><ul><li>现有的类可以很容易被更新，以实现新的接口。</li><li>接口是定义mixin(混合类型)的理想选择。</li><li>接口允许构造非层次结构的类型框架。</li><li>接口使得安全的增强类的功能成为可能。</li><li>通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的优点结合起来。</li></ul><h3 id="19-接口只用于定义类型"><a href="#19-接口只用于定义类型" class="headerlink" title="19.接口只用于定义类型"></a>19.接口只用于定义类型</h3><ul><li>常量接口模式是对接口的不良使用。</li></ul><h3 id="20-类层级优于标签类"><a href="#20-类层级优于标签类" class="headerlink" title="20.类层级优于标签类"></a>20.类层级优于标签类</h3><h3 id="21-用函数对象表示策略"><a href="#21-用函数对象表示策略" class="headerlink" title="21.用函数对象表示策略"></a>21.用函数对象表示策略</h3><p>策略模式</p><h3 id="22-优先考虑静态成员类"><a href="#22-优先考虑静态成员类" class="headerlink" title="22.优先考虑静态成员类"></a>22.优先考虑静态成员类</h3><p>静态类成员：Map中的Entry<br>非静态类成员：Iterator<br>匿名类：无法实例化，无法声明实现接口，扩展类，无法调用任何成员除了从它的超类继承的，必须简洁，常用来作为函数对象，即函数表达式；另一种是创建过程对象（Runable）<br>局部类：声明局部变量的地方都可以声明局部类。</p><p>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中。</p><h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h3 id="23-请不要在新代码中使用原生态类型"><a href="#23-请不要在新代码中使用原生态类型" class="headerlink" title="23.请不要在新代码中使用原生态类型"></a>23.请不要在新代码中使用原生态类型</h3><ul><li>如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。</li><li>泛型有子类化的规则，虽然可以将List<string>传递给List的参数，但是不能将它传给类型List<object>的参数。</object></string></li><li>如果使用像List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<object>这样的参数化类型，则不会。</object></li><li>在类文字中必须使用原生态类型。</li><li>在参数化类型而非无限制通配符类型上使用instanceof操作法是非法的。</li></ul><h3 id="24-消除非受检警告"><a href="#24-消除非受检警告" class="headerlink" title="24.消除非受检警告"></a>24.消除非受检警告</h3><ul><li>尽可能消除每一个非受检警告</li><li>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，只有这种情况下可以用@SuppressWarnings(“unchecked”)注解来禁止这条警告。</li><li>应该在尽可能小的范围内使用SuppressWarnings注解。</li><li>每当使用SuppressWarnings注解，都要增加注释，说明为什么这么做是安全的。</li></ul><h3 id="25-列表优于数组"><a href="#25-列表优于数组" class="headerlink" title="25.列表优于数组"></a>25.列表优于数组</h3><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型。<br><strong>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</strong></p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p><strong>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</strong></p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型时无限制通配符类型，如List&lt;?&gt;和Map&lt;?,?&gt;。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h3 id="26-优先考虑泛型"><a href="#26-优先考虑泛型" class="headerlink" title="26.优先考虑泛型"></a>26.优先考虑泛型</h3><ul><li>不能创建不可具体化的（non-reifiable）类型的数组。解决方案是新建Object数组强制转换为不可具体化类型，确保未受检的转换是安全的，就要尽可能小的范围中禁止警告。</li></ul><h3 id="27-优先考虑泛型方法"><a href="#27-优先考虑泛型方法" class="headerlink" title="27.优先考虑泛型方法"></a>27.优先考虑泛型方法</h3><h3 id="28-利用有限制通配符来提升API的灵活性"><a href="#28-利用有限制通配符来提升API的灵活性" class="headerlink" title="28.利用有限制通配符来提升API的灵活性"></a>28.利用有限制通配符来提升API的灵活性</h3><ul><li>为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。</li><li>如果类型参数只在方法声明中出现一次，就可以用通配符取代它，如果是无限制的类型参数，就用无限制的通配符取代它。</li><li>如果类的用户必须考虑通配符类型，类的API或许就会出错。</li><li>不要用通配符类型作为返回类型，除了为用户提供额外的灵活性之外，它还会强制用户在客户端代码中使用通配符类型。</li></ul><h3 id="29-优先考虑类型安全的异构容器"><a href="#29-优先考虑类型安全的异构容器" class="headerlink" title="29.优先考虑类型安全的异构容器"></a>29.优先考虑类型安全的异构容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Favorites&#123;</span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);</span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不像普通的map，它的<strong>所有键都是不同类型</strong>的，因此Favorites称作类型安全的异构容器（typesafe heterogeneous container）。</p><p>集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数，但是可以通过将类型参数放在键上而不是容器上来避开这一限制。</p><h2 id="五、枚举和注解"><a href="#五、枚举和注解" class="headerlink" title="五、枚举和注解"></a>五、枚举和注解</h2><h3 id="30-用enum代替int常量"><a href="#30-用enum代替int常量" class="headerlink" title="30.用enum代替int常量"></a>30.用enum代替int常量</h3><p>只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。</p><p>如果多个枚举常量同时共享相同的行为，则考虑策略枚举（strategy enum）。</p><h3 id="31-用实例代替序数索引"><a href="#31-用实例代替序数索引" class="headerlink" title="31.用实例代替序数索引"></a>31.用实例代替序数索引</h3><p>永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Ensemble&#123;</span><br><span class="line">    SOLO(1),DUET(2);</span><br><span class="line">    private final int numberOfMusicians;</span><br><span class="line">    Ensemble(int size)&#123;this.numberOfMusicians = size;&#125;</span><br><span class="line">    public int numberOfMusicians()&#123;return numberOfMusicians;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="32-用EnumSet代替位域"><a href="#32-用EnumSet代替位域" class="headerlink" title="32.用EnumSet代替位域"></a>32.用EnumSet代替位域</h3><h3 id="33-用EnumMap代替序数索引"><a href="#33-用EnumMap代替序数索引" class="headerlink" title="33.用EnumMap代替序数索引"></a>33.用EnumMap代替序数索引</h3><h3 id="34-用接口模拟可伸缩的枚举"><a href="#34-用接口模拟可伸缩的枚举" class="headerlink" title="34.用接口模拟可伸缩的枚举"></a>34.用接口模拟可伸缩的枚举</h3><h3 id="35-注解优先于命名模式"><a href="#35-注解优先于命名模式" class="headerlink" title="35.注解优先于命名模式"></a>35.注解优先于命名模式</h3><h3 id="36-坚持使用Override注解"><a href="#36-坚持使用Override注解" class="headerlink" title="36.坚持使用Override注解"></a>36.坚持使用Override注解</h3><h3 id="37-用标记接口定义类型"><a href="#37-用标记接口定义类型" class="headerlink" title="37.用标记接口定义类型"></a>37.用标记接口定义类型</h3><h2 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h2><h3 id="38-检查参数的有效性"><a href="#38-检查参数的有效性" class="headerlink" title="38.检查参数的有效性"></a>38.检查参数的有效性</h3><p>每当编写方法或者构造器时，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显示的检查来实施这些限制。<br>非公有的方法通常应该使用断言（assertion）来检查它们的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(long a[], int offset, int length)&#123;</span><br><span class="line">    assert a != null;</span><br><span class="line">    assert offset &gt;= 0 &amp;&amp; offset &lt;= a.length;</span><br><span class="line">    assert length &gt;= 0 &amp;&amp; length &lt;= a.length - offset;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="39-必要时进行保护性拷贝"><a href="#39-必要时进行保护性拷贝" class="headerlink" title="39.必要时进行保护性拷贝"></a>39.必要时进行保护性拷贝</h3><p>对于构造器的每个可变参数进行保护性拷贝（defensive copy）是必要的。<br>保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    this.start = start;</span><br><span class="line">    this.end = end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中虽然增加约束条件，但是Date在此对象外部还是可以被修改的，因为Date是引用传递，所以为避免这种问题，使用备份对象，而不是使用原始对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    this.start = new Date(start.getTime);</span><br><span class="line">    this.end = new Date(end.getTime);</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。<br>如果类中提供了对其可变内部成员的访问能力，则使它返回可变内部域的保护性拷贝即可。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date start = new Date();</span><br><span class="line">Date end = new Date();</span><br><span class="line">Period p = new Period(start, end);</span><br><span class="line">p.end().setYear(78);//end()方法返回Date对象，Period中提供setYear改变Date属性。</span><br></pre></td></tr></table></figure><p>为了保证传入Period中的start或者end不被改变，只需要修改Period中获取start和end的访问方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Date start()&#123;</span><br><span class="line">    return new Date(start.getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Date end()&#123;</span><br><span class="line"></span><br><span class="line">    return new Date(end.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数的保护性拷贝不仅仅针对不可变类。如果客户端提供的对象是可变的且该对象不允许在你的类对象中变化，就必须对该对象进行保护性拷贝。</p><p>如果拷贝成本受到限制，并且信任它的客户端不会不恰当的修改组件，就可以在文档中声明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。</p><h3 id="40-谨慎设计方法签名"><a href="#40-谨慎设计方法签名" class="headerlink" title="40.谨慎设计方法签名"></a>40.谨慎设计方法签名</h3><p>谨慎的选择方法的名称；<br>不要过于追求提供便利的方法。只有当一项操作被经常用到的时候，才考虑为它提供快捷方式（shorthand）。如果不确定还是不提供快捷为好；<br>避免过长的参数列表；</p><h3 id="41-慎用重载"><a href="#41-慎用重载" class="headerlink" title="41.慎用重载"></a>41.慎用重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionClassifier&#123;</span><br><span class="line"></span><br><span class="line">    public static String classify(Set&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;set&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(List&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;list&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(Collection&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;unknow&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">            new HashSet&lt;String&gt;(),</span><br><span class="line">            new ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">            new HashMap&lt;String, String&gt;().value()</span><br><span class="line">        &#125;;</span><br><span class="line">        for(Collection&lt;?&gt; c : collections)</span><br><span class="line">            System.out.println(classify(c)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果是打印“unknow”三次。</p><h3 id="42-慎用可变参数"><a href="#42-慎用可变参数" class="headerlink" title="42.慎用可变参数"></a>42.慎用可变参数</h3><p>定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用，使用不当，将产生混乱的结果。</p><h3 id="43-返回零长度的数组或者集合，而不是null"><a href="#43-返回零长度的数组或者集合，而不是null" class="headerlink" title="43.返回零长度的数组或者集合，而不是null"></a>43.返回零长度的数组或者集合，而不是null</h3><h3 id="44-为所有导出的API元素编写文档注释"><a href="#44-为所有导出的API元素编写文档注释" class="headerlink" title="44.为所有导出的API元素编写文档注释"></a>44.为所有导出的API元素编写文档注释</h3><h2 id="七、通用程序设计"><a href="#七、通用程序设计" class="headerlink" title="七、通用程序设计"></a>七、通用程序设计</h2><h3 id="45-将局部变量的作用域最小化"><a href="#45-将局部变量的作用域最小化" class="headerlink" title="45.将局部变量的作用域最小化"></a>45.将局部变量的作用域最小化</h3><p>要使用局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。<br>几乎每个局部变量的声明都应该包含一个初始化表达式。</p><h3 id="46-for-each循环优先于传统的for循环"><a href="#46-for-each循环优先于传统的for循环" class="headerlink" title="46.for-each循环优先于传统的for循环"></a>46.for-each循环优先于传统的for循环</h3><p>虽然for-each循环在简洁性和预防bug方面比传统的for循环有优势，且没有性能损失。但是有三种常见情况无法使用for-each:</p><ul><li>过滤： 如果需要遍历集合，并且删除选定的元素，就需要使用显式的迭代器。</li><li>转换： 如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引。</li><li>平行迭代： 如果需要并行的遍历多个集合，就需要显式的控制迭代器或者索引变量。</li></ul><h3 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47.了解和使用类库"></a>47.了解和使用类库</h3><p>每个程序员都应该熟悉java.lang、java.util、java.io中的内容。</p><h3 id="48-如果需要精确的答案，请避免使用float和double"><a href="#48-如果需要精确的答案，请避免使用float和double" class="headerlink" title="48.如果需要精确的答案，请避免使用float和double"></a>48.如果需要精确的答案，请避免使用float和double</h3><p>使用BigDecimal、int或者long进行计算。如果数值防伪不超过9位十进制数字，就可以使用int；如果不超过18位就可以使用long；如果数值超过18位就必须使用BigDecimal。</p><p>BigDecimal缺点：不方便，慢。</p><h3 id="49-基本类型优先于装箱基本类型"><a href="#49-基本类型优先于装箱基本类型" class="headerlink" title="49.基本类型优先于装箱基本类型"></a>49.基本类型优先于装箱基本类型</h3><p>基本类型与装箱基本类型之间主要区别：</p><ul><li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。</li><li>基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值之外，还有非功能值：null。</li><li>基本类型通常比装箱基本类型更节省空间和时间。</li></ul><p>第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型（在代码中不用自己去装箱，如果把基本类型放入集合中，集合会自动把基本类型装箱）。不能放在集合中的原因是：基本类型存放在栈上，集合中的引用则存在堆或方法取上。</p><p>在参数化类型中，必须使用装箱基本类型作为参数，Java不允许使用基本类型，因为Java泛型要求使用的是对象类型，基本类型不是对象类型。</p><h3 id="50-如果其他类型更适合，则尽量避免使用字符串"><a href="#50-如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="50.如果其他类型更适合，则尽量避免使用字符串"></a>50.如果其他类型更适合，则尽量避免使用字符串</h3><p>字符串不适合代替其他的值类型。<br>字符串不适合代替枚举类型。<br>字符串不适合代替聚集类型。<br>字符串也不适合代替能力表。</p><h3 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51.当心字符串连接的性能"></a>51.当心字符串连接的性能</h3><h3 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52.通过接口引用对象"></a>52.通过接口引用对象</h3><p>如果有适合的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。</p><p>如果没有合适的接口存在，完全可以用类而不是接口来引用对象：</p><ul><li>如果具体类没有相关联的接口，不管它是否表示一个值，你都没有别的选择，只有通过它的类来引用它的对象。</li><li>对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架（class-based</li><li>framework），就应该用相关的积累（base class）来引用这个对象，而不是用它的实现类。</li></ul><h3 id="53-接口优先于反射机制"><a href="#53-接口优先于反射机制" class="headerlink" title="53.接口优先于反射机制"></a>53.接口优先于反射机制</h3><p>反射机制：</p><ul><li>丧失了编译时类型检查的好处，包括异常检查。如果程序企图用反射方式调用不存在的活不可访问的方法，在运行时它将会失败，除非采用了特别的预防措施。</li><li>执行反射访问所需的代码非常笨拙和冗长。编写这样的代码非常乏味，阅读起来也很困难。</li><li>性能损失。反射方法调用比普通方法调用慢了许多。</li></ul><p>通常普通应用程序在运行时不应该以反射方式访问对象。<br>对于有些程序，它们必须用到在编译时无法获取的类，但是在编译时存在适当的接口或者超类，通过它们可以引用这个类。如果是这种情况，就可以以反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例。如果适当的构造器不带参数，甚至根本不需要使用<code>java.lang.reflect</code>；<code>Class.newInstance</code>方法就已经提供了所需的功能。</p><h3 id="54-谨慎的使用本地方法"><a href="#54-谨慎的使用本地方法" class="headerlink" title="54.谨慎的使用本地方法"></a>54.谨慎的使用本地方法</h3><h3 id="55-谨慎的优化"><a href="#55-谨慎的优化" class="headerlink" title="55.谨慎的优化"></a>55.谨慎的优化</h3><blockquote><p>很多计算上的过失都被归咎于效率（没有必要达到的效率），而不是任何其他的原因—甚至包括盲目的做傻事。<br>不要取计较效率上的一些小小的得失，在97%的情况下，不成熟的优化才是一切问题的根源。<br>在优化方面，我们应该遵守两条规则：<br>规则1: 不要进行优化。<br>规则2: 还是不要进行优化—也就是说，在你还没有绝对清晰的未优化方案之前，请不要优化。</p></blockquote><p>不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。好的程序体现了信息隐藏的原则：只要有可能，它们就会把设计决策几种在单个模块中，因此，可以改变单个决策，而不会影响到系统的其他部分。</p><p>在设计的过程中考虑性能问题。努力避免限制性能的设计决策。</p><h3 id="56-遵守普遍接受的命名惯例"><a href="#56-遵守普遍接受的命名惯例" class="headerlink" title="56.遵守普遍接受的命名惯例"></a>56.遵守普遍接受的命名惯例</h3><h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><h3 id="57-只针对异常的情况才使用异常"><a href="#57-只针对异常的情况才使用异常" class="headerlink" title="57.只针对异常的情况才使用异常"></a>57.只针对异常的情况才使用异常</h3><p>异常机制的设计初衷是用于不正常的情形，所以很少会有JVM实现试图对它们进行优化，使得与显式的测试一样快速。</p><p>把代码放在try-catch块中反而阻止了现代JVM实现本来可能要执行的某些特定的优化。</p><p>对数组进行遍历的标准模式并不会导致冗余的检查。有些现代的JVM实现会将它们优化掉。</p><h3 id="58-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#58-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="58.对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>58.对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><h3 id="59-避免不必要的使用受检异常"><a href="#59-避免不必要的使用受检异常" class="headerlink" title="59.避免不必要的使用受检异常"></a>59.避免不必要的使用受检异常</h3><h3 id="60-优先使用标准异常"><a href="#60-优先使用标准异常" class="headerlink" title="60.优先使用标准异常"></a>60.优先使用标准异常</h3><p><img src="/media/article/15583547431411.jpg" alt=""></p><h3 id="61-抛出域抽象相对应的异常"><a href="#61-抛出域抽象相对应的异常" class="headerlink" title="61.抛出域抽象相对应的异常"></a>61.抛出域抽象相对应的异常</h3><p>更高层次的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。<br>如果不能阻止或者处理来自低层的异常，一般做法是使用异常转译，除非低层方法碰巧可以保证它抛出的所有异常对高层也合适才可以将异常从低层传播到高层。异常链对高层和低层异常都提供了最佳功能：它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析。</p><h3 id="62-每个方法抛出的异常都要有文档"><a href="#62-每个方法抛出的异常都要有文档" class="headerlink" title="62.每个方法抛出的异常都要有文档"></a>62.每个方法抛出的异常都要有文档</h3><p>始终要单独的声明受检异常，并且利用Javadoc的@throws标记，准确的记录下抛出的每个异常的条件。</p><p>使用Javadoc的@throws标签记录下一个方法可能抛出的每个受检异常，但是不要使用throws关键字将未受检异常包含在方法的声明中。</p><p>如果一个类中的许多方法处于同样的原因而抛出同一个异常，则该类的文档注释中对这个异常建立文档，是可以接受的。</p><h3 id="63-在细节消息中包含能捕获失败的信息"><a href="#63-在细节消息中包含能捕获失败的信息" class="headerlink" title="63.在细节消息中包含能捕获失败的信息"></a>63.在细节消息中包含能捕获失败的信息</h3><p>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。</p><h3 id="64-努力使失败保持原子性"><a href="#64-努力使失败保持原子性" class="headerlink" title="64.努力使失败保持原子性"></a>64.努力使失败保持原子性</h3><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p><h3 id="65-不要忽略异常"><a href="#65-不要忽略异常" class="headerlink" title="65.不要忽略异常"></a>65.不要忽略异常</h3><h2 id="九、并发"><a href="#九、并发" class="headerlink" title="九、并发"></a>九、并发</h2><h3 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66.同步访问共享的可变数据"></a>66.同步访问共享的可变数据</h3><p>Java语言规范保证读或写一个变量是原子的，除非这个变量的类型为long或者double[JLS，17.4.7]。对于这句话不要误解，虽然语言规范保证了线程在读取原子数据的时候，不会看到任意的数值，但是它并不保证一个线程写入的值对于另一个线程将是可见的。为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。</p><h3 id="67-避免过度同步"><a href="#67-避免过度同步" class="headerlink" title="67.避免过度同步"></a>67.避免过度同步</h3><p>为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法，要尽量限制同步区域内部的工作量。</p><h3 id="68-executor和task优先于线程"><a href="#68-executor和task优先于线程" class="headerlink" title="68.executor和task优先于线程"></a>68.executor和task优先于线程</h3><h3 id="69-并发工具优先于wait和notify"><a href="#69-并发工具优先于wait和notify" class="headerlink" title="69.并发工具优先于wait和notify"></a>69.并发工具优先于wait和notify</h3><p>java.util.concurrent中更高级的的工具分成三类：Execcutor Framework、并发集合（Concurrent Collection）以及同步器（Synchronizer）。</p><p>同步器是一些使线程能够等待另一个线程的对象，允许它们协调动作。常用的是CountDownLatch和Semaphore。不常用的是CyclicBarrier和Exchanger。</p><p>对于间歇式的定时，始终应该优先使用System.nanoTime，而不是使用System.currentTimeMills。System.nanoTime更加准确也更加精确，它不受系统的实时时钟的调整所影响。</p><p>如果你在维护使用wait和notify的代码，务必确保始终是利用标准的模式从while循环内部调用wait。一般情况下，你应该优先使用notifyAll，而不是使用notify。如果使用notify，请一定小心，以确保程序的活性。</p><h3 id="70-线程安全性的文档化"><a href="#70-线程安全性的文档化" class="headerlink" title="70.线程安全性的文档化"></a>70.线程安全性的文档化</h3><p>一个类为了可被多个线程安全的使用，必须在文档中清楚的说明它所支持的线程安全级别。</p><ul><li>不可变的（immutable）这个类是不可变的。所以不需要外部同步。例如：String、Long、BigInteger。</li><li>无条件的线程安全（unconditionally thread-safe）这个类的实例是可变的，但是这个类有着足够的内部同步，所以，它的实例可以被并发使用，无需任何外部同步。例如：Random、ConcurrentHashMap。</li><li>有条件的线程安全（conditionally thread-safe）除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。例如：Collections.synchronized包装返回的集合，它们的迭代器（iterator）要求外部同步。</li><li>非线程安全（not thread-safe）这个类的实例是可变的。为了并发地使用它们，客户端必须利用自己选择的外部同步包围每个方法调用。例如：ArrayList、HashMap。</li><li>线程对立（thread-hostile）这个类不能安全的被多个线程并发使用，即使所有的方法调用都被外部同步包围。</li></ul><h3 id="71-慎用延迟初始化"><a href="#71-慎用延迟初始化" class="headerlink" title="71.慎用延迟初始化"></a>71.慎用延迟初始化</h3><p>延迟初始化（lazy initialization）是延迟到需要域的值时才将它初始化的这种行为。<br>大多数的域应该正常地进行初始化，而不是延迟初始化。如果为了达到性能目的，或者为了破坏有害的初始化循环，必须延迟初始化一个域则：<br>对于实例域，就使用双重检查模式（double-check idiom）；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            result = field;</span><br><span class="line">            if(result == null)&#123;</span><br><span class="line">                field = result = computeFieldValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于静态域，则使用lazy initialization holder class idiom；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class FieldHolder&#123;</span><br><span class="line">    static final FieldType field = computeFieldValue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static FieldType getField()&#123;return FieldHolder.field;&#125;</span><br></pre></td></tr></table></figure></p><p>对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式（single-check idiom）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line"></span><br><span class="line">private FieldType getField()&#123;</span><br><span class="line"></span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        field = result = computeFieldValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="72-不要依赖于线程调度器"><a href="#72-不要依赖于线程调度器" class="headerlink" title="72.不要依赖于线程调度器"></a>72.不要依赖于线程调度器</h3><h3 id="73-避免使用线程组"><a href="#73-避免使用线程组" class="headerlink" title="73.避免使用线程组"></a>73.避免使用线程组</h3><p>线程组的初衷是作为一种隔离applet的机制，当然是出于安全的考虑。线程组并没有提供太多有用的功能，而且它们提供的许多功能还都是有缺陷的。</p><h2 id="十、序列化"><a href="#十、序列化" class="headerlink" title="十、序列化"></a>十、序列化</h2><h3 id="74-谨慎的实现Serializable接口"><a href="#74-谨慎的实现Serializable接口" class="headerlink" title="74.谨慎的实现Serializable接口"></a>74.谨慎的实现Serializable接口</h3><p>实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。</p><p>如果接受了默认的序列化形式，并且以后要改变这个类的内部表示法，结果可能导致序列化形式的不兼容。</p><p>第二个代价是，它增加了出现Bug和安全漏洞的可能性。</p><p>实现Serializable第三个代价是，随着类发行新的版本，相关的测试负担也增加了。</p><p>为了继承而设计的类应该尽可能少的趋势线Serializable接口，用户的接口也应该尽可能少的继承Serializable接口。如果违反了这条规则，扩展这个类或者实现该接口的程序员就会背上沉重的负担。然而有些情况下，这条规则确实适合的。例如：如果一个类或者接口存在的目的主要是为了参加到某个框架中，该框架要求所有的参与者都必须实现Serializable接口，那么对于类或者接口来说实现扩展Serializable是有意义的。</p><p>如果一个专门为了继承而设计的类不是可序列化的，就不可能编写出可序列化的子类。特别是，如果超类没有提供可访问的无参构造器，子类也不可能做到序列化。对于未继承而设计的不可序列化的类，你应该提供一个无参构造器。</p><h3 id="75-考虑使用自定义的序列化形式"><a href="#75-考虑使用自定义的序列化形式" class="headerlink" title="75.考虑使用自定义的序列化形式"></a>75.考虑使用自定义的序列化形式</h3><p>如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Name implements Serializable&#123;</span><br><span class="line">    private final String lastName;</span><br><span class="line">    </span><br><span class="line">    private final String firstName;</span><br><span class="line">    </span><br><span class="line">    private final String middleName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使你确定了默认的序列化形式是合适的，通常还必须提供一个readObject方法保证约束关系和安全性。</p><p>当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下4个缺点：</p><ul><li>它使这个类的导出API永远地束缚在该类的内部表示法上。</li><li>它会消耗过多的时间。</li><li>它会消耗过多空间。</li><li>它会引起栈溢出。</li></ul><p>如果所有的实例域都是瞬时的（transient），从技术角度而言，不调用DefaultWriteObject和defaultReadObject也是允许的，但是不推荐这样做。<br>在决定将一个域做成非transient的之前，请一定要确信它的值将是该对象逻辑状态的一部分。<br>如果在读取整个对象状态的任何其他方法上强制任何同步，则也必须在对象序列化上强制这种同步。<br>不管你选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显式的序列版本UID（serial version UID）。</p><h3 id="76-保护性的编写readObject方法"><a href="#76-保护性的编写readObject方法" class="headerlink" title="76.保护性的编写readObject方法"></a>76.保护性的编写readObject方法</h3><p><strong><em>记得回来看反序列化代码</em></strong></p><p>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。保护性拷贝在有效性检查之前进行。</p><p>不要使用writeUnshared和readUnshared方法。</p><p>对于非final的可序列化类，readObject方法不可以调用可被覆盖的方法，无论是直接调用还是间接调用都不可以。如果违反了规则，并覆盖了该方法，被覆盖的方法将在子类的状态被序列化之前先运行，程序很可能失败。</p><p>readObject方法指导：</p><ul><li>对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别。</li><li>对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li><li>如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。</li><li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li></ul><h3 id="77-对于实例控制，枚举类型优先于readResolve"><a href="#77-对于实例控制，枚举类型优先于readResolve" class="headerlink" title="77.对于实例控制，枚举类型优先于readResolve"></a>77.对于实例控制，枚举类型优先于readResolve</h3><p>如果这个类的声明加上了“implements Serializable”的字样，它就不再是一个单例类。无论使用默认的序列化形式，还是自定义的序列化形式，都会返回一个新建的实例，这个新建实例不用于该类初始化时创建的实例。</p><p>readResolve特性允许你用readObject创建的实例代替另一个实例。对于一个正在被序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化后，新建对象上的readResolve方法就会被调用，该方法返回的对象引用将被返回，取代新建对象，指向新建对象的引用不需要再被保留，因此立即成为垃圾回收对象。</p><p>如果readResolve方法忽略被反序列化的对象，只返回该类初始化时创建的实例。如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient的。</p><p>readResolve的可访问性很重要。如果把readResolve方法放在一个final类上，它就应该是私有的。如果吧readResolve方法放在一个非final类上，就必须考虑它的可访问性。</p><p>尽可能的使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控（instance-controlled）的类，就必须提供一个readResolve方法，并确保该类的所有实例域都为基本类型，或者是transient的。</p><h3 id="78-考虑用序列化代理代替序列化实例"><a href="#78-考虑用序列化代理代替序列化实例" class="headerlink" title="78.考虑用序列化代理代替序列化实例"></a>78.考虑用序列化代理代替序列化实例</h3><p>每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。要想文件的带有重要约束条件的对象序列化，这种模式可能是最容易的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;摘自《Effective Java》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Effective-Java&quot;&gt;&lt;a href=&quot;#Effective-Java&quot; class=&quot;headerlink&quot; title=&quot;Effective J
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 枚举类</title>
    <link href="https://zhongyp.me/java/2019-05-01-java-enum/"/>
    <id>https://zhongyp.me/java/2019-05-01-java-enum/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-06-26T02:45:28.470Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java枚举类笔记，摘自《疯狂Java讲义》</p></blockquote><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在早期代码中，可能会直接使用简单的静态常量表示枚举，例如如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final int SEASON_SPRING = 1;</span><br><span class="line">public static final int SEASON_SUMMER = 2;</span><br><span class="line">public static final int SEASON_FALL = 3;</span><br><span class="line">public static final int SEASON_WINTER = 4;</span><br></pre></td></tr></table></figure><p>但是这种方式定义会存在如下问题：</p><ul><li>类型不安全：可能存在SEASON_SPRING + SEASON_FALL。</li><li>没有命名空间：当需要使用季节时，必须在SPRING钱使用SEASON_前缀，否则程序可能与其他类中的静态常量混淆。</li><li>打印输出的意义不明确：当输出某个季节时，实际的输出值时数字。</li></ul><p>JDK1.5 之后新增了enum关键字，用来定义枚举类。枚举类是一种特殊类，有自己的成员变量、方法，可以实现一个或者多个接口，可以定义自己的构造器。一个Java源文件中最多只能定一个public访问权限的枚举类，且该Java源文件必须和该枚举类的类名相同。和普通类区别如下：</p><ul><li>使用enum定义的默认枚举类默认继承了java.lang.Enum类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。</li><li>使用enum定义、<strong>非抽象</strong>的枚举类默认会使用final修饰，因此不能派生子类。</li><li>枚举类的构造器只能使用private访问控制符。</li><li>枚举类所有的实例必须在枚举类的第一行显示列出，否则这个枚举类永远都不能产生实例。</li></ul><p>Java枚举类型基本思想：通过公有的静态final域为每个枚举常量到处实例的类。因为没有可以访问的构造器，枚举类型是真正的final。</p><h3 id="1-枚举类的成员变量、方法和构造器"><a href="#1-枚举类的成员变量、方法和构造器" class="headerlink" title="1. 枚举类的成员变量、方法和构造器"></a>1. 枚举类的成员变量、方法和构造器</h3><p>枚举类也是一种比较特殊的类。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;),FEMALE(&quot;女&quot;);</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看出，枚举类中列出枚举值时，实际上就是调用构造器创建枚举类对象，只是这里不是使用new关键字，也无需显式调用构造器。</p><p>上面<code>MALE(&quot;男&quot;),FEMALE(&quot;女&quot;)</code>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void final Gender MALE = new Gender(&quot;男&quot;)；</span><br><span class="line">public static void final Gender FEMALE = new Gender(&quot;女&quot;)；</span><br></pre></td></tr></table></figure></p><h3 id="2-实现接口的枚举类"><a href="#2-实现接口的枚举类" class="headerlink" title="2. 实现接口的枚举类"></a>2. 实现接口的枚举类</h3><p>接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface GenderDesc&#123;</span><br><span class="line">    void info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;men&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,FEMALE(&quot;女&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;women&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong>并非所有的枚举类都使用final修饰，非抽象的枚举类才默认使用final修饰。对于一个抽象的枚举类，系统默认使用abstract修饰，而不是final。</p><h3 id="3-包含抽象方法的抽象类"><a href="#3-包含抽象方法的抽象类" class="headerlink" title="3. 包含抽象方法的抽象类"></a>3. 包含抽象方法的抽象类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public enum Operation&#123;</span><br><span class="line"></span><br><span class="line">    PLUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x-y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x*y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x/y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    public abstract double eval(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Java枚举类笔记，摘自《疯狂Java讲义》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;枚举类&quot;&gt;&lt;a href=&quot;#枚举类&quot; class=&quot;headerlink&quot; title=&quot;枚举类&quot;&gt;&lt;/a&gt;枚举类&lt;/h2&gt;&lt;p&gt;在早期代码中，可能
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zhongyp.me/tags/Java/"/>
    
      <category term="笔记" scheme="https://zhongyp.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
