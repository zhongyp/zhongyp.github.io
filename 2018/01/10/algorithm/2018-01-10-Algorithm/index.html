
<!DOCTYPE html>
<html lang="zh-Hans">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">

  
    <meta name="keywords" content="算法,">
  

  
    <meta name="description" content="钟宇鹏的博客">
  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" type="image/x-icon" href="/logo.png">
  <title>算法（Algorithm） [ DO IT ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/simple.css">
    
  
</head>


<body>
  <nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed">
  <ul class="pure-menu-list float-r clearfix">
    
      <!-- <li class="pure-menu-item toc-menu pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main-post" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
      </li> -->
      <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
        <ul class="pure-menu-children">
        
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
          
          
      </ul>
      </li>
    
  </ul>
  <a class="pure-menu-heading" href="/">
      <h1 class="title">DO IT</h1>
      <!-- <span>钟宇鹏的博客</span> -->
  </a>
  <!-- 
  <img class="logo" id="logo" src="/logo.png" alt="logo">
   -->
</nav>


  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <article class="post" id="post">
  <header class="post-header text-center">
    <h1 class="title">
      算法（Algorithm）
    </h1>
    
    <time class="time" datetime="2018-01-09T16:00:00.000Z">
      2018-01-10
    </time>
     |
    <span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
    <hr>
  </header>
  <div class="post-content">
    <p><a href="https://github.com/zhongyp/Demo/tree/master/src/main/java/com/zhongyp/algorithm" target="_blank" rel="noopener">本文的所有算法代码均在github上保存，点击此链接即可访问</a></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 先序、中序遍历二叉树</span><br><span class="line"> * 先序：根左右</span><br><span class="line"> * 中序：左根右</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// 标记先序索引位置</span><br><span class="line">int count = 0;</span><br><span class="line">public  Tree buildTreeByPreMid(int[] a, int s1, int e1,int[] b, int s2, int e2)&#123;</span><br><span class="line"></span><br><span class="line">    if(s1&gt;e1||s2&gt;e2)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree tree = new Tree();</span><br><span class="line">     tree.value = a[count];</span><br><span class="line">    // index为a[s1]在b中的索引</span><br><span class="line">    int index = getIndex(b, a[count]);</span><br><span class="line">    count++;</span><br><span class="line">    // count标识左子树先序的起点，s1+index为左子树先序的终点，s2,index-1分别为左子树中序的起点和终点</span><br><span class="line">    tree.left = buildTreeByPreMid(a, count, s1+index, b, s2, index-1);</span><br><span class="line">    tree.right = buildTreeByPreMid(a, count, s1+e2-index, b, index+1, e2);</span><br><span class="line"></span><br><span class="line">    return tree;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 中序、后序 构建二叉树</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">int count1 = 7;</span><br><span class="line">public Tree buildTreeByMidLast(int[] a, int s1, int e1,int[] b, int s2, int e2)&#123;</span><br><span class="line">    if(s1&gt;e1||s2&gt;e2)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree tree = new Tree();</span><br><span class="line">    tree.value = a[e1];</span><br><span class="line">    int index = getIndex(b, a[e1]);</span><br><span class="line">    count1--;</span><br><span class="line">    tree.right = buildTreeByMidLast(a, count1+index-e2+1, count1, b, index+1, e2);</span><br><span class="line">    tree.left = buildTreeByMidLast(a, s1, count1, b, s2, index-1);</span><br><span class="line">    return tree;</span><br><span class="line">&#125;</span><br><span class="line">private int getIndex(int[] b,int value)&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for(int tmp:b)&#123;</span><br><span class="line">        if(tmp==value)&#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 先序</span><br><span class="line">public void printPre(Tree tree)&#123;</span><br><span class="line">    if(tree != null)&#123;</span><br><span class="line">        System.out.print(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        printPre(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        printPre(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 中序</span><br><span class="line">public void printMid(Tree tree)&#123;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        printMid(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (tree != null)&#123;</span><br><span class="line">        System.out.print(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        printMid(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 后序</span><br><span class="line">public void printLast(Tree tree)&#123;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        printLast(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        printLast(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">    if (tree != null)&#123;</span><br><span class="line">        System.out.print(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 1.将节点放入队列</span><br><span class="line"> * 2.取出队列第一个节点</span><br><span class="line"> * 3.将取出的节点的左右节点一次放入队列</span><br><span class="line"> * 递归</span><br><span class="line"> */</span><br><span class="line">public void printLevel(Tree tree)&#123;</span><br><span class="line">    if(tree == null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree current;</span><br><span class="line">    LinkedList list = new LinkedList();</span><br><span class="line">    list.offer(tree);</span><br><span class="line">    while(!list.isEmpty())&#123;</span><br><span class="line">        current = (Tree)list.poll();</span><br><span class="line">        System.out.print(current.value);</span><br><span class="line">        if(current.left != null)&#123;</span><br><span class="line">            list.offer(current.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(current.right != null)&#123;</span><br><span class="line">            list.offer(current.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 二叉树叶子节点个数</span><br><span class="line">int count2 = 0;</span><br><span class="line">public void sumLeaf(Tree tree)&#123;</span><br><span class="line">    if(tree.left == null&amp;&amp;tree.right == null)&#123;</span><br><span class="line">        count2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        sumLeaf(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        sumLeaf(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 二叉树的高度</span><br><span class="line">public int hightTree(Tree tree)&#123;</span><br><span class="line">    if(tree == null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.left == null &amp;&amp; tree.right == null)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int l_hight = hightTree(tree.left);</span><br><span class="line">    int r_hight = hightTree(tree.right);</span><br><span class="line">    return l_hight&gt;r_hight?l_hight+1:r_hight+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求两个节点的最近公共祖先</span><br><span class="line">public void commonParent(int value1, int value2)&#123;</span><br><span class="line">    if(root == null || p == root || q == root) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tree l = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    Tree r = lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">    if(l!= null &amp;&amp; r!= null) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return l != null?l:r;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 路径值</span><br><span class="line">Stack&lt;Integer&gt; stack = new Stack();</span><br><span class="line">public void FindPath(Tree tree, int sum, int current)&#123;</span><br><span class="line">    if(tree==null)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current+=tree.value;</span><br><span class="line">    stack.push(tree.value);</span><br><span class="line">    if(current==sum)&#123;</span><br><span class="line">        System.out.println(&quot;PATH:&quot;);</span><br><span class="line">        for(int val : stack)&#123;</span><br><span class="line">            System.out.print(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current&lt;sum)&#123;</span><br><span class="line">        if(tree.left != null)&#123;</span><br><span class="line">            FindPath(tree.left,sum,current);</span><br><span class="line">        &#125;</span><br><span class="line">        if(tree.right != null)&#123;</span><br><span class="line">            FindPath(tree.right,sum,current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current -= tree.value;</span><br><span class="line">    stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol>
<li>链表逆序（不可使用其他空间）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 非递归</span><br><span class="line"> */</span><br><span class="line">public Node reverse(Node node)&#123;</span><br><span class="line">    Node init = null;</span><br><span class="line">    while(node != null)&#123;</span><br><span class="line">        Node node1 = init;</span><br><span class="line">        Node node2 = node;</span><br><span class="line">        node = node.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        init = node2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归方式</span><br><span class="line"> * @param node1</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Node reverse1(Node node1)&#123;</span><br><span class="line"></span><br><span class="line">    Node init = node1.next;</span><br><span class="line">    if(init != null)&#123;</span><br><span class="line">        Node node2= reverse1(init);</span><br><span class="line">        Node tmp = getLastNode(node2);</span><br><span class="line">        node1.next = null;</span><br><span class="line">        tmp.next = node1;</span><br><span class="line">        return node2;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h2><ul>
<li>插入排序： 直接插入，希尔排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 直接插入排序算法的空间复杂度为O(1)。</span><br><span class="line">     * 最好的情况，要比较的无序序列原本就是顺序有序的，那么要比较的次数是n-1，移动了0次，时间复杂度O(n)。</span><br><span class="line">     * 最坏的情况，要比较的无序序列原本就是逆序有序的，那么要比较的次数是(n+2)(n-1)/2，移动的次数(n+4)(n-1)/2，时间复杂度O(n²)。</span><br><span class="line">     * 直接插入排序的平均复杂度为O(n²)。</span><br><span class="line">     * 直接插入排序是稳定的。</span><br><span class="line">     * @param num</span><br><span class="line">     */</span><br><span class="line">public void directInsert(int[] num)&#123;</span><br><span class="line">    for(int i=1; i&lt;num.length; i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">            if(num[i]&lt;num[j])&#123;</span><br><span class="line">                int a = num[j];</span><br><span class="line">                num[j] = num[i];</span><br><span class="line">                num[i] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int val:num)&#123;</span><br><span class="line">        System.out.print(val + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">     * 希尔排序在最坏的情况下的运行时间是O(n²)，平均时间复杂度为O(n^1.3)。</span><br><span class="line">     * 希尔排序对于多达几千个数据项的，中等大小规模的数组排序表现良好。</span><br><span class="line">     * 希尔排序不像快速排序和其它时间复杂度为O(nlog2n)的排序算法那么快，因此对非常大的文件排序，它不是最优选择。</span><br><span class="line">     * 但是，希尔排序比选择排序和插入排序这种时间复杂度为O(n²)的排序算法还是要快得多，并且它非常容易实现。</span><br><span class="line">     * 它在最坏情况下的执行效率和在平均情况下的执行效率相比没有差很多。</span><br><span class="line">     * 此外希尔排序是不稳定的(指在多次插入排序中，相同元素可能在插入排序中移动，导致稳定性被破坏)。</span><br><span class="line">     * @param num</span><br><span class="line">     */</span><br><span class="line">public void hillSort(int[] num)&#123;</span><br><span class="line">    int gap = 5;</span><br><span class="line">    while(gap&gt;0)&#123;</span><br><span class="line">        for(int i=0; i&lt;num.length-gap; i++)&#123;</span><br><span class="line">            if(num[i]&gt;num[i+gap])&#123;</span><br><span class="line">                int a = num[i];</span><br><span class="line">                num[i] = num[i+gap];</span><br><span class="line">                num[i+gap] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = gap/2;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int val:num)&#123;</span><br><span class="line">        System.out.print(val + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>选择排序： 简单选择排序，堆排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 选择排序</span><br><span class="line">     * @param num</span><br><span class="line">     */</span><br><span class="line">    public void simpleSort(int[] num)&#123;</span><br><span class="line">        for(int i=0;i&lt;num.length;i++)&#123;</span><br><span class="line">            int index = i;</span><br><span class="line">            for(int j=i;j&lt;num.length-1;j++)&#123;</span><br><span class="line">                if(num[index]&gt;num[j+1])&#123;</span><br><span class="line">                    index = j+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int a = num[i];</span><br><span class="line">            num[i] = num[index];</span><br><span class="line">            num[index] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int val:num)&#123;</span><br><span class="line">            System.out.print(val + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 堆排序</span><br><span class="line">     *</span><br><span class="line">     * 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</span><br><span class="line">     *</span><br><span class="line">     * @param num</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public void heapSort(int[] num, int index)&#123;</span><br><span class="line"></span><br><span class="line">        for(int i=index/2;i&gt;-1;i--)&#123;</span><br><span class="line">            if((2*i)&lt;index&amp;&amp;num[i]&lt;num[2*i])&#123;</span><br><span class="line">                int a = num[i];</span><br><span class="line">                num[i] = num[2*i];</span><br><span class="line">                num[2*i] = a;</span><br><span class="line">            &#125;</span><br><span class="line">            if((2*i+1)&lt;index&amp;&amp;num[i]&lt;num[2*i+1])&#123;</span><br><span class="line">                int a = num[i];</span><br><span class="line">                num[i] = num[2*i+1];</span><br><span class="line">                num[2*i+1] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int a = num[index];</span><br><span class="line">        num[index] = num[0];</span><br><span class="line">        num[0] = a;</span><br><span class="line">        index = index-1;</span><br><span class="line">        if(index&gt;0)&#123;</span><br><span class="line">            heapSort(num,index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>交换排序： 冒泡排序，快速排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    // 冒泡排序</span><br><span class="line">    public static void bubbleSort()&#123;</span><br><span class="line">//        int[] arr = &#123;3,5,7,1,4&#125;;</span><br><span class="line">        int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">        int i,j,temp,len=arr.length;</span><br><span class="line">        //是否已经完成排序的标志</span><br><span class="line">        boolean flag;</span><br><span class="line">        //排序</span><br><span class="line">        for(i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            for(j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">                if(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    flag = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                System.out.println(&quot;第&quot; + (i+1) + &quot;趟结束了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出数组</span><br><span class="line">        for(int o:arr)&#123;</span><br><span class="line">            System.out.print(&quot; &quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 快速排序</span><br><span class="line">    public static void quickSort(int[] num,int start, int end)&#123;</span><br><span class="line">            int sys = num[start];</span><br><span class="line">            int left = start;</span><br><span class="line">            int right = end;</span><br><span class="line"></span><br><span class="line">            while(start&lt;end)&#123;</span><br><span class="line">                if(num[end]&lt;sys)&#123;</span><br><span class="line">                    num[start] = num[end];</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    end--;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(sys&lt;num[start])&#123;</span><br><span class="line">                    num[end] = num[start];</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num[start] = sys;</span><br><span class="line">            if(left&lt;start-1)&#123;</span><br><span class="line">                quickSort(num,left,start-1);</span><br><span class="line">            &#125;</span><br><span class="line">            if(right&gt;end+1)&#123;</span><br><span class="line">                quickSort(num,end+1,right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>归并排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">static int[] sort(int[] a, int start, int end)&#123;</span><br><span class="line"></span><br><span class="line">    int mid ;</span><br><span class="line">    if(start&lt;end)&#123;</span><br><span class="line">        mid = (start + end)/2;</span><br><span class="line">        a = sort(a, start, mid);</span><br><span class="line">        a = sort(a, mid+1, end);</span><br><span class="line">        a = merge(a, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int[] merge(int[] a, int start, int mid, int end)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    int[] c = new int[a.length];</span><br><span class="line">    while((start+i)&lt;=mid&amp;&amp;(mid+1+j)&lt;=end)&#123;</span><br><span class="line">        if(a[start+i]&gt;a[mid+1+j])&#123;</span><br><span class="line">            c[i+j] = a[mid+1+j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            c[i+j] = a[start+i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    while((start+i)&lt;=mid)&#123;</span><br><span class="line">        c[i+j] = a[start+i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while((mid+1+j)&lt;=end)&#123;</span><br><span class="line">        c[i+j] = a[mid+1+j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int k=0;k&lt;=(i+j-1);k++)&#123;</span><br><span class="line">        a[start+k] = c[k];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基数排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int[] radixSort(int[] A, int n) &#123;</span><br><span class="line">    int length = n;</span><br><span class="line">    int divisor = 1;// 定义每一轮的除数，1,10,100...</span><br><span class="line">    int[][] bucket = new int[10][length];// 定义了10个桶，以防每一位都一样全部放入一个桶中</span><br><span class="line">    int[] count = new int[10];// 统计每个桶中实际存放的元素个数</span><br><span class="line">    int digit;// 获取元素中对应位上的数字，即装入那个桶</span><br><span class="line">    for (int i = 1; i &lt;= 3; i++) &#123;// 经过4次装通操作，排序完成</span><br><span class="line">        for (int temp : A) &#123;// 计算入桶</span><br><span class="line">            digit = (temp / divisor) % 10;</span><br><span class="line">            bucket[digit][count[digit]++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = 0;// 被排序数组的下标</span><br><span class="line">        for (int b = 0; b &lt; 10; b++) &#123;// 从0到9号桶按照顺序取出</span><br><span class="line">            if (count[b] == 0)// 如果这个桶中没有元素放入，那么跳过</span><br><span class="line">            continue;</span><br><span class="line">            for (int w = 0; w &lt; count[b]; w++) &#123;</span><br><span class="line">                A[k++] = bucket[b][w];</span><br><span class="line">            &#125;</span><br><span class="line">            count[b] = 0;// 桶中的元素已经全部取出，计数器归零</span><br><span class="line">        &#125;</span><br><span class="line">        divisor *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offfer-所有算法"><a href="#剑指offfer-所有算法" class="headerlink" title="剑指offfer 所有算法"></a>剑指offfer 所有算法</h2><p>第01-10题</p>
<p>【剑指Offer学习】【面试题02：实现Singleton 模式——七种实现方式】</p>
<p>【剑指Offer学习】【面试题03：二维数组中的查找】</p>
<p>【剑指Offer学习】【面试题04：替换空格】</p>
<p>【剑指Offer学习】【面试题05：从尾到头打印链表】</p>
<p>【剑指Offer学习】【面试题06：重建二叉树】</p>
<p>【剑指Offer学习】【面试题07：用两个栈实现队列】</p>
<p>【剑指Offer学习】【面试题08：旋转数组的最小数字】</p>
<p>【剑指Offer学习】【面试题09：斐波那契数列】</p>
<p>【剑指Offer学习】【面试题10：二进制中1 的个数】</p>
<p>第11-20题</p>
<p>【剑指Offer学习】【面试题11：数值的整数次方】</p>
<p>【剑指Offer学习】【面试题12：打印1 到最大的n 位数】</p>
<p>【剑指Offer学习】【面试题13：在O（1）时间删除链表结点】</p>
<p>【剑指Offer学习】【面试题14：调整数组顺序使奇数位于偶数前面】</p>
<p>【剑指Offer学习】【面试题15：链表中倒数第k个结点】</p>
<p>【剑指Offer学习】【面试题16：反转链表】</p>
<p>【剑指Offer学习】【面试题17：合并两个排序的链表】</p>
<p>【剑指Offer学习】【面试题18：树的子结构】</p>
<p>【剑指Offer学习】【面试题19：二叉树的镜像】</p>
<p>【剑指Offer学习】【面试题20：顺时针打印矩阵】</p>
<p>第21-30题</p>
<p>【剑指Offer学习】【面试题21：包含min函数的钱】</p>
<p>【剑指Offer学习】【面试题22：栈的压入、弹出序列】</p>
<p>【剑指Offer学习】【面试题23：从上往下打印二叉树】</p>
<p>【剑指Offer学习】【面试题24：二叉搜索树的后序遍历序列】</p>
<p>【剑指Offer学习】【面试题25：二叉树中和为某一值的路径】</p>
<p>【剑指Offer学习】【面试题26：复杂链表的复制】</p>
<p>【剑指Offer学习】【面试题27：二叉搜索树与双向链表】</p>
<p>【剑指Offer学习】【面试题28：字符串的排列】</p>
<p>【剑指Offer学习】【面试题29：数组中出现次数超过一半的数字】</p>
<p>【剑指Offer学习】【面试题30：最小的k个数】</p>
<p>第31-40题</p>
<p>【剑指Offer学习】【面试题31：连续子数组的最大和】</p>
<p>【剑指Offer学习】【面试题32：求从1到n的整数中1出现的次数】</p>
<p>【剑指Offer学习】【面试题33：把数组排成最小的数】</p>
<p>【剑指Offer学习】【面试题34：丑数】</p>
<p>【剑指Offer学习】【面试题35：第一个只出现一次的字符】</p>
<p>【剑指Offer学习】【面试题36：数组中的逆序对】</p>
<p>【剑指Offer学习】【面试题37：两个链表的第一个公共结点】</p>
<p>【剑指Offer学习】【面试题38：数字在排序数组中出现的次数】</p>
<p>【剑指Offer学习】【面试题39：二叉树的深度】</p>
<p>【剑指Offer学习】【面试题40：数组中只出现一次的数字】</p>
<p>第41-50题</p>
<p>【剑指Offer学习】【面试题41：和为s 的两个数字vs 和为s 的连续正数序列】</p>
<p>【剑指Offer学习】【面试题42：翻转单词顺序vs左旋转字符串】</p>
<p>【剑指Offer学习】【面试题43 : n 个锻子的点数】</p>
<p>【剑指Offer学习】【面试题44：扑克牌的顺子】</p>
<p>【剑指Offer学习】【面试题45：圆圈中最后剩下的数字(约瑟夫环问题)】</p>
<p>【剑指Offer学习】【面试题47：不用加减乘除做加法】</p>
<p>【剑指Offer学习】【面试题49：把字符串转换成整数】</p>
<p>【剑指Offer学习】【面试题50：树中两个结点的最低公共祖先】</p>
<p>第51-60题</p>
<p>【剑指Offer学习】【面试题51：数组中重复的数字】</p>
<p>【剑指Offer学习】【面试题52：构建乘积数组】</p>
<p>【剑指Offer学习】【面试题53：正则表达式匹配】</p>
<p>【剑指Offer学习】【面试题54：表示数值的字符串】</p>
<p>【剑指Offer学习】【面试题55：字符流中第一个不重复的字符】</p>
<p>【剑指Offer学习】【面试题56：链表中环的入口结点】</p>
<p>【剑指Offer学习】【面试题57：删除链表中重复的结点】</p>
<p>【剑指Offer学习】【面试题58：二叉树的下一个结点】</p>
<p>【剑指Offer学习】【面试题59：对称的二叉树】</p>
<p>【剑指Offer学习】【面试题60：把二叉树打印出多行】</p>
<p>第61-67题</p>
<p>【剑指Offer学习】【面试题61：按之字形顺序打印二叉树】</p>
<p>【剑指Offer学习】【面试题62：序列化二叉树】</p>
<p>【剑指Offer学习】【面试题63：二叉搜索树的第k个结点】</p>
<p>【剑指Offer学习】【面试题64：数据流中的中位数】</p>
<p>【剑指Offer学习】【面试题65：滑动窗口的最大值】</p>
<p>【剑指Offer学习】【面试题66：矩阵中的路径】</p>
<p>【剑指Offer学习】【面试题67：机器人的运动范围】</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>并查集</p>
</li>
<li><p>KMP</p>
</li>
</ul>

  </div>
  <div class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
  </div>
</article>
  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2018/01/09/interfaceview/2018-01-09-DDInterview/" rel="next" title="DD面试总结">
          DD面试总结
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2018/01/10/java/2018-01-10-Set/" rel="prev" title="Set常用集合类源码解读">
            Set常用集合类源码解读
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十大经典排序算法"><span class="toc-text">十大经典排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指offfer-所有算法"><span class="toc-text">剑指offfer 所有算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a></li></ol>
  </div>



    </div>

    

  </div>

  <footer class="footer text-center">
    <div id="bottom-inner">

      <a href="http://programer.group" target="_blank">主站</a> |
      <a href="http://zhongyp.me">DO IT</a> |
      <a href="https://github.com/zhongyp" target="_blank">GitHub</a> |
      <a href="http://hexo.io" target="_blank">Hexo</a> |
      <a href="https://github.com/zhongyp/hexo-theme-simple" target="_blank">Theme simple</a> |
      <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank">Base on theme microb</a> |
      <a><span id="busuanzi_container_site_pv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></a> |
      <a><span id="busuanzi_container_site_pv">本站访问量<span id="busuanzi_value_site_pv"></span>次</span></a>
    </div>
  </footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     *
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }

    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      // var menu = document.getElementById('menu-main-post');
      // if (menu) {
      //   var toc = document.getElementById('toc');
      //   if (toc) {
      //     menu.onclick = function() {
      //       if (toc) {
      //         if (toc.style.display == 'block') {
      //           toc.style.display = 'none';
      //         } else {
      //           toc.style.display = 'block';
      //         }
      //       }
      //     };
      //   } else {
      //     menu.style.display = 'none';
      //   }
      // }
    }

  })(window, document);
</script>


  



</body>
</html>
