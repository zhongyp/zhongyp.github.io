
<!DOCTYPE html>
<html lang="zh-Hans">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  
    <meta name="keywords" content="Dubbo," />
  

  
    <meta name="description" content="钟宇鹏的博客" />
  
  
  <link rel="icon" type="image/x-icon" href="/logo.png">
  <title>Dubbo客户端消费（转载） [ DO IT ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/simple.css">
    
  
</head>

<body>
  <nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed">
  <ul class="pure-menu-list float-r clearfix">
    
      <li class="pure-menu-item toc-menu">
        <a id="menu-main-post" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
      </li>
    
  </ul>  
  <a class="pure-menu-heading" href="/">
      <h1 class="title">DO IT</h1>
      <!-- <span>钟宇鹏的博客</span> -->
  </a>
  <!-- 
  <img class="logo" id="logo" src="/logo.png" alt="logo">
   -->
</nav>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <article class="post" id="post">
  <header class="post-header text-center">
    <h1 class="title">
      Dubbo客户端消费（转载）
    </h1>
    
    <time class="time" datetime="2018-01-13T16:00:00.000Z">
      2018-01-14
    </time>
    
    <hr>
  </header>
  <div class="post-content">
    <p><a href="https://blog.csdn.net/qiangcai/article/details/77581201" target="_blank" rel="noopener">尊重原创：参考文档：https://blog.csdn.net/qiangcai/article/details/77581201</a></p>
<p>开发一个简单的RPC框架，重点需要考虑的是两点，即编解码方式和底层通讯协议的选型，编解码方式指的是需要传输的数据在调用方将以什么组织形式拆解成字节流并在服务提供方以什么形式解析出来。编解码方式的设计需要考虑到后期的版本升级，所以很多RPC协议在设计时都会带上当前协议的版本信息。而底层通讯协议的选型都大同小异，一般都是TCP（当然也可以选择建立于TCP之上更高级的协议，比如Avro、Thrift和HTTP等），在Java语言中就是指套接字Socket，当然，在Netty出现后，很少RPC框架会直接以自己写Socket作为默认实现的通讯方式，但通常也会自己实现一个aio、nio或bio版本给那些“不方便”依赖Netty库的应用系统来使用。</p>
<p> 在Dubbo的源码中，有一个单独模块dubbo-rpc，其中，最重要的应该是Protocol和Invoker两个接口，代表着协议（编解码方式）和调用过程（通讯方式）。Invoker接口继承于Node接口，Node接口规范了Dubbo体系中各组件之间通讯的基本要素： </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Node &#123;  </span><br><span class="line">    // 协议数据载体  </span><br><span class="line">    URL getUrl();  </span><br><span class="line">    // 状态监测，当前是否可用  </span><br><span class="line">    boolean isAvailable();  </span><br><span class="line">    // 销毁方法  </span><br><span class="line">    void destroy();  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public interface Invoker&lt;T&gt; extends Node &#123;  </span><br><span class="line">    // 获取调用的接口  </span><br><span class="line">    Class&lt;T&gt; getInterface();  </span><br><span class="line">    // 调用过程  </span><br><span class="line">    Result invoke(Invocation invocation) throws RpcException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring在初始化IOC容器，通过DubboNamespaceHandler类来解析dubbo相关标签，在解析客户端标签dubbo:reference时，标签解析出来的相关属性都是存储到ReferenceBean类中，因为ReferenceBean类实现了InitializingBean接口，所以在设置标签所有属性后会调用afterPropertiesSet方法，关于标签bean载体类实现spring框架的InitializingBean接口相关知识可以自己百度了解下，有很多写的比较好的文章，这里就不在细说。具体看afterPropertiesSet方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@SuppressWarnings(&#123; &quot;unchecked&quot;&#125;)  </span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        //判断当前ConsumerConfig是否存在，如果不存在从spring容器中取相关的ConsumerConfig对象，并设置到当前属性中  </span><br><span class="line">        if (getConsumer() == null) &#123;  </span><br><span class="line">            Map&lt;String, ConsumerConfig&gt; consumerConfigMap = applicationContext == null ? null  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, false, false);  </span><br><span class="line">            if (consumerConfigMap != null &amp;&amp; consumerConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                ConsumerConfig consumerConfig = null;  </span><br><span class="line">                for (ConsumerConfig config : consumerConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        if (consumerConfig != null) &#123;  </span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate consumer configs: &quot; + consumerConfig + &quot; and &quot; + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        consumerConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (consumerConfig != null) &#123;  </span><br><span class="line">                    //设置当前ConsumerConfig对象  </span><br><span class="line">                    setConsumer(consumerConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        //判断当前ApplicationConfig是否存在，不存在从spring容器中获取，并关联到当前类的属性中  </span><br><span class="line">        if (getApplication() == null  </span><br><span class="line">                &amp;&amp; (getConsumer() == null || getConsumer().getApplication() == null)) &#123;  </span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);  </span><br><span class="line">            if (applicationConfigMap != null &amp;&amp; applicationConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                ApplicationConfig applicationConfig = null;  </span><br><span class="line">                for (ApplicationConfig config : applicationConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        if (applicationConfig != null) &#123;  </span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate application configs: &quot; + applicationConfig + &quot; and &quot; + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        applicationConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (applicationConfig != null) &#123;  </span><br><span class="line">                    //设置当前ApplicationConfig属性  </span><br><span class="line">                    setApplication(applicationConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        //判断当前ModuleConfig是否存在，不存在从spring容器中获取，并关联到当前类属性中  </span><br><span class="line">        if (getModule() == null  </span><br><span class="line">                &amp;&amp; (getConsumer() == null || getConsumer().getModule() == null)) &#123;  </span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);  </span><br><span class="line">            if (moduleConfigMap != null &amp;&amp; moduleConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                ModuleConfig moduleConfig = null;  </span><br><span class="line">                for (ModuleConfig config : moduleConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        if (moduleConfig != null) &#123;  </span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate module configs: &quot; + moduleConfig + &quot; and &quot; + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        moduleConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (moduleConfig != null) &#123;  </span><br><span class="line">                    //设置当前ModuleConfig对象  </span><br><span class="line">                    setModule(moduleConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        //判断当前List&lt;RegistryConfig&gt;注册中心是否存在，如果不存在从spring容器中获取，并关联到当前类属性中  </span><br><span class="line">        if ((getRegistries() == null || getRegistries().size() == 0)  </span><br><span class="line">                &amp;&amp; (getConsumer() == null || getConsumer().getRegistries() == null || getConsumer().getRegistries().size() == 0)  </span><br><span class="line">                &amp;&amp; (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().size() == 0)) &#123;  </span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);  </span><br><span class="line">            if (registryConfigMap != null &amp;&amp; registryConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = new ArrayList&lt;RegistryConfig&gt;();  </span><br><span class="line">                for (RegistryConfig config : registryConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        registryConfigs.add(config);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                if (registryConfigs != null &amp;&amp; registryConfigs.size() &gt; 0) &#123;  </span><br><span class="line">                    //设置当前的注册中心  </span><br><span class="line">                    super.setRegistries(registryConfigs);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        //判断当前MonitorConfig监控中心是否存在，如果不存在从spring容器中获取  </span><br><span class="line">        if (getMonitor() == null  </span><br><span class="line">                &amp;&amp; (getConsumer() == null || getConsumer().getMonitor() == null)  </span><br><span class="line">                &amp;&amp; (getApplication() == null || getApplication().getMonitor() == null)) &#123;  </span><br><span class="line">            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);  </span><br><span class="line">            if (monitorConfigMap != null &amp;&amp; monitorConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                MonitorConfig monitorConfig = null;  </span><br><span class="line">                for (MonitorConfig config : monitorConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        if (monitorConfig != null) &#123;  </span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate monitor configs: &quot; + monitorConfig + &quot; and &quot; + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        monitorConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (monitorConfig != null) &#123;  </span><br><span class="line">                    //设置当前的监控中心  </span><br><span class="line">                    setMonitor(monitorConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Boolean b = isInit();  </span><br><span class="line">        if (b == null &amp;&amp; getConsumer() != null) &#123;  </span><br><span class="line">            b = getConsumer().isInit();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        //是否容器启动加载时，立即初始化，默认是不立刻初始化处理，可以通过在dubbo:reference标签里面配置init=true来设置  </span><br><span class="line">        if (b != null &amp;&amp; b.booleanValue()) &#123;  </span><br><span class="line">            getObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>getObject中调用init(),init总体思路就是再次检测了Consumer，Application，Module，Registries等配置信息，并将配置信息全部存入到Map中。注意最后一段代码 ref = createProxy(map); 看代码应该就能理解它的作用创建代理对象，并传入了前面存进所有参数的map属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private T createProxy(Map&lt;String, String&gt; map) &#123;  </span><br><span class="line">       //根据map中的属性值生成URL对象  </span><br><span class="line">       URL tmpUrl = new URL(&quot;temp&quot;, &quot;localhost&quot;, 0, map);  </span><br><span class="line">       final boolean isJvmRefer;  </span><br><span class="line">       if (isInjvm() == null) &#123;  </span><br><span class="line">           if (url != null &amp;&amp; url.length() &gt; 0) &#123; //指定URL的情况下，不做本地引用  </span><br><span class="line">               isJvmRefer = false;  </span><br><span class="line">           &#125; else if (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) &#123;  </span><br><span class="line">               //默认情况下如果本地有服务暴露，则引用本地服务.  </span><br><span class="line">               isJvmRefer = true;  </span><br><span class="line">           &#125; else &#123;  </span><br><span class="line">               isJvmRefer = false;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125; else &#123;  </span><br><span class="line">           isJvmRefer = isInjvm().booleanValue();  </span><br><span class="line">       &#125;  </span><br><span class="line">         </span><br><span class="line">       if (isJvmRefer) &#123;  </span><br><span class="line">           URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);  </span><br><span class="line">           invoker = refprotocol.refer(interfaceClass, url);  </span><br><span class="line">           if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">               logger.info(&quot;Using injvm service &quot; + interfaceClass.getName());  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125; else &#123;  </span><br><span class="line"> </span><br><span class="line">           //判断当前客户端是否是点对点直连，直连会跳过注册中心  </span><br><span class="line">           //直连或者注册连接的url都会存储在urls中  </span><br><span class="line">           if (url != null &amp;&amp; url.length() &gt; 0) &#123; // 用户指定URL，指定的URL可能是对点对直连地址，也可能是注册中心URL  </span><br><span class="line">               String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);  </span><br><span class="line">               if (us != null &amp;&amp; us.length &gt; 0) &#123;  </span><br><span class="line">                   for (String u : us) &#123;  </span><br><span class="line">                       URL url = URL.valueOf(u);  </span><br><span class="line">                       if (url.getPath() == null || url.getPath().length() == 0) &#123;  </span><br><span class="line">                           url = url.setPath(interfaceName);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;  </span><br><span class="line">                           urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));  </span><br><span class="line">                       &#125; else &#123;  </span><br><span class="line">                           urls.add(ClusterUtils.mergeUrl(url, map));  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125; else &#123;  </span><br><span class="line">               // 通过注册中心配置拼装URL  </span><br><span class="line">               List&lt;URL&gt; us = loadRegistries(false);  </span><br><span class="line">               if (us != null &amp;&amp; us.size() &gt; 0) &#123;  </span><br><span class="line">                   for (URL u : us) &#123;  </span><br><span class="line">                       URL monitorUrl = loadMonitor(u);  </span><br><span class="line">                       if (monitorUrl != null) &#123;  </span><br><span class="line">                           map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               if (urls == null || urls.size() == 0) &#123;  </span><br><span class="line">                   throw new IllegalStateException(&quot;No such any registry to reference &quot; + interfaceName  + &quot; on the consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, please config &lt;dubbo:registry address=\&quot;...\&quot; /&gt; to your spring config.&quot;);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">           if (urls.size() == 1) &#123;  </span><br><span class="line">               //只有一个注册服务器时，生成客户端的代理invoker  </span><br><span class="line">               invoker = refprotocol.refer(interfaceClass, urls.get(0));  </span><br><span class="line">           &#125; else &#123;  </span><br><span class="line"> </span><br><span class="line">               //当有多个注册服务器时，生成多个客户端代理  </span><br><span class="line">               List&lt;Invoker&lt;?&gt;&gt; invokers = new ArrayList&lt;Invoker&lt;?&gt;&gt;();  </span><br><span class="line">               URL registryURL = null;  </span><br><span class="line">               for (URL url : urls) &#123;  </span><br><span class="line">                   //多个服务端，生成多个对应的invoker对象  </span><br><span class="line">                   invokers.add(refprotocol.refer(interfaceClass, url));  </span><br><span class="line">                   if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;  </span><br><span class="line">                       registryURL = url; // 用了最后一个注册服务器作为注册中心 registry url  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               if (registryURL != null) &#123; // 有 注册中心协议的URL  </span><br><span class="line">                   // 对有注册中心的集群 只用 AvailableCluster  </span><br><span class="line">                   URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);   </span><br><span class="line">                   invoker = cluster.join(new StaticDirectory(u, invokers));  </span><br><span class="line">               &#125;  else &#123; // 不是 注册中心的URL  </span><br><span class="line">                   invoker = cluster.join(new StaticDirectory(invokers));  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line"> </span><br><span class="line">       Boolean c = check;  </span><br><span class="line">       if (c == null &amp;&amp; consumer != null) &#123;  </span><br><span class="line">           c = consumer.isCheck();  </span><br><span class="line">       &#125;  </span><br><span class="line">       if (c == null) &#123;  </span><br><span class="line">           c = true; // default true  </span><br><span class="line">       &#125;  </span><br><span class="line">       if (c &amp;&amp; ! invoker.isAvailable()) &#123;  </span><br><span class="line">           throw new IllegalStateException(&quot;Failed to check the status of the service &quot; + interfaceName + &quot;. No provider available for the service &quot; + (group == null ? &quot;&quot; : group + &quot;/&quot;) + interfaceName + (version == null ? &quot;&quot; : &quot;:&quot; + version) + &quot; from the url &quot; + invoker.getUrl() + &quot; to the consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion());  </span><br><span class="line">       &#125;  </span><br><span class="line">       if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">           logger.info(&quot;Refer dubbo service &quot; + interfaceClass.getName() + &quot; from url &quot; + invoker.getUrl());  </span><br><span class="line">       &#125;  </span><br><span class="line">       // 创建服务代理  </span><br><span class="line">       return (T) proxyFactory.getProxy(invoker);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面方法中主要做了一件事情就是创建客户端接口的invoker对象，我们重点解析这段代码 invoker = refprotocol.refer(interfaceClass, url);Protocol有很多个实现类，但是ReferenceConfig作为服务提供方的一个接口实例，此时并不知道该调用哪个实现类，当生成一个refprotocol来代表所有的实现类，当调用到该类中的export方法的时候，再根据方法的参数来决定调用到哪个具体的实现类中，相当于一种高级别的代理。</p>
<p>refprotocol对象是什么怎么创建的，创建代码如下 <code>Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code>具体如何创建出来的后面专门通过章节来讲解， 这里我就默认refprotocol属性是DubboProtocol类了，查看该类的refer方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123;  </span><br><span class="line">  </span><br><span class="line">        // modified by lishen  </span><br><span class="line">        optimizeSerialization(url);  </span><br><span class="line">  </span><br><span class="line">        // create rpc invoker.  </span><br><span class="line">        DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);  </span><br><span class="line">        invokers.add(invoker);  </span><br><span class="line">        return invoker;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invoker对象原来就是DubboInvoker类。因为DubboInvoker继承了AbstractInvoker类，它重写了父类的doInvoke方法。在看看AbstractInvoker代码，它的invoke方法中最终还是执行了doInvoke方法，因为当前类的doInvoke是抽象的，所以最终还是执行了DubboInvoker中的doInvoke方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class DubboInvoker&lt;T&gt; extends AbstractInvoker&lt;T&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">        private final ExchangeClient[]      clients;  </span><br><span class="line">  </span><br><span class="line">        private final AtomicPositiveInteger index = new AtomicPositiveInteger();  </span><br><span class="line">  </span><br><span class="line">        private final String                version;  </span><br><span class="line">          </span><br><span class="line">        private final ReentrantLock     destroyLock = new ReentrantLock();  </span><br><span class="line">          </span><br><span class="line">        private final Set&lt;Invoker&lt;?&gt;&gt; invokers;  </span><br><span class="line">          </span><br><span class="line">        public DubboInvoker(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients)&#123;  </span><br><span class="line">            this(serviceType, url, clients, null);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        public DubboInvoker(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients, Set&lt;Invoker&lt;?&gt;&gt; invokers)&#123;  </span><br><span class="line">            super(serviceType, url, new String[] &#123;Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY&#125;);  </span><br><span class="line">            this.clients = clients;  </span><br><span class="line">            // get version.  </span><br><span class="line">            this.version = url.getParameter(Constants.VERSION_KEY, &quot;0.0.0&quot;);  </span><br><span class="line">            this.invokers = invokers;   </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        @Override  </span><br><span class="line">        protected Result doInvoke(final Invocation invocation) throws Throwable &#123;  </span><br><span class="line">            RpcInvocation inv = (RpcInvocation) invocation;  </span><br><span class="line">            final String methodName = RpcUtils.getMethodName(invocation);  </span><br><span class="line">            inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());  </span><br><span class="line">            inv.setAttachment(Constants.VERSION_KEY, version);  </span><br><span class="line">              </span><br><span class="line">            ExchangeClient currentClient;  </span><br><span class="line">            if (clients.length == 1) &#123;  </span><br><span class="line">                currentClient = clients[0];  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                currentClient = clients[index.getAndIncrement() % clients.length];  </span><br><span class="line">            &#125;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);  </span><br><span class="line">                boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);  </span><br><span class="line">                int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY,Constants.DEFAULT_TIMEOUT);  </span><br><span class="line">                if (isOneway) &#123;  </span><br><span class="line">                    //只负责发送消息，不需要等待反馈接口，所以结果始终未NULL  </span><br><span class="line">                    boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);  </span><br><span class="line">                    currentClient.send(inv, isSent);  </span><br><span class="line">                    RpcContext.getContext().setFuture(null);  </span><br><span class="line">                    return new RpcResult();  </span><br><span class="line">                &#125; else if (isAsync) &#123;  </span><br><span class="line">                    //异步请求  </span><br><span class="line">                    ResponseFuture future = currentClient.request(inv, timeout) ;  </span><br><span class="line">                    RpcContext.getContext().setFuture(new FutureAdapter&lt;Object&gt;(future));  </span><br><span class="line">                    return new RpcResult();  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    //默认阻塞请求  </span><br><span class="line">                    RpcContext.getContext().setFuture(null);  </span><br><span class="line">                    return (Result) currentClient.request(inv, timeout).get();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; catch (TimeoutException e) &#123;  </span><br><span class="line">                throw new RpcException(RpcException.TIMEOUT_EXCEPTION, &quot;Invoke remote method timeout. method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);  </span><br><span class="line">            &#125; catch (RemotingException e) &#123;  </span><br><span class="line">                throw new RpcException(RpcException.NETWORK_EXCEPTION, &quot;Failed to invoke remote method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        @Override  </span><br><span class="line">        public boolean isAvailable() &#123;  </span><br><span class="line">            if (!super.isAvailable())  </span><br><span class="line">                return false;  </span><br><span class="line">            for (ExchangeClient client : clients)&#123;  </span><br><span class="line">                if (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY))&#123;  </span><br><span class="line">                    //cannot write == not Available ?  </span><br><span class="line">                    return true ;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public void destroy() &#123;  </span><br><span class="line">            //防止client被关闭多次.在connect per jvm的情况下，client.close方法会调用计数器-1，当计数器小于等于0的情况下，才真正关闭  </span><br><span class="line">            if (super.isDestroyed())&#123;  </span><br><span class="line">                return ;  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                //dubbo check ,避免多次关闭  </span><br><span class="line">                destroyLock.lock();  </span><br><span class="line">                try&#123;  </span><br><span class="line">                    if (super.isDestroyed())&#123;  </span><br><span class="line">                        return ;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    super.destroy();  </span><br><span class="line">                    if (invokers != null)&#123;  </span><br><span class="line">                        invokers.remove(this);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    for (ExchangeClient client : clients) &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            client.close();  </span><br><span class="line">                        &#125; catch (Throwable t) &#123;  </span><br><span class="line">                            logger.warn(t.getMessage(), t);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                      </span><br><span class="line">                &#125;finally &#123;  </span><br><span class="line">                    destroyLock.unlock();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意看doInvoke方法中的实现，从ExchangeClient clients[]数组中取出一个对象currentClient将客户端接口请求信息发送给服务端处理。注意了这里的ExchangeClient保存的是客户端与服务器建立的socket链接对象，也就是netty的客户端对象。 在发送请求处理有3个逻辑判断</p>
<p>1.只负责发送请求，不需要等待反馈消息</p>
<p>2.异步请求</p>
<p>3.默认是阻塞的请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class AbstractProxyFactory implements ProxyFactory &#123;  </span><br><span class="line">  </span><br><span class="line">        public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123;  </span><br><span class="line">            Class&lt;?&gt;[] interfaces = null;  </span><br><span class="line">            String config = invoker.getUrl().getParameter(&quot;interfaces&quot;);  </span><br><span class="line">            if (config != null &amp;&amp; config.length() &gt; 0) &#123;  </span><br><span class="line">                String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);  </span><br><span class="line">                if (types != null &amp;&amp; types.length &gt; 0) &#123;  </span><br><span class="line">                    interfaces = new Class&lt;?&gt;[types.length + 2];  </span><br><span class="line">                    interfaces[0] = invoker.getInterface();  </span><br><span class="line">                    interfaces[1] = EchoService.class;  </span><br><span class="line">                    for (int i = 0; i &lt; types.length; i ++) &#123;  </span><br><span class="line">                        interfaces[i + 1] = ReflectUtils.forName(types[i]);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (interfaces == null) &#123;  </span><br><span class="line">                interfaces = new Class&lt;?&gt;[] &#123;invoker.getInterface(), EchoService.class&#125;;  </span><br><span class="line">            &#125;  </span><br><span class="line">            return getProxy(invoker, interfaces);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        public abstract &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types);  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们回到代理的创建方法ReferenceConfig.createProxy中最后一行的代码return (T) proxyFactory.getProxy(invoker); 最后还是执行了抽象的getProxy方法。因为JavassistProxyFactory类继承了AbstractProxyFactory，并重写了getProxy方法所以最终还是执行了JavassistProxyFactory类中的getProxy方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)  </span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;  </span><br><span class="line">        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

  </div>
  <div class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo/">Dubbo</a></li></ul>
  </div>
</article>
  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2018/01/12/java/2018-01-12-LinkedList/" rel="next" title="LinkedList源码解析">
          LinkedList源码解析
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2018/01/15/dubbo/2018-01-15-DubboDirector/" rel="prev" title="Dubbo源码解析目录">
            Dubbo源码解析目录
          </a>
          <span>〉</span>
        
      </div>
    </div>
  




    </div>

    

  </div>

  <footer class="footer text-center">
    <div id="bottom-inner">
      
      <a href="http://programer.group" target="_blank">主站</a> |
      <a href="https://zhongyp.me" target="_blank">DO IT</a> |
      <a href="https://github.com/zhongyp" target="_blank">GitHub</a> |
      <a href="http://hexo.io" target="_blank">Hexo</a> |
      <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank">Theme microb</a>
    </div>
  </footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



</body>
</html>
