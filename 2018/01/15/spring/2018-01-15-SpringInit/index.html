
<!DOCTYPE html>
<html lang="zh-Hans">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="google-site-verification" content="9GY-OrjvdT8TkXuLJFSJcJqolHfXKJ5NVYKRUv8mCRM">
  
    <meta name="keywords" content="Spring,">
  

  
    <meta name="description" content="钟宇鹏的博客">
  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" type="image/x-icon" href="/logo.png">
  <title>Spring Bean容器加载Bean源码解析（转载） [ DO IT ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/simple.css">
    
  
</head>


<body>
  <nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed">
  <ul class="pure-menu-list float-r clearfix">
    
      <!-- <li class="pure-menu-item toc-menu pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main-post" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
      </li> -->
      <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
        <a id="menu-main" class="pure-menu-link" href="javascript:;">
          <img class="menu-icon" src="/logo.png" alt="MENU">
        </a>
        <ul class="pure-menu-children">
        
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
          
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
          
          
      </ul>
      </li>
    
  </ul>
  <a class="pure-menu-heading" href="/">
      <h1 class="title">DO IT</h1>
      <!-- <span>钟宇鹏的博客</span> -->
  </a>
  <!-- 
  <img class="logo" id="logo" src="/logo.png" alt="logo">
   -->
</nav>


  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <article class="post" id="post">
  <header class="post-header text-center">
    <h1 class="title">
      Spring Bean容器加载Bean源码解析（转载）
    </h1>
    
    <time class="time" datetime="2018-01-14T16:00:00.000Z">
      2018-01-15
    </time>
     |
    <span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
    <hr>
  </header>
  <div class="post-content">
    <h2 id="Spring初始化"><a href="#Spring初始化" class="headerlink" title="Spring初始化"></a>Spring初始化</h2><p>Spring初始化类关系图</p>
<p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/springinit.png?raw=true" alt="Spring初始化类关系图"></p>
<p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/springinit1.png?raw=true" alt="Spring初始化类关系图"></p>
<p>DefaultResourceLoader，该类设置classLoader，并且将配置文件 封装为Resource文件。</p>
<p>AbstractApplicationContext，该类完成了大部分的IOC容器初始化工作，同时也提供了扩展接口留给子类去重载。该类的refresh()函数是核心初始化操作。</p>
<p>AbstractRefreshableApplicationContext，该类支持刷新BeanFactory。</p>
<p>AbstractRefreshableConfigApplicationContext，该类保存了配置文件路径</p>
<p>AbstractXmlApplicationContext：该类支持解析bean定义文件</p>
<p>最后ClassPathXmlApplicationContext:只提供了一个简单的构造函数</p>
<p>Spring 将类职责分开，形成职责链，每一层次的扩展 都只是添加了某个功能</p>
<p>然后父类定义大量的模板，让子类实现，父类层层传递到子类 直到某个子类重载了抽象方法。这里应用到了职责链设计模式和模板设计模式，IOC是个容器工厂设计模式。</p>
<p>测试程序：</p>
<p>Bean配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;test&quot; class=&quot;com.bodu.spring.demo.Test&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring-beans.xml&quot;);</span><br><span class="line">Test test = (Test) ctx.getBean(&quot;test&quot;);</span><br><span class="line">test.getTestName();</span><br></pre></td></tr></table></figure>
<p>开始跟源码啦！！！</p>
<p>Spring初始化时，先初始化Bean容器</p>
<p>测试代码通过new ClassPathXmlApplicationContext(“spring-beans.xml”)，初始化ClassPathXmlApplicationContext实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">	super(parent);// 把ApplicationContext作为父容器，上述测试类中由于直接载入的xml,没有父容器所以实际传了null</span><br><span class="line">	this.setConfigLocations(configLocations);// 替换$&#123;&#125;后设置配置路径</span><br><span class="line">	if(refresh) &#123;</span><br><span class="line">		this.refresh();// 这个会直接访问至AbstractApplicationContext类的refresh方法,这个是容器创建的核心方法</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractRefreshableConfigApplicationContext类 setConfigLocations()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void setConfigLocations(String... locations) &#123;</span><br><span class="line">    if(locations != null) &#123; // 判断locations非null</span><br><span class="line">        Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);// 断言locations元素非空</span><br><span class="line">        this.configLocations = new String[locations.length];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; locations.length; ++i) &#123;</span><br><span class="line">            this.configLocations[i] = this.resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.configLocations = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>refresh()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">	</span><br><span class="line">	Object var1 = this.startupShutdownMonitor;</span><br><span class="line">	// 同步锁，对一个全局对象或者类加锁时，对该类的所有对象都起作用</span><br><span class="line">	synchronized(this.startupShutdownMonitor) &#123;</span><br><span class="line">		// 刷新前的准备工作，准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证。</span><br><span class="line">		this.prepareRefresh();</span><br><span class="line">		//首先调用AbstractRefreshableApplicationContext的refreshBeanFactory()解析xml</span><br><span class="line">		//然后调用AbstractXmlApplicationContext/XmlWebApplicationContext.loadBeanDefinitions()方法，加载bean信息</span><br><span class="line">		// 告诉子类刷新内部bean工厂</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();</span><br><span class="line">		//为BeanFactory配置容器特性，例如类加载器、事件处理器等.</span><br><span class="line">		this.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		    //设置BeanFactory的后置处理. 空方法，留给子类拓展用。</span><br><span class="line">			this.postProcessBeanFactory(beanFactory);</span><br><span class="line">			//在上下文中调用factory工厂的时候注册bean的 实例对象，//调用BeanFactory的后处理器, 这些后处理器是在Bean定义中向容器注册的. </span><br><span class="line">			this.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">			// 注册bean的过程当中拦截所有bean的创建，//注册Bean的后处理器, 在Bean创建过程中调用.</span><br><span class="line">			this.registerBeanPostProcessors(beanFactory);</span><br><span class="line">			//初始化上下文中的消息源，即不同语言的消息体进行国际化处理</span><br><span class="line">			this.initMessageSource();</span><br><span class="line">			//初始化事物传播属性，//初始化ApplicationEventMulticaster bean,应用事件广播器</span><br><span class="line">			this.initApplicationEventMulticaster();</span><br><span class="line">			// 在特定上下文初始化其他特殊bean子类。//初始化其它特殊的Bean， 空方法，留给子类拓展用。</span><br><span class="line">			this.onRefresh();</span><br><span class="line">			// 检查侦听器bean并注册。//检查并向容器注册监听器Bean</span><br><span class="line">			this.registerListeners();</span><br><span class="line">			// 实例化所有剩余(non-lazy-init)单例.//实例化所有剩余的(non-lazy-init) 单例Bean.</span><br><span class="line">			this.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">			// 最后一步:发布对应的事件。//发布容器事件, 结束refresh过程. </span><br><span class="line">			this.finishRefresh();</span><br><span class="line">		&#125; catch (BeansException var9) &#123;</span><br><span class="line">			if(this.logger.isWarnEnabled()) &#123;</span><br><span class="line">				this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);</span><br><span class="line">			&#125;</span><br><span class="line">            // 销毁已经创建的单例对象避免浪费资源</span><br><span class="line">			this.destroyBeans();</span><br><span class="line">			//取消refresh操作, 重置active标志. </span><br><span class="line">			this.cancelRefresh(var9);</span><br><span class="line">			// 异常传播到调用者</span><br><span class="line">			throw var9;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">		    // 在spring 核心包里重置了内存（缓存），因为我们不需要元数据单例bean对象了</span><br><span class="line">			this.resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractRefreshableApplicationContext类</p>
<p style="color:red">refresh方法中obtainFreshBeanFactory方法调用了refreshBeanFactory，该方法使用DefaultListableBeanFactory去定位resources资源</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">    if(this.hasBeanFactory()) &#123;</span><br><span class="line">        this.destroyBeans();//先消除所有已经存在的bean</span><br><span class="line">        this.closeBeanFactory();// beanFactory = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;//创建并设置DefaultListableBeanFactory同时调用loadBeanDefinitions载入loadBeanDefinition</span><br><span class="line">        // 实例化一个工厂，这里是DefaultListableBeanFactory</span><br><span class="line">        DefaultListableBeanFactory beanFactory = this.createBeanFactory();</span><br><span class="line">        </span><br><span class="line">        beanFactory.setSerializationId(this.getId());</span><br><span class="line">        this.customizeBeanFactory(beanFactory);</span><br><span class="line">        // XmlWebApplicationContext方法</span><br><span class="line">        // 在本类中是抽象方法，需要子类AbstractXmlApplicationContext中实现</span><br><span class="line">        this.loadBeanDefinitions(beanFactory);</span><br><span class="line">        Object var2 = this.beanFactoryMonitor;</span><br><span class="line">        synchronized(this.beanFactoryMonitor) &#123; // 同步锁，刷新beanFactory实例</span><br><span class="line">            this.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException var5) &#123;</span><br><span class="line">        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + this.getDisplayName(), var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected DefaultListableBeanFactory createBeanFactory() &#123;</span><br><span class="line">    return new DefaultListableBeanFactory(this.getInternalParentBeanFactory());// 根据beanFactory的父类，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractXmlApplicationContext类</p>
<p style="color:red">loadBeanDefinitions其具体实现在AbstractXmlApplicationContext中，定义了一个Reader作为入参执行载入过程</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">	// //这和在BeanFactory中的加载过程一样，也是委托给XmlBeanDefinitionReader去读取配置文件，</span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">	beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">	beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">	this.initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	// 加载Bean定义</span><br><span class="line">	this.loadBeanDefinitions(beanDefinitionReader);// 核心方法</span><br><span class="line">&#125;</span><br><span class="line">// getConfigResources采用模板方法设计模式，具体的实现由子类完成，实际上这里getConfigResources调用的就是子类ClassPathXmlApplicationContext的getConfigResources方法。ClassPathXmlApplicationContext继承了DefaultResourceLoader，具备了Resource加载资源的功能。至此完成了Resource定位！</span><br><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">	Resource[] configResources = this.getConfigResources();</span><br><span class="line">	if(configResources != null) &#123;</span><br><span class="line">		// 读取配置文件都是用的这个方法，和BeanFactory是一样的，</span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	String[] configLocations = this.getConfigLocations();</span><br><span class="line">	// FileSystemXmlApplicationContext类</span><br><span class="line">	if(configLocations != null) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="color:red">这里支持2种模式：1.模板匹配多资源，生成Resource[]。2.载入单个资源url绝对地址，生成一个Resource</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();//获取ResourceLoader资源加载器</span><br><span class="line">    if (resourceLoader == null) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">                &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 1.匹配模板解析 ClassPathXmlApplicationContext是ResourcePatternResolver接口的实例</span><br><span class="line">    if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">       </span><br><span class="line">        try &#123;//接口ResourcePatternResolver</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            int loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            if (actualResources != null) &#123;</span><br><span class="line">                for (Resource resource : resources) &#123;</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(</span><br><span class="line">                    &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 2.载入单个资源url绝对地址</span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        int loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        if (actualResources != null) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeBeanFactoryPostProcessors方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, this.getBeanFactoryPostProcessors());</span><br><span class="line">	if(beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(&quot;loadTimeWeaver&quot;)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PostProcessorRegistrationDelegate类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line">    Set&lt;String&gt; processedBeans = new HashSet();</span><br><span class="line">    int var9;</span><br><span class="line">    ArrayList currentRegistryProcessors;</span><br><span class="line">    String[] postProcessorNames;</span><br><span class="line">    if(beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;</span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList();</span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new LinkedList();</span><br><span class="line">        Iterator var6 = beanFactoryPostProcessors.iterator();</span><br><span class="line"></span><br><span class="line">        while(var6.hasNext()) &#123;</span><br><span class="line">            BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();</span><br><span class="line">            if(postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;</span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentRegistryProcessors = new ArrayList();</span><br><span class="line">        </span><br><span class="line">        // 不初始化factoryBeans：我们需要把所以没有初始化的bean让bean工厂处理他们，单例BeanDefinitionRegistryPostProcessors之间实现PriorityOrdered接口、序列化接口</span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">        String[] var18 = postProcessorNames;</span><br><span class="line">        var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">        int var10;</span><br><span class="line">        String ppName;</span><br><span class="line">        for(var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">            ppName = var18[var10];</span><br><span class="line">            if(beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">        var18 = postProcessorNames;</span><br><span class="line">        var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">        for(var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">            ppName = var18[var10];</span><br><span class="line">            if(!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line">        boolean reiterate = true;</span><br><span class="line"></span><br><span class="line">        while(reiterate) &#123;</span><br><span class="line">            reiterate = false;</span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">            String[] var21 = postProcessorNames;</span><br><span class="line">            var10 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">            for(int var28 = 0; var28 &lt; var10; ++var28) &#123;</span><br><span class="line">                String ppName = var21[var28];</span><br><span class="line">                if(!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    reiterate = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = new ArrayList();</span><br><span class="line">    currentRegistryProcessors = new ArrayList();</span><br><span class="line">    postProcessorNames = postProcessorNames;</span><br><span class="line">    int var22 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">    String ppName;</span><br><span class="line">    for(var9 = 0; var9 &lt; var22; ++var9) &#123;</span><br><span class="line">        ppName = postProcessorNames[var9];</span><br><span class="line">        if(!processedBeans.contains(ppName)) &#123;</span><br><span class="line">            if(beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">            &#125; else if(beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                orderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentRegistryProcessors.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors((Collection)priorityOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList();</span><br><span class="line">    Iterator var23 = orderedPostProcessorNames.iterator();</span><br><span class="line"></span><br><span class="line">    while(var23.hasNext()) &#123;</span><br><span class="line">        String postProcessorName = (String)var23.next();</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList();</span><br><span class="line">    Iterator var26 = currentRegistryProcessors.iterator();</span><br><span class="line"></span><br><span class="line">    while(var26.hasNext()) &#123;</span><br><span class="line">        ppName = (String)var26.next();</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractApplicationContext类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">    this.startupDate = System.currentTimeMillis();//获取时间</span><br><span class="line">    //AtomicBoolean是java.util.concurrent.atomic包下的原子变量，这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。</span><br><span class="line">    this.closed.set(false);</span><br><span class="line">    this.active.set(true);</span><br><span class="line">    if(this.logger.isInfoEnabled()) &#123;</span><br><span class="line">        this.logger.info(&quot;Refreshing &quot; + this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.initPropertySources();// 空方法</span><br><span class="line">    // 校验所有可解析的根据需要标记的属性</span><br><span class="line">    this.getEnvironment().validateRequiredProperties();// 校验在接口ConfigurablePropertyResolver接口中定义，未找到实现类</span><br><span class="line">    this.earlyApplicationEvents = new LinkedHashSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">    this.refreshBeanFactory();// 新实例化一个beanFactory</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();// 获取beanFactory</span><br><span class="line">    if(this.logger.isDebugEnabled()) &#123;</span><br><span class="line">        this.logger.debug(&quot;Bean factory for &quot; + this.getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FileSystemXmlApplicationContext</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">	super(parent);</span><br><span class="line">	this.setConfigLocations(configLocations);</span><br><span class="line">	if(refresh) &#123;</span><br><span class="line">		this.refresh();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别"><a href="#ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别" class="headerlink" title="ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别"></a>ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别</h2><p>ClassPathXmlApplicationContext</p>
<p>ClassPathXmlApplicationContext[只能读放在web-info/classes目录下的配置文件]，classpath:前缀是不需要的,默认就是指项目的classpath路径下面;如果要使用绝对路径,需要加上file:前缀表示这是绝对路径;<br>对于FileSystemXmlApplicationContext，默认表示的是两种，如果要使用classpath路径,需要前缀classpath: </p>
<h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="http://www.cnblogs.com/dennyzhangdd/p/7652075.html" target="_blank" rel="noopener">只会一点Java</a></p>

  </div>
  <div class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li></ul>
  </div>
</article>
  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2018/01/15/dubbo/2018-01-15-XSD/" rel="next" title="XSD文件解析">
          XSD文件解析
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2018/01/25/mysql/2018-01-25-Procedures/" rel="prev" title="存储过程">
            存储过程
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring初始化"><span class="toc-text">Spring初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别"><span class="toc-text">ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考博文"><span class="toc-text">参考博文</span></a></li></ol>
  </div>



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

    </div>

    

  </div>

  <footer class="footer text-center">
    <div id="bottom-inner">

      <a href="http://programer.group" target="_blank">主站</a> |
      <a href="http://zhongyp.me">DO IT</a> |
      <a href="https://github.com/zhongyp" target="_blank">GitHub</a> |
      <a href="http://hexo.io" target="_blank">Hexo</a> |
      <a href="https://github.com/zhongyp/hexo-theme-simple" target="_blank">Theme simple</a> |
      <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank">Base on theme microb</a> |
      <a><span id="busuanzi_container_site_pv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></a> |
      <a><span id="busuanzi_container_site_pv">本站访问量<span id="busuanzi_value_site_pv"></span>次</span></a>
    </div>
  </footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     *
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }

    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      // var menu = document.getElementById('menu-main-post');
      // if (menu) {
      //   var toc = document.getElementById('toc');
      //   if (toc) {
      //     menu.onclick = function() {
      //       if (toc) {
      //         if (toc.style.display == 'block') {
      //           toc.style.display = 'none';
      //         } else {
      //           toc.style.display = 'block';
      //         }
      //       }
      //     };
      //   } else {
      //     menu.style.display = 'none';
      //   }
      // }
    }

  })(window, document);
</script>


  



</body>
</html>
