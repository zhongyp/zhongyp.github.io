<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Git常用命令总结</title>
      <link href="/2018/10/23/utils/2018-10-23-git/"/>
      <url>/2018/10/23/utils/2018-10-23-git/</url>
      <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>系统系统性的学习Git，请移步<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Git中文学习文档</a>，这篇文章只是分类记录一下git的常用命令。</p><p><img src="/media/15403035072735.jpg" alt="Git版本控制系统VCS基本操作流程图"></p><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><h3 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h3><p><code>git init</code> 将当前目录变为可管理的仓库<br><code>git clone</code> 克隆一个仓库到本地</p><h3 id="设置与配置"><a href="#设置与配置" class="headerlink" title="设置与配置"></a>设置与配置</h3><p><code>git config -global user.name/email &quot;参数&quot;</code> git是分布式版本控制，所以添加用户名和邮箱作为一个标识<br><code>ssh -keygen -t rsa -C &quot;email&quot;</code> 生成本地ssh key</p><h3 id="将文件提交到版本库"><a href="#将文件提交到版本库" class="headerlink" title="将文件提交到版本库"></a>将文件提交到版本库</h3><p><code>git add &quot;filename.*&quot;</code> 添加到暂存区<br><code>git commit -m &quot;filename.*&quot;</code> 提交到仓库<br><code>git commit --amend</code> 尝试重新提交,这个操作需要组合操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add file1 // 将file1 添加至缓存区</span><br><span class="line">git commmit -m &quot;update files&quot; //提交file1到本地仓库,提交完发现忘记file2没有提交，则你可以使用如下命令，提交file2并覆盖之前的提交信息。</span><br><span class="line">git add file2 // 添加file2</span><br><span class="line">git commit -amend // 尝试重新提交commit信息，并覆盖掉之前的提交信息</span><br></pre></td></tr></table></figure><p><code>git status</code> 查看文件状态<br><code>git diff filename.*</code> 查看修改了什么<br><code>git log</code> 看看每次修改的日志<br><code>git log --pretty=oneline</code> 日志显示为缩略版<br>注：<code>git reset</code> 不加<code>--hard</code>参数对当前工作区文件不会有任何修改，只是对缓存区进行操作。一旦加了参数，操作一定要慎重，否则你当前工作区中的修改将会全部被清除。<br><code>git reset HEAD file</code> 将file退回到当前版本（仅仅是对缓存区进行操作）<br><code>git reset --hard HEAD^</code> 退回到上一版本<br><code>git reset --hard HEAD^^</code> 退回到前二的版本<br><code>git reset --hard HEAD~100</code> 退回到前100版本<br><code>git reset --hard 版本号</code> 退回到一个特定的版本<br><code>git reflog</code> 查看版本号和上一个命令一块用效果比较好<br><code>git rm --cached file</code> 删除缓存区file<br><code>git checkout -- file</code> 恢复工作区file（取消工作区文件的修改）</p><h3 id="git远程库"><a href="#git远程库" class="headerlink" title="git远程库"></a>git远程库</h3><p><code>git remote add origin 远程git地址</code> 连接<br><code>git push -u origin master</code> 把本地库分支master内容推送到远程库（-u 命令在第一次关联本地库和远程库时使用）<br><code>git clone url</code> 克隆远程(url)库</p><h3 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h3><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p><code>git branch</code> 查看分支<br><code>git checkout</code> 切换分支<br><code>git checkout -b</code>  创建并切换分支<br><code>git merge</code> 合并到当前分支<br><code>git branch -d</code>删除某分支<br><code>git merge --no-ff -m &quot;注释&quot;</code>分支合并分支禁用fast forward<br><code>git stash</code> 将当前分支的工作现场保留下来<br><code>git stash list</code> 查看工作现场<br><code>git stash apply</code> 恢复内容但是你需要git stash drop删除stash<br><code>git stash pop</code> 恢复的同时把stash内容也删除</p><p>注：如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p><code>git remote</code> 查看远程库的信息<br><code>git remote -v</code> 查看远程库的详细信息<br><code>git push origin master</code> master为本地的分支名推送分支<br><code>git checkout -b dev origin/dev</code> dev为分支名，做完开发后<br><code>git push origin dev</code> 推送到远程库<br><code>git pull</code> 抓取最新的提交,并尝试自动合并到本地当前所在的分支<br><code>git fetch</code> 抓取最新的提交，不会自动合并，必须手动。<br><code>git branch --set-upstream dev origin/dev</code> 指定本地dev分支（已经创建的）与远程origin/dev分支的连接<br><code>git branch -u origin/dev</code> 指定当前所在连接远程origin/dev分支的连接<br><code>git checkout --track origin/dev</code> 创建新的dev分支，制定远程连接origin/dev</p>]]></content>
      
      
        <tags>
            
            <tag> Utils </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring AOP</title>
      <link href="/2018/10/03/spring/2018-09-28-AOP/"/>
      <url>/2018/10/03/spring/2018-09-28-AOP/</url>
      <content type="html"><![CDATA[<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>本篇文章翻译自<a href="https:www.tutorialspoint.com/spring/aop_with_spring.htm" target="_blank" rel="noopener">AOP with Spring</a>，主要介绍是关于AOP的概念。</p><h3 id="Brief-introduction-（简介）"><a href="#Brief-introduction-（简介）" class="headerlink" title="Brief introduction （简介）"></a>Brief introduction （简介）</h3><p>One of the key components of Spring Framework is the Aspect oriented programming (AOP) framework. Aspect-Oriented Programming entails breaking down program logic into distinct parts called so-called concerns. The functions that span multiple points of an application are called cross-cutting concerns and these cross-cutting concerns are conceptually separate from the application’s business logic. There are various common good examples of aspects like logging, auditing, declarative transactions, security, caching, etc.</p><p>The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Dependency Injection helps you decouple your application objects from each other and AOP helps you decouple cross-cutting concerns from the objects that they affect. AOP is like triggers in programming languages such as Perl, .NET, Java, and others.</p><p>Spring AOP module provides interceptors to intercept an application. For example, when a method is executed, you can add extra functionality before or after the method execution.</p><p>翻译：</p><p>AOP面向切面编程是Spring框架中的最关键的部分之一。面向切面编程需要拆分程序逻辑到被称为关注点的不同部分。一个在应用程序内跨越多个点的方法被称为横切点，这些横切点和应用的业务逻辑在概念上是分开的。目前已经有很多应用切面的例子，比如日志，审计，声明式事务，安全，缓存等。</p><p>在面向对象编程中，模块化的关键单元是类，但是在面向切面编程中，模块化单元是切面。依赖注入帮助你将应用中的对象相互解耦，AOP帮助你将横切点从它们作用的对象中解耦。AOP就像是Perl,.NET,Java或者其他编程语言中的触发器。</p><p>Spring AOP模块提供拦截应用的拦截器。举个🌰，你可以在你运行的方法之前或者之后添加额外的功能或者方法。</p><h3 id="AOP-Terminologies（AOP-术语）"><a href="#AOP-Terminologies（AOP-术语）" class="headerlink" title="AOP Terminologies（AOP 术语）"></a>AOP Terminologies（AOP 术语）</h3><h4 id="Aspect（切面）"><a href="#Aspect（切面）" class="headerlink" title="Aspect（切面）"></a>Aspect（切面）</h4><p>This is a module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement.</p><p>翻译： Aspect一个提供横切（cross-cutting）APIs的模块。举个例子，日志模块被称为AOP 日志切面。一个应用可以根据需求拥有任何数量的切面。</p><h4 id="Join-point（连接点）"><a href="#Join-point（连接点）" class="headerlink" title="Join point（连接点）"></a>Join point（连接点）</h4><p>This represents a point in your application where you can plug-in the AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.</p><p>翻译： 在应用中可以插入AOP切面的地方可被抽象为一个点。你也可以说，这是一个在应用中存在的地方，这个地方将被Spring AOP 框架执行一些动作。</p><p>Advice（通知）</p><p>This is the actual action to be taken either before or after the method execution. This is an actual piece of code that is invoked during the program execution by Spring AOP framework.</p><p>翻译：Advice是一个实际的动作，它将在方法执行前和方法执行后执行。这段代码通过Spring AOP框架在程序运行时被调用。</p><h4 id="Pointcut（切入点）"><a href="#Pointcut（切入点）" class="headerlink" title="Pointcut（切入点）"></a>Pointcut（切入点）</h4><p>This is a set of one or more join points where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples.</p><p>翻译：Pointcut是一个或者多个连接点的集合。正如我们将在AOP例子中看到的，你可以使用表达式或者正则表达式制定你的切入点。</p><h4 id="Introduction（引入）"><a href="#Introduction（引入）" class="headerlink" title="Introduction（引入）"></a>Introduction（引入）</h4><p>An introduction allows you to add new methods or attributes to the existing classes.</p><p>翻译：引入可以允许你添加新的方法或者属性到已经存在的类中。</p><h4 id="Target-object"><a href="#Target-object" class="headerlink" title="Target object"></a>Target object</h4><p>The object being advised by one or more aspects. This object will always be a proxied object, also referred to as the advised object.</p><p>翻译：这个对象被一个或者多个切面通知。这个对象一般是代理对象，作为被通知对象引用。</p><h4 id="Weaving（织入）"><a href="#Weaving（织入）" class="headerlink" title="Weaving（织入）"></a>Weaving（织入）</h4><p>Weaving is the process of linking aspects with other application types or objects to create an advised object. This can be done at compile time, load time, or at runtime.</p><p>翻译：织入是链接切面和其他应用类型或者对象来创建通知对象的过程。这个过程可以在编译、加载或者执行期间进行。</p><h3 id="Types-of-Advice"><a href="#Types-of-Advice" class="headerlink" title="Types of Advice"></a>Types of Advice</h3><p>Spring aspects can work with five kinds of advice mentioned as follows.<br>翻译：Spring 切面可以使用如下提到的五种advice</p><ul><li><p>before: Run advice before a method execution.</p></li><li><p>after: Run advice after a method execution.</p></li><li><p>after-returning: Run advice after the a method execution only if method completes successfully.</p></li><li><p>after-throwing: Run advice after the method execution only if method exits by throwing an exception.</p></li><li><p>around: Run advice before and after the advised method is invoked.</p></li></ul><h3 id="Custom-Aspects-Implementation-自定义接口实现"><a href="#Custom-Aspects-Implementation-自定义接口实现" class="headerlink" title="Custom Aspects Implementation(自定义接口实现)"></a>Custom Aspects Implementation(自定义接口实现)</h3><p>XML Schema based（基于XML模式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http:www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http:www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http:www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:tx=&quot;http:www.springframework.org/schema/tx&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http:www.springframework.org/schema/beans</span><br><span class="line">        http:www.springframework.org/schema/beans/spring-beans-4.2.xsd</span><br><span class="line">        http:www.springframework.org/schema/aop</span><br><span class="line">        http:www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 业务逻辑类--AOP连接点 --&gt;</span><br><span class="line">    &lt;bean id=&quot;aopTest&quot; class=&quot;com.zhongyp.zen.service.aop.AOPTestService&quot; /&gt;</span><br><span class="line">    &lt;!--AOP切面--&gt;</span><br><span class="line">    &lt;bean id=&quot;timeHandler&quot; class=&quot;com.zhongyp.zen.service.handler.TimeHandler&quot; /&gt;</span><br><span class="line">    &lt;!--AOP切面--&gt;</span><br><span class="line">    &lt;bean id=&quot;printHandler&quot; class=&quot;com.zhongyp.zen.service.handler.PrintHandler&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspectj-autoproxy /&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!-- pointcut切入点（AOP连接点的集合）--&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.zhongyp.zen.service.*.*.*(..))&quot; /&gt;</span><br><span class="line">        &lt;!-- 切面 --&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt;</span><br><span class="line">            &lt;!-- AOP Advice --&gt;</span><br><span class="line">            &lt;aop:before method=&quot;printStartTime&quot; pointcut-ref=&quot;pointcut&quot; /&gt;</span><br><span class="line">            &lt;aop:after method=&quot;printEndTime&quot; pointcut-ref=&quot;pointcut&quot; /&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;print&quot; ref=&quot;printHandler&quot;&gt;</span><br><span class="line">            &lt;aop:after-returning method=&quot;printString&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after-returning&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>@AspectJ based（基于切面注解）</p><p>注解方式可以将上述xml配置以注解的形式配置一下，我这里只是给出一个样例，其他的还需读者自己实践。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component(&quot;logHandler&quot;)</span><br><span class="line">public class LogHandler &#123;</span><br><span class="line">    @Pointcut(&quot;execution(* com.zhongyp.zen.service.*.*.*(..))&quot;)</span><br><span class="line">    private void hehe()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    @Before(&quot;hehe()&quot;)</span><br><span class="line">    public void doBefore()&#123;</span><br><span class="line">        System.out.println(&quot;为毛国庆要加班！！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高性能MySQL -- 摘自《高性能MySQL第三版》</title>
      <link href="/2018/04/02/mysql/2018-04-02-MySQL/"/>
      <url>/2018/04/02/mysql/2018-04-02-MySQL/</url>
      <content type="html"><![CDATA[<h2 id="引擎篇"><a href="#引擎篇" class="headerlink" title="引擎篇"></a>引擎篇</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li><p>Myisam是Mysql的默认存储引擎，当create创建新表时，未指定新表的存储引擎时，默认使用Myisam。</p></li><li><p>每个MyISAM在磁盘上存储成三个文件。文件名都和表名相同，扩展名分别是.frm（存储表定义）、.MYD (MYData，存储数据)、.MYI (MYIndex，存储索引)。数据文件和索引文件可以放置在不同的目录，平均分布io，获得更快的速度。</p></li><li><p>它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一 .</p></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li><p>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比Myisam的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</p></li><li><p>用于事务处理应用程序，具有众多特性，包括ACID 事务支持。</p></li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>将所有数据保存在RAM 中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。</p><table><br><tr></tr><br><tr></tr><br><tr><td>特点</td><td>Myisam</td><td> BDB</td><td> Memory</td> <td>InnoDB</td><td> Archive</td></tr><br><tr><td>存储限制</td><td>没有</td><td>没有</td><td>有</td><td>64TB </td><td>没有</td></tr><br><tr><td>事务安全</td><td></td><td>支持</td><td></td><td>支持</td><td></td></tr><br><tr><td>锁机制</td><td>表锁</td><td>页锁</td><td>表锁</td><td>行锁</td><td>行锁</td></tr><br><tr><td>B 树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><br><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><br><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><br><tr><td>集群索引</td><td></td><td></td><td></td><td>支持</td><td></td></tr><br><tr><td>数据缓存</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><br><tr><td>索引缓存</td><td>支持</td><td></td><td>支持</td><td>支持</td><td></td></tr><br><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td>支持</td></tr><br><tr><td>空间使用</td><td>低</td><td>低</td><td>N/A</td><td> 高</td><td>非常低</td></tr><br><tr><td>内存使用</td><td>低</td><td>低</td><td>中等</td><td>高</td><td>低</td></tr><br><tr><td>批量插入的速度</td><td>高</td><td>高</td><td>高</td><td>低</td><td>非常高</td></tr><br><tr><td>支持外键</td><td></td><td></td><td></td><td>支持</td><td></td></tr><br><tr></tr><br></table><h2 id="Schema与数据类型优化"><a href="#Schema与数据类型优化" class="headerlink" title="Schema与数据类型优化"></a>Schema与数据类型优化</h2><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li><p>一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p></li><li><p>简单的数据类型通常需要更少的CPU周期。</p></li><li><p>尽量避免使用NULL，原因是由于NULL可能需要单独的位（bit）去存储或者NULL使得索引、索引统计、值比较都更为复杂。</p></li></ul><h3 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h3><ul><li><p>范式化的更新操作会比反范式化的快。</p></li><li><p>当数据较好范式化的时候，只有很少或者没有重复数据，所以只需要修改更少的数据。</p></li><li><p>范式化的表通常更小。</p></li><li><p>很少有冗余数据意味着检索列表数据更少需要distinct或者group by语句。</p></li></ul><h3 id="反范式的优点和缺点"><a href="#反范式的优点和缺点" class="headerlink" title="反范式的优点和缺点"></a>反范式的优点和缺点</h3><ul><li>反范式的schema所有数据都在一张表中，可以很好的避免关联，还可以避免随机IO(和存储引擎有关)。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>尽可能避免过度设计，例如会导致复杂查询的schema设计，或者有很多列的表的设计。</p></li><li><p>使用小而简单的合适数据类型，除非真实数据模型中确切的需要，否则应尽可能的避免NULL值。</p></li><li><p>尽量使用相同的数据类型存储相似或者相关的值，尤其是在关联条件中要使用的列。</p></li><li><p>避免使用MySQL已经遗弃的特性，例如浮点数的精度，或者整数的显示宽度。</p></li><li><p>小心使用ENUM和SET。避免使用BIT。</p></li></ul><h2 id="高性能索引创建"><a href="#高性能索引创建" class="headerlink" title="高性能索引创建"></a>高性能索引创建</h2><p>系统从磁盘读取数据到内存是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页（page）的概念，页是其磁盘管理的最小单位。</p><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><h4 id="B-Tree索引（平衡多路查找树）"><a href="#B-Tree索引（平衡多路查找树）" class="headerlink" title="B-Tree索引（平衡多路查找树）"></a>B-Tree索引（平衡多路查找树）</h4><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree.png?raw=true" alt="b-tree"></p><p>B-Tree 通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。B-Tree索引能够加快访问数据的速度，存储引擎不需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放指向子节点的指针，存储引擎根据这些指针向下层查找。指针中定义了子节点页中值的<br>上限和下限。最终找到该值或者不存在。</p><p>叶子节点比较特殊，他们指向的是被索引的数据，而不是其他的节点页。</p><p>树的深度和表的大小直接相关。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree1.png?raw=true" alt="b-tree"></p><p>可以使用B-Tree索引的查询类型：</p><p>全值匹配：全值匹配指的是和索引的所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen 1960-01-01。</p><p>匹配最左前缀：可用于查找索引的第一列。</p><p>匹配列前缀：也可以匹配某一列的值的开头部分。</p><p>匹配范围值：遵循最左前缀的前提下，范围查找。</p><p>精确匹配某一列并范围匹配另外一列：可用于查找所有姓为Allen,并且名字是字母K开头的人。</p><p>只访问索引的查询：B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。</p><p>B-Tree使用限制：</p><p>必须遵循最左原则。</p><p>如果查询中某个列的范围查询，则其右边所有列都无法使用索引优化查找。</p><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>在B-tree的基础上，为叶子节点增加链表指针，而且所有的关键字都在叶子节点中出现，且数据只存储在叶子节点中。非叶子节点的关键字仅作为叶子节点的索引。</p><h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h4><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><p>在MySQL中，只有Memory引擎显式支持哈希索引且支持非唯一哈希索引的。</p><p>哈希索引每个槽点编号是有序的。</p><p>哈希索引使用限制：</p><p>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</p><p>哈希索引并不是按照索引值顺序存储的，所以无法用于排序。</p><p>哈希索引也不支持部分索引列的匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</p><p>哈希索引支持等值比较查询，包括=、in()、&lt;=&gt;也不支持任何范围查询，例如WHERE price &gt; 100。</p><p>访问哈希索引的数据非常快，除非有很多哈希冲突。</p><p>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。</p><p>除了Memory引擎外，NDB集群引擎也支持唯一哈希索引，且在NDB集群引擎中作用非常特殊。</p><p>InnoDB引擎有一个特殊的功能叫“自适应哈希索引”。当InnoDB引擎注意到某些索引值被使用的非常频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型索引，它查找的是文本中的关键词，而不是直接比较索引中的值。适用于MATCH AGINST操作，而不是普通的WHERE条件操作。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li><p>索引大大减少了服务器需要扫描的数据量。</p></li><li><p>索引可以帮助服务器避免排序和临时表。</p></li><li><p>索引可以将随机IO变为顺序IO。</p></li></ul><h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。我们应该简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。</p><p>例如：<code>select actor_id from sakila.actor where actor_id + 1 = 4</code></p><h4 id="前缀索引和索引的选择性"><a href="#前缀索引和索引的选择性" class="headerlink" title="前缀索引和索引的选择性"></a>前缀索引和索引的选择性</h4><p>问题： 有时候需要索引很长的字符串，这会让索引变的大且慢。</p><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但会降低索引的选择性。</p><p>一般情况下对于Blob、text或者很长的varchar()类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p><p>前缀的基数应该接近于完整列的基数。</p><h4 id="多索引列"><a href="#多索引列" class="headerlink" title="多索引列"></a>多索引列</h4><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。</p><h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>多列索引的列顺序经典法则：当不需要考虑排序和分组时，将选择性最高的列放到索引最前列。大都情况下是适用的，也需要根据业务去考虑一些特殊情况。</p><p>需要考虑哪些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单纯的索引类型，而是一种数据存储方式。具体细节依赖其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p><p>当表有聚簇索引时，它的数据行实际存放在索引的叶子页中。术语“聚簇”标识数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>由于是存储引擎自己实现聚簇索引，因此不是每个引擎都支持聚簇索引。</p><p>叶子页包含了行的全部数据，但是节点页只包含了索引列。InnoDB将通过主键聚集数据，这也就是说图中的“被索引列”就是主键列。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/clusterindex.png?raw=true" alt="cluster-index"></p><p>注： 如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。</p><p>聚簇索引的优点：</p><ul><li><p>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘IO。</p></li><li><p>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引查找的要快。</p></li><li><p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p></li></ul><p>聚簇索引缺点：</p><ul><li><p>聚簇索引最大限度的提高了IO密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有什么优势了。</p></li><li><p>插入速度严重依赖插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用optimize table命令重新组织一下表。</p></li><li><p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被动更新的行移动到新的位置。</p></li><li><p>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</p></li><li><p>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</p></li><li><p>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</p></li><li><p>二级索引访问需要两次索引查找，而不是一次。二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找对应的行。对于InnoDB，自适应性哈希索引能够减少这样重复的工作。</p></li></ul><h4 id="InnoDB和MyISAM的数据分布对比"><a href="#InnoDB和MyISAM的数据分布对比" class="headerlink" title="InnoDB和MyISAM的数据分布对比"></a>InnoDB和MyISAM的数据分布对比</h4><p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table    layout_test&#123;</span><br><span class="line">col1 int not null,</span><br><span class="line">col2 int not null,</span><br><span class="line">primary key(col1),</span><br><span class="line">key(col2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设该表主键取值1-10000，按照随机顺序插入并使用OPTIMIZE TABLE命令做了优化。换句话说，数据在磁盘上的存储已经做到最优，但行的顺序是随机的。</p><p>列col2的值是从1-100的随机值，所以有很多重复的值。</p><p>MyISAM数据（非聚簇）分布：</p><p>MyISAM按照数据插入顺序存储在磁盘上。</p><p>在行的旁边显示行号，从0开始递增。因为行是定长的，所以MyISAM可以从表的开头跳过所需的字节找到需要的行。</p><p>这种分布方式容易创建索引。</p><p>数据分布：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/myisam.png?raw=true" alt="数据分布"></p><p>主键分布：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/myisamcol.png?raw=true" alt="表的主键"></p><p>col2列索引分布：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/myisamkey.png?raw=true" alt="col2列索引分布"></p><p>InnoDB数据（聚簇）分布：</p><p>InnoDB支持聚簇索引，所以使用非常不同的方式存储同样的数据。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/innodbkey.png?raw=true" alt="主键分布"></p><p>该图显示了整个表，而不是只有索引。在InnoDB中，聚簇索引就是表，所以不像MyISAM那样需要独立的存储。</p><p>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。</p><p>InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。利：减少了当出现行移动或者数据页分裂时二级索引的维护工作。弊：使用主键值当做指针会让二级索引占用更多的空间。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/innodb.png?raw=true" alt="索引分布"></p><p>上图显示了示例表col2的索引，每一个叶子节点都包含了索引列（col2）,紧接着是主键值（col1）。</p><p>该图展示了B-Tree的叶子节点结构，InnoDB的非叶子节点包含了索引列和一个指向下级节点的指针（下一级节点可以是非叶子节点，也可以是叶子节点）。这对聚簇索引和二级索引都适用。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/innodba.png?raw=true" alt="聚簇索引和非聚簇索引"></p><h4 id="InnoDB表中按主键顺序插入行"><a href="#InnoDB表中按主键顺序插入行" class="headerlink" title="InnoDB表中按主键顺序插入行"></a>InnoDB表中按主键顺序插入行</h4><p>如果正在使用InnoDB表并且并没有什么数据需要聚集，可以定义一个代理键作为主键，最简单的方法是使用AUTO_INCREMENT自增列。这样可以保证数据按顺序写入，对于根据主键做关联操作的性能也会更好。</p><p>最好避免随机（不连续且值分布范围非常大）聚簇索引，特别对IO密集型应用。从性能考虑，使用UUID作为聚簇索引，使得聚簇索引的插入变的完全随机，使得数据没有任何聚集特性。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/clustersort.png?raw=true" alt="聚簇索引插入顺序的索引值"></p><p>如上图所示，因为主键的值是顺序的，所以InnoDB把每一条纪律都存储在上一条纪律后面。当达到页的最大填充因子时，下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。</p><p>聚簇索引顺序插入缺点：</p><ul><li><p>对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用（主键引起间隙锁竞争）。</p></li><li><p>另一个热点是AUTO_INCREMENT锁机制，如果遇到这个问题，可以重新设计表或者应用，或者修改innodb_autoinc_lock_mode配置。</p></li></ul><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/clusternosort.png?raw=true" alt="非聚簇索引插入顺序的索引值"></p><p>非聚簇索引因为新行的主键值不一定比之前插入的大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找需要的位置—通常是已有数据的中间位置—并且分配空间。还会增加很多额外的工作，并导致数据分布不够优化。</p><p>非聚簇索引插入缺点：</p><ul><li><p>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这样会导致大量的随机IO。</p></li><li><p>因为写入是乱序的，InnoDB不得不频繁的做页分裂操作，以便新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</p></li><li><p>由于频繁的页分裂，页会变的稀疏并被不规则的填充，所以最终会有数据碎片。</p></li></ul><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>通常大家会根据查询的where条件来创建索引，不过这只是优化索引的一个方面。如果一个索引包含所有需要查询字段的值我们就称之为“覆盖索引”。</p><p>覆盖索引的优点：</p><ul><li><p>索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大的减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对IO密集型应用也有帮助，因为索引比数据更小，更容易全部放入内存中（MyISAM压缩索引以变得更小）。</p></li><li><p>因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多。（MyISAM和Percona XtraDB，甚至可以通过OPTIMIZE命令使得索引完全顺序排列，这样简单的范围查询能使用完全顺序的索引访问）</p></li><li><p>一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。</p></li><li><p>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</p></li></ul><p>不是所有的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree做索引覆盖。</p><p>当发起一个索引覆盖查询时，在Explain的Extra列可以看到“Using index”的信息（Extra列的Using index和type列的inxex搞混淆，其实两者我完全不同，type列标识查询访问数据方式，也称之为join type）。</p><p>索引覆盖查询可能还有很多陷阱可能导致无法实现优化。MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了WHERE条件中的字段，但不是整个查询涉及的字段。如果条件为假，MySQL5.5和更早版本也总是会回表获取数据行，尽管并不需要这一行且最终也会被过滤掉。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain select * from products where actor=&apos;scan carrey&apos; and title like &apos;%APOLLO%&apos; --这条语句使用的是Extra:using where</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有列，而没有任何索引覆盖了所有的列。MySQL存在另一个途径：WHERE条件中的列是有索引可以覆盖的，因此MySQL可以使用该索引找到对应的actor并检查title是否匹配，过滤之后再读取需要的数据行。</p></li><li><p>MySQL不能再索引中执行LIKE操作。这是底层存储引擎API的限制，MySQL5.5和更早版本中只允许在索引中做简单比较操作。MySQL能在索引中做最左前缀匹配的LIKE查询，存储引擎就无法比较匹配。MySQL服务器只能提取数据行的值而不是索引值来做比较。</p></li></ul><p>解决方案：</p><p>先将索引扩展至3个（artist，title，prod_id）,然后按照如下方式重写查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain select * from products join(select prob_id from products where actor=&apos;sean carrey&apos; and title like &apos;%APOLLO%&apos;) as t1 on(t1.prod_id=products.prod_id)</span><br></pre></td></tr></table></figure><p>Extra: using where;using index</p><p>我们把这种方式叫做延迟关联，因为延迟了对列的访问。在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id,然后根据这些prop_id值在外层查询匹配获取需要的所有列值。虽然无法使用索引覆盖整个查询，但总算比完全无法利用索引覆盖的好。</p><p>这样的优化效果取决于WHERE条件匹配返回的行数。举个例子：</p><p>假设products有100w行数据，我们使用上面两个SQL在不同的三个场景中测试。</p><ol><li><p>sean carrey 出演了3w部作品，2w部标题中包含Apollo。</p></li><li><p>sean carrey 出演了3w部作品，40部标题中包含Apollo。</p></li><li><p>sean carrey 出演了50部作品，10部标题中包含Apollo。</p></li></ol><p>测试结果：</p><table><br><br><tr><td>序号</td><td>原查询</td><td>优化后</td></tr><br><tr><td>1</td><td>5</td><td>5</td></tr><br><tr><td>2</td><td>7</td><td>35</td></tr><br><tr><td>3</td><td>2400</td><td>2000</td></tr><br><br></table><p>结果分析：</p><p>实例1中，查询返回了一个很大的结果集，因此看不到优化结果。大部分时间都花在读取和发送数据上了。</p><p>实例2中，经过索引过滤，尤其第二个条件过滤后只返回很少的结果集，优化效果很明显，优化查询的效率主要得益于只需要读取40行完整的数据行。</p><p>实例3中，显示了子查询效率反而下降的情况。因为索引过滤符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。</p><h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>MySQL有两种方式生成有序的结果：通过排序操作。按索引顺序扫描。</p><p>如果explain出来的type列的值为index，则说明MySQL使用索引扫描来做排序。</p><p>扫描索引本身是很快的，因为只需要从一条索引纪律移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不没扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机IO，因此按索引顺序读取数据的速度通常要比顺序的全表扫描慢，尤其是在IO密集型的工作负载时。</p><p>MySQL可以使用同一个索引既满足排序，又满足查找行。</p><p>只有当索引的列顺序和 order by子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一个表时，才能使用索引做排序。order by子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则MySQL都需执行排序操作，而无法利用索引排序。</p><p>有一种情况下 order by子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以弥补索引的不足。</p><p>例如：表rental在列(rental_date,inventory_id,customer_id)上有名为rental_date的索引。</p><p>建表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table rental(</span><br><span class="line">    primary key(rental_id),</span><br><span class="line">    unique key rental_date(rental_date,inventory_id,customer_id),</span><br><span class="line">    key idx_fk_inventory_id(inventory_id),</span><br><span class="line">    key idx_fk_customer(customer_id),</span><br><span class="line">    key idx_fk_staff_id(staff_id),</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查询排序：</p><p><code>explain select rental_id,staff_id from sakila.rental where rental_date=&#39;2005-05-25&#39; order by inventory_id, customer_id</code></p><p>即时order by 子句不满足索引的最左前缀的要求，也可以用于查询排序，这是因为索引的第一列被指定为一个常数。</p><p>下面这个查询可以利用索引排序，是因为查询为索引的第一列提供了常量条件，而使用第二列进行排序，将两列组合在一起，就形成了索引的最左前缀,总的来说只要查询满足最左前缀即可排序：</p><p><code>where rental_date=&#39;2005-05-05&#39; order by inventory_id desc</code></p><p>下面是一些不能使用索引做排序的查询：</p><ul><li><p>这个查询使用了两种不同的排序方向，但索引列都是正序排序的：</p><p><code>where rental_date =&#39;2005-05-25&#39; order by inventory_id desc,customer_id asc</code></p></li></ul><ul><li><p>这个查询的order by 子句中引用了一个不在索引中的列：</p><p><code>where rental_date =&#39;2005-05-25&#39; order by inventory_id,staff_id</code></p></li><li><p>这个查询的where和order by中的列无法组合成索引的最左前缀：</p><p><code>where rental_date =&#39;2005-05-25&#39; order by customer_id</code></p></li><li><p>这个查询在索引列的第一列上是范围条件，所以MySQL无法使用索引的其余列：</p></li></ul><p><code>where rental_date &gt; &#39;2005-05-25 order by ...</code> </p><ul><li>这个查询在inventory_id上有多个等于条件，对于排序来说，这也是一种范围查询：</li></ul><p><code>where rental_date=&#39;2015-05-25&#39; and inventory_id in(1,2) order by customer_id</code></p><p>下面这个例子理论上是可以使用索引进行关联排序的，但由于优化器在优化时将film_actor表当做关联的第二张表，所以实际上无法使用索引：</p><p><code>explain select actor_id,title from sakila.film_actor inner join sakila.film using(film_id) order by actor_id</code></p><p>使用索引排序做排序的一个重要的用法是当查询同时有order by和limit子句的时候。</p><h4 id="压缩索引"><a href="#压缩索引" class="headerlink" title="压缩索引"></a>压缩索引</h4><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入到内存中，这在某些情况下能极大的提高性能。默认只压缩字符串，但通过参数设置也可以对整数进行压缩。</p><p>MyISAM的压缩方法是：先完全保存索引块的第一个值，然后将其他值和第一个值进行比较得到相同的前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。</p><p>压缩块使用更少的时间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以无法使用二分查找而只能从头开始。正序快，倒序慢。</p><p>使用pack_keys来控制索引压缩的方式。</p><h4 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h4><p>MySQL允许在相同列上创建多个索引，并且需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个的进行考虑，影响性能。</p><p>重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。</p><p>错误示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table test(</span><br><span class="line"> id int not null primary key,</span><br><span class="line"> a int not null,</span><br><span class="line"> b int not null,</span><br><span class="line"> unique(id),</span><br><span class="line"> index(id)</span><br><span class="line">)engine=InnoDB;</span><br></pre></td></tr></table></figure><p>上面其实给id创建了3条索引，MySQL的唯一限制和主键限制都是通过索引实现的。</p><p>通常没有理由在同一列上创建多条索引，除非在同一列上创建不同类型的索引来满足查询需求。例如key（id）和fulltext key（id）就是两种类型的索引。</p><p>冗余和重复有些不同，如果创建了索引（A,B），再创建（A），则（A）就是冗余的。这种冗余只是对B-Tree来说的。另外，其他不同类型的索引（哈希索引或者全文索引）也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是什么。</p><p>冗余索引通常发生在为表添加新索引的时候。</p><p>大多数情况下都不需要冗余索引，应该尽量扩展已经有的索引而不是创建新索引。有时候出于性能问题也考虑冗余索引，因为扩展已有的索引会导致其变的太大，从而影响其他使用该索引的查询性能。</p><h4 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h4><p>除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。建议删除。</p><p>最简单有效的办法是在Percona Server或者MariaDB中先打开userstates服务器变量，然后让服务器正常运行一段时间，再通过查询Information_schema.index_statistics就能查到每个索引的使用频率。</p><p>还可以使用Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行explain操作，然后打印出关于索引和查询的报告。</p><h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p>索引可以让查询锁定更少的行。</p><p>优点：</p><ul><li><p>InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外的开销。</p></li><li><p>锁定超过需要的行会增加锁争用并减少并发性。</p></li></ul><p>InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问行数，从而减少锁的数量。只有当InnoDB在存储引擎层能够过滤所有不需要的行时才有效。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set autocommmit = 0;</span><br><span class="line">begin;</span><br><span class="line">select actor_id from sakila.actor where actor_id &lt; 5 and actor_id &lt;&gt; 1 for update;</span><br></pre></td></tr></table></figure><table><tr><td>actor_id</td></tr><tr><td>2</td></tr><tr><td>3</td></tr><tr><td>4</td></tr></table><p>这条查询仅仅会返回2-4行数据，但是实际上获取了1-4行之间的行的排它锁。锁住第一行是因为MySQL为该查询选择的执行计划是索引范围扫描：</p><table><br>    <tr><td>id</td><td>select_type</td><td>table</td><td>type</td><td>key</td><td>Extra</td></tr><br>    <tr><td>1</td><td>SIMPLE</td><td>actor</td><td>range</td><td>PRIMARY</td><td>Using where;Using index</td></tr><br><br></table><p>问题：如果不能使用索引查找和锁定行的话问题可能会更糟糕，MySQL会做全表扫描并锁住所有的行。</p><p>InnoDB在二级索引上使用共享锁，但访问主键索引需要排他锁。这消除了使用覆盖索引的可能性，并且使得<code>select for update</code> 比<code>lock in share mode</code>或非锁定查询要慢的多。</p><h3 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h3><h3 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h3><p>维护表有3个目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。</p><h4 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h4><p>表损坏（corruption）是件很糟糕的事情。对于MyISAM，表损坏通常是系统崩溃导致的。</p><p>损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时甚至还会导致数据库的崩溃。</p><p>修复：</p><ul><li><p>check table，能找出大多数表和索引错误。有些存储引擎不支持该命令。</p></li><li><p>repair table，和check类似。</p></li><li><p>alter table innodb_tbl engine=innodb，修改表的存储引擎为当前引擎重建表。</p></li><li><p>离线工具myisamchk</p></li><li><p>将数据导出在重新导入。</p></li><li><p>如果损坏的是行数据或者系统区域，以上办法无效。</p></li><li><p>如果损坏系统区域或者行数据，可以从备份中恢复表，或者尝试从损坏的数据文件中尽可能的恢复数据。</p></li></ul><p>如果InnoDB引擎的表出现损坏，那么一定是发生了严重的错误，需要立刻调查原因。具体细节可以查看MySQL手册。</p><h4 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h4><h4 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三个原则：</p><ul><li><p>单行访问时很慢的。最好读取块中能包含尽可能多的所需要的行。使用索引可以创建位置引用以提升效率。</p></li><li><p>按顺序访问范围数据是很快的，这有两个原因。第一、顺序IO不需要多次磁盘寻道，所以比随机IO快很多。第二、如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且group by查询也无需再做排序和将行按组进行聚合计算了。</p></li><li><p>索引覆盖查询是很快的。</p></li></ul><p>一般来说，我们建议按响应时间来对查询进行分析。</p><p>如果一个查询无法从所有可能的索引中获益，则应该看看是否可以创建一个更合适的索引来提升性能。</p><h2 id="剖析MySQL查询"><a href="#剖析MySQL查询" class="headerlink" title="剖析MySQL查询"></a>剖析MySQL查询</h2><p>对查询进行性能剖析有两种方式，每种方式都有各自的问题。</p><h3 id="剖析服务器负载"><a href="#剖析服务器负载" class="headerlink" title="剖析服务器负载"></a>剖析服务器负载</h3><p>服务器端可以有效的审计效率低下的查询。</p><h4 id="捕获MySQL的查询到日志文件中"><a href="#捕获MySQL的查询到日志文件中" class="headerlink" title="捕获MySQL的查询到日志文件中"></a>捕获MySQL的查询到日志文件中</h4><p>慢查询日志是一种轻量而且功能全面的性能剖析工具，是优化服务器查询的利器。可以通过修改针对每个链接的long_query_time的阈值来捕获所以的查询。</p><p>通用日志在查询请求到服务器时进行记录，所以不包含响应时间和执行计划等重要信息。日志信息记录到数据库表中。</p><h4 id="分析查询日志"><a href="#分析查询日志" class="headerlink" title="分析查询日志"></a>分析查询日志</h4><p>工具：pt-query-digest</p><p>剖析报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest1.png?raw=true" alt="查询日志"></p><p>详细报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest2.png?raw=true" alt="详细查询日志"></p><h3 id="剖析单条查询"><a href="#剖析单条查询" class="headerlink" title="剖析单条查询"></a>剖析单条查询</h3><h4 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h4><p>show profile命令是在5.1版本之后引入的，默认是禁用的，可以通过<code>set profiling=1</code>动态的修改。这个功能有一定的作用，将来能会被Performance Schema所取代。</p><p>下面是对一个视图的剖析结果：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling1.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling2.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling3.png?raw=true" alt="详细查询日志"></p><p>剖析报告给出查询执行每个步骤花费的时间，看结果无法快速确定哪个步骤花费时间最多，因为输出是按照执行顺序排序，而不是花费的时间排序的。如果不使用show profile命令。还可以直接查询information_schema中对应的表，按照格式化输出。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/information_schema.png?raw=true" alt="详细查询日志"></p><p>效果比看show profile输出的结果好很多，可以很直观的看到哪些步骤花费时长较长。</p><h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="查询慢的原因"><a href="#查询慢的原因" class="headerlink" title="查询慢的原因"></a>查询慢的原因</h3><p>查询最重要的是响应时间，如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行更快。</p><p>MySQL执行查询的时候，查询需要在不同的地方花费时间，如网络、cpu、生成统计信息和执行计划、锁等待等。在每一个消耗大量时间的查询案例中，我们都能看到一些不必要的额外操作、某些操作被额外的执行了很多次、某些操作执行的太慢等。</p><p>优化查询的目的就是减少和消除这些操作所花费的时间。</p><h3 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h3><p>查询性能低下最基本的原因是访问的数据太多。某些查询不可避免的需要筛选大量数据，大部分查询都可以通过减少访问的数据量的方式进行优化。对于低效查询可以分为两个步骤分析：</p><ul><li><p>1.确认应用程序是否检索大量超过需要的数据。如访问过多的行或者列。</p></li><li><p>2.确定MySQL服务器层是否在分析大量超过需要的数据行。</p></li></ul><h4 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h4><ul><li><p>查询不需要的记录</p></li><li><p>多表关联返回全部的列</p></li><li><p>总是取出全部的列</p></li><li><p>重复查询相同的数据</p></li></ul><h4 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h4><p>在确定查询只返回需要的数据以后，最简单的衡量查询开销的三个指标如下：</p><ul><li><p>响应时间</p></li><li><p>扫描的行数</p></li><li><p>返回的行数</p></li></ul><p>响应时间：响应时间只是一个表面上的值。响应时间是服务时间和排队时间。服务时间指数据库处理这个时间花费的时间。排队时间指服务器因为等待某些资源而没有真正执行查询的时间。</p><p>快速上限估计：了解查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以在具体硬件条件下一次IO的消耗时间。</p><p>扫描的行数和返回的行数： 分析查询时，查看扫描的行数一定程度上可以反映出该查询找到需要的数据的效率高不高。</p><p>扫描的行数和访问类型：在explain语句中的type列反映了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。从慢到快，扫描的行数从小到大。</p><p>如果查询没有找到合适的访问类型，那么解决的最好办法通常是增加一个合适的索引。</p><p>例如：</p><p><code>select * from sakila.film_actor where film_id = 1;</code></p><p>这个查询返回10行数据，从explain的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/ref.png?raw=true" alt="详细查询日志"></p><p>explain的结果也显示MySQL预估需要访问10行数据。查询优化器认为这种访问类型可以高效的完成查询。如果我们删除索引再来运行：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/where.png?raw=true" alt="详细查询日志"></p><p>正如我们预料的，查询变成全表扫描，MySQL预估会扫描5073条记录来完成查询。</p><p>一般MySQL使用如下三种方式应用WHERE条件，从好到坏依次是：</p><ul><li><p>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</p></li><li><p>使用索引覆盖扫描（Extra:using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录。</p></li><li><p>从数据表中返回数据（Extra:using where），然后过滤不满足条件的记录。这是在服务器层完成的，MySQL需要从数据表中读出来然后再进行过滤。</p></li></ul><p>虽然例子说明了好的索引多么重要，但是也不是说增加了索引就能让扫描的行数等于返回的行数。例如使用聚合函数的查询：</p><p><code>select actor_id,count(*) from sakila.film_actor group by actor_id</code></p><p>这个例子没有什么索引能够让这样的查询减少需要扫描的行数。</p><p>通常如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试使用下面的技巧去优化：</p><ul><li><p>使用覆盖索引扫描，把所有需要的列放到索引中，这样存储引擎无需回表获取对应行就可以返回结果了。</p></li><li><p>改变库表结构。例如使用单独的汇总表。</p></li><li><p>重写复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</p></li></ul><h3 id="重构查询的方式非锁"><a href="#重构查询的方式非锁" class="headerlink" title="重构查询的方式非锁"></a>重构查询的方式非锁</h3><h4 id="一个复杂的查询还是多个简单的查询"><a href="#一个复杂的查询还是多个简单的查询" class="headerlink" title="一个复杂的查询还是多个简单的查询"></a>一个复杂的查询还是多个简单的查询</h4><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><p>将大查询分为小查询，每个查询功能完全一样，只完成一小部分，每次返回一小部分查询结果。删除旧数据就是一个很好的例子</p><h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><p>对每一个表进行一次单表查询，然后将结果在应用程序中关联。</p><p>分解关联查询的优点：</p><ul><li><p>让缓存效率跟高。</p></li><li><p>执行单个查询可以减少锁的竞争。</p></li><li><p>做应用层关联，可以更好的对数据库拆分，更容易做到，高性能可扩展。</p></li><li><p>查询效率本身效率也可能会有所提升。</p></li><li><p>可以减少冗余记录的查询。</p></li><li><p>这样做相当于在应用中实现了哈希关联而不是MySQL的嵌套循环关联。</p></li></ul><h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><p>查询执行路径：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/process.png?raw=true" alt="查询执行路径"></p><h3 id="MySQL查询优化器的局限性"><a href="#MySQL查询优化器的局限性" class="headerlink" title="MySQL查询优化器的局限性"></a>MySQL查询优化器的局限性</h3><h3 id="查询优化器的提示"><a href="#查询优化器的提示" class="headerlink" title="查询优化器的提示"></a>查询优化器的提示</h3><h3 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h3><h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><h2 id="MySQL的高级特性"><a href="#MySQL的高级特性" class="headerlink" title="MySQL的高级特性"></a>MySQL的高级特性</h2><ul><li><p>分区表</p></li><li><p>视图</p></li><li><p>外键约束</p></li><li><p>MySQL内部存储代码</p></li><li><p>游标</p></li><li><p>绑定变量</p></li><li><p>用户自定义函数</p></li><li><p>插件</p></li><li><p>字符集和校对</p></li><li><p>全文索引</p></li><li><p>分布式（XA）事务</p></li><li><p>查询缓存</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL优化</title>
      <link href="/2018/04/02/mysql/2018-04-02-SQL/"/>
      <url>/2018/04/02/mysql/2018-04-02-SQL/</url>
      <content type="html"><![CDATA[<h2 id="常用SQL技巧"><a href="#常用SQL技巧" class="headerlink" title="常用SQL技巧"></a>常用SQL技巧</h2><h3 id="1-1-检索包含最大和最小值的行"><a href="#1-1-检索包含最大和最小值的行" class="headerlink" title="1.1 检索包含最大和最小值的行"></a>1.1 检索包含最大和最小值的行</h3><p><code>select max(test_score),min(test_score) from student</code></p><h3 id="1-2-巧用rand-rand-n-提取随机行"><a href="#1-2-巧用rand-rand-n-提取随机行" class="headerlink" title="1.2 巧用rand()/rand(n)提取随机行"></a>1.2 巧用rand()/rand(n)提取随机行</h3><p><code>select * from table order by rand()</code></p><h3 id="1-3-group-by的with-rollup子句做统计"><a href="#1-3-group-by的with-rollup子句做统计" class="headerlink" title="1.3 group by的with rollup子句做统计"></a>1.3 group by的with rollup子句做统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table sales(</span><br><span class="line"></span><br><span class="line">year int not null,</span><br><span class="line">country varchar(20) not null,</span><br><span class="line">product varchar(32) not null,</span><br><span class="line">profit int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2001);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2002);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2003);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2004);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2005);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2006);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2007);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2008);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2009);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2010);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2011);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2012);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year;</span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year with rollup;</span><br></pre></td></tr></table></figure><p>当你使用ROLLUP时, 你不能同时使用ORDER BY子句进行结果排序。换言之， ROLLUP和ORDER BY 是互相排斥的LIMIT 用在ROLLUP 后面。</p><h3 id="1-4-bit-group-functions做统计"><a href="#1-4-bit-group-functions做统计" class="headerlink" title="1.4 bit group functions做统计"></a>1.4 bit group functions做统计</h3><p>bit_count:用来计算二进制数中包含1的个数</p><p>bit_or:就是对两个二进制数进行或运算</p><p>bit_and:就是对两个二进制数进行并运算</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="通过show-status和应用特点了解各种SQL的执行频率。"><a href="#通过show-status和应用特点了解各种SQL的执行频率。" class="headerlink" title="通过show status和应用特点了解各种SQL的执行频率。"></a>通过show status和应用特点了解各种SQL的执行频率。</h3><p>首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)</p><p>show status</p><p>常用的:</p><p>show status like ‘uptime’ ; </p><p>show stauts like ‘com_select’  show status like ‘com_insert’ …类推 update  delete</p><p>show session或global status like …. 如果你不写session或global,默认是session 会话，指取出当前窗口的执行，如果你想看所有session,从mysql 启动到现在，则应该 global。</p><p>show status like ‘connections’; </p><p>//显示慢查询次数</p><p>show status like ‘slow_queries’;</p><p>以下几个参数对Myisam 和Innodb 存储引擎都计数：</p><ol><li><p>Com_select 执行select 操作的次数，一次查询只累加1；</p></li><li><p>Com_insert 执行insert 操作的次数，对于批量插入的insert 操作，只累加一次；</p></li><li><p>Com_update 执行update 操作的次数；</p></li><li><p>Com_delete 执行delete 操作的次数；</p></li></ol><p>以下几个参数是针对Innodb 存储引擎计数的，累加的算法也略有不同：</p><ol><li><p>Innodb_rows_read select 查询返回的行数；</p></li><li><p>Innodb_rows_inserted 执行Insert 操作插入的行数；</p></li><li><p>Innodb_rows_updated 执行update 操作更新的行数；</p></li><li><p>Innodb_rows_deleted 执行delete 操作删除的行数；</p></li></ol><p>对于事务型的应用，通过Com_commit 和Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。</p><p>此外，以下几个参数便于我们了解数据库的基本情况：</p><ol><li><p>Connections 试图连接Mysql 服务器的次数</p></li><li><p>Uptime 服务器工作时间</p></li><li><p>Slow_queries 慢查询的次数</p></li></ol><h3 id="定位执行效率较低的SQL"><a href="#定位执行效率较低的SQL" class="headerlink" title="定位执行效率较低的SQL"></a>定位执行效率较低的SQL</h3><p>可以通过以下两种方式定位执行效率较低的SQL 语句：</p><ol><li><p>可以通过慢查询日志定位那些执行效率较低的sql 语句，用–log-slowqueries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过long_query_time 秒的SQL语句的日志文件。可以链接到管理维护中的相关章节。</p></li><li><p>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist 命令查看当前MySQL 在进行的线程，包括线程的状态，是否锁表等等，可以实时的查看SQL 执行情况，同时对一些锁表操作进行优化。</p></li></ol><h3 id="通过explain分析低效SQL的执行计划"><a href="#通过explain分析低效SQL的执行计划" class="headerlink" title="通过explain分析低效SQL的执行计划"></a>通过explain分析低效SQL的执行计划</h3><h4 id="select-type：-select-类型"><a href="#select-type：-select-类型" class="headerlink" title="select_type： select 类型"></a>select_type： select 类型</h4><p>A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个</p><p>B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</p><p>C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union</p><p>D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响</p><p>E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</p><p>F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</p><p>G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</p><p>H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</p><h4 id="table：-输出结果集的表"><a href="#table：-输出结果集的表" class="headerlink" title="table： 输出结果集的表"></a>table： 输出结果集的表</h4><p>显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的<derived n="">就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的<union m,n="">，与<derived n="">类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</derived></union></derived></p><h4 id="type：-表示表的连接类型"><a href="#type：-表示表的连接类型" class="headerlink" title="type： 表示表的连接类型"></a>type： 表示表的连接类型</h4><p>当表中仅有一行是type的值为system是最佳的连接类型；</p><p>当select操作中使用索引进行表连接时type的值为ref；</p><p>当select的表连接没有使用索引时，经常会看到type的值为ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。</p><p>依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</p><p>A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p><p>B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</p><p>C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</p><p>D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</p><p>E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p><p>F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</p><p>G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</p><p>H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p><p>I：range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</p><p>J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</p><p>K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p><p>L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p><h4 id="possible-keys：-表示查询时-可以使用的索引列"><a href="#possible-keys：-表示查询时-可以使用的索引列" class="headerlink" title="possible_keys： 表示查询时,可以使用的索引列."></a>possible_keys： 表示查询时,可以使用的索引列.</h4><h4 id="key：-表示使用的索引"><a href="#key：-表示使用的索引" class="headerlink" title="key： 表示使用的索引"></a>key： 表示使用的索引</h4><h4 id="key-len：-索引长度"><a href="#key-len：-索引长度" class="headerlink" title="key_len： 索引长度"></a>key_len： 索引长度</h4><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p><h4 id="rows：-扫描范围"><a href="#rows：-扫描范围" class="headerlink" title="rows： 扫描范围"></a>rows： 扫描范围</h4><h4 id="Extra：-执行情况的说明和描述"><a href="#Extra：-执行情况的说明和描述" class="headerlink" title="Extra： 执行情况的说明和描述"></a>Extra： 执行情况的说明和描述</h4><p>A：distinct：在select部分使用了distinc关键字</p><p>B：no tables used：不带from字句的查询或者From dual查询</p><p>C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</p><p>D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</p><p>E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p><p>F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。</p><p>G：using sort_union，using_union，using intersect，using sort_intersection：</p><p>using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集</p><p>using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集</p><p>using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。</p><p>H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</p><p>I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition</p><p>J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个</p><p>K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p><p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息</p><h3 id="确定问题并采取响应的优化措施"><a href="#确定问题并采取响应的优化措施" class="headerlink" title="确定问题并采取响应的优化措施"></a>确定问题并采取响应的优化措施</h3><h3 id="索引的存储分类"><a href="#索引的存储分类" class="headerlink" title="索引的存储分类"></a>索引的存储分类</h3><p>myisam 表的数据文件和索引文件是自动分开的；innodb 的数据和索引是存储在<br>同一个表空间里面，但可以有多个文件组成。<br>创建索引语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</span><br><span class="line">[USING index_type]</span><br><span class="line">ON tbl_name (index_col_name,...)</span><br><span class="line">index_col_name:</span><br><span class="line">col_name [(length)] [ASC | DESC]</span><br></pre></td></tr></table></figure><p>索引的存储类型目前只有两种（btree 和hash），具体和表的模式相关：</p><p>myisam btree</p><p>innodb btree</p><p>memory/heap hash，btree</p><p>mysql 目前不支持函数索引，只能对列的前一部分（length）进行索引，例：</p><p><code>create index ind_test on table1(name(5))</code></p><p>对于char 和varchar 列，使用前缀索引将大大节省空间。</p><h3 id="MySQL如何使用索引"><a href="#MySQL如何使用索引" class="headerlink" title="MySQL如何使用索引"></a>MySQL如何使用索引</h3><p>索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高SELECT 操作性能的最佳途径。</p><p>查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。</p><p>下列情况下，Mysql 不会使用已有的索引：</p><p>1.如果mysql 估计使用索引比全表扫描更慢，则不使用索引。例如：如果key_part1均匀分布在1 和100 之间，下列查询中使用索引就不是很好：</p><p><code>SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90</code></p><p>2.如果使用heap 表并且where 条件中不用＝索引列，其他&gt; 、&lt;、&gt;=、&lt;=均不使用索引；</p><p>3.如果不是索引列的第一部分；</p><p>4.如果like 是以％开始；</p><p>5.对where 后边条件为字符串的一定要加引号，字符串如果为数字mysql 会自动转为字符串，但是不使用索引。</p><h3 id="查看索引的使用情况"><a href="#查看索引的使用情况" class="headerlink" title="查看索引的使用情况"></a>查看索引的使用情况</h3><p>如果索引正在工作，Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。</p><p>Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明表索引不正确或写入的查询没有利用索引。</p><p><code>show status like &#39;Handler_read%&#39;;</code></p><h3 id="定期分析表"><a href="#定期分析表" class="headerlink" title="定期分析表"></a>定期分析表</h3><h4 id="ANALYZE-TABLE"><a href="#ANALYZE-TABLE" class="headerlink" title="ANALYZE TABLE"></a>ANALYZE TABLE</h4><p>语法：</p><p><code>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM, BDB 和InnoDB 表有作用。对于MyISAM 表，本语句与使用myisamchk -a 相当。</p><h4 id="CHECK-TABLE"><a href="#CHECK-TABLE" class="headerlink" title="CHECK TABLE"></a>CHECK TABLE</h4><p>语法：</p><p><code>CHECK TABLE tbl_name [, tbl_name] ... [option] ...</code></p><p><code>option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}</code></p><p>检查一个或多个表是否有错误。CHECK TABLE 对MyISAM 和InnoDB 表有作用。对于MyISAM 表，关键字统计数据被更新。</p><p>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。</p><h4 id="CHECKSUM-TABLE"><a href="#CHECKSUM-TABLE" class="headerlink" title="CHECKSUM TABLE"></a>CHECKSUM TABLE</h4><p>语法：</p><p><code>CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]</code></p><p>报告一个表校验和。</p><h3 id="使用optimize-table"><a href="#使用optimize-table" class="headerlink" title="使用optimize table"></a>使用optimize table</h3><h4 id="OPTIMIZE-TABLE"><a href="#OPTIMIZE-TABLE" class="headerlink" title="OPTIMIZE TABLE"></a>OPTIMIZE TABLE</h4><p>语法：</p><p><code>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>如果已经删除了表的一大部分，或者如果您已经对含有可变长度行的表（含有VARCHAR, BLOB 或TEXT 列的表）进行了很多更改，则应使用OPTIMIZE TABLE。被删除的记录被保持在链接清单中，后续的INSERT 操作会重新使用旧的记录位置。您可以使用OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。</p><p>OPTIMIZE TABLE 只对MyISAM, BDB 和InnoDB 表起作用。</p><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><h4 id="对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。"><a href="#对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。" class="headerlink" title="对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。"></a>对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tblname DISABLE KEYS;</span><br><span class="line">loading the data</span><br><span class="line">ALTER TABLE tblname ENABLE KEYS;</span><br></pre></td></tr></table></figure><p>这两个命令用来打开或者关闭Myisam 表非唯一索引的更新。在导入大量的数据到一个非空的Myisam 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的Myisam 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。</p><h4 id="而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率："><a href="#而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率：" class="headerlink" title="而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率："></a>而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率：</h4><p>a. 因为Innodb 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果Innodb 表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。</p><p>b. 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SETUNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p><p>c. 如果应用使用自动提交的方式，建议在导入前执行SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p><h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><p>如果你同时从同一客户插入很多行，使用多个值表的INSERT 语句。这比使用分开INSERT 语句快(在一些情况中几倍)。</p><p><code>Insert into test values(1,2),(1,3),(1,4)…</code></p><p>如果你从不同客户插入很多行，能通过使用INSERT DELAYED 语句得到更高的速度。Delayed 的含义是让insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘；这比每条语句分别插入要快的多；LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完后才进行插入。</p><p><code>Insert delayed into test values(1,2),(1,3),(1,4)…</code></p><p><code>Insert low_priority into test values(1,2),(1,3),(1,4)…</code></p><p>将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）。</p><p>如果进行批量插入，可以增加bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对myisam 表使用。</p><p>在my.cnf中添加如下语句，将insert语句的长度设为最大。</p><p><code>Max_allowed_packet=1M</code></p><p><code>Net_buffer_length=2k</code></p><p>当从一个文本文件装载一个表时，使用LOAD DATA INFILE。这通常比使用很多INSERT 语句快20 倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//数据</span><br><span class="line"></span><br><span class="line">1669,Jim,Smith</span><br><span class="line">337,Mary,Jones</span><br><span class="line">2005,Linda,Black</span><br><span class="line"></span><br><span class="line">示例语句：</span><br><span class="line"></span><br><span class="line">load data infile &quot;/data/mysql/e.sql&quot; into table tablename fields terminated by &apos;,&apos;;</span><br></pre></td></tr></table></figure><p>根据应用情况使用replace 语句代替insert。<code>replace low_priority into ta values(1,2);</code><br>replace具备替换拥有唯一索引或者主键索引重复数据的能力，也就是如果使用replaceinto插入的数据的唯一索引或者主键索引与之前的数据有重复的情况，将会删除原先的数据，然后再进行添加。</p><p>根据应用情况使用ignore 关键字忽略重复记录。<br><code>insert ignore into</code><br>当插入数据时，如出现错误时，如重复数据，将不返回错误，只以警告形式返回。所以使用ignore请确保语句本身没有问题，否则也会被忽略掉。例如：<code>INSERT IGNORE INTO books (name) VALUES (&#39;MySQL Manual&#39;)</code></p><h3 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h3><p>默认情况下，MySQL 排序所有GROUP BY col1，col2，….。查询的方法如同在查询中指定ORDER BY col1，col2，…。如果显式包括一个包含相同的列的ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。</p><p>如果查询包括GROUP BY 但你想要避免排序结果的消耗，你可以指定ORDER BY NULL禁止排序。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO foo</span><br><span class="line">SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;</span><br></pre></td></tr></table></figure><h3 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h3><p>在某些情况中，MySQL 可以使用一个索引来满足ORDER BY 子句，而不需要额外的排序。where 条件和order by 使用相同的索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或者都是降序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如：下列sql 可以使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1,key_part2,... ;</span><br><span class="line">SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2</span><br><span class="line">DESC;</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</span><br><span class="line">但是以下情况不使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;</span><br><span class="line">--order by 的字段混合ASC 和DESC</span><br><span class="line">SELECT * FROM t1 WHERE key2=constant ORDER BY key1;</span><br><span class="line">--用于查询行的关键字与ORDER BY 中所使用的不相同</span><br><span class="line">SELECT * FROM t1 ORDER BY key1, key2;</span><br><span class="line">--对不同的关键字使用ORDER BY。</span><br></pre></td></tr></table></figure><h3 id="优化join语句"><a href="#优化join语句" class="headerlink" title="优化join语句"></a>优化join语句</h3><p>Mysql4.1 开始支持SQL 的子查询。这个技术可以使用SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。</p><p>假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><p><code>SELECT * FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerIDFROM salesinfo)</code></p><p>如果使用连接(JOIN).. 来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID 建有索引的话，性能将会更好，查询如下：</p><p><code>SELECT * FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL</code></p><p>连接(JOIN).. 之所以更有效率一些，是因为MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h3 id="mysql如何优化or条件"><a href="#mysql如何优化or条件" class="headerlink" title="mysql如何优化or条件"></a>mysql如何优化or条件</h3><p>对于or 子句，如果要利用索引，则or 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。</p><h3 id="查询优先还是更新优先"><a href="#查询优先还是更新优先" class="headerlink" title="查询优先还是更新优先"></a>查询优先还是更新优先</h3><p>MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。</p><p>我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。</p><p>下面我们提到的改变调度策略的方法主要是针对Myisam 存储引擎的，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。</p><p>MySQL 的默认的调度策略可用总结如下：</p><ol><li><p>写入操作优先于读取操作。</p></li><li><p>对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。</p></li><li><p>对某张数据表的多个读取操作可以同时地进行。</p></li></ol><p>MySQL 提供了几个语句调节符，允许你修改它的调度策略：</p><ol><li><p>LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE。</p></li><li><p>HIGH_PRIORITY关键字应用于SELECT和INSERT语句。</p></li><li><p>DELAYED关键字应用于INSERT和REPLACE语句。</p></li></ol><p>如果写入操作是一个LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在LOW_PRIORITY 写入操作永远被阻塞的情况。</p><p>SELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的SELECT 在正常的SELECT 语句之前执行，因为这些语句会被写入操作阻塞。</p><p>如果你希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么请使用–low-priority-updates 选项来启动服务器。通过使用INSERT HIGH_PRIORITY 来把INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT 语句的影响。</p><h3 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h3><p><code>SELECT SQL_BUFFER_RESULTS ...</code></p><p>将强制MySQL 生成一个临时结果集。只要所有临时结果集生成后，所有表上的锁定均被释放。这能在遇到表锁定问题时或要花很长时间将结果传给客户端时有所帮助。</p><p>当处理一个会让客户端耗费点时间才能处理的大结果集时， 可以考虑使用SQL_BUFFER_RESULT 提示字。这样可以告诉MySQL 将结果集保存在一个临时表中，这样可以尽早的释放各种锁。</p><h4 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h4><p>在你查询语句中表名的后面，添加USE INDEX 来提供你希望MySQ 去参考的索引列表，就可以让MySQL 不再考虑其他可用的索引。</p><p><code>Eg:SELECT * FROM mytable USE INDEX (mod_time, name) ...</code></p><h4 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h4><p>如果你只是单纯的想让MySQL 忽略一个或者多个索引，可以使用IGNORE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytale IGNORE INDEX (priority) ...</code></p><h4 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h4><p>为强制MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytable FORCE INDEX (mod_time) ...</code></p><h3 id="其他优化措施"><a href="#其他优化措施" class="headerlink" title="其他优化措施"></a>其他优化措施</h3><ol><li><p>使用持久的连接数据库以避免连接开销。</p></li><li><p>经常检查所有查询确实使用了必要的索引。</p></li><li><p>避免在频繁更新的表上执行复杂的SELECT 查询，以避免与锁定表有关的由于读、写冲突发生的问题。</p></li><li><p>对于没有删除的行操作的MyISAM 表，插入操作和查询操作可以并行进行，因为没有删除操作的表查询期间不会阻塞插入操作．对于确实需要执行删除操作的表，尽量在空闲时间进行批量删除操作，避免阻塞其他操作。</p></li><li><p>充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少MySQL 需要做的语法分析从而提高插入速度。</p></li><li><p>对经常访问的可以重构的数据使用内存表，可以显著提高访问的效率。</p></li><li><p>通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份期间对应用的影响，可以在复制服务器上执行备份操作。</p></li><li><p>表的字段尽量不使用自增长变量，在高并发情况下该字段的自增可能对效率有比较大的影响，推荐通过应用来实现字段的自增长。</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Callable、Future、FutureTask</title>
      <link href="/2018/03/29/concurrent/2018-03-29-Callable/"/>
      <url>/2018/03/29/concurrent/2018-03-29-Callable/</url>
      <content type="html"><![CDATA[<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>Callable接口类似于Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的，方法可以有返回值，并且可以抛出异常。但是Runnable不行。</p><p>Callable需要依赖FutureTask，用于接收运算结果。一个产生结果，一个拿到结果。FutureTask是Future接口的实现类，也可以用作闭锁（）。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/Callable.png?raw=true" alt="类图"></p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>闭锁和栅栏</title>
      <link href="/2018/03/29/concurrent/2018-03-29-Latch-CyclicBarrier/"/>
      <url>/2018/03/29/concurrent/2018-03-29-Latch-CyclicBarrier/</url>
      <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/yujin753/article/details/46125283" target="_blank" rel="noopener">参考原文：https://blog.csdn.net/yujin753/article/details/46125283</a></p><h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><p>闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。通俗的讲就是，一个闭锁相当于一扇大门，在大门打开之前所有线程都被阻断，一旦大门打开所有线程都将通过，但是一旦大门打开，所有线程都通过了，那么这个闭锁的状态就失效了，门的状态也就不能变了，只能是打开状态。也就是说闭锁的状态是一次性的，它确保在闭锁打开之前所有特定的活动都需要在闭锁打开之后才能完成。</p><p>应用场景：</p><ul><li><p>确保某个计算在其需要的所有资源都被初始化之后才继续执行。二元闭锁（包括两个状态）可以用来表示“资源R已经被初始化”，而所有需要R的操作都必须先在这个闭锁上等待。</p></li><li><p>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。</p></li><li><p>等待直到某个操作的所有参与者都就绪在继续执行。（例如：多人游戏中需要所有玩家准备才能开始）</p></li></ul><p>CountDownLatch是JDK 5+里面闭锁的一个实现，允许一个或者多个线程等待某个事件的发生。CountDownLatch有一个正数计数器，countDown方法对计数器做减操作，await方法等待计数器达到0。所有await的线程都会阻塞直到计数器为0或者等待线程中断或者超时。</p><p><a href="https://github.com/zhongyp/Demo/tree/master/src/main/java/com/zhongyp/thread/latchcyclicbarrier" target="_blank" rel="noopener">看源码实例点我！</a></p><h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。 栅栏与闭锁的关键区别在于，所有的线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。<br>场景： 应用一些协议，比如几个家庭成员决定在某个地方集合，所有人在6：00在某地集合，到了以后要等待其他人，之后才能讨论去哪里吃饭。 并行迭代，将一个问题分成很多子问题，当一系列的子问题都解决之后（所有子问题线程都已经await（）），此时将栅栏打开，所有子问题线程被释放，而栅栏位置可以留着下次使用。</p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java类加载和双亲委派机制</title>
      <link href="/2018/03/28/jvm/2018-03-28-Classloader/"/>
      <url>/2018/03/28/jvm/2018-03-28-Classloader/</url>
      <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">尊重原创:https://www.cnblogs.com/ityouknow/p/5603287.html</a></p><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p>•全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p><p>•父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p><p>•缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>加载.class文件的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">– 从本地系统中直接加载</span><br><span class="line">– 通过网络下载.class文件</span><br><span class="line">– 从zip，jar等归档文件中加载.class文件</span><br><span class="line">– 从专有数据库中提取.class文件</span><br><span class="line">– 将Java源文件动态编译为.class文件</span><br></pre></td></tr></table></figure><p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><ul><li>加载：查找并加载类的二进制数据</li></ul><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><p>1、通过一个类的全限定名来获取其定义的二进制字节流。</p><p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。加载后在常量池存储编译器生成的各种字面量和符号引用。</p><ul><li>验证：确保被加载的类的正确性</li></ul><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><p>符号引用验证：确保解析动作能正确执行。</p><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><ul><li>准备：为类的静态变量分配内存，并将其初始化为默认值</li></ul><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><p>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p><p>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p><p>假设一个类变量的定义为：public static int value = 3；</p><p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>()方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</clinit></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里还需要注意如下几点：</span><br><span class="line"></span><br><span class="line">对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</span><br><span class="line"></span><br><span class="line">static int d;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line">    System.out.println(d + &quot; &quot; + c);//d可以编译不报错，c报错。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</span><br><span class="line"></span><br><span class="line">对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</span><br><span class="line"></span><br><span class="line">如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</span><br></pre></td></tr></table></figure><p>3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p><p>假设上面的类变量value被定义为： public static final int value = 3；</p><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p><ul><li>解析：把类中的符号引用转换为直接引用</li></ul><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><ul><li>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</li></ul><p>①声明类变量是指定初始值</p><p>②使用静态代码块为类变量指定初始值</p><p>JVM初始化步骤</p><p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p><p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p><p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><p>– 创建类的实例，也就是new的方式</p><p>– 访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>– 调用类的静态方法</p><p>– 反射（如Class.forName(“com.shengsiyuan.Test”)）</p><p>– 初始化某个类的子类，则其父类也会被初始化</p><p>– Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</p><p>在如下几种情况下，Java虚拟机将结束生命周期</p><p>– 执行了System.exit()方法</p><p>– 程序正常执行结束</p><p>– 程序在执行过程中遇到了异常或错误而异常终止</p><p>– 由于操作系统出现错误而导致Java虚拟机进程终止</p><h2 id="Java对象创建过程"><a href="#Java对象创建过程" class="headerlink" title="Java对象创建过程"></a>Java对象创建过程</h2><p>new一个对象时，根据new的参数在常量池中定位一个类的符号引用，如果没有找到，则说明类未被加载，则进行类加载等等上面5个步骤。</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>过程：</p><p>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p><p>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p><p>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</p><p>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p><p>双亲委派模型意义：</p><p>-系统类防止内存中出现多份同样的字节码</p><p>-保证Java程序安全稳定运行</p><h2 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h2><p>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p><p>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p><p>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><p>1）在执行非置信代码之前，自动验证数字签名。</p><p>2）动态地创建符合用户特定需要的定制化构建类。</p><p>3）从特定的场所取得java class，例如数据库中和网络中。</p><p>类加载有三种方式：</p><p>1、命令行启动应用时候由JVM初始化加载</p><p>2、通过Class.forName()方法动态加载</p><p>3、通过ClassLoader.loadClass()方法动态加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ClassLoader loader = HelloWorld.class.getClassLoader();</span><br><span class="line">System.out.println(loader);</span><br><span class="line">//使用ClassLoader.loadClass()来加载类，不会执行初始化块</span><br><span class="line">loader.loadClass(&quot;Test2&quot;);</span><br><span class="line">//使用Class.forName()来加载类，默认会执行初始化块</span><br><span class="line">//                Class.forName(&quot;Test2&quot;);</span><br><span class="line">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块</span><br><span class="line">//                Class.forName(&quot;Test2&quot;, false, loader);</span><br><span class="line"></span><br><span class="line">public class Test2 &#123;</span><br><span class="line">        static &#123;</span><br><span class="line">                System.out.println(&quot;静态初始化块执行了！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM(Java虚拟机)--摘自《深入理解Java虚拟机》</title>
      <link href="/2018/03/27/jvm/2018-03-27-JVM/"/>
      <url>/2018/03/27/jvm/2018-03-27-JVM/</url>
      <content type="html"><![CDATA[<h2 id="JVM的运行机制"><a href="#JVM的运行机制" class="headerlink" title="JVM的运行机制"></a>JVM的运行机制</h2><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>程序计数器： 当前线程所执行字节码的行号指示器，字节码解释器的作用是通过改变计数器的值来选取下一条需要执行的字节码指令。如果当前执行的是Native方法，则这个计数器为空。Java虚拟机中唯一没有OOM的区域。</p><p>Java虚拟机栈：虚拟机栈描述的是Java方法执行的内存模型，生命周期与线程相同。每个方法运行都会创建一个栈帧，存储局部变量表，操作栈，方法出口等信息。局部变量表（编译期分配）存放各种基本数据类型和对象引用类型，returnAddress。</p><p>本地方法栈：虚拟机栈为执行Java方法服务，本地方法栈为Native方法服务。</p><p>Java堆：虚拟机启动时创建被所有线程共享的内存区域，为了存储所有对象实例。垃圾回收的主要区域。</p><p>方法区：各个线程共享的内存区域，存储类信息，静态变量、常量、即时编译器编译后的代码数据。</p><p>运行时常量池：方法区的一部分（JDK1.6以前），Java7中已经将运行时常量池从永久代移除，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做元空间。 类加载后存储编译器生成的各种字面量和符号引用。基本数据类型不叫常量，可被修改，String和final修饰的才是。</p><p>直接内存：堆外内存，JVM虚拟机各个区域内存总和大于机器物理内存可能会导致OOM。</p><h2 id="对象状态算法"><a href="#对象状态算法" class="headerlink" title="对象状态算法"></a>对象状态算法</h2><p>引用计数算法： 很难解决对象之间相互引用的问题，内存泄露。</p><p>跟搜索算法：通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索的路径成为引用链，当一个对象到GC Root没有一个引用时，则证明此对象是不可用的。</p><p>注：GC对象包括：虚拟机栈（本地变量表）中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI。</p><p>跟搜索算法中，没有引用的对象并非非死不可，还有经历两次标记，第一次发现没有引用，则进行标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或finalize()已经被调用过，虚拟机将这两种情况都视为没有必要执行。</p><p>回收方法区： 回收废弃变量和无用的类，无用的类：该类所有实例都已被回收，加载该类的ClassLoader被回收，该类对应的java.lang.Class对象没有在任何地方被引用。反射、代理、bytecode框架需具备卸载功能。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>标记清除算法： 标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。效率问题，空间问题（内存碎片）。</p><p>复制算法： 将可用内存按照容量分为大小相等的两块，每次只是用其中的一块。当这块用完了，就将存活的对象复制到另一块上面，然后再把已经使用过的空间清理掉。新生代（EDEN）使用复制算法，当回收时，将Eden和Survivor中还存活的对象一次性的拷贝到另一块的Survivor上。最后清理掉Eden和刚才使用过的Survivor。</p><p>标记-整理算法：让所有存活的对象向一端移动，然后清理掉端边界以外的内存。</p><p>分代收集算法： 根据对象的存活周期不同，将内存划分为几块，根据各个年代的特点进行垃圾回收。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/gc.jpg?raw=true" alt="垃圾回收器"></p><p>如果两个收集器之间存在连线，就说明他们可以搭配使用。</p><ol><li><p>Serial</p><p> 复制算法，新生代的单线程收集器，简单高效，运行时停掉其他所有线程。</p></li><li><p>ParNew</p><p> 复制算法，Serial多线程版本，首选的新生代收集器。</p></li><li><p>Parallel Scavenge</p><p> 新生代收集器，使用复制算法，并行线程。目标达到可控制的吞吐量。运行用户代码时间/CPU消耗总时常=吞吐量。</p></li><li><p>Serial Old</p><p> Serial收集器的老年代版本，单线程收集器，使用标记-整理算法。</p></li><li><p>Parallel Old</p><p> 老年代版本，标记-整理算法。</p></li><li><p>CMS收集器</p><p> 最短回收停顿时间为目标的收集器，重视服务响应速度，标记-清除算法实现。第一款并发收集器，可与用户线程</p><p> 初始标记、并发标记、重新标记、并发清除。初始和重新stop the world。初始标记只是标记GCRoots能直接关联的对象，速度很快，并发标记进行GCROOTs Tracing的过程。重新标记为了修复并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</p><p> 缺点：1. 对CPU资源非常敏感，解决方案，减少GC线程的独占时间。2. 无法处理浮动垃圾。如果CMS运行期间，内存无法满足要求，出现Concurrent Mode Failure失败导致另一个FullGC产生，启动预备方案 Serial Old。CMS运行期间，用户线程产生的垃圾为浮动垃圾，CMS无法在本次收集中个清理这些浮动垃圾。3. 产生大量的空间碎片。</p></li><li><p>G1收集器</p><p> 标记整理算法实现，精确的控制停顿。G1将整个Java堆（老年代，新生代）划分多个大小固定的独立区域，并且追踪这些区域里面的垃圾堆积程度。在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ol><h2 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h2><p>对象在Eden中分配内存，没有足够的空间进行垃圾回收。MinorGC。</p><pre><code>MinorGC: 新生代垃圾回收的动作，频繁且速度快。MajorGC（FullGC）: 指发生在老年代的GC，慢，清理新生代和老年代，CMS</code></pre><p>大对象指需要大量连续空间的Java对象。典型就是很长的字符串和数组。直接进入老年代分配，避免在Eden及Survivor中大量复制拷贝。</p><p>长期生活的对象进入老年代。对象年龄计数器，每一次MinorGC增长1岁。默认15岁进入老年代。</p><p>动态对象年龄判断，如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄段的对象直接进入老年代。</p><p>空间担保分配，每次MinorGC,检测升级到老年代的大小是否大于老年代的空间，如果大于，则进行FullGC。</p><h2 id="JDK命令行工具-性能监控和故障处理"><a href="#JDK命令行工具-性能监控和故障处理" class="headerlink" title="JDK命令行工具 性能监控和故障处理"></a>JDK命令行工具 性能监控和故障处理</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>虚拟机进程状况工具。 显示当前所有java进程pid的命令。</p><p>-l 输出主类的全名，如果进程执行的是Jar包，输出Jar路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -l</span><br><span class="line">5696 com.intellij.rt.execution.application.AppMain</span><br><span class="line">944 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">4488</span><br><span class="line">1900 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">7244 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure><p>-v 输出虚拟机进程启动时JVM参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -v</span><br><span class="line">5696 AppMain -Didea.launcher.port=7534 -Didea.launcher.bin.path=F:\Program Files\intellij IDEA\bin -Dfile.encoding=UTF-8</span><br><span class="line">944 RemoteMavenServer -Djava.awt.headless=true -Didea.version==2016.2.5 -Xmx768m -Didea.maven.embedder.version=3.0.5 -Dfile.encoding=GBK</span><br><span class="line">1656 Jps -Denv.class.path=.;C:\Program Files\Java\jdk1.8.0_161\lib\dt.jar;C:\Program Files\Java\jdk1.8.0_161\lib\tools.jar; -Dapplication.home=C:\Program Files\Java\jdk1.8.0_161 -Xms8m</span><br><span class="line">4488  -Xms128m -Xmx750m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djb.vmOptionsFile=F:\Program Files\intellij IDEA\bin\idea64.exe.v</span><br><span class="line">moptions -Xbootclasspath/a:F:\Program Files\intellij IDEA\lib\boot.jar -Didea.paths.selector=IntelliJIdea2016.2 -Didea.jre.check=true -XX:ErrorFile=C:\Users\zhongyp\java_error_in_idea_%p.log -XX:HeapDumpPath=C:\Users\zhongyp\java_error_in_idea.hprof</span><br><span class="line">1900 Launcher -Xmx700m -Djava.awt.headless=true -Djava.endorsed.dirs=&quot;&quot; -Djdt.compiler.useSingleThread=true -Dpreload.project.path=E:/demo -Dpreload.config.path=C:/Users/zhongyp/.IntelliJIdea2016.2/config/options -Dcompile.parallel=false -Drebuild.on.dependency.change=true -Djava.net.preferIPv4Stack=true</span><br><span class="line"> -Dio.netty.initialSeedUniquifier=-1505227146882843300 -Dfile.encoding=GBK -Djps.file.types.component.name=FileTypeManager -Duser.language=zh -Duser.country=CN -Didea.paths.selector=IntelliJIdea2016.2 -Didea.home.path=F:\Program Files\intellij IDEA -Didea.config.path=C:\Users\zhongyp\.IntelliJIdea2016.2\</span><br><span class="line">config -Didea.plugins.path=C:\Users\zhongyp\.IntelliJIdea2016.2\config\plugins -Djps.log.dir=C:/Users/zhongyp/.IntelliJIdea2016.2/system/log/build-log -Djps.fallback.jdk.home=C:/Program Files/Java/jdk1.8.0_161/jre -Djps.fallback.jdk.version=1.8.0_161 -Djava.io.tmpdir=C:/Users/zhongyp/.IntelliJIdea2016.2/</span><br><span class="line">system/compile-server/_temp_ -Dkotlin.incremental.compilation.experimental=true -Dkotlin.daemon.enabled -Dkotlin.daemon.cli</span><br></pre></td></tr></table></figure><p>-q 只输出LVMID，省略主类的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -q</span><br><span class="line">5696</span><br><span class="line">8912</span><br><span class="line">944</span><br><span class="line">4488</span><br><span class="line">1900</span><br></pre></td></tr></table></figure><p>-m 输出虚拟机进程启动时传递给主类main()函数的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">5696 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">10484 Jps -m</span><br><span class="line">4488</span><br><span class="line">1900 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/intel</span><br><span class="line">lij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/id</span><br><span class="line">ea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.ja</span><br><span class="line">r;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br></pre></td></tr></table></figure><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p> 虚拟机统计信息监视工具，用于监视虚拟机各种运行状态信息的命令。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾回收、JIT编译等运行数据。运行期定位虚拟机性能问题的首选工具。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-class：监视类装载、卸载数量、总空间以及类装载所耗时间。</span><br><span class="line"></span><br><span class="line">-gc：监视JAVA堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间，GC已用时间合计等信息；</span><br><span class="line"></span><br><span class="line">-gccapacity：监视内容与-gc基本相同，但输出主要关注 java堆各个区域使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcutil：监视内容与-gc基本相同，便输出主要关注已使用空间占总空间的百分比；</span><br><span class="line"></span><br><span class="line">-gccause：与-gcutil功能一样，但是会额外输出导致 一次GC产生的原因；</span><br><span class="line"></span><br><span class="line">-gcnew：监视新生代GC状态；</span><br><span class="line"></span><br><span class="line">-gcnewcapacity：监视内容与-gcnew基本相同，输出最要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcold：监视老年代GC状况；</span><br><span class="line"></span><br><span class="line">-gcoldcapacity：监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcpermcapacity：监视永久代使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-compiler：输入JIT编译器编译过的方法，耗时等信息；</span><br><span class="line"></span><br><span class="line">-printcompilation：输出已经被JIT编译的方法；</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat1.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat2.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat3.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat4.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat5.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat6.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat7.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat8.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat9.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat10.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat11.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat12.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat13.png?raw=true" alt="jstat"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jstat14.png?raw=true" alt="jstat"></p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-flag &lt;name&gt; ：可查看虚拟机启动时显式指定的参数列表。</span><br><span class="line">-flag [+|-]&lt;name&gt;：设置或取消VM参数</span><br><span class="line">-flag &lt;name&gt;=&lt;value&gt;：给VM参数设置新值</span><br><span class="line">-flags：可查看所有VM参数；</span><br><span class="line">-sysprops：查看java系统参数;</span><br><span class="line">&lt;no option&gt;：表示在不给定任何选项时，打印出以上所有的VM参数</span><br></pre></td></tr></table></figure><p> 实时的查看和调整虚拟机的各项参数。</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-dump：生成java堆转储快照，格式为：-dump[live, ] format=b, file=&lt;filename&gt;,其中live子参数说明是否只dump出存活对象；</span><br><span class="line"></span><br><span class="line">-finalizerinfo：显示在F-QueuiK 等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-heap：显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-histo：显示堆中对象统计信息，包括类、实例数量、合计容量；</span><br><span class="line"></span><br><span class="line">-permstat：以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台有效；</span><br><span class="line"></span><br><span class="line">-F：当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，只在Linux/Solaris平台有效</span><br></pre></td></tr></table></figure><p> Java内存映像工具。用于生成堆转储快照，还可以查询finalize()执行队列，Java堆和永久代的详细信息，如空间使用率、当前使用的哪种收集器等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jmap -dump:format=b,file=D:\test.bin 2768</span><br><span class="line">Dumping heap to D:\test.bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p><code>jhat D:\test.bin</code></p><p> 分析jmap生成的堆转储快照，在浏览器查看。</p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p> 用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合，生成快照的目的是定位线程出现长时间停顿的原因。</p><p>-F    当正常输出的请求不被响应时，强制输出线程堆栈</p><p>-l    除堆栈外，显示关于锁的附加信息</p><p>-m    如果调用到本地方法的话，可以显示c/c++的堆栈</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">//        Thread t1 = new Worker(1);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        t1.start();</span><br><span class="line">        final A a = new A();</span><br><span class="line">        final B b = new B();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                a.getBLock(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                b.getALock(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getBLock(B b)&#123;</span><br><span class="line"></span><br><span class="line">        b.getALock(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getALock(A a)&#123;</span><br><span class="line">        a.getBLock(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">1904 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">11540 Jps -m</span><br><span class="line">13204 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/inte</span><br><span class="line">llij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/i</span><br><span class="line">dea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.j</span><br><span class="line">ar;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br><span class="line">4488</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jstack -F 1904</span><br><span class="line">Attaching to process ID 1904, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.161-b12</span><br><span class="line">Deadlock Detection:</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193ce108 (Object@0x00000000d6129700, a com/zhongyp/B),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193cb878 (Object@0x00000000d6127d20, a com/zhongyp/A),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line"></span><br><span class="line">Found a total of 1 deadlock.</span><br><span class="line"></span><br><span class="line">Thread 1: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 18: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=0, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=2, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$2.run() @bci=18, line=38 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 17: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=0, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=2, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$1.run() @bci=18, line=26 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 16: (state = IN_NATIVE)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.accept0(int, java.net.InetSocketAddress[]) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.socketAccept(java.net.SocketImpl) @bci=37, line=131 (Interpreted frame)</span><br><span class="line"> - java.net.AbstractPlainSocketImpl.accept(java.net.SocketImpl) @bci=7, line=409 (Interpreted frame)</span><br><span class="line"> - java.net.PlainSocketImpl.accept(java.net.SocketImpl) @bci=42, line=199 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.implAccept(java.net.Socket) @bci=60, line=545 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.accept() @bci=48, line=513 (Interpreted frame)</span><br><span class="line"> - com.intellij.rt.execution.application.AppMain$1.run() @bci=13, line=79 (Interpreted frame)</span><br><span class="line"> - java.lang.Thread.run() @bci=11, line=748 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 10: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 9: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 8: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 7: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.Object.wait() @bci=2, line=502 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference.tryHandlePending(boolean) @bci=54, line=191 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference$ReferenceHandler.run() @bci=1, line=153 (Interpreted frame)</span><br></pre></td></tr></table></figure><h2 id="JDK可视化工具"><a href="#JDK可视化工具" class="headerlink" title="JDK可视化工具"></a>JDK可视化工具</h2><p>JConsole: Java监视与管理控制台。基于JMX的可视化监视和管理工具。监视Java堆和永久代的的变化趋势。</p><p>VisualVM: 多合一故障处理工具。</p><h2 id="JVM调优案例"><a href="#JVM调优案例" class="headerlink" title="JVM调优案例"></a>JVM调优案例</h2><h3 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h3><p>使用64位JDK大内存。</p><p>问题：1.内存回收导致长时间停顿。2.64位JDK的性能测试结果普遍低于32位JDK。3.需要保证程序足够稳定，这种应用如果产生堆溢出几乎就无法产生堆转储快照。4. 相同程序64位JDK中消耗内存一般比32位大，这是由于指针膨胀和数据类型对其补白导致的。</p><p>使用若干个32位虚拟机建立逻辑集群来利用集群资源。</p><p>问题：1.尽量避免节点竞争全局资源，如并发写操作导致IO异常。2.很难高效率的利用某些资源池，比如连接池，导致一些节点满了，其他的还为零。3.各个节点仍然不可避免的受到32位的限制（2GB）。4.大量使用本地缓存的应用，改为集中式的缓存。</p><h3 id="集群间同步导致内存溢出"><a href="#集群间同步导致内存溢出" class="headerlink" title="集群间同步导致内存溢出"></a>集群间同步导致内存溢出</h3><h3 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h3><h3 id="外部命令导致系统缓慢"><a href="#外部命令导致系统缓慢" class="headerlink" title="外部命令导致系统缓慢"></a>外部命令导致系统缓慢</h3><h2 id="java内存模型和线程"><a href="#java内存模型和线程" class="headerlink" title="java内存模型和线程"></a>java内存模型和线程</h2><h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><h4 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h4><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p><p>注： 这里说的变量包括了实例变量、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有，不会被共享，自然就不存在竞争问题。</p><h2 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h2><p>线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象时线程安全的。</p><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><h4 id="1-互斥同步（阻塞同步）"><a href="#1-互斥同步（阻塞同步）" class="headerlink" title="1.互斥同步（阻塞同步）"></a>1.互斥同步（阻塞同步）</h4><p>悲观锁。</p><p>sychronized 和 ReentrantLock。</p><h4 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2.非阻塞同步"></a>2.非阻塞同步</h4><p>乐观锁，CAS。</p><p>AtomicInteger等</p><h4 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3.无同步方案"></a>3.无同步方案</h4><ul><li><p>可重入代码：可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。判断代码是否具备可重入性：如果一个方法，他的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求。</p></li><li><p>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？ThreadLocal（不共享）。volatile(共享)。</p></li></ul><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁和自适应锁"><a href="#自旋锁和自适应锁" class="headerlink" title="自旋锁和自适应锁"></a>自旋锁和自适应锁</h4><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射和动态代理</title>
      <link href="/2018/03/18/java/2018-03-18-JavaReflection/"/>
      <url>/2018/03/18/java/2018-03-18-JavaReflection/</url>
      <content type="html"><![CDATA[<p>要想理解反射的原理，首先要了解什么是类型信息。Java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。</p><h2 id="CLASS-对象"><a href="#CLASS-对象" class="headerlink" title="CLASS 对象"></a>CLASS 对象</h2><p>每个类都会产生一个对应的Class对象，也就是保存在.class文件。所有类都是在对其第一次使用时，动态加载到JVM的，当程序创建一个对类的静态成员的引用时，就会加载这个类。Class对象仅在需要的时候才会加载，static初始化是在类加载时进行的。</p><p>类加载器首先会检查这个类的Class对象是否已被加载过，如果尚未加载，默认的类加载器就会根据类名查找对应的.class文件。</p><p>想在运行时使用类型信息，必须获取对象(比如类Base对象)的Class对象的引用，使用功能Class.forName(“Base”)可以实现该目的，或者使用base.class。注意，有一点很有趣，使用功能”.class”来创建Class对象的引用时，不会自动初始化该Class对象，使用forName()会自动初始化该Class对象。为了使用类而做的准备工作一般有以下3个步骤：</p><ul><li><p>加载：由类加载器完成，找到对应的字节码，创建一个Class对象</p></li><li><p>链接：验证类中的字节码，为静态域分配空间</p></li><li><p>初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Base &#123;</span><br><span class="line">    static int num = 1;</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Base &quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 不会初始化静态块</span><br><span class="line">        Class clazz1 = Base.class;</span><br><span class="line">        System.out.println(&quot;------&quot;);</span><br><span class="line">        // 会初始化</span><br><span class="line">        Class clazz2 = Class.forName(&quot;zzz.Base&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>如果不知道某个对象的确切类型，RTTI可以告诉你，但是有一个前提：这个类型在编译时必须已知，这样才能使用RTTI来识别它。Class类与java.lang.reflect类库一起对反射进行了支持，该类库包含Field、Method和Constructor类，这些类的对象由JVM在启动时创建，用以表示未知类里对应的成员。这样的话就可以使用Contructor创建新的对象，用get()和set()方法获取和修改类中与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getFields()、getMethods()和getConstructors()等许多便利的方法，以返回表示字段、方法、以及构造器对象的数组，这样，对象信息可以在运行时被完全确定下来，而在编译时不需要知道关于类的任何事情。</p><p>反射机制并没有什么神奇之处，当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类。因此，那个类的.class对于JVM来说必须是可获取的，要么在本地机器上，要么从网络获取。所以对于RTTI和反射之间的真正区别只在于：</p><ul><li><p>RTTI，编译器在编译时打开和检查.class文件</p></li><li><p>反射，运行时打开和检查.class文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        Test test =  new Test();</span><br><span class="line">    </span><br><span class="line">        Class clazz = Class.forName(&quot;com.zhongyp.advanced.proxy.Test&quot;);</span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        for(Constructor str:constructors)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method[] method = clazz.getDeclaredMethods();</span><br><span class="line">        for(Method method1:method)&#123;</span><br><span class="line">            System.out.println(method1);</span><br><span class="line">        &#125;</span><br><span class="line">        Method method1 = clazz.getMethod(&quot;go&quot;, null);</span><br><span class="line">        method1.invoke(test,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">class Test&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Test()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private void test()&#123;&#125;</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        System.out.println(&quot;go&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void gogogo()&#123;</span><br><span class="line">        System.out.println(&quot;gogogo&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理模式是为了提供额外或不同的操作，而插入的用来替代”实际”对象的对象，这些操作涉及到与”实际”对象的通信，因此代理通常充当中间人角色。Java的动态代理比代理的思想更前进了一步，它可以动态地创建并代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的策略。以下是一个动态代理示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface TestService&#123;</span><br><span class="line"></span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestServiceImpl implements TestService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;我要开始测试啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyInvokeHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    public MyInvokeHandler(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        return method.invoke(obj,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">        TestServiceImpl testService = new TestServiceImpl();</span><br><span class="line"></span><br><span class="line">        MyInvokeHandler myInvokeHandler = new MyInvokeHandler(testService);</span><br><span class="line"></span><br><span class="line">        TestService proxy = (TestService) Proxy.newProxyInstance(TestService.class.getClassLoader(),new Class[]&#123;TestService.class&#125;,myInvokeHandler);</span><br><span class="line"></span><br><span class="line">        proxy.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据存储-Spring事务</title>
      <link href="/2018/03/17/spring/2018-03-17-Spring-Transaction/"/>
      <url>/2018/03/17/spring/2018-03-17-Spring-Transaction/</url>
      <content type="html"><![CDATA[<h2 id="事务传播特性"><a href="#事务传播特性" class="headerlink" title="事务传播特性"></a>事务传播特性</h2><p><a href="https://github.com/zhongyp/Demo" target="_blank" rel="noopener">源码实例</a></p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h2 id="Spring-事务（转载）"><a href="#Spring-事务（转载）" class="headerlink" title="Spring 事务（转载）"></a>Spring 事务（转载）</h2><p><a href="https://www.cnblogs.com/qjjazry/p/6366204.html" target="_blank" rel="noopener">参考博文：https://www.cnblogs.com/qjjazry/p/6366204.html</a></p><p>事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。  </p><p>在 Spring 中通常可以通过以下三种方式来实现对事务的管理： </p><ol><li><p>使用 Spring 的事务代理工厂管理事务 </p></li><li><p>使用 Spring 的事务注解管理事务 </p></li><li><p>使用 AspectJ 的 AOP 配置管理事务 </p></li></ol><p>Spring 的事务管理，主要用到两个事务相关的接口。</p><p> <img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/transaction.jpg?raw=true" alt="Spring事务接口"></p><h2 id="事务管理器接口"><a href="#事务管理器接口" class="headerlink" title="事务管理器接口"></a>事务管理器接口</h2><p>事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Public interface PlatformTransactionManager()...&#123;  </span><br><span class="line">// 由TransactionDefinition得到TransactionStatus对象</span><br><span class="line">TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; </span><br><span class="line">// 提交</span><br><span class="line">Void commit(TransactionStatus status) throws TransactionException;  </span><br><span class="line">// 回滚</span><br><span class="line">Void rollback(TransactionStatus status) throws TransactionException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A) 常用的两个实现类，PlatformTransactionManager 接口有两个常用的实现类：  　　　　　　　　　　</p><ul><li>DataSourceTransactionManager：使用 JDBC 或 iBatis  进行持久化数据时使用。  </li></ul><p>如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p><p>　　</p><ul><li>HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。 </li></ul><p>如果应用程序的持久化是通过Hibernate实现的，那么你需要使用HibernateTransactionManager。对于Hibernate3，需要在Spring上下文定义中添加如下的<bean>声明：</bean></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p><p>B) PlatformTransactionManager其他实现类</p><p>Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA(事务)、JPA(持久化)。下面分别介绍各个平台框架实现事务管理的机制。</p><ul><li>Java持久化API事务（JPA）</li></ul><p>Hibernate多年来一直是事实上的Java持久化标准，但是现在Java持久化API作为真正的Java持久化标准进入大家的视野。如果你计划使用JPA的话，那你需要使用Spring的JpaTransactionManager来处理事务。你需要在Spring中这样配置JpaTransactionManager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>JpaTransactionManager只需要装配一个JPA实体管理工厂（javax.persistence.EntityManagerFactory接口的任意实现）。JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务。</p><ul><li>Java原生API事务(JTA)</li></ul><p>如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;transactionManagerName&quot; value=&quot;java:/TransactionManager&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象，其中事务成功完成通过UserTransaction.commit()方法提交，事务失败通过UserTransaction.rollback()方法回滚。</p><p>C) Spring 的回滚方式 　　</p><ul><li>Spring 事务的默认回滚方式是：发生运行时异常时回滚，发生受查异常时提交。不过，对于受查异常，程序员也可以手工设置其回滚方式。</li></ul><h2 id="事务定义接口"><a href="#事务定义接口" class="headerlink" title="事务定义接口"></a>事务定义接口</h2><p>事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限，及对它们的操作。</p><p>A) 定义了五个事务隔离级别常量,这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX： 　　　　　　　　 </p><ul><li>DEFAULT：采用DB默认的事务隔离级别。MySql的默认为REPEATABLE_READ；  Oracle默认为 READ_COMMITTED。 　　</li><li>READ_UNCOMMITTED：读未提交。未解决任何并发问题。 　　</li><li>READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。  　　</li><li>REPEATABLE_READ：可重复读。解决脏读、不可重复读，存在幻读  　　</li><li>SERIALIZABLE：串行化。不存在并发问题。</li></ul><p>B) 定义了七个事务传播行为常量，所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如，A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。事务传播行为常量都是以 PROPAGATION_  开头，形如 PROPAGATION_XXX。  　　</p><ul><li>REQUIRED：指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是Spring 默认的事务传播行为。如该传播行为加在 doOther()方法上。若 doSome()方法在执行时就是在事务内的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法没有在事务内执行，则 doOther()方法会创建一个事务，并在其中执行。　　</li><li><p>SUPPORTS：指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。 </p></li><li><p>MANDATORY：指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。</p></li><li><p>REQUIRES_NEW：总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。</p></li><li><p>NOT_SUPPORTED：指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。</p></li><li><p>NEVER：指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。</p></li><li><p>NESTED：指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。嵌套事务在外部事务提交后，才真正的提交。</p></li></ul><p>C) 定义了默认事务超时时限 </p><ul><li><p>常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。 </p></li><li><p>注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。</p></li></ul><h2 id="Spring-的事务代理工厂管理事务"><a href="#Spring-的事务代理工厂管理事务" class="headerlink" title="Spring 的事务代理工厂管理事务"></a>Spring 的事务代理工厂管理事务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册数据源：C3P0数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册JDBC属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册Dao --&gt;</span><br><span class="line">    &lt;bean id=&quot;accountDao&quot; class=&quot;com.tongji.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;stockDao&quot; class=&quot;com.tongji.dao.StockDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册Service --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockService&quot; class=&quot;com.tongji.service.StockProcessServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;stockDao&quot; ref=&quot;stockDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;!-- 注册事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 生成事务代理 --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockServiceProxy&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;transactionManager&quot; ref=&quot;myTxManager&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot; ref=&quot;stockService&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;transactionAttributes&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;open*&quot;&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;buyStock&quot;&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED,-StockException&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="Spring-的事务注解管理事务"><a href="#Spring-的事务注解管理事务" class="headerlink" title="Spring 的事务注解管理事务"></a>Spring 的事务注解管理事务</h2><p>注：需要注意的是，@Transactional 若用在方法上，只能用于 public 方法上。对于其他非public 方法，如果加上了注解@Transactional，虽然 Spring 不会报错，但不会将指定事务织入到该方法中。因为 Spring 会忽略掉所有非 public 方法上的@Transaction 注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; </span><br><span class="line">        xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx </span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop </span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册数据源：C3P0数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册JDBC属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册Dao --&gt;</span><br><span class="line">    &lt;bean id=&quot;accountDao&quot; class=&quot;com.tongji.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;stockDao&quot; class=&quot;com.tongji.dao.StockDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册Service --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockService&quot; class=&quot;com.tongji.service.StockProcessServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;stockDao&quot; ref=&quot;stockDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;!-- 注册事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 开启注解驱动 --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;myTxManager&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED)</span><br><span class="line">public void openAccount(String aname, double money) &#123;</span><br><span class="line">    accountDao.insertAccount(aname, money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED)</span><br><span class="line">public void openStock(String sname, int amount) &#123;</span><br><span class="line">    stockDao.insertStock(sname, amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED, rollbackFor=StockException.class)</span><br><span class="line">public void buyStock(String aname, double money, String sname, int amount) throws StockException &#123;</span><br><span class="line">    boolean isBuy = true;</span><br><span class="line">    accountDao.updateAccount(aname, money, isBuy);</span><br><span class="line">    if (true) &#123;</span><br><span class="line">        throw new StockException(&quot;购买股票异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    stockDao.updateStock(sname, amount, isBuy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-使用AspectJ的AOP配置管理事务"><a href="#Spring-使用AspectJ的AOP配置管理事务" class="headerlink" title="Spring 使用AspectJ的AOP配置管理事务"></a>Spring 使用AspectJ的AOP配置管理事务</h2><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/aop-3.jpg?raw=true" alt="aop3"></p><p>AOP术语：</p><ul><li><p>连接点（joinpoint）你可以切入的方法（注意是可以）。</p></li><li><p>切点（pointcut）是你切入的方法。</p></li><li><p>增强（advice）往切点里面增加其他特殊的东西，比如事务传播。</p></li><li><p>目标对象（target）引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p></li><li><p>引介（introduction）允许我们向现有的类添加新方法属性。</p></li><li><p>织入（weaving） 把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。</p></li><li><p>代理（proxy）实现整套aop机制的，都是通过代理。</p></li><li><p>切面（aspect）切面是通知和切入点的结合,就是定义了通知的类。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; </span><br><span class="line">        xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx </span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop </span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册数据源：C3P0数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册JDBC属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册Dao --&gt;</span><br><span class="line">    &lt;bean id=&quot;accountDao&quot; class=&quot;com.tongji.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;stockDao&quot; class=&quot;com.tongji.dao.StockDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册Service --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockService&quot; class=&quot;com.tongji.service.StockProcessServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;stockDao&quot; ref=&quot;stockDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;!-- 注册事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册事务通知 --&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;myTxManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!-- 指定在切入点方法上应用的事务属性 --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;open*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;buyStock&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;StockException&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- AOP配置 --&gt;</span><br><span class="line">    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;//表示使用CGLib动态代理技术织入增强。设置为false时，表示使用jdk动态代理织入增强，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br><span class="line">        &lt;!-- 指定切入点 --&gt;</span><br><span class="line">        &lt;aop:pointcut expression=&quot;execution(* *..service.*.*(..))&quot; id=&quot;stockPointCut&quot;/&gt;//这里设置切入点，expression设置切面植入的切入点的方法地址</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;stockPointCut&quot;/&gt;// 加入事务传播特性</span><br><span class="line">        &lt;aop:aspect ref=&quot;stockService&quot;&gt;//定义一个切面</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 数据存储 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 多线程（一）</title>
      <link href="/2018/03/16/concurrent/2017-03-16-Threads/"/>
      <url>/2018/03/16/concurrent/2017-03-16-Threads/</url>
      <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">原文地址：https://www.cnblogs.com/snow-flower/p/6114765.html</a></p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul><li>新建：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。</li></ul><p style="color:red">注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</p><ul><li>就绪：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。</li></ul><p style="color:red">如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠，转去执行子线程。</p><ul><li>运行：处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</li></ul><p>处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。</p><pre><code>注： 当发生如下情况是，线程会从运行状态变为阻塞状态：     ①、线程调用sleep方法主动放弃所占用的系统资源     ②、线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞     ③、线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有     ④、线程在等待某个通知（notify）     ⑤、程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。</code></pre><ul><li><p>阻塞：处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。</p></li><li><p>死亡：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ul><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><ul><li>线程睡眠 sleep</li></ul><p>如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法。</p><p>sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread=new MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        myThread.sleep(1000);//这里sleep的就是main线程，而非myThread线程  </span><br><span class="line">        Thread.sleep(10);  </span><br><span class="line">        for(int i=0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</p><ul><li>线程让步 yield</li></ul><p>yield()方法和sleep()方法有点相似，它也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。</p><p style="color:red">sleep和yield的区别</p><pre><code>①、sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。②、sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常。③、sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行。</code></pre><ul><li>线程合并</li></ul><p>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void join()      </span><br><span class="line">     当前线程等该加入线程后面，等待该线程终止。    </span><br><span class="line">void join(long millis)  </span><br><span class="line">     当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度  </span><br><span class="line">void join(long millis,int nanos)   </span><br><span class="line">     等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String [] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1 = new Thread(&quot;小明&quot;);</span><br><span class="line">    Thread t2 = new Thread(&quot;小东&quot;);</span><br><span class="line">    t1.start();</span><br><span class="line">    /**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：</span><br><span class="line">     程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕</span><br><span class="line">     所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会</span><br><span class="line">     */</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置线程优先级</li></ul><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。</p><p style="color:red">注：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p><ul><li>后台守护</li></ul><p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：</p><pre><code>• 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。• Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final void setDaemon(boolean on)        将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。    </span><br><span class="line">         该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。   </span><br><span class="line">  参数：</span><br><span class="line">     on - 如果为 true，则将该线程标记为守护线程。    </span><br><span class="line">  抛出：    </span><br><span class="line">    IllegalThreadStateException - 如果该线程处于活动状态。    </span><br><span class="line">    SecurityException - 如果当前线程无法修改该线程。</span><br></pre></td></tr></table></figure><ul><li>线程结束</li></ul><p>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法：</p><pre><code>• 正常执行完run方法，然后结束掉；• 控制循环条件和判断条件的标识符来结束掉线程。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i=0;  </span><br><span class="line">    boolean next=true;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (next) &#123;  </span><br><span class="line">            if(i==10)  </span><br><span class="line">                next=false;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li>synchronized 关键字</li></ul><p>即有synchronized关键字修饰的方法。由于Java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public synchronized void buy(int i)&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;我买&quot; + i + &quot;个苹果&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了修饰方法，synchronized关键字也可以修饰代码块，根据传入对象的不同，可以分为Java对象锁和类锁。对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void test()&#123;</span><br><span class="line">    String a = &quot;a&quot;;// 随便一个String不变量</span><br><span class="line">    sychronized(a)&#123;// 这个锁只在方法内，加入这个类中还有其他的对象锁方法，则两者互不影响</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized(this)&#123;// 对象锁，其中this也可以使用类中定义的全局变量，不能是静态变量</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void buy(int i)&#123;// 对象锁</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized (Buy.class)&#123;//类锁</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static synchronized void test2()//类锁 </span><br><span class="line">&#123;  </span><br><span class="line">   try &#123;</span><br><span class="line">       Thread.sleep(2000);</span><br><span class="line">   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用特殊域变量volatile</li></ul><p><a href="http://zhongyp.me/2018/01/04/Volatile/">volatile详解</a></p><ul><li>使用重入锁Lock</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">private int account = 100;</span><br><span class="line">//需要声明这个锁</span><br><span class="line">private Lock lock = new ReentrantLock();</span><br><span class="line">public int getAccount() &#123;</span><br><span class="line">    return account;</span><br><span class="line">&#125;</span><br><span class="line">//这里不再需要synchronized </span><br><span class="line">public void save(int money) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        account += money;</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><ul><li><p>wait()，notify()，notifyAll()</p><p>线程执行wait()后，就放弃了运行资格，wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。；线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。notifyall(), 唤醒线程池中所有线程。</p></li></ul><p style="color:red">注：</p> <p>（1） wait(), notify(),notifyall()都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；</p><p>（2） wait(),notify(),notifyall(),  在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。</p><ul><li>Condition</li></ul><p>jdk1.5中，提供了多线程的升级解决方案为：</p><pre><code>（1）将同步synchronized替换为显式的Lock操作；（2）将Object类中的wait(), notify(),notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取;（3）一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而jdk1.5之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Resource&#123;  </span><br><span class="line">    private String name;  </span><br><span class="line">    private int count=1;  </span><br><span class="line">    private boolean flag=false;  </span><br><span class="line">    private Lock lock = new ReentrantLock();/*Lock是一个接口，ReentrantLock是该接口的一个直接子类。*/  </span><br><span class="line">    private Condition condition_pro=lock.newCondition(); /*创建代表生产者方面的Condition对象*/  </span><br><span class="line">    private Condition condition_con=lock.newCondition(); /*使用同一个锁，创建代表消费者方面的Condition对象*/  </span><br><span class="line">      </span><br><span class="line">    public void set(String name)&#123;  </span><br><span class="line">        lock.lock();//锁住此语句与lock.unlock()之间的代码  </span><br><span class="line">        try&#123;  </span><br><span class="line">            while(flag)  </span><br><span class="line">                condition_pro.await(); //生产者线程在conndition_pro对象上等待  </span><br><span class="line">            this.name=name+&quot;---&quot;+count++;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name);  </span><br><span class="line">            flag=true;  </span><br><span class="line">             condition_con.signalAll();  </span><br><span class="line">        &#125;  </span><br><span class="line">        finally&#123;  </span><br><span class="line">            lock.unlock(); //unlock()要放在finally块中。  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void out()&#123;  </span><br><span class="line">        lock.lock(); //锁住此语句与lock.unlock()之间的代码  </span><br><span class="line">        try&#123;  </span><br><span class="line">            while(!flag)  </span><br><span class="line">                condition_con.await(); //消费者线程在conndition_con对象上等待  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name);  </span><br><span class="line">        flag=false;  </span><br><span class="line">        condition_pro.signqlAll(); /*唤醒所有在condition_pro对象下等待的线程，也就是唤醒所有生产者线程*/  </span><br><span class="line">        &#125;  </span><br><span class="line">        finally&#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阻塞队列BlockingQueue</li></ul><p>BlockingQueue是一个接口，也是Queue的子接口。BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从BlockingQueue中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。</p><p>BlockingQueue提供如下两个支持阻塞的方法：</p><pre><code>（1）put(E e)：尝试把Eu元素放如BlockingQueue中，如果该队列的元素已满，则阻塞该线程。（2）take（）：尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。</code></pre><p>BlockingQueue继承了Queue接口，当然也可以使用Queue接口中的方法，这些方法归纳起来可以分为如下三组：</p><pre><code>（1）在队列尾部插入元素，包括add（E e）、offer（E e）、put（E e）方法，当该队列已满时，这三个方法分别会抛出异常、返回false、阻塞队列。（2）在队列头部删除并返回删除的元素。包括remove（）、poll（）、和take（）方法，当该队列已空时，这三个方法分别会抛出异常、返回false、阻塞队列。（3）在队列头部取出但不删除元素。包括element（）和peek（）方法，当队列已空时，这两个方法分别抛出异常、返回false。</code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a href="http://zhongyp.me/2018/03/10/ThreadPool/">线程池博文</a></p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2018/03/16/concurrent/2018-03-16-ThreadLocal/"/>
      <url>/2018/03/16/concurrent/2018-03-16-ThreadLocal/</url>
      <content type="html"><![CDATA[<h2 id="ThreadLocal基本原理"><a href="#ThreadLocal基本原理" class="headerlink" title="ThreadLocal基本原理"></a>ThreadLocal基本原理</h2><h3 id="ThreadLocal的作用"><a href="#ThreadLocal的作用" class="headerlink" title="ThreadLocal的作用"></a>ThreadLocal的作用</h3><p>ThreadLocal提供本地线程变量。</p><h3 id="ThreadLocal示例"><a href="#ThreadLocal示例" class="headerlink" title="ThreadLocal示例"></a>ThreadLocal示例</h3><p>那ThreadLocal是怎样给本地线程提供线程变量的呢？看下面的示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        final ThreadLocal threadLocal = new ThreadLocal();</span><br><span class="line">        Thread thread1 = new Thread()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                threadLocal.set(&quot;a&quot;);</span><br><span class="line">                System.out.println(threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                threadLocal.set(&quot;b&quot;);</span><br><span class="line">                System.out.println(threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread3 = new Thread()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                threadLocal.set(&quot;c&quot;);</span><br><span class="line">                System.out.println(threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        </span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果输出：<br>a<br>b<br>c</p><p>代码示例解读：</p><p>1.首先声明一个ThreadLocal变量</p><p>2.在每个线程内，通过threadLocal.set()的方法为当前线程提供线程变量，set()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();// 获取当前线程</span><br><span class="line">    ThreadLocalMap map = getMap(t);// 通过getMap 获取 Thread对象的threadlocal.ThreadLocalMap</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);// 以this(ThreadLocal本身)为Key,参数value为值进行保存</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ThreadLocal 是一个和Thread无关的对象，可以把它理解成一个工具，如果需要给线程提供线程变量，就用ThreadLocal的set()方法给线程提供变量。</p><p>注：ThreadLocal在当前线程内都可用，不局限于当前方法内。</p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java值传递</title>
      <link href="/2018/03/10/java/2018-03-10-JavaPara/"/>
      <url>/2018/03/10/java/2018-03-10-JavaPara/</url>
      <content type="html"><![CDATA[<p>最近在整理一些之前的博客，发现关于Java值传递的问题还是有些模糊，在此再整理一下。</p><p>对于Java的值传递，并不想C++一样可以由自己掌控，不过理解Java的值传递后感觉比C++简单。</p><p><b style="color: red">可能理解不太对，欢迎大家加我qq打我脸，谢谢！！！（QQ:879376937）</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int[] b = &#123;1&#125;;</span><br><span class="line">        StringBuilder sb = new StringBuilder(&quot;22&quot;);</span><br><span class="line">        change(sb);</span><br><span class="line">        System.out.print(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(int a)&#123;</span><br><span class="line">        a=10;// 不起作用</span><br><span class="line">    &#125;</span><br><span class="line">    public static void change(int[] b)&#123;</span><br><span class="line">        b[0]=10;// 起作用</span><br><span class="line">    &#125;</span><br><span class="line">    public static void change(StringBuilder sb)&#123;</span><br><span class="line">//        sb.append(&quot;3&quot;);// 起作用</span><br><span class="line">        StringBuilder sb1 = new StringBuilder(&quot;232&quot;);</span><br><span class="line">        sb=sb1;// 不起作用</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面这个例子我用了int常量，数组，StringBuilder对象三种参数值作为Java参数进行传递，总的来说这三种参数值从宏观上来说性质是一样的，都是对传递对象的引用复制，例如a, main方法定义的a是对常量池中1的引用，change(int a)中的a是对main方法a的引用，这里一定要明白这两个a是两个对象，所以我们更改change中a的值，实质上是把change方法中a的引用从对main方法中a的引用改为引用常量池上的10，所以main 方法中的a值不会发生变化。</p><p>对于b和sb对象参数传递，其实质a对象一样，都是对main方法中的b和sb对象的引用。不同的是，在b[0]赋值时，因为change方法中的b引用main 方法中的b对象，所以change中的b[0]没有办法赋值，只能交给main方法中的b去赋值，这样更改的就是main中b对象所引用的数组实例，所以起了作用。</p><p>change方法中sb在append赋值时和b[0]赋值的情况一样。</p><p>sb=sb1,这种情况是和a对象重新赋值类似，不过不再是常量池中的常数对象10，而是StringBuilder对象sb1。</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo工作原理</title>
      <link href="/2018/03/07/dubbo/2018-03-07-DubboPrinciple/"/>
      <url>/2018/03/07/dubbo/2018-03-07-DubboPrinciple/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/nethackatschool/article/details/78560574" target="_blank" rel="noopener">尊重原创：参考文档：http://blog.csdn.net/nethackatschool/article/details/78560574</a></p><h2 id="Dubbo启动初始化"><a href="#Dubbo启动初始化" class="headerlink" title="Dubbo启动初始化"></a>Dubbo启动初始化</h2><p>我们大都可能都是用过Dubbo分布式服务架构，但是大部分使用的人可能只是使用并不了解Dubbo是怎样初始化加载的，本篇博文将使用最简单的dubbo-demo例子来描述Dubbo的启动初始化。</p><h2 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h2><p>dubbo框架设计总共分了10层： </p><ul><li><p>服务接口层（Service）：该层是与实际业务逻辑相关，就如下面面demo配置的<code>&lt;dubbo:service interface=&quot;com.xxx.xxx.xxxService&quot; ref=&quot;xxxService&quot; timeout=&quot;5000&quot;/&gt;</code>,这个service就是业务方自己定义的接口与其实现。</p></li><li><p>配置层（Config）：该层是将业务方的service信息，配置文件的信息收集起来，主要是以ServiceConfig和ReferenceConfig为中心，ServiceConfig是服务提供方的配置，当Spring启动的时候会相应的启动provider服务发布和注册的过程，当service在spring容器加载完成后，ServiceBean通过监听器监听spring容器是否加载完毕，然后出发监听方法，onApplicationEvent-&gt;export-&gt;doExport-&gt;doExportUrls-&gt;doExportUrlsFor1Protocol,最后得到provider的代理对象invoker，Procotol将invoker封装为Exporter。</p></li><li><p>服务代理层（Proxy）：对服务接口进行透明代理，生成服务的客户端和服务器端，使服务的远程调用就像在本地调用一样。默认使用JavassistProxyFactory，返回一个Invoker，Invoker则是个可执行核心实体，Invoker的invoke方法通过反射执行service方法。</p></li><li><p>服务注册层（Registry）：封装服务地址的注册和发现，以服务URL为中心，基于zk。</p></li><li><p>集群层（Cluster）:提供多个节点并桥接注册中心，主要负责负载均衡（loadBanlance）、容错。</p></li><li><p>监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。</p></li><li><p>远程调用层（Protocol）：封装RPC调用，provider通过export方法进行暴露服务/consumer通过refer方法调用服务。而Protocol依赖的是Invoker。通过上面说的Proxy获得的Invoker，包装成Exporter。</p></li><li><p>信息交换层（Exchange）：该层封装了请求响应模型，将同步转为异步，信息交换层依赖Exporter，最终将通过网络传输层接收调用请求RequestFuture和ResponseFuture。</p></li><li><p>网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。</p></li><li><p>数据序列化层：该层无需多言，将数据序列化反序列化。</p></li></ul><p>先看到demo中的spring-dubbo配置文件。这些配置文件全都会被装配成RegistryConfig，其属性如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RegistryConfig extends AbstractConfig &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 5508512956753757169L;</span><br><span class="line"></span><br><span class="line">    public static final String NO_AVAILABLE = &quot;N/A&quot;;</span><br><span class="line"></span><br><span class="line">    // 注册中心地址</span><br><span class="line">    private String            address;</span><br><span class="line"></span><br><span class="line">    // 注册中心登录用户名</span><br><span class="line">    private String            username;</span><br><span class="line"></span><br><span class="line">    // 注册中心登录密码</span><br><span class="line">    private String            password;</span><br><span class="line"></span><br><span class="line">    // 注册中心缺省端口</span><br><span class="line">    private Integer           port;</span><br><span class="line"></span><br><span class="line">    // 注册中心协议</span><br><span class="line">    private String            protocol;</span><br><span class="line"></span><br><span class="line">    // 客户端实现</span><br><span class="line">    private String            transporter;</span><br><span class="line"></span><br><span class="line">    private String            server;</span><br><span class="line"></span><br><span class="line">    private String            client;</span><br><span class="line"></span><br><span class="line">    private String            cluster;</span><br><span class="line"></span><br><span class="line">    private String            group;</span><br><span class="line"></span><br><span class="line">    private String            version;</span><br><span class="line"></span><br><span class="line">    // 注册中心请求超时时间(毫秒)</span><br><span class="line">    private Integer           timeout;</span><br><span class="line"></span><br><span class="line">    // 注册中心会话超时时间(毫秒)</span><br><span class="line">    private Integer           session;</span><br><span class="line"></span><br><span class="line">    // 动态注册中心列表存储文件</span><br><span class="line">    private String            file;</span><br><span class="line"></span><br><span class="line">    // 停止时等候完成通知时间</span><br><span class="line">    private Integer           wait;</span><br><span class="line"></span><br><span class="line">    // 启动时检查注册中心是否存在</span><br><span class="line">    private Boolean           check;</span><br><span class="line"></span><br><span class="line">    // 在该注册中心上注册是动态的还是静态的服务</span><br><span class="line">    private Boolean           dynamic;</span><br><span class="line"></span><br><span class="line">    // 在该注册中心上服务是否暴露</span><br><span class="line">    private Boolean           register;</span><br><span class="line"></span><br><span class="line">    // 在该注册中心上服务是否引用</span><br><span class="line">    private Boolean           subscribe;</span><br><span class="line"></span><br><span class="line">    // 自定义参数</span><br><span class="line">    private Map&lt;String, String&gt; parameters;</span><br><span class="line"></span><br><span class="line">    // 是否为缺省</span><br><span class="line">    private Boolean             isDefault;</span><br></pre></td></tr></table></figure><p>这些配置文件根据注册中心的个数会被装配拼接成Dubbo的URL（该url是dubbo中自定义的），该URL长这个样子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">registry://sit-zk.host:2181/com.alibaba.dubbo.registry.RegistryService?application=ifenqu-web&amp;dubbo=2.5.3&amp;pid=13168&amp;registry=zookeeper&amp;timestamp=1510828420296</span><br></pre></td></tr></table></figure></p><p>看完配置信息，接下来让我们看下Service发布的核心方法：ServiceConfig类中的doExportUrls<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void doExportUrls() &#123;</span><br><span class="line">    //该方法根据配置文件装配成一个URL的list</span><br><span class="line">    List&lt;URL&gt; registryURLs = loadRegistries(true);</span><br><span class="line">    //根据每一个协议配置来分别暴露服务</span><br><span class="line">    for (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个protocols长这个样子<code>&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20888&quot; id=&quot;dubbo&quot; /&gt;</code>protocols也是根据配置装配出来的。接下来让我们进入doExportUrlsFor1Protocol方法看看dubbo具体是怎么样将服务暴露出去的。这个方法特别大，有将近300多行代码，但是其中大部分都是获取类似protocols的name、port、host和一些必要的上下文，代码太长就不全都贴出来了，只贴关键部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; </span><br><span class="line">//........省略获取上下文代码</span><br><span class="line">//通过interfaceClass获取要暴露服务的所有要暴露的方法</span><br><span class="line">String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">//.......省略非核心代码</span><br><span class="line">//根据上下文创建URL对象</span><br><span class="line"> URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);</span><br><span class="line"></span><br><span class="line">//通过proxyFactory来获取Invoker对象</span><br><span class="line"> Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">//将invoker对象在protocol中封装成Exporter方便提供给信息交换层进行网络传输</span><br><span class="line"> Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line"> //将exporter添加到list中</span><br><span class="line"> exporters.add(exporter);</span><br></pre></td></tr></table></figure><p>看到这里就比较明白dubbo的工作原理了doExportUrlsFor1Protocol方法，先创建URL，URL创建出来长这样<code>dubbo://192.168.xx.63:20888/com.xxx.xxx.VehicleInfoService?anyhost=true&amp;application=test-web&amp;default.retries=0&amp;dubbo=2.5.3&amp;interface=com.xxx.xxx.VehicleInfoService&amp;methods=get,save,update,del,list&amp;pid=13168&amp;revision=1.2.38&amp;side=provider&amp;timeout=5000&amp;timestamp=1510829644847</code>，是不是觉得这个URL很眼熟，没错在注册中心看到的services的providers信息就是这个，再传入url通过proxyFactory获取Invoker，再将Invoker封装成Exporter的数组，只需要将这个list提供给网络传输层组件，然后consumer执行Invoker的invoke方法就行了。让我们再看看这个proxyFactory的getInvoker方法。proxyFactory下有JDKProxyFactory和JavassistProxyFactory。官方推荐也是默认使用的是JavassistProxyFactory。因为javassist动态代理性能比JDK的高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class JavassistProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        // TODO Wrapper类不能正确处理带$的类名</span><br><span class="line">        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName, </span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes, </span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用了动态代理的方式调用了要暴露的service的方法。并且返回了Invoker对象。在dubbo的服务发布中我们可以看到，这个Invoker贯穿始终，都可以看成是一个context的作用了，让我们进Invoker里面去看看这个Invoker到底是何方神圣。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Invoker&lt;T&gt; extends Node &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get service interface.</span><br><span class="line">     * </span><br><span class="line">     * @return service interface.</span><br><span class="line">     */</span><br><span class="line">    Class&lt;T&gt; getInterface();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * invoke.</span><br><span class="line">     * </span><br><span class="line">     * @param invocation</span><br><span class="line">     * @return result</span><br><span class="line">     * @throws RpcException</span><br><span class="line">     */</span><br><span class="line">    Result invoke(Invocation invocation) throws RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Invoker就两个方法，一个getInterface，也就是要暴露的服务接口，一个就是invoke方法，这个invoke方法在AbstractProxyInvoker中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    //调用doInvoke方法，返回一个Result</span><br><span class="line">        return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        return new RpcResult(e.getTargetException());</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Failed to invoke remote proxy method &quot; + invocation.getMethodName() + &quot; to &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实看到JavassistProxyFactory大家就应该大概明白了这个Invoker的作用，同时这个类的名字就叫Invoker也可以猜个大概，Invoker就是调用service的方法的实体类。其中doInvoke方法已经在JavassistProxyFactory中定义了，通过反射调用要暴露的service的方法。</p><p>业务方将服务接口和实现编写定义好，添加dubbo相关配置文件。</p><ul><li><p>Config层加载配置文件形成上下文，Config层包括：ServiceConfig、ProviderConfig、RegistryConfig等。</p></li><li><p>ServiceConfig根据Protocol类型，根据ProtocolConfig、ProviderConfig加载registry，根据加载的registry创建dubbo的URL。</p></li><li><p>准备工作做完后ProxyFactory上场，dubbo中有两种代理方式，JDK代理和Javassist代理，默认使用Javassist代理，Proxy代理类根据dubbo配置信息获取到接口信息、通过动态代理方式将接口的所有方法交给Proxy代理类进行代理，并封装进Invoker里面。</p></li><li><p>将所有需要暴露的service封装的Invoker组成一个list传给信息交换层提供给消费方进行调用。</p></li></ul><p>有需要的同学可以去下载源码这样可能更方便了解</p><p>Demo代码<a href="https://github.com/zhongyp/bodu/bodu-dubbo" target="_blank" rel="noopener">下载地址</a></p><p>代码结构：</p><p>src</p><ul><li><p>main</p><ul><li>java<ul><li>com.bodu.dubbo<ul><li>api<ul><li>DemoService.java</li></ul></li><li>consumer<ul><li>Consumer.java</li></ul></li><li>producer<ul><li>DemoServiceImpl.java</li><li>Producer</li></ul></li></ul></li></ul></li><li>resources<ul><li>dubbo-demo-producer.xml</li><li>dubbo-demo-consumer.xml</li></ul></li></ul></li><li><p>pom.xml</p></li></ul><p>pom.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;dubbo.version&gt;2.5.4&lt;/dubbo.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>DemoService.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface DemoService &#123;</span><br><span class="line"></span><br><span class="line">    String sayHello(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Producer.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;dubbo-demo-producer.xml&quot;&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">// 添加监听，点击任何键，退出服务</span><br><span class="line">        System.in.read(); // press any key to exit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DemoServiceImpl.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DemoServiceImpl implements DemoService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()) + &quot;] Hello &quot; + name + &quot;, request from consumer: &quot; + RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        return &quot;Hello &quot; + name + &quot;, response form provider: &quot; + RpcContext.getContext().getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dubbo-demo-producer.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 生产者的名称，用于跟踪依赖关系 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;demo-provider&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用组播注册中心来暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用dubbo协议暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 接口的实现类 --&gt;</span><br><span class="line">    &lt;bean id=&quot;demoService&quot; class=&quot;com.bodu.dubbo.producer.DemoServiceImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义用于暴露的服务接口 --&gt;</span><br><span class="line">    &lt;dubbo:service interface=&quot;com.bodu.dubbo.api.DemoService&quot; ref=&quot;demoService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arsgs)&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;dubbo-demo-producer.xml&quot;&#125;);// 获取dubbo-demo-producer.xml配置文件</span><br><span class="line">        context.start();// 初始化配置文件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Consumer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Prevent to get IPV6 address,this way only work in debug mode</span><br><span class="line">        //But you can pass use -Djava.net.preferIPv4Stack=true,then it work well whether in debug mode or not</span><br><span class="line">        // 防止取到IPV6的地址，这种方式仅适用于debug模式，但是你可以直接使用-Djava.net.preferIPv4Stack=true，这样不管是否是debug模式，运行都不会有问题</span><br><span class="line">        System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);</span><br><span class="line">        // 获取配置文件初始化xml</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;dubbo-demo-consuner.xml&quot;&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        // 获取远程服务代理</span><br><span class="line">        DemoService demoService = (DemoService) context.getBean(&quot;demoService&quot;); // get remote service proxy</span><br><span class="line">        // 循环访问远程代理服务</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                String hello = demoService.sayHello(&quot;world&quot;); // call remote method</span><br><span class="line">                System.out.println(hello); // get result</span><br><span class="line"></span><br><span class="line">            &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>dubbo-demo-consumer.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 消费者的名称，用于跟踪依赖关系，不要和生产者名称相同  --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;demo-consumer&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用广播发现服务 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 生成远程服务代理，远程服务代理可以向使用本地的接口一样使用 --&gt;</span><br><span class="line">    &lt;dubbo:reference id=&quot;demoService&quot; check=&quot;false&quot; interface=&quot;com.bodu.dubbo.api.DemoService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>红黑树</title>
      <link href="/2018/03/07/algorithm/2018-03-07-RedBlackTree/"/>
      <url>/2018/03/07/algorithm/2018-03-07-RedBlackTree/</url>
      <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://www.cnblogs.com/sandy2013/p/3270999.html" target="_blank" rel="noopener">博文转载：https://www.cnblogs.com/sandy2013/p/3270999.html</a></p><h2 id="红黑树和平衡二叉树的区别"><a href="#红黑树和平衡二叉树的区别" class="headerlink" title="红黑树和平衡二叉树的区别"></a>红黑树和平衡二叉树的区别</h2><ul><li><p>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。</p></li><li><p>平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。<br>平衡二叉树又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。构造与调整方法 平衡二叉树的常用算法有红黑树、AVL、Treap等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原子读语义（转载）</title>
      <link href="/2018/03/04/concurrent/2018-03-04-Automic/"/>
      <url>/2018/03/04/concurrent/2018-03-04-Automic/</url>
      <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/chengxiao/p/6789109.html" target="_blank" rel="noopener">原文地址：https://www.cnblogs.com/chengxiao/p/6789109.html</a></p><p>在谈谈java中的volatile一文中，我们提到过并发包中的原子类可以解决类似num++这样的复合类操作的原子性问题，相比锁机制，使用原子类更精巧轻量，性能开销更小，本章就一起来分析下原子类的实现机理。</p><h2 id="悲观的解决方案（阻塞同步）"><a href="#悲观的解决方案（阻塞同步）" class="headerlink" title="悲观的解决方案（阻塞同步）"></a>悲观的解决方案（阻塞同步）</h2><p>　　<br>    我们知道，num++看似简单的一个操作，实际上是由1.读取 2.加一 3.写入 三步组成的，这是个复合类的操作（所以我们之前提到过的volatile是无法解决num++的原子性问题的），在并发环境下，如果不做任何同步处理，就会有线程安全问题。最直接的处理方式就是加锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">synchronized(this)&#123;</span><br><span class="line">    num++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>　　使用独占锁机制来解决，是一种悲观的并发策略，抱着一副“总有刁民想害朕”的态势，每次操作数据的时候都认为别的线程会参与竞争修改，所以直接加锁。同一刻只能有一个线程持有锁，那其他线程就会阻塞。线程的挂起恢复会带来很大的性能开销，尽管jvm对于非竞争性的锁的获取和释放做了很多优化，但是一旦有多个线程竞争锁，频繁的阻塞唤醒，还是会有很大的性能开销的。所以，使用synchronized或其他重量级锁来处理显然不够合理。</p><h2 id="乐观的解决方案（非阻塞同步）"><a href="#乐观的解决方案（非阻塞同步）" class="headerlink" title="乐观的解决方案（非阻塞同步）"></a>乐观的解决方案（非阻塞同步）</h2><p>　　乐观的解决方案，顾名思义，就是很大度乐观，每次操作数据的时候，都认为别的线程不会参与竞争修改，也不加锁。如果操作成功了那最好；如果失败了，比如中途确有别的线程进入并修改了数据（依赖于冲突检测），也不会阻塞，可以采取一些补偿机制，一般的策略就是反复重试。很显然，这种思想相比简单粗暴利用锁来保证同步要合理的多。</p><p>　　鉴于并发包中的原子类其实现机理都差不太多，本章我们就通过AtomicInteger这个原子类来进行分析。我们先来看看对于num++这样的操作AtomicInteger是如何保证其原子性的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Atomically increments by one the current value.</span><br><span class="line">     *</span><br><span class="line">     * @return the updated value</span><br><span class="line">     */</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = get();</span><br><span class="line">            int next = current + 1;</span><br><span class="line">            if (compareAndSet(current, next))</span><br><span class="line">                return next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　我们来分析下incrementAndGet的逻辑：1.先获取当前的value值，2.对value加一，3.第三步是关键步骤，调用compareAndSet方法来来进行原子更新操作，这个方法的语义是：</p><p>先检查当前value是否等于current，如果相等，则意味着value没被其他线程修改过，更新并返回true。如果不相等，compareAndSet则会返回false，然后循环继续尝试更新。compareAndSet调用了Unsafe类的compareAndSwapInt方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Atomically sets the value to the given updated value</span><br><span class="line">     * if the current value &#123;@code ==&#125; the expected value.</span><br><span class="line">     *</span><br><span class="line">     * @param expect the expected value</span><br><span class="line">     * @param update the new value</span><br><span class="line">     * @return true if successful. False return indicates that</span><br><span class="line">     * the actual value was not equal to the expected value.</span><br><span class="line">     */</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Unsafe的compareAndSwapInt是个native方法，也就是平台相关的。它是基于CPU的CAS指令来完成的。</p><p><code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code></p><h3 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS(Compare-and-Swap)　"></a>CAS(Compare-and-Swap)　</h3><p>　<br>　　CAS算法是由硬件直接支持来保证原子性的，有三个操作数：内存位置V、旧的预期值A和新值B，当且仅当V符合预期值A时，CAS用新值B原子化地更新V的值，否则，它什么都不做。</p><pre><code>CAS的ABA问题</code></pre><p>　　当然CAS也并不完美，它存在”ABA”问题，假若一个变量初次读取是A，在compare阶段依然是A，但其实可能在此过程中，它先被改为B，再被改回A，而CAS是无法意识到这个问题的。CAS只关注了比较前后的值是否改变，而无法清楚在此过程中变量的变更明细，这就是所谓的ABA漏洞。 </p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>经典面试题整理</title>
      <link href="/2018/03/02/interfaceview/2018-03-02-Classic/"/>
      <url>/2018/03/02/interfaceview/2018-03-02-Classic/</url>
      <content type="html"><![CDATA[<h2 id="corejava"><a href="#corejava" class="headerlink" title="corejava"></a>corejava</h2><ol><li><p>hashcode 相等两个类一定相等么？equals呢？相反呢？</p></li><li><p>介绍一下集合框架</p></li><li><p>hashmap hashtable 底层实现什么区别？hashtale和concurrenthashmap呢？</p></li><li><p>hashmap和treemap 什么区别？底层数据结构呢？</p></li><li><p>线程池用过么？都有什么参数？底层如何实现的？</p></li><li><p>sychnized和Lock什么区别？sychnize什么情况是对象锁，什么时候是全局锁？为什么？</p></li><li><p>ThreadLocal 是什么？底层如何实现？写一个例子？</p></li><li><p>volitile的工作原理？</p></li><li><p>cas知道么？如何实现的？</p></li><li><p>请用至少四种写法？写一个单例模式？</p></li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol><li><p>请介绍一下JVM内存模型？用过什么垃圾回收器，都说说？</p></li><li><p>线上发送频繁full gc如何处理？CPU使用率过高怎么办？如何定位问题？如何解决？说一下解决思路和处理方法。</p></li><li><p>知道字节码么？字节码都有那些？Integer * 5,int y=5, 比较x==y 都经过那些步骤？</p></li><li><p>讲讲类加载机制？都有哪些类加载器，这些类加载器都加载哪些文件？手写一下类加载Demo</p></li><li><p>知道osgi么？他是如何实现的？</p></li><li><p>请问你做过哪些JVM优化？使用什么方法？达到什么效果？</p></li></ol><ol start="7"><li>class.forName(“java.lang.String”)和String.class.getClassLoader.loadClass(“java.lang.String”)什么区别？</li></ol><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol><li><p>spring都有哪些机制？AOP底层如何实现的？IOC？</p></li><li><p>cglib知道么？它和JDK动态代理有什么区别？手写一个jdk动态代理？</p></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li><p>使用mysql索引都有哪些原则？索引什么数据结构？B+tree和B tree什么区别？</p></li><li><p>mysql有哪些存储引擎啊？都有啥区别？要详细？</p></li><li><p>设计高并发系统数据库层面该怎么设计？数据库锁有哪些类型？如何实现？</p></li><li><p>数据库事务有哪些？</p></li></ol><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ol><li><p>如何设计可以动态扩容缩容的分库分表方案？</p></li><li><p>用过哪些分库分表的中间件，有啥优点和缺点，讲一下你了解的分库分表中间件的底层实现原理。</p></li><li><p>我现在有一个未分库分表的系统，以后系统需要分库分表，如何设计，让未分库分表的系统动态切换到分库分表系统上？</p></li><li><p>分布式事务知道么？ 你们怎么解决的？ TCC?那若出现网络原因，网络连不通怎么办啊？</p></li><li><p>为什么分库分表？</p></li><li><p>分布式寻址方式都有哪些算法？知道一致hash么？手写一下Java实现代码？你若userId取模分片，那我要查一段连续时间里的数据怎么办？</p></li><li><p>如何解决分库分表主键问题？有什么实现方案？</p></li></ol><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><ol><li><p>redis和memched 什么区别？为什么单线程的redis比多线程的memched效率要高？</p></li><li><p>redis有什么数据类型？都在哪些场景下使用？</p></li><li><p>redis的主从复制是怎么实现的？redis的集群模式是如何实现的呢？redis的key是如何寻址的？</p></li><li><p>使用redis如何设计分布式锁？使用zk可以么？如何实现？这两种哪个效率更高？</p></li><li><p>知道redis的持久化么？有什么优点和缺点？具体底层实现呢？</p></li><li><p>redis过期策略都有哪些？LRU？写一下Java版本代码？</p></li></ol><h2 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h2><ol><li><p>说一下dubbo的实现过程，注册中心挂了可以继续通信么？</p></li><li><p>zk原理知道么？zk都可以干什么？paxos算法知道么？说一下原理和实现？</p></li><li><p>dubbo支持哪些序列化协议？hessian？说一下hessian的数据结构？PB知道么？为啥PB效率是最高的？</p></li><li><p>知道netty么？netty可以干嘛？NIO,BIO,AIO都是什么啊？有什么区别？</p></li><li><p>dubbo复制均衡策略和高可用策略都有哪些？动态代理策略呢？</p></li><li><p>为什么要进行系统拆分啊？拆分不用dubbo可以么？dubbo和thrift什么区别啊？</p></li></ol><h2 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h2><ol><li><p>为什么使用消息队列？消息队列有什么优点和缺点？</p></li><li><p>如何保证消息队列的高可用？如何保证消息不被重复消费？</p></li><li><p>kafka，activemq，rabbitmq，rocketmq都有什么优点和缺点？</p></li><li><p>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路？</p></li></ol><h2 id="分布式搜索引擎"><a href="#分布式搜索引擎" class="headerlink" title="分布式搜索引擎"></a>分布式搜索引擎</h2><ol><li><p>es的工作过程实现是如何的？如何实现分布式的啊？</p></li><li><p>es在数据量很大的情况下，如何提高查询效率？</p></li><li><p>es的查询是一个怎么的工作过程？底层的lucence介绍一下？倒排索引知道么？es和mongodb什么区别？都在什么场景下使用？</p></li></ol><h2 id="高并发高可用架构设计"><a href="#高并发高可用架构设计" class="headerlink" title="高并发高可用架构设计"></a>高并发高可用架构设计</h2><ol><li><p>如何设计一个高并发高可用系统？</p></li><li><p>如何限流？工程中怎么做的，说一下具体实现？</p></li><li><p>缓存如何使用的？缓存使用不会造成什么后果？</p></li><li><p>如何熔断？熔断框架都有哪些？具体实现原理知道么？</p></li><li><p>如何降级？ 如何进行系统拆分？如何数据库拆分？</p></li></ol><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><ol><li><p>说一下TCP/IP 四层？</p></li><li><p>http的工作流程？ http1.0 http1.1 http2.0具体哪些区别？</p></li><li><p>TCP三次握手，四层分手的工作流程？画一下流程图？为什么不是四次五次或者两次？</p></li><li><p>画一下https的工作流程？具体如何实现？如何防止被抓包？</p></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>45亿阿拉伯数字，如何进行去重？如何找出最大的那个数？</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>二叉树和红黑树</li></ol><p><a href="https://www.jianshu.com/p/a07d1d4004b0" target="_blank" rel="noopener">博文推荐</a></p>]]></content>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo服务端发布（转载）</title>
      <link href="/2018/02/15/dubbo/2018-02-15-Dubbo-Provider/"/>
      <url>/2018/02/15/dubbo/2018-02-15-Dubbo-Provider/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/qiangcai/article/details/73992080" target="_blank" rel="noopener">尊重原创：参考文档：http://blog.csdn.net/qiangcai/article/details/73992080</a></p><p> dubbo自定义标签 里面说过启动服务时会首先加载XML文件中的标签，解析出来的标签数据会装配到对应的实体类中，dubbo框架里面也是这样的。我们首先看看com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler类的实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123;  </span><br><span class="line">  </span><br><span class="line">    static &#123;  </span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void init() &#123;  </span><br><span class="line">        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));  // ServiceBean</span><br><span class="line">        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));  </span><br><span class="line">        registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean实现了spring的ApplicationListener接口，所以也是一个监听器。在spring容器加载完成后触发contextrefreshedevent事件，这个事件会被实现了ApplicationListener接口的类监听到，执行对应的onApplicationEvent函数。我们看看ServiceBean类的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void onApplicationEvent(ApplicationEvent event) &#123;  </span><br><span class="line">    if (ContextRefreshedEvent.class.getName().equals(event.getClass().getName())) &#123;  </span><br><span class="line">        if (isDelay() &amp;&amp; ! isExported() &amp;&amp; ! isUnexported()) &#123;  </span><br><span class="line">            if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">                logger.info(&quot;The service ready on spring started. service: &quot; + getInterface());  </span><br><span class="line">            &#125;  </span><br><span class="line">            export();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个监听方法最终调用了export方法来实现服务的发布处理。因为ServiceBean继承了ServiceConfig类，所以最终还是调用了ServiceConfig中的export方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void export() &#123;  </span><br><span class="line">    if (provider != null) &#123;  </span><br><span class="line">        if (export == null) &#123;  </span><br><span class="line">            export = provider.getExport();//是否暴露  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (delay == null) &#123;  </span><br><span class="line">            delay = provider.getDelay();//是否延迟暴露  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (export != null &amp;&amp; ! export.booleanValue()) &#123;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //是否延迟发布服务接口  </span><br><span class="line">    if (delay != null &amp;&amp; delay &gt; 0) &#123;  </span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    Thread.sleep(delay);//延迟睡眠后调用doExport发布接口  </span><br><span class="line">                &#125; catch (Throwable e) &#123;  </span><br><span class="line">                &#125;  </span><br><span class="line">                doExport();//直接发布接口  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        thread.setDaemon(true);//设置为守护线程  </span><br><span class="line">        thread.setName(&quot;DelayExportServiceThread&quot;);  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        doExport();//直接发布接口  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected synchronized void doExport() &#123;</span><br><span class="line">        if(this.unexported) &#123;//如果是已经解除暴露的接口则抛出异常</span><br><span class="line">            throw new IllegalStateException(&quot;Already unexported!&quot;);</span><br><span class="line">        &#125; else if(!this.exported) &#123; //如果已经暴露则不需要重复暴露 </span><br><span class="line">            this.exported = true;</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            ... 省略获取注册中心url、遍历所有protocol、遍历所有注册中心、给注册中心设置监控url、</span><br><span class="line"></span><br><span class="line">                this.checkApplication();</span><br><span class="line">                this.checkRegistry();</span><br><span class="line">                this.checkProtocol();</span><br><span class="line">                appendProperties(this);</span><br><span class="line">                this.checkStubAndMock(this.interfaceClass);</span><br><span class="line">                if(this.path == null || this.path.length() == 0) &#123;</span><br><span class="line">                    this.path = this.interfaceName;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.doExportUrls();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;&lt;dubbo:service interface=\&quot;\&quot; /&gt; interface not allow null!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>里面做了很多逻辑判断，但最后还是调用了doExport方法，doExport做了很多配置上检查代码比较长也非重点就不贴出来，大家可以去查看相关源码。里面调用doExportUrls方法，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void doExportUrls() &#123;</span><br><span class="line">        List&lt;URL&gt; registryURLs = this.loadRegistries(true);// </span><br><span class="line">        Iterator var2 = this.protocols.iterator();</span><br><span class="line"></span><br><span class="line">        while(var2.hasNext()) &#123;</span><br><span class="line">            ProtocolConfig protocolConfig = (ProtocolConfig)var2.next();</span><br><span class="line">            this.doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loadRegistries方法返回的是两个URL,返回注册中心的url，例如zk的url，<code>registry://192.168.14.46:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;pid=524&amp;registry=zookeeper×tamp=1498806201853</code></p><p>从URL可以看出，dubbo将我们设置的注册标签数据全部转换URL的形式，所有的配置参数均跟着URL后面。而集合protocols属性里面存储了我们配置的协议数据。协议可以配置多个种类。也就是说这里主要是使用这个循环将当前这个服务以某种协议在多个注册机上进行发布。但是我没看懂集合protocols对象是从哪里注入的数据，细节的我就懒得管啦！继续往doExportUrlsFor1Protocol方法中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123;  </span><br><span class="line">        String name = protocolConfig.getName();  </span><br><span class="line">        if (name == null || name.length() == 0) &#123;  </span><br><span class="line">            name = &quot;dubbo&quot;;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        String host = protocolConfig.getHost();  </span><br><span class="line">        if (provider != null &amp;&amp; (host == null || host.length() == 0)) &#123;  </span><br><span class="line">            host = provider.getHost();  </span><br><span class="line">        &#125;  </span><br><span class="line">        boolean anyhost = false;  </span><br><span class="line">        if (NetUtils.isInvalidLocalHost(host)) &#123;  </span><br><span class="line">            anyhost = true;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                host = InetAddress.getLocalHost().getHostAddress();  </span><br><span class="line">            &#125; catch (UnknownHostException e) &#123;  </span><br><span class="line">                logger.warn(e.getMessage(), e);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (NetUtils.isInvalidLocalHost(host)) &#123;  </span><br><span class="line">                if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0) &#123;  </span><br><span class="line">                    for (URL registryURL : registryURLs) &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            Socket socket = new Socket();  </span><br><span class="line">                            try &#123;  </span><br><span class="line">                                SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());  </span><br><span class="line">                                socket.connect(addr, 1000);  </span><br><span class="line">                                host = socket.getLocalAddress().getHostAddress();  </span><br><span class="line">                                break;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                try &#123;  </span><br><span class="line">                                    socket.close();  </span><br><span class="line">                                &#125; catch (Throwable e) &#123;&#125;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125; catch (Exception e) &#123;  </span><br><span class="line">                            logger.warn(e.getMessage(), e);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (NetUtils.isInvalidLocalHost(host)) &#123;  </span><br><span class="line">                    host = NetUtils.getLocalHost();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        Integer port = protocolConfig.getPort();  </span><br><span class="line">        if (provider != null &amp;&amp; (port == null || port == 0)) &#123;  </span><br><span class="line">            port = provider.getPort();  </span><br><span class="line">        &#125;  </span><br><span class="line">        //获取协议默认的端口号  </span><br><span class="line">        final int defaultPort = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();  </span><br><span class="line">        if (port == null || port == 0) &#123;  </span><br><span class="line">            port = defaultPort;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (port == null || port &lt;= 0) &#123;  </span><br><span class="line">            port = getRandomPort(name);//随机生成端口  </span><br><span class="line">            if (port == null || port &lt; 0) &#123;  </span><br><span class="line">                port = NetUtils.getAvailablePort(defaultPort);  </span><br><span class="line">                putRandomPort(name, port);  </span><br><span class="line">            &#125;  </span><br><span class="line">            logger.warn(&quot;Use random available port(&quot; + port + &quot;) for protocol &quot; + name);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  </span><br><span class="line">        if (anyhost) &#123;  </span><br><span class="line">            map.put(Constants.ANYHOST_KEY, &quot;true&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);  </span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());  </span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));  </span><br><span class="line">        if (ConfigUtils.getPid() &gt; 0) &#123;  </span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));  </span><br><span class="line">        &#125;  </span><br><span class="line">        appendParameters(map, application);  </span><br><span class="line">        appendParameters(map, module);  </span><br><span class="line">        appendParameters(map, provider, Constants.DEFAULT_KEY);  </span><br><span class="line">        appendParameters(map, protocolConfig);  </span><br><span class="line">        appendParameters(map, this);  </span><br><span class="line">        if (methods != null &amp;&amp; methods.size() &gt; 0) &#123;  </span><br><span class="line">            for (MethodConfig method : methods) &#123;  </span><br><span class="line">                appendParameters(map, method, method.getName());  </span><br><span class="line">                String retryKey = method.getName() + &quot;.retry&quot;;  </span><br><span class="line">                if (map.containsKey(retryKey)) &#123;  </span><br><span class="line">                    String retryValue = map.remove(retryKey);  </span><br><span class="line">                    if (&quot;false&quot;.equals(retryValue)) &#123;  </span><br><span class="line">                        map.put(method.getName() + &quot;.retries&quot;, &quot;0&quot;);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                List&lt;ArgumentConfig&gt; arguments = method.getArguments();  </span><br><span class="line">                if (arguments != null &amp;&amp; arguments.size() &gt; 0) &#123;  </span><br><span class="line">                    for (ArgumentConfig argument : arguments) &#123;  </span><br><span class="line">                        //类型自动转换.  </span><br><span class="line">                        if(argument.getType() != null &amp;&amp; argument.getType().length() &gt;0)&#123;  </span><br><span class="line">                            Method[] methods = interfaceClass.getMethods();  </span><br><span class="line">                            //遍历所有方法  </span><br><span class="line">                            if(methods != null &amp;&amp; methods.length &gt; 0)&#123;  </span><br><span class="line">                                for (int i = 0; i &lt; methods.length; i++) &#123;  </span><br><span class="line">                                    String methodName = methods[i].getName();  </span><br><span class="line">                                    //匹配方法名称，获取方法签名.  </span><br><span class="line">                                    if(methodName.equals(method.getName()))&#123;  </span><br><span class="line">                                        Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();  </span><br><span class="line">                                        //一个方法中单个callback  </span><br><span class="line">                                        if (argument.getIndex() != -1 )&#123;  </span><br><span class="line">                                            if (argtypes[argument.getIndex()].getName().equals(argument.getType()))&#123;  </span><br><span class="line">                                                appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());  </span><br><span class="line">                                            &#125;else &#123;  </span><br><span class="line">                                                throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attirbute not match :index :&quot;+argument.getIndex() + &quot;, type:&quot; + argument.getType());  </span><br><span class="line">                                            &#125;  </span><br><span class="line">                                        &#125; else &#123;  </span><br><span class="line">                                            //一个方法中多个callback  </span><br><span class="line">                                            for (int j = 0 ;j&lt;argtypes.length ;j++) &#123;  </span><br><span class="line">                                                Class&lt;?&gt; argclazz = argtypes[j];  </span><br><span class="line">                                                if (argclazz.getName().equals(argument.getType()))&#123;  </span><br><span class="line">                                                    appendParameters(map, argument, method.getName() + &quot;.&quot; + j);  </span><br><span class="line">                                                    if (argument.getIndex() != -1 &amp;&amp; argument.getIndex() != j)&#123;  </span><br><span class="line">                                                        throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attirbute not match :index :&quot;+argument.getIndex() + &quot;, type:&quot; + argument.getType());  </span><br><span class="line">                                                    &#125;  </span><br><span class="line">                                                &#125;  </span><br><span class="line">                                            &#125;  </span><br><span class="line">                                        &#125;  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;else if(argument.getIndex() != -1)&#123;  </span><br><span class="line">                            appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());  </span><br><span class="line">                        &#125;else &#123;  </span><br><span class="line">                            throw new IllegalArgumentException(&quot;argument config must set index or type attribute.eg: &lt;dubbo:argument index=&apos;0&apos; .../&gt; or &lt;dubbo:argument type=xxx .../&gt;&quot;);  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; // end of methods for  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (ProtocolUtils.isGeneric(generic)) &#123;  </span><br><span class="line">            map.put(&quot;generic&quot;, generic);  </span><br><span class="line">            map.put(&quot;methods&quot;, Constants.ANY_VALUE);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);  </span><br><span class="line">            if (revision != null &amp;&amp; revision.length() &gt; 0) &#123;  </span><br><span class="line">                map.put(&quot;revision&quot;, revision);  </span><br><span class="line">            &#125;  </span><br><span class="line">            //根据服务实现的接口获取相关服务方法  </span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();  </span><br><span class="line">            if(methods.length == 0) &#123;  </span><br><span class="line">                logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());  </span><br><span class="line">                map.put(&quot;methods&quot;, Constants.ANY_VALUE);  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (! ConfigUtils.isEmpty(token)) &#123;  </span><br><span class="line">            if (ConfigUtils.isDefault(token)) &#123;  </span><br><span class="line">                map.put(&quot;token&quot;, UUID.randomUUID().toString());  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                map.put(&quot;token&quot;, token);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (&quot;injvm&quot;.equals(protocolConfig.getName())) &#123;  </span><br><span class="line">            protocolConfig.setRegister(false);  </span><br><span class="line">            map.put(&quot;notify&quot;, &quot;false&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 导出服务  </span><br><span class="line">        String contextPath = protocolConfig.getContextpath();  </span><br><span class="line">        if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123;  </span><br><span class="line">            contextPath = provider.getContextpath();  </span><br><span class="line">        &#125;  </span><br><span class="line">        //根据Map中存储的属性组装URL地址  </span><br><span class="line">        URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);  </span><br><span class="line">  </span><br><span class="line">        if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)  </span><br><span class="line">                .hasExtension(url.getProtocol())) &#123;  </span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)  </span><br><span class="line">                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        String scope = url.getParameter(Constants.SCOPE_KEY);  </span><br><span class="line">        //配置为none不暴露  </span><br><span class="line">        if (! Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;  </span><br><span class="line">  </span><br><span class="line">            //配置不是remote的情况下做本地暴露 (配置为remote，则表示只暴露远程服务)  </span><br><span class="line">            if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;  </span><br><span class="line">                exportLocal(url);  </span><br><span class="line">            &#125;  </span><br><span class="line">            //如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露远程服务)  </span><br><span class="line">            if (! Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope) )&#123;  </span><br><span class="line">                if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">                    logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0  </span><br><span class="line">                        &amp;&amp; url.getParameter(&quot;register&quot;, true)) &#123;  </span><br><span class="line">                    for (URL registryURL : registryURLs) &#123;  </span><br><span class="line">                        url = url.addParameterIfAbsent(&quot;dynamic&quot;, registryURL.getParameter(&quot;dynamic&quot;));  </span><br><span class="line">                        URL monitorUrl = loadMonitor(registryURL);  </span><br><span class="line">                        if (monitorUrl != null) &#123;  </span><br><span class="line">                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">                            logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        //通过proxyFactory对象生成接口实现类代理对象Invoker  </span><br><span class="line">                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));  </span><br><span class="line">                        //将Invoker对象封装到protocol协议对象中，同时开启socket服务监听端口，这里socket通信是使用netty框架来处理的  </span><br><span class="line">                        Exporter&lt;?&gt; exporter = protocol.export(invoker);  </span><br><span class="line">                        //添加对象到集合  </span><br><span class="line">                        exporters.add(exporter);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);  </span><br><span class="line">  </span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(invoker);  </span><br><span class="line">                    exporters.add(exporter);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        this.urls.add(url);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>doExportUrlsFor1Protocol方法中主要做了几件事</p><p>1.根据xml中dubbo标签配置组装dubbo协议URL，如果没有配置任何协议，默认使用了dubbo协议。比如这里组装后端URL<br><code>dubbo://192.168.14.46:20880/com.service.interfaces.DubboService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.5.3&amp;interface=com.service.interfaces.DubboService&amp;methods=sayName,sayHello&amp;pid=6844&amp;revision=1.0-SNAPSHOT&amp;side=provider&amp;timestamp=1502851260474</code><br>细看这里组装的URL里面携带了发布一个接口服务所有相关的参数，包括接口全限定名，接口相关方法名称，版本号，模块名称</p><p>2.通信协议未指明端口时，随机生成端口号</p><p>3.通过proxyFactory对象生成接口实现类的代理对象invoker</p><p>4.通过protocol对象将invoker封装成Exporter对象，同时开启了socket服务监听端口。这里socket通信使用的是netty框架，</p>]]></content>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ENUM 枚举类</title>
      <link href="/2018/02/04/java/2018-02-04-ENUM/"/>
      <url>/2018/02/04/java/2018-02-04-ENUM/</url>
      <content type="html"><![CDATA[<p>枚举（Enums）<br>JDK1.5加入了一个全新的类型的“类”– 枚举类型。为此JDK1.5引入了一个新关键字enum。</p><p>定义枚举类型时本质上就是定义一个类别，只不过很多细节由编译器帮您完成了，所以某种程度上，enum关键字的作用就像是class或interface。</p><p>当您使用“enum”定义枚举类型时，实质上您定义出来的类型继承自java.lang.Enum类型，而每个枚举的成员其实就是您定义的枚举类型的一个实例（Instance），它们都被预设为final，所以您无法改变它们，它们也是static成员，所以您可以通过类型名称直接使用它们，当然最重要的它们都是公开的public。换句话说，当定义一个枚举类型后，在编译时刻就能确定该枚举类型有几个实例，分别是什么。在运行期间我们无法再使用该枚举类型创建新的实例了，这些实例在编译期间就已经完全确定下来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Coin &#123;    </span><br><span class="line">    penny(&quot;PENNY&quot;), nickel(&quot;NICKEL&quot;), dime(&quot;DIME&quot;), quarter(&quot;QUARTER&quot;);</span><br><span class="line">    private String value;</span><br><span class="line">    Coin(String value)&#123;        this.value = value;    &#125;        </span><br><span class="line">    public String getValue()&#123;        return value;    &#125;        </span><br><span class="line">    public static void main(String[] args)&#123;        </span><br><span class="line">        Coin coin = Coin.nickel;        </span><br><span class="line">        System.out.println(coin.getValue());    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的构造函数定义 Coin(String value)和penny(“PENNY”)是对应的；<br>枚举中也可以定义变量、方法，还可以定义main方法。</p><p><a href="http://blog.csdn.net/zlfprogram/article/details/74066800" target="_blank" rel="noopener">参考博文</a></p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ConcurrentHashMap1.8源码解析</title>
      <link href="/2018/01/26/java/2018-01-26-ConcurrentHashMap/"/>
      <url>/2018/01/26/java/2018-01-26-ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>采用Node + CAS + Synchronized来保证并发安全进行实现，结构如下：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/concurrenthashmap1.8.png?raw=true" alt="1.8"></p><p>只有在执行第一次put方法时才会调用initTable()初始化Node数组，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];// table还是NODE数组</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put实现<br>当执行put方法插入数据时，根据key的hash值，在Node数组中找到相应的位置，实现如下：</p><p>1、如果相应位置的Node还未初始化，则通过CAS插入相应的数据；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 判断当前table的hash位置是否为空，为空通过cas算法插入</span><br><span class="line">    if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">        break;                   // no lock when adding to empty bin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (fh &gt;= 0) &#123;</span><br><span class="line">    binCount = 1;</span><br><span class="line">    for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            if (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        if ((e = e.next) == null) &#123;</span><br><span class="line">            pred.next = new Node&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if (f instanceof TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = 2;</span><br><span class="line">    if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        if (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (binCount != 0) &#123;</span><br><span class="line">    if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    if (oldVal != null)</span><br><span class="line">        return oldVal;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p><p>size实现<br>1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if ((as = counterCells) != null ||</span><br><span class="line">    !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">    CounterCell a; long v; int m;</span><br><span class="line">    boolean uncontended = true;</span><br><span class="line">    if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">        (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">        !(uncontended =</span><br><span class="line">          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">        fullAddCount(x, uncontended);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (check &lt;= 1)</span><br><span class="line">        return;</span><br><span class="line">    s = sumCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、初始化时counterCells为空，在并发量很高时，如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，使用CounterCell记录元素个数的变化；</p><p>2、如果CounterCell数组counterCells为空，调用fullAddCount()方法进行初始化，并插入对应的记录数，通过CAS设置cellsBusy字段，只有设置成功的线程才能初始化CounterCell数组，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">         U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">    boolean init = false;</span><br><span class="line">    try &#123;                           // Initialize table</span><br><span class="line">        if (counterCells == as) &#123;</span><br><span class="line">            CounterCell[] rs = new CounterCell[2];</span><br><span class="line">            rs[h &amp; 1] = new CounterCell(x);</span><br><span class="line">            counterCells = rs;</span><br><span class="line">            init = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        cellsBusy = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (init)</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如果通过CAS设置cellsBusy字段失败的话，则继续尝试通过CAS修改baseCount字段，如果修改baseCount字段成功的话，就退出循环，否则继续循环插入CounterCell对象；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p>所以在1.8中的size实现比1.7简单多，因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int size() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap源码解析（1.8版本）</title>
      <link href="/2018/01/26/java/2018-03-30-HashMap/"/>
      <url>/2018/01/26/java/2018-03-30-HashMap/</url>
      <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h2 id="初始化HashMap"><a href="#初始化HashMap" class="headerlink" title="初始化HashMap"></a>初始化HashMap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    ...</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);// 获取tableSize，由于HashMap的容量是2的幂，所以当传入的initialCapacity不是2的幂时，计算一个大于且最靠近initialCapacity的2的幂。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 无参数构造器，默认负载因子0.75</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap提供了4个构造方法，前两个构造方法都是指定初始化容量大小。容量大小为tableSizeFor(initialCapacity)。无参数构造器使用默认的cap和factor，在第一次put时初始化。第四个构造器传入的是Map,容量大小为大于且最靠近 m.size()/Default_load_factor + 1F 这个数的2的幂。</p><h2 id="HashMap的put操作"><a href="#HashMap的put操作" class="headerlink" title="HashMap的put操作"></a>HashMap的put操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// hashcode 值为32bit </span><br><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 首先key.hashCode计算出32位hash值，然后和hash值的后16位（h&gt;&gt;&gt;16）异或，最后得到16位hash值，且保留了高位信息，增强了随机性。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;// resize() 大小为旧表的2倍，因此n为2的x次幂，x大小和表的大小相关</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)// 判断table中hash匹配的位置第一个节点是否为null,如果为null，则插入当前值。获取当前数据要插入的位置（n-1）&amp; hash,并判断这个位置的值是否为空，如果为空则插入。初始化hash表大小为16，16位的hash与 当前数组大小与（&amp;）运算得到4位的2进制整数。判断Node节点是否空，为空建立Node节点。</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))// 判断hash和key是否相同，如果相同则e=p;</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)// 如果是树节点，直接插入</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;// 不是树节点，遍历到最后，然后插入。如果遍历过程中有hash和key相同，则跳出循环。如果插入后链表长度大于TREEIFY_THRESHOLD（链表最大容量，如果量表长度大于这个值，则使用红黑树来代替链表，提高性能）</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st </span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // 替换key相同的map值，然后返回老的值。</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);// 提供接口给LinkedHashMap使用，用于LRU。</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-的get操作"><a href="#HashMap-的get操作" class="headerlink" title="HashMap 的get操作"></a>HashMap 的get操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;// 根据hash 与运算获得table的索引位置</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node  // 判断第一个是否相等，相等则输出，否则继续</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;// 继续如果是树节点，则使用getTreeNode查询，如果是链表，遍历查询</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-的扩容操作"><a href="#HashMap-的扩容操作" class="headerlink" title="HashMap 的扩容操作"></a>HashMap 的扩容操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;// 老的hashmap的容量</span><br><span class="line">    int oldThr = threshold;// 老的hashmap 是否需要扩容的的容量标志</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123; //如果大于0且大于最大允许容量，则返回最大允许容量，否则*2返回。</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // 如果老的hashmap容量值&lt;0且容量标志大于0，则新容量为大于且最接近newCap的2的幂。</span><br><span class="line">        newCap = oldThr;// 这里未计算2的幂，只是赋值。</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;// 遍历桶</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;// 遍历逆序</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>存储过程</title>
      <link href="/2018/01/25/mysql/2018-01-25-Procedures/"/>
      <url>/2018/01/25/mysql/2018-01-25-Procedures/</url>
      <content type="html"><![CDATA[<p>存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟，它允许控制数据的访问方式。</p><h2 id="存储过程优点"><a href="#存储过程优点" class="headerlink" title="存储过程优点"></a>存储过程优点</h2><ul><li><p>增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p></li><li><p>标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</p></li><li><p>较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</p></li><li><p>减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</p></li><li><p>作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</p></li></ul><h2 id="MySQL-存储过程语法示例"><a href="#MySQL-存储过程语法示例" class="headerlink" title="MySQL 存储过程语法示例"></a>MySQL 存储过程语法示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE pf_changeSetYear(IN set_year decimal(4,0), IN dbname varchar(40))</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE pre_year decimal(4,0);</span><br><span class="line">  DECLARE v_sql varchar(500);</span><br><span class="line">  DECLARE done INT DEFAULT 0;-- 声明一个标志done， 用来判断游标是否遍历完成</span><br><span class="line">  DECLARE TT_CURSOR varchar(500);-- 接收游标值的变量</span><br><span class="line">  DECLARE T_CURSOR CURSOR FOR SELECT distinct  TABLE_NAME FROM  INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = dbname and column_name = &apos;SET_YEAR&apos; and table_name in (SELECT table_name FROM INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA =  dbname and table_type = &apos;BASE TABLE&apos;);-- 游标</span><br><span class="line">  DECLARE CONTINUE HANDLER FOR NOT FOUND set done = 1;-- 在游标循环到最后会将 done 设置为 1</span><br><span class="line">  SET pre_year := set_year - 1;</span><br><span class="line">  OPEN T_CURSOR;-- 打开游标</span><br><span class="line">  loop1:LOOP -- 开始循环</span><br><span class="line">     FETCH T_CURSOR INTO TT_CURSOR; -- 将游标中的值放到TT_CURSOR</span><br><span class="line">     IF not done THEN  -- 判断是否结束</span><br><span class="line">         LEAVE loop1;</span><br><span class="line">     END IF;</span><br><span class="line">    -- 业务逻辑</span><br><span class="line">    IF (</span><br><span class="line">    TT_CURSOR &lt;&gt; &apos;SYS_YEAR&apos;</span><br><span class="line">    AND TT_CURSOR &lt;&gt; &apos;SYS_WORK_DAY&apos;</span><br><span class="line">    ) THEN</span><br><span class="line">      set v_sql = CONCAT(&apos;UPDATE &apos;,TT_CURSOR,CONCAT(&apos; SET SET_YEAR = &apos;, set_year,CONCAT(&apos; WHERE SET_YEAR  =&apos;, pre_year,&apos; &apos;)));</span><br><span class="line">      SET @v_sql = v_sql;--必须使用@v_sql代替v_sql否则执行时会报错</span><br><span class="line">      prepare stmt from @v_sql;  </span><br><span class="line">      EXECUTE stmt;  </span><br><span class="line">      deallocate prepare stmt;  </span><br><span class="line">    END IF;</span><br><span class="line">  END LOOP;</span><br><span class="line">  CLOSE T_CURSOR;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="MySQL-方法（Function）语法示例"><a href="#MySQL-方法（Function）语法示例" class="headerlink" title="MySQL 方法（Function）语法示例"></a>MySQL 方法（Function）语法示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE DEFINER=`root`@`localhost` FUNCTION `getChildList`() RETURNS longtext CHARSET utf8</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sTemp LongText;</span><br><span class="line">DECLARE sTempChd VARCHAR(1000);</span><br><span class="line">SET sTemp = &apos;$&apos;;</span><br><span class="line">SET sTempChd = &apos;&apos;;</span><br><span class="line">SELECT GROUP_CONCAT(parent_id) INTO sTempChd FROM MA_ELE_AGENCYMB;</span><br><span class="line">SELECT GROUP_CONCAT(parent_id) INTO sTemp FROM MA_ELE_AGENCYMB;</span><br><span class="line">        WHILE sTempChd IS NOT NULL DO</span><br><span class="line">       SET sTemp = CONCAT(sTemp,&apos;,&apos;,sTempChd);</span><br><span class="line">       SELECT GROUP_CONCAT(parent_id) INTO sTempChd FROM ma_ele_agency WHERE FIND_IN_SET(chr_id,sTempChd)&gt;0;</span><br><span class="line">        END WHILE;</span><br><span class="line">  RETURN sTemp;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo源码解析目录</title>
      <link href="/2018/01/15/dubbo/2018-01-15-DubboDirector/"/>
      <url>/2018/01/15/dubbo/2018-01-15-DubboDirector/</url>
      <content type="html"><![CDATA[<h2 id="准备篇"><a href="#准备篇" class="headerlink" title="准备篇"></a>准备篇</h2><p><a href="http://zhongyp.me/2018/01/15/XSD/">XSD文件解读</a></p><p><a href="http://zhongyp.me/2018/03/18/JavaReflection/">Java反射和动态代理</a></p><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><p><a href="http://zhongyp.me/2018/01/15/DubboPrinciple/">Dubbo工作原理了解篇（一）</a></p><h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2>]]></content>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对Spring 的IOC的认识</title>
      <link href="/2018/01/15/spring/2018-01-15-Spring/"/>
      <url>/2018/01/15/spring/2018-01-15-Spring/</url>
      <content type="html"><![CDATA[<h2 id="Spring-Bean的初始化源码解析"><a href="#Spring-Bean的初始化源码解析" class="headerlink" title="Spring Bean的初始化源码解析"></a>Spring Bean的初始化源码解析</h2><p><a href="https://www.cnblogs.com/xdp-gacl/p/4249939.html" target="_blank" rel="noopener">原文地址</a></p><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p><ul><li><p>谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p></li><li><p>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p></li></ul><h2 id="IoC-控制反转"><a href="#IoC-控制反转" class="headerlink" title="IoC(控制反转)"></a>IoC(控制反转)</h2><p>　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p><h2 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI(依赖注入)"></a>DI(依赖注入)</h2><p>　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>]]></content>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>XSD文件解析</title>
      <link href="/2018/01/15/dubbo/2018-01-15-XSD/"/>
      <url>/2018/01/15/dubbo/2018-01-15-XSD/</url>
      <content type="html"><![CDATA[<p>从今天开始，打算读一遍dubbo的源码，源码解析也将陆续更新到<a href="https://github.com/zhongyp/dubbo.git" target="_blank" rel="noopener">github</a>上，从本篇开始源码解析就开始啦。</p><p>在解析源码的时候，一直对配置文件的解析好奇呀，所以嘞，源码解析就从配置文件开始吧。gogogo</p><p>XSD （xml Schema Definition）</p><h2 id="Xml-Schema的用途"><a href="#Xml-Schema的用途" class="headerlink" title="Xml Schema的用途"></a>Xml Schema的用途</h2><ul><li><p>定义一个Xml文档中都有什么元素</p></li><li><p>定义一个Xml文档中都会有什么属性</p></li><li><p>定义某个节点的都有什么样的子节点，可以有多少个子节点，子节点出现的顺序</p></li><li><p>定义元素或者属性的数据类型</p></li><li><p>定义元素或者属性的默认值或者固定值</p></li></ul><p>具体定义示例<a href="http://www.cnblogs.com/newsouls/archive/2011/10/28/2227765.html" target="_blank" rel="noopener">XSD定义详解</a></p><h2 id="Spring配置文中解析xsd文件版本"><a href="#Spring配置文中解析xsd文件版本" class="headerlink" title="Spring配置文中解析xsd文件版本"></a>Spring配置文中解析xsd文件版本</h2><p><a href="http://blog.csdn.net/jackyechina/article/details/53125673" target="_blank" rel="noopener">原文链接：http://blog.csdn.net/jackyechina/article/details/53125673</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 初始化Spring配置文件头部声明 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    </span><br><span class="line">&lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN 2.0//EN&quot;    </span><br><span class="line">&quot;http://www.springframework.org/dtd/spring-beans-2.0.dtd&quot;&gt;    </span><br><span class="line">&lt;beans&gt;    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>1、第一行表示xml声明，任何格式良好的xml文档都必须第一行是声明。相当于告诉解析器这个是xml文档，你给我用xml解析器解析。<br>2、dtd声明，表示该xml里的元素和属性等需符合spring-beans-2.0.dtd这个文档类型定义标准。DTD：文件的文件型别定义（Document Type Definition）可以看成一个或者多个 XML 文件的模板，在这里可以定义 XML 文件中的元素、元素的属性、元素的排列方式、元素包含的内容等等。</p><p>因为DTD的一些局限性，以及XML Schema对数据类型和命名空间的支持。目前已使用XML Schema将 DTD 取而代之，被XML Schema 取代后的Spring 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    </span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    </span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    </span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    </span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span><br><span class="line">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span><br><span class="line">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd</span><br><span class="line">&quot;&gt;    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>XML Schema命名空间作用：  </p><p>1、避免命名冲突，像Java中的package一样  </p><p>2、将不同作用的标签分门别类（像Spring中的tx命名空间针对事务类的标签，context命名空间针对组件的标签）  </p><p>代码解释：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">声明xml文件默认的命名空间，表示未使用其他命名空间的所有标签的默认命名空间。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br></pre></td></tr></table></figure><p>声明XML Schema 实例，声明后就可以使用 schemaLocation 属性了，此处就是xsi属性  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">声明前缀为aop的命名空间，后面的URL用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span><br></pre></td></tr></table></figure><p>这个从命名可以看出个大概，指定Schema的位置这个属性必须结合命名空间使用。这个属性有两个值，第一个值表示需要使用的命名空间。第二个值表示供命名空间使用的 XML schema 的位置所以我们需要什么样的标签的时候，就引入什么样的命名空间和Schema 定义就可以了。</p><p>XSD有没有版本号的区别</p><p>通常情况下，namespace对应的URI是一个存放XSD的地址，尽管规范没有这么要求。如果没有提供schemaLocation，那么Spring的XML解析器会从namespace的URI里加载XSD文件。我们可以把配置文件改成这个样子，也是可以正常工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    </span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans/spring-beans.xsd&quot;    </span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span><br></pre></td></tr></table></figure><p>schemaLocation提供了一个xml namespace到对应的XSD文件的一个映射，所以我们可以看到，在xsi:schemaLocation后面配置的字符串都是成对的，前面的是namespace的URI，后面是xsd文件的URI。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd    </span><br><span class="line">http://www.springframework.org/schema/security    </span><br><span class="line">http://www.springframework.org/schema/security/spring-security.xsd&quot;</span><br></pre></td></tr></table></figure><p>Spring默认在启动时是要加载XSD文件来验证xml文件的，所以如果有的时候断网了，或者一些开源软件切换域名，那么就很容易碰到应用启动不了。我记得当时Oracle收购Sun公司时，遇到过这个情况。为了防止这种情况，Spring提供了一种机制，默认从本地加载XSD文件。打开spring-context-3.2.0.RELEASE.jar，可以看到里面有两个特别的文件：</p><p>spring.handlers<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler    </span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler    </span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler    </span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler    </span><br><span class="line">http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></table></figure></p><p>spring.schemas<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context/spring-context-2.5.xsd=org/springframework/context/config/spring-context-2.5.xsd    </span><br><span class="line">http\://www.springframework.org/schema/context/spring-context-3.0.xsd=org/springframework/context/config/spring-context-3.0.xsd    </span><br><span class="line">http\://www.springframework.org/schema/context/spring-context-3.1.xsd=org/springframework/context/config/spring-context-3.1.xsd    </span><br><span class="line">http\://www.springframework.org/schema/context/spring-context-3.2.xsd=org/springframework/context/config/spring-context-3.2.xsd    </span><br><span class="line">http\://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context-3.2.xsd    </span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">再打开jar包里的org/springframework/context/config/ 目录，可以看到下面有</span><br><span class="line">spring-context-2.5.xsd</span><br><span class="line">spring-context-3.0.xsd</span><br><span class="line">spring-context-3.1.xsd</span><br><span class="line">spring-context-3.2.xsd</span><br><span class="line">很明显，可以想到Spring是把XSD文件放到本地了，再在spring.schemas里做了一个映射，优先从本地里加载XSD文件。并且Spring很贴心，把旧版本的XSD文件也全放了。这样可以防止升级了Spring版本，而配置文件里用的还是旧版本的XSD文件，然后断网了，应用启动不了。</span><br><span class="line">我们还可以看到，在没有配置版本号时，用的就是当前版本的XSD文件：</span><br></pre></td></tr></table></figure></p><p>http\://<a href="http://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context-3.2.xsd" target="_blank" rel="noopener">www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context-3.2.xsd</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结论：不要在Spring的配置里，配置上XSD的版本号，因为如果没有配置版本号，取的就是当前jar里的XSD文件，减少了各种风险。而且这样约定大于配置的方式很优雅。</span><br><span class="line">同样，我们打开dubbo的jar包，可以在它的spring.schemas文件里看到有这样的配置：</span><br></pre></td></tr></table></figure></p><p>http\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd<br><code>`</code></p><p>所以，Spring在加载dubbo时，会从dubbo的jar里加载dubbo.xsd。</p><p><a href="https://github.com/zhongyp/bodu/tree/master/bodu-dubbo/src/main/java/com/bodu/dubbo/xsd" target="_blank" rel="noopener">扩展Spring的自定义标签源码</a></p>]]></content>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Bean容器加载Bean源码解析（转载）</title>
      <link href="/2018/01/15/spring/2018-01-15-SpringInit/"/>
      <url>/2018/01/15/spring/2018-01-15-SpringInit/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/dennyzhangdd/p/7652075.html" target="_blank" rel="noopener">原文链接</a></p><h2 id="Spring初始化"><a href="#Spring初始化" class="headerlink" title="Spring初始化"></a>Spring初始化</h2><p>Spring初始化类关系图</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/springinit.png?raw=true" alt="Spring初始化类关系图"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/springinit1.png?raw=true" alt="Spring初始化类关系图"></p><p>DefaultResourceLoader，该类设置classLoader，并且将配置文件 封装为Resource文件。</p><p>AbstractApplicationContext，该类完成了大部分的IOC容器初始化工作，同时也提供了扩展接口留给子类去重载。该类的refresh()函数是核心初始化操作。</p><p>AbstractRefreshableApplicationContext，该类支持刷新BeanFactory。</p><p>AbstractRefreshableConfigApplicationContext，该类保存了配置文件路径</p><p>AbstractXmlApplicationContext：该类支持解析bean定义文件</p><p>最后ClassPathXmlApplicationContext:只提供了一个简单的构造函数</p><p>Spring 将类职责分开，形成职责链，每一层次的扩展 都只是添加了某个功能</p><p>然后父类定义大量的模板，让子类实现，父类层层传递到子类 直到某个子类重载了抽象方法。这里应用到了职责链设计模式和模板设计模式，IOC是个容器工厂设计模式。</p><p>测试程序：</p><p>Bean配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;test&quot; class=&quot;com.bodu.spring.demo.Test&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring-beans.xml&quot;);</span><br><span class="line">Test test = (Test) ctx.getBean(&quot;test&quot;);</span><br><span class="line">test.getTestName();</span><br></pre></td></tr></table></figure><p>开始跟源码啦！！！</p><p>Spring初始化时，先初始化Bean容器</p><p>测试代码通过new ClassPathXmlApplicationContext(“spring-beans.xml”)，初始化ClassPathXmlApplicationContext实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">super(parent);// 把ApplicationContext作为父容器，上述测试类中由于直接载入的xml,没有父容器所以实际传了null</span><br><span class="line">this.setConfigLocations(configLocations);// 替换$&#123;&#125;后设置配置路径</span><br><span class="line">if(refresh) &#123;</span><br><span class="line">this.refresh();// 这个会直接访问至AbstractApplicationContext类的refresh方法,这个是容器创建的核心方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRefreshableConfigApplicationContext类 setConfigLocations()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void setConfigLocations(String... locations) &#123;</span><br><span class="line">    if(locations != null) &#123; // 判断locations非null</span><br><span class="line">        Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);// 断言locations元素非空</span><br><span class="line">        this.configLocations = new String[locations.length];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; locations.length; ++i) &#123;</span><br><span class="line">            this.configLocations[i] = this.resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.configLocations = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refresh()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line"></span><br><span class="line">Object var1 = this.startupShutdownMonitor;</span><br><span class="line">// 同步锁，对一个全局对象或者类加锁时，对该类的所有对象都起作用</span><br><span class="line">synchronized(this.startupShutdownMonitor) &#123;</span><br><span class="line">// 刷新前的准备工作，准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证。</span><br><span class="line">this.prepareRefresh();</span><br><span class="line">//首先调用AbstractRefreshableApplicationContext的refreshBeanFactory()解析xml</span><br><span class="line">//然后调用AbstractXmlApplicationContext/XmlWebApplicationContext.loadBeanDefinitions()方法，加载bean信息</span><br><span class="line">// 告诉子类刷新内部bean工厂</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();</span><br><span class="line">//为BeanFactory配置容器特性，例如类加载器、事件处理器等.</span><br><span class="line">this.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    //设置BeanFactory的后置处理. 空方法，留给子类拓展用。</span><br><span class="line">this.postProcessBeanFactory(beanFactory);</span><br><span class="line">//在上下文中调用factory工厂的时候注册bean的 实例对象，//调用BeanFactory的后处理器, 这些后处理器是在Bean定义中向容器注册的. </span><br><span class="line">this.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">// 注册bean的过程当中拦截所有bean的创建，//注册Bean的后处理器, 在Bean创建过程中调用.</span><br><span class="line">this.registerBeanPostProcessors(beanFactory);</span><br><span class="line">//初始化上下文中的消息源，即不同语言的消息体进行国际化处理</span><br><span class="line">this.initMessageSource();</span><br><span class="line">//初始化事物传播属性，//初始化ApplicationEventMulticaster bean,应用事件广播器</span><br><span class="line">this.initApplicationEventMulticaster();</span><br><span class="line">// 在特定上下文初始化其他特殊bean子类。//初始化其它特殊的Bean， 空方法，留给子类拓展用。</span><br><span class="line">this.onRefresh();</span><br><span class="line">// 检查侦听器bean并注册。//检查并向容器注册监听器Bean</span><br><span class="line">this.registerListeners();</span><br><span class="line">// 实例化所有剩余(non-lazy-init)单例.//实例化所有剩余的(non-lazy-init) 单例Bean.</span><br><span class="line">this.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">// 最后一步:发布对应的事件。//发布容器事件, 结束refresh过程. </span><br><span class="line">this.finishRefresh();</span><br><span class="line">&#125; catch (BeansException var9) &#123;</span><br><span class="line">if(this.logger.isWarnEnabled()) &#123;</span><br><span class="line">this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);</span><br><span class="line">&#125;</span><br><span class="line">            // 销毁已经创建的单例对象避免浪费资源</span><br><span class="line">this.destroyBeans();</span><br><span class="line">//取消refresh操作, 重置active标志. </span><br><span class="line">this.cancelRefresh(var9);</span><br><span class="line">// 异常传播到调用者</span><br><span class="line">throw var9;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 在spring 核心包里重置了内存（缓存），因为我们不需要元数据单例bean对象了</span><br><span class="line">this.resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRefreshableApplicationContext类</p><p style="color:red">refresh方法中obtainFreshBeanFactory方法调用了refreshBeanFactory，该方法使用DefaultListableBeanFactory去定位resources资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">    if(this.hasBeanFactory()) &#123;</span><br><span class="line">        this.destroyBeans();//先消除所有已经存在的bean</span><br><span class="line">        this.closeBeanFactory();// beanFactory = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;//创建并设置DefaultListableBeanFactory同时调用loadBeanDefinitions载入loadBeanDefinition</span><br><span class="line">        // 实例化一个工厂，这里是DefaultListableBeanFactory</span><br><span class="line">        DefaultListableBeanFactory beanFactory = this.createBeanFactory();</span><br><span class="line">        </span><br><span class="line">        beanFactory.setSerializationId(this.getId());</span><br><span class="line">        this.customizeBeanFactory(beanFactory);</span><br><span class="line">        // XmlWebApplicationContext方法</span><br><span class="line">        // 在本类中是抽象方法，需要子类AbstractXmlApplicationContext中实现</span><br><span class="line">        this.loadBeanDefinitions(beanFactory);</span><br><span class="line">        Object var2 = this.beanFactoryMonitor;</span><br><span class="line">        synchronized(this.beanFactoryMonitor) &#123; // 同步锁，刷新beanFactory实例</span><br><span class="line">            this.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException var5) &#123;</span><br><span class="line">        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + this.getDisplayName(), var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected DefaultListableBeanFactory createBeanFactory() &#123;</span><br><span class="line">    return new DefaultListableBeanFactory(this.getInternalParentBeanFactory());// 根据beanFactory的父类，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractXmlApplicationContext类</p><p style="color:red">loadBeanDefinitions其具体实现在AbstractXmlApplicationContext中，定义了一个Reader作为入参执行载入过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">// //这和在BeanFactory中的加载过程一样，也是委托给XmlBeanDefinitionReader去读取配置文件，</span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">this.initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">// 加载Bean定义</span><br><span class="line">this.loadBeanDefinitions(beanDefinitionReader);// 核心方法</span><br><span class="line">&#125;</span><br><span class="line">// getConfigResources采用模板方法设计模式，具体的实现由子类完成，实际上这里getConfigResources调用的就是子类ClassPathXmlApplicationContext的getConfigResources方法。ClassPathXmlApplicationContext继承了DefaultResourceLoader，具备了Resource加载资源的功能。至此完成了Resource定位！</span><br><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">Resource[] configResources = this.getConfigResources();</span><br><span class="line">if(configResources != null) &#123;</span><br><span class="line">// 读取配置文件都是用的这个方法，和BeanFactory是一样的，</span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] configLocations = this.getConfigLocations();</span><br><span class="line">// FileSystemXmlApplicationContext类</span><br><span class="line">if(configLocations != null) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="color:red">这里支持2种模式：1.模板匹配多资源，生成Resource[]。2.载入单个资源url绝对地址，生成一个Resource</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();//获取ResourceLoader资源加载器</span><br><span class="line">    if (resourceLoader == null) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">                &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 1.匹配模板解析 ClassPathXmlApplicationContext是ResourcePatternResolver接口的实例</span><br><span class="line">    if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">       </span><br><span class="line">        try &#123;//接口ResourcePatternResolver</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            int loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            if (actualResources != null) &#123;</span><br><span class="line">                for (Resource resource : resources) &#123;</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(</span><br><span class="line">                    &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 2.载入单个资源url绝对地址</span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        int loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        if (actualResources != null) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invokeBeanFactoryPostProcessors方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, this.getBeanFactoryPostProcessors());</span><br><span class="line">if(beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(&quot;loadTimeWeaver&quot;)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PostProcessorRegistrationDelegate类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line">    Set&lt;String&gt; processedBeans = new HashSet();</span><br><span class="line">    int var9;</span><br><span class="line">    ArrayList currentRegistryProcessors;</span><br><span class="line">    String[] postProcessorNames;</span><br><span class="line">    if(beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;</span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList();</span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new LinkedList();</span><br><span class="line">        Iterator var6 = beanFactoryPostProcessors.iterator();</span><br><span class="line"></span><br><span class="line">        while(var6.hasNext()) &#123;</span><br><span class="line">            BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();</span><br><span class="line">            if(postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;</span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentRegistryProcessors = new ArrayList();</span><br><span class="line">        </span><br><span class="line">        // 不初始化factoryBeans：我们需要把所以没有初始化的bean让bean工厂处理他们，单例BeanDefinitionRegistryPostProcessors之间实现PriorityOrdered接口、序列化接口</span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">        String[] var18 = postProcessorNames;</span><br><span class="line">        var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">        int var10;</span><br><span class="line">        String ppName;</span><br><span class="line">        for(var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">            ppName = var18[var10];</span><br><span class="line">            if(beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">        var18 = postProcessorNames;</span><br><span class="line">        var9 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">        for(var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">            ppName = var18[var10];</span><br><span class="line">            if(!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line">        boolean reiterate = true;</span><br><span class="line"></span><br><span class="line">        while(reiterate) &#123;</span><br><span class="line">            reiterate = false;</span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">            String[] var21 = postProcessorNames;</span><br><span class="line">            var10 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">            for(int var28 = 0; var28 &lt; var10; ++var28) &#123;</span><br><span class="line">                String ppName = var21[var28];</span><br><span class="line">                if(!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    reiterate = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = new ArrayList();</span><br><span class="line">    currentRegistryProcessors = new ArrayList();</span><br><span class="line">    postProcessorNames = postProcessorNames;</span><br><span class="line">    int var22 = postProcessorNames.length;</span><br><span class="line"></span><br><span class="line">    String ppName;</span><br><span class="line">    for(var9 = 0; var9 &lt; var22; ++var9) &#123;</span><br><span class="line">        ppName = postProcessorNames[var9];</span><br><span class="line">        if(!processedBeans.contains(ppName)) &#123;</span><br><span class="line">            if(beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">            &#125; else if(beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                orderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentRegistryProcessors.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors((Collection)priorityOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList();</span><br><span class="line">    Iterator var23 = orderedPostProcessorNames.iterator();</span><br><span class="line"></span><br><span class="line">    while(var23.hasNext()) &#123;</span><br><span class="line">        String postProcessorName = (String)var23.next();</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList();</span><br><span class="line">    Iterator var26 = currentRegistryProcessors.iterator();</span><br><span class="line"></span><br><span class="line">    while(var26.hasNext()) &#123;</span><br><span class="line">        ppName = (String)var26.next();</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AbstractApplicationContext类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">    this.startupDate = System.currentTimeMillis();//获取时间</span><br><span class="line">    //AtomicBoolean是java.util.concurrent.atomic包下的原子变量，这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。</span><br><span class="line">    this.closed.set(false);</span><br><span class="line">    this.active.set(true);</span><br><span class="line">    if(this.logger.isInfoEnabled()) &#123;</span><br><span class="line">        this.logger.info(&quot;Refreshing &quot; + this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.initPropertySources();// 空方法</span><br><span class="line">    // 校验所有可解析的根据需要标记的属性</span><br><span class="line">    this.getEnvironment().validateRequiredProperties();// 校验在接口ConfigurablePropertyResolver接口中定义，未找到实现类</span><br><span class="line">    this.earlyApplicationEvents = new LinkedHashSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">    this.refreshBeanFactory();// 新实例化一个beanFactory</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();// 获取beanFactory</span><br><span class="line">    if(this.logger.isDebugEnabled()) &#123;</span><br><span class="line">        this.logger.debug(&quot;Bean factory for &quot; + this.getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FileSystemXmlApplicationContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">super(parent);</span><br><span class="line">this.setConfigLocations(configLocations);</span><br><span class="line">if(refresh) &#123;</span><br><span class="line">this.refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别"><a href="#ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别" class="headerlink" title="ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别"></a>ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别</h2><p>ClassPathXmlApplicationContext</p><p>ClassPathXmlApplicationContext[只能读放在web-info/classes目录下的配置文件]，classpath:前缀是不需要的,默认就是指项目的classpath路径下面;如果要使用绝对路径,需要加上file:前缀表示这是绝对路径;<br>对于FileSystemXmlApplicationContext，默认表示的是两种，如果要使用classpath路径,需要前缀classpath: </p>]]></content>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo客户端消费（转载）</title>
      <link href="/2018/01/14/dubbo/2018-02-14-Dubbo-Consumer/"/>
      <url>/2018/01/14/dubbo/2018-02-14-Dubbo-Consumer/</url>
      <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qiangcai/article/details/77581201" target="_blank" rel="noopener">尊重原创：参考文档：https://blog.csdn.net/qiangcai/article/details/77581201</a></p><p>开发一个简单的RPC框架，重点需要考虑的是两点，即编解码方式和底层通讯协议的选型，编解码方式指的是需要传输的数据在调用方将以什么组织形式拆解成字节流并在服务提供方以什么形式解析出来。编解码方式的设计需要考虑到后期的版本升级，所以很多RPC协议在设计时都会带上当前协议的版本信息。而底层通讯协议的选型都大同小异，一般都是TCP（当然也可以选择建立于TCP之上更高级的协议，比如Avro、Thrift和HTTP等），在Java语言中就是指套接字Socket，当然，在Netty出现后，很少RPC框架会直接以自己写Socket作为默认实现的通讯方式，但通常也会自己实现一个aio、nio或bio版本给那些“不方便”依赖Netty库的应用系统来使用。</p><p> 在Dubbo的源码中，有一个单独模块dubbo-rpc，其中，最重要的应该是Protocol和Invoker两个接口，代表着协议（编解码方式）和调用过程（通讯方式）。Invoker接口继承于Node接口，Node接口规范了Dubbo体系中各组件之间通讯的基本要素： </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Node &#123;  </span><br><span class="line">    // 协议数据载体  </span><br><span class="line">    URL getUrl();  </span><br><span class="line">    // 状态监测，当前是否可用  </span><br><span class="line">    boolean isAvailable();  </span><br><span class="line">    // 销毁方法  </span><br><span class="line">    void destroy();  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public interface Invoker&lt;T&gt; extends Node &#123;  </span><br><span class="line">    // 获取调用的接口  </span><br><span class="line">    Class&lt;T&gt; getInterface();  </span><br><span class="line">    // 调用过程  </span><br><span class="line">    Result invoke(Invocation invocation) throws RpcException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring在初始化IOC容器，通过DubboNamespaceHandler类来解析dubbo相关标签，在解析客户端标签dubbo:reference时，标签解析出来的相关属性都是存储到ReferenceBean类中，因为ReferenceBean类实现了InitializingBean接口，所以在设置标签所有属性后会调用afterPropertiesSet方法，关于标签bean载体类实现spring框架的InitializingBean接口相关知识可以自己百度了解下，有很多写的比较好的文章，这里就不在细说。具体看afterPropertiesSet方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@SuppressWarnings(&#123; &quot;unchecked&quot;&#125;)  </span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        //判断当前ConsumerConfig是否存在，如果不存在从spring容器中取相关的ConsumerConfig对象，并设置到当前属性中  </span><br><span class="line">        if (getConsumer() == null) &#123;  </span><br><span class="line">            Map&lt;String, ConsumerConfig&gt; consumerConfigMap = applicationContext == null ? null  : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, false, false);  </span><br><span class="line">            if (consumerConfigMap != null &amp;&amp; consumerConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                ConsumerConfig consumerConfig = null;  </span><br><span class="line">                for (ConsumerConfig config : consumerConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        if (consumerConfig != null) &#123;  </span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate consumer configs: &quot; + consumerConfig + &quot; and &quot; + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        consumerConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (consumerConfig != null) &#123;  </span><br><span class="line">                    //设置当前ConsumerConfig对象  </span><br><span class="line">                    setConsumer(consumerConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        //判断当前ApplicationConfig是否存在，不存在从spring容器中获取，并关联到当前类的属性中  </span><br><span class="line">        if (getApplication() == null  </span><br><span class="line">                &amp;&amp; (getConsumer() == null || getConsumer().getApplication() == null)) &#123;  </span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);  </span><br><span class="line">            if (applicationConfigMap != null &amp;&amp; applicationConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                ApplicationConfig applicationConfig = null;  </span><br><span class="line">                for (ApplicationConfig config : applicationConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        if (applicationConfig != null) &#123;  </span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate application configs: &quot; + applicationConfig + &quot; and &quot; + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        applicationConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (applicationConfig != null) &#123;  </span><br><span class="line">                    //设置当前ApplicationConfig属性  </span><br><span class="line">                    setApplication(applicationConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        //判断当前ModuleConfig是否存在，不存在从spring容器中获取，并关联到当前类属性中  </span><br><span class="line">        if (getModule() == null  </span><br><span class="line">                &amp;&amp; (getConsumer() == null || getConsumer().getModule() == null)) &#123;  </span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);  </span><br><span class="line">            if (moduleConfigMap != null &amp;&amp; moduleConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                ModuleConfig moduleConfig = null;  </span><br><span class="line">                for (ModuleConfig config : moduleConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        if (moduleConfig != null) &#123;  </span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate module configs: &quot; + moduleConfig + &quot; and &quot; + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        moduleConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (moduleConfig != null) &#123;  </span><br><span class="line">                    //设置当前ModuleConfig对象  </span><br><span class="line">                    setModule(moduleConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        //判断当前List&lt;RegistryConfig&gt;注册中心是否存在，如果不存在从spring容器中获取，并关联到当前类属性中  </span><br><span class="line">        if ((getRegistries() == null || getRegistries().size() == 0)  </span><br><span class="line">                &amp;&amp; (getConsumer() == null || getConsumer().getRegistries() == null || getConsumer().getRegistries().size() == 0)  </span><br><span class="line">                &amp;&amp; (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().size() == 0)) &#123;  </span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);  </span><br><span class="line">            if (registryConfigMap != null &amp;&amp; registryConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = new ArrayList&lt;RegistryConfig&gt;();  </span><br><span class="line">                for (RegistryConfig config : registryConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        registryConfigs.add(config);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                if (registryConfigs != null &amp;&amp; registryConfigs.size() &gt; 0) &#123;  </span><br><span class="line">                    //设置当前的注册中心  </span><br><span class="line">                    super.setRegistries(registryConfigs);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        //判断当前MonitorConfig监控中心是否存在，如果不存在从spring容器中获取  </span><br><span class="line">        if (getMonitor() == null  </span><br><span class="line">                &amp;&amp; (getConsumer() == null || getConsumer().getMonitor() == null)  </span><br><span class="line">                &amp;&amp; (getApplication() == null || getApplication().getMonitor() == null)) &#123;  </span><br><span class="line">            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);  </span><br><span class="line">            if (monitorConfigMap != null &amp;&amp; monitorConfigMap.size() &gt; 0) &#123;  </span><br><span class="line">                MonitorConfig monitorConfig = null;  </span><br><span class="line">                for (MonitorConfig config : monitorConfigMap.values()) &#123;  </span><br><span class="line">                    if (config.isDefault() == null || config.isDefault().booleanValue()) &#123;  </span><br><span class="line">                        if (monitorConfig != null) &#123;  </span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate monitor configs: &quot; + monitorConfig + &quot; and &quot; + config);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        monitorConfig = config;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (monitorConfig != null) &#123;  </span><br><span class="line">                    //设置当前的监控中心  </span><br><span class="line">                    setMonitor(monitorConfig);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Boolean b = isInit();  </span><br><span class="line">        if (b == null &amp;&amp; getConsumer() != null) &#123;  </span><br><span class="line">            b = getConsumer().isInit();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        //是否容器启动加载时，立即初始化，默认是不立刻初始化处理，可以通过在dubbo:reference标签里面配置init=true来设置  </span><br><span class="line">        if (b != null &amp;&amp; b.booleanValue()) &#123;  </span><br><span class="line">            getObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getObject中调用init(),init总体思路就是再次检测了Consumer，Application，Module，Registries等配置信息，并将配置信息全部存入到Map中。注意最后一段代码 ref = createProxy(map); 看代码应该就能理解它的作用创建代理对象，并传入了前面存进所有参数的map属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private T createProxy(Map&lt;String, String&gt; map) &#123;  </span><br><span class="line">       //根据map中的属性值生成URL对象  </span><br><span class="line">       URL tmpUrl = new URL(&quot;temp&quot;, &quot;localhost&quot;, 0, map);  </span><br><span class="line">       final boolean isJvmRefer;  </span><br><span class="line">       if (isInjvm() == null) &#123;  </span><br><span class="line">           if (url != null &amp;&amp; url.length() &gt; 0) &#123; //指定URL的情况下，不做本地引用  </span><br><span class="line">               isJvmRefer = false;  </span><br><span class="line">           &#125; else if (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) &#123;  </span><br><span class="line">               //默认情况下如果本地有服务暴露，则引用本地服务.  </span><br><span class="line">               isJvmRefer = true;  </span><br><span class="line">           &#125; else &#123;  </span><br><span class="line">               isJvmRefer = false;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125; else &#123;  </span><br><span class="line">           isJvmRefer = isInjvm().booleanValue();  </span><br><span class="line">       &#125;  </span><br><span class="line">         </span><br><span class="line">       if (isJvmRefer) &#123;  </span><br><span class="line">           URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);  </span><br><span class="line">           invoker = refprotocol.refer(interfaceClass, url);  </span><br><span class="line">           if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">               logger.info(&quot;Using injvm service &quot; + interfaceClass.getName());  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125; else &#123;  </span><br><span class="line"> </span><br><span class="line">           //判断当前客户端是否是点对点直连，直连会跳过注册中心  </span><br><span class="line">           //直连或者注册连接的url都会存储在urls中  </span><br><span class="line">           if (url != null &amp;&amp; url.length() &gt; 0) &#123; // 用户指定URL，指定的URL可能是对点对直连地址，也可能是注册中心URL  </span><br><span class="line">               String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);  </span><br><span class="line">               if (us != null &amp;&amp; us.length &gt; 0) &#123;  </span><br><span class="line">                   for (String u : us) &#123;  </span><br><span class="line">                       URL url = URL.valueOf(u);  </span><br><span class="line">                       if (url.getPath() == null || url.getPath().length() == 0) &#123;  </span><br><span class="line">                           url = url.setPath(interfaceName);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;  </span><br><span class="line">                           urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));  </span><br><span class="line">                       &#125; else &#123;  </span><br><span class="line">                           urls.add(ClusterUtils.mergeUrl(url, map));  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125; else &#123;  </span><br><span class="line">               // 通过注册中心配置拼装URL  </span><br><span class="line">               List&lt;URL&gt; us = loadRegistries(false);  </span><br><span class="line">               if (us != null &amp;&amp; us.size() &gt; 0) &#123;  </span><br><span class="line">                   for (URL u : us) &#123;  </span><br><span class="line">                       URL monitorUrl = loadMonitor(u);  </span><br><span class="line">                       if (monitorUrl != null) &#123;  </span><br><span class="line">                           map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               if (urls == null || urls.size() == 0) &#123;  </span><br><span class="line">                   throw new IllegalStateException(&quot;No such any registry to reference &quot; + interfaceName  + &quot; on the consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, please config &lt;dubbo:registry address=\&quot;...\&quot; /&gt; to your spring config.&quot;);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">           if (urls.size() == 1) &#123;  </span><br><span class="line">               //只有一个注册服务器时，生成客户端的代理invoker  </span><br><span class="line">               invoker = refprotocol.refer(interfaceClass, urls.get(0));  </span><br><span class="line">           &#125; else &#123;  </span><br><span class="line"> </span><br><span class="line">               //当有多个注册服务器时，生成多个客户端代理  </span><br><span class="line">               List&lt;Invoker&lt;?&gt;&gt; invokers = new ArrayList&lt;Invoker&lt;?&gt;&gt;();  </span><br><span class="line">               URL registryURL = null;  </span><br><span class="line">               for (URL url : urls) &#123;  </span><br><span class="line">                   //多个服务端，生成多个对应的invoker对象  </span><br><span class="line">                   invokers.add(refprotocol.refer(interfaceClass, url));  </span><br><span class="line">                   if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;  </span><br><span class="line">                       registryURL = url; // 用了最后一个注册服务器作为注册中心 registry url  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               if (registryURL != null) &#123; // 有 注册中心协议的URL  </span><br><span class="line">                   // 对有注册中心的集群 只用 AvailableCluster  </span><br><span class="line">                   URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);   </span><br><span class="line">                   invoker = cluster.join(new StaticDirectory(u, invokers));  </span><br><span class="line">               &#125;  else &#123; // 不是 注册中心的URL  </span><br><span class="line">                   invoker = cluster.join(new StaticDirectory(invokers));  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line"> </span><br><span class="line">       Boolean c = check;  </span><br><span class="line">       if (c == null &amp;&amp; consumer != null) &#123;  </span><br><span class="line">           c = consumer.isCheck();  </span><br><span class="line">       &#125;  </span><br><span class="line">       if (c == null) &#123;  </span><br><span class="line">           c = true; // default true  </span><br><span class="line">       &#125;  </span><br><span class="line">       if (c &amp;&amp; ! invoker.isAvailable()) &#123;  </span><br><span class="line">           throw new IllegalStateException(&quot;Failed to check the status of the service &quot; + interfaceName + &quot;. No provider available for the service &quot; + (group == null ? &quot;&quot; : group + &quot;/&quot;) + interfaceName + (version == null ? &quot;&quot; : &quot;:&quot; + version) + &quot; from the url &quot; + invoker.getUrl() + &quot; to the consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion());  </span><br><span class="line">       &#125;  </span><br><span class="line">       if (logger.isInfoEnabled()) &#123;  </span><br><span class="line">           logger.info(&quot;Refer dubbo service &quot; + interfaceClass.getName() + &quot; from url &quot; + invoker.getUrl());  </span><br><span class="line">       &#125;  </span><br><span class="line">       // 创建服务代理  </span><br><span class="line">       return (T) proxyFactory.getProxy(invoker);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面方法中主要做了一件事情就是创建客户端接口的invoker对象，我们重点解析这段代码 invoker = refprotocol.refer(interfaceClass, url);Protocol有很多个实现类，但是ReferenceConfig作为服务提供方的一个接口实例，此时并不知道该调用哪个实现类，当生成一个refprotocol来代表所有的实现类，当调用到该类中的export方法的时候，再根据方法的参数来决定调用到哪个具体的实现类中，相当于一种高级别的代理。</p><p>refprotocol对象是什么怎么创建的，创建代码如下 <code>Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code>具体如何创建出来的后面专门通过章节来讲解， 这里我就默认refprotocol属性是DubboProtocol类了，查看该类的refer方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123;  </span><br><span class="line">  </span><br><span class="line">        // modified by lishen  </span><br><span class="line">        optimizeSerialization(url);  </span><br><span class="line">  </span><br><span class="line">        // create rpc invoker.  </span><br><span class="line">        DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);  </span><br><span class="line">        invokers.add(invoker);  </span><br><span class="line">        return invoker;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoker对象原来就是DubboInvoker类。因为DubboInvoker继承了AbstractInvoker类，它重写了父类的doInvoke方法。在看看AbstractInvoker代码，它的invoke方法中最终还是执行了doInvoke方法，因为当前类的doInvoke是抽象的，所以最终还是执行了DubboInvoker中的doInvoke方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class DubboInvoker&lt;T&gt; extends AbstractInvoker&lt;T&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">        private final ExchangeClient[]      clients;  </span><br><span class="line">  </span><br><span class="line">        private final AtomicPositiveInteger index = new AtomicPositiveInteger();  </span><br><span class="line">  </span><br><span class="line">        private final String                version;  </span><br><span class="line">          </span><br><span class="line">        private final ReentrantLock     destroyLock = new ReentrantLock();  </span><br><span class="line">          </span><br><span class="line">        private final Set&lt;Invoker&lt;?&gt;&gt; invokers;  </span><br><span class="line">          </span><br><span class="line">        public DubboInvoker(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients)&#123;  </span><br><span class="line">            this(serviceType, url, clients, null);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        public DubboInvoker(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients, Set&lt;Invoker&lt;?&gt;&gt; invokers)&#123;  </span><br><span class="line">            super(serviceType, url, new String[] &#123;Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY&#125;);  </span><br><span class="line">            this.clients = clients;  </span><br><span class="line">            // get version.  </span><br><span class="line">            this.version = url.getParameter(Constants.VERSION_KEY, &quot;0.0.0&quot;);  </span><br><span class="line">            this.invokers = invokers;   </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        @Override  </span><br><span class="line">        protected Result doInvoke(final Invocation invocation) throws Throwable &#123;  </span><br><span class="line">            RpcInvocation inv = (RpcInvocation) invocation;  </span><br><span class="line">            final String methodName = RpcUtils.getMethodName(invocation);  </span><br><span class="line">            inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());  </span><br><span class="line">            inv.setAttachment(Constants.VERSION_KEY, version);  </span><br><span class="line">              </span><br><span class="line">            ExchangeClient currentClient;  </span><br><span class="line">            if (clients.length == 1) &#123;  </span><br><span class="line">                currentClient = clients[0];  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                currentClient = clients[index.getAndIncrement() % clients.length];  </span><br><span class="line">            &#125;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);  </span><br><span class="line">                boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);  </span><br><span class="line">                int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY,Constants.DEFAULT_TIMEOUT);  </span><br><span class="line">                if (isOneway) &#123;  </span><br><span class="line">                    //只负责发送消息，不需要等待反馈接口，所以结果始终未NULL  </span><br><span class="line">                    boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);  </span><br><span class="line">                    currentClient.send(inv, isSent);  </span><br><span class="line">                    RpcContext.getContext().setFuture(null);  </span><br><span class="line">                    return new RpcResult();  </span><br><span class="line">                &#125; else if (isAsync) &#123;  </span><br><span class="line">                    //异步请求  </span><br><span class="line">                    ResponseFuture future = currentClient.request(inv, timeout) ;  </span><br><span class="line">                    RpcContext.getContext().setFuture(new FutureAdapter&lt;Object&gt;(future));  </span><br><span class="line">                    return new RpcResult();  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    //默认阻塞请求  </span><br><span class="line">                    RpcContext.getContext().setFuture(null);  </span><br><span class="line">                    return (Result) currentClient.request(inv, timeout).get();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; catch (TimeoutException e) &#123;  </span><br><span class="line">                throw new RpcException(RpcException.TIMEOUT_EXCEPTION, &quot;Invoke remote method timeout. method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);  </span><br><span class="line">            &#125; catch (RemotingException e) &#123;  </span><br><span class="line">                throw new RpcException(RpcException.NETWORK_EXCEPTION, &quot;Failed to invoke remote method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        @Override  </span><br><span class="line">        public boolean isAvailable() &#123;  </span><br><span class="line">            if (!super.isAvailable())  </span><br><span class="line">                return false;  </span><br><span class="line">            for (ExchangeClient client : clients)&#123;  </span><br><span class="line">                if (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY))&#123;  </span><br><span class="line">                    //cannot write == not Available ?  </span><br><span class="line">                    return true ;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public void destroy() &#123;  </span><br><span class="line">            //防止client被关闭多次.在connect per jvm的情况下，client.close方法会调用计数器-1，当计数器小于等于0的情况下，才真正关闭  </span><br><span class="line">            if (super.isDestroyed())&#123;  </span><br><span class="line">                return ;  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                //dubbo check ,避免多次关闭  </span><br><span class="line">                destroyLock.lock();  </span><br><span class="line">                try&#123;  </span><br><span class="line">                    if (super.isDestroyed())&#123;  </span><br><span class="line">                        return ;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    super.destroy();  </span><br><span class="line">                    if (invokers != null)&#123;  </span><br><span class="line">                        invokers.remove(this);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    for (ExchangeClient client : clients) &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            client.close();  </span><br><span class="line">                        &#125; catch (Throwable t) &#123;  </span><br><span class="line">                            logger.warn(t.getMessage(), t);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                      </span><br><span class="line">                &#125;finally &#123;  </span><br><span class="line">                    destroyLock.unlock();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意看doInvoke方法中的实现，从ExchangeClient clients[]数组中取出一个对象currentClient将客户端接口请求信息发送给服务端处理。注意了这里的ExchangeClient保存的是客户端与服务器建立的socket链接对象，也就是netty的客户端对象。 在发送请求处理有3个逻辑判断</p><p>1.只负责发送请求，不需要等待反馈消息</p><p>2.异步请求</p><p>3.默认是阻塞的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class AbstractProxyFactory implements ProxyFactory &#123;  </span><br><span class="line">  </span><br><span class="line">        public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123;  </span><br><span class="line">            Class&lt;?&gt;[] interfaces = null;  </span><br><span class="line">            String config = invoker.getUrl().getParameter(&quot;interfaces&quot;);  </span><br><span class="line">            if (config != null &amp;&amp; config.length() &gt; 0) &#123;  </span><br><span class="line">                String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);  </span><br><span class="line">                if (types != null &amp;&amp; types.length &gt; 0) &#123;  </span><br><span class="line">                    interfaces = new Class&lt;?&gt;[types.length + 2];  </span><br><span class="line">                    interfaces[0] = invoker.getInterface();  </span><br><span class="line">                    interfaces[1] = EchoService.class;  </span><br><span class="line">                    for (int i = 0; i &lt; types.length; i ++) &#123;  </span><br><span class="line">                        interfaces[i + 1] = ReflectUtils.forName(types[i]);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (interfaces == null) &#123;  </span><br><span class="line">                interfaces = new Class&lt;?&gt;[] &#123;invoker.getInterface(), EchoService.class&#125;;  </span><br><span class="line">            &#125;  </span><br><span class="line">            return getProxy(invoker, interfaces);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        public abstract &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types);  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们回到代理的创建方法ReferenceConfig.createProxy中最后一行的代码return (T) proxyFactory.getProxy(invoker); 最后还是执行了抽象的getProxy方法。因为JavassistProxyFactory类继承了AbstractProxyFactory，并重写了getProxy方法所以最终还是执行了JavassistProxyFactory类中的getProxy方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)  </span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;  </span><br><span class="line">        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 深拷贝和浅拷贝</title>
      <link href="/2018/01/12/java/2018-01-12-Clone/"/>
      <url>/2018/01/12/java/2018-01-12-Clone/</url>
      <content type="html"><![CDATA[<p>总结：浅拷贝是指在拷贝对象时，对于基本数据类型的变量会重新复制一份，而对于引用类型的变量只是对引用进行拷贝，</p><p>没有对引用指向的对象进行拷贝。</p><p>而深拷贝是指在拷贝对象时，同时会对引用指向的对象进行拷贝。</p><p>区别就在于是否对  对象中的引用变量所指向的对象进行拷贝。</p><p>还有一点需要注意的是，如下实例也算是浅拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Address implements Cloneable &#123;</span><br><span class="line">private String add;</span><br><span class="line">    </span><br><span class="line">    Private Data date;</span><br><span class="line"></span><br><span class="line">public String getAdd() &#123;</span><br><span class="line">return add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public Date getDate()&#123;</span><br><span class="line">    </span><br><span class="line">        return this.date;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    public void setDate(Date date)&#123;</span><br><span class="line">        this.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public void setAdd(String add) &#123;</span><br><span class="line">this.add = add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object clone() &#123;</span><br><span class="line">Address addr = null;</span><br><span class="line">try&#123;</span><br><span class="line">addr = (Address)super.clone();</span><br><span class="line">&#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//addr.setDate(this.getDate().clone());如果没有这句，addr对象和原有对象对Date对象引用还是一个，属于浅拷贝。</span><br><span class="line">return addr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ListIterator和Iterator的区别</title>
      <link href="/2018/01/12/java/2018-01-12-listirerator/"/>
      <url>/2018/01/12/java/2018-01-12-listirerator/</url>
      <content type="html"><![CDATA[<p>我们在使用List,Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。</p><p>但是在使用的时候也是有不同的。List和Set都有iterator()来取得其迭代器。对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面：</p><ul><li><p>ListIterator有add()方法，可以向List中添加对象，而Iterator不能</p></li><li><p>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</p></li><li><p>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</p></li><li><p>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</p></li><li><p>使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能用于List及其子类型。</p></li></ul><p>因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedList源码解析</title>
      <link href="/2018/01/12/java/2018-01-12-LinkedList/"/>
      <url>/2018/01/12/java/2018-01-12-LinkedList/</url>
      <content type="html"><![CDATA[<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</p><p>LinkedList 是List和Deque接口的双向链表的实现。实现了所有可选列表操作，并允许包括null值。</p><p>LinkedList 其顺序访问非常高效，而随机访问效率比较低。</p><p>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。</p><p>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。</p><p>LinkedList 是非同步的。</p><p>如果多个线程同时访问一个LinkedList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。这通常是通过同步那些用来封装列表的 对象来实现的。但如果没有这样的对象存在，则该列表需要运用{@link Collections#synchronizedList Collections.synchronizedList}来进行“包装”，该方法最好是在创建列表对象时完成，为了避免对列表进行突发的非同步操作。</p><p><code>List list = Collections.synchronizedList(new LinkedList(...));</code></p><p>使用synchronizedList在迭代的时候，需要开发者自己加上线程锁控制代码，因为在整个迭代的过程中如果在循环外面不加同步代码，在一次次迭代之间，其他线程对于这个容器的add或者remove会影响整个迭代的预期效果，所以这里需要用户在整个循环外面加上synchronized(list);</p><p>类中的iterator()方法和listIterator()方法返回的iterators迭代器是fail-fast的：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p><p><img src="https://images0.cnblogs.com/blog/497634/201401/272345393446232.jpg" alt="LinkedList关系图"></p><p><a href="https://images0.cnblogs.com/blog/497634/201401/272345393446232.jpg" target="_blank" rel="noopener">图片地址：https://images0.cnblogs.com/blog/497634/201401/272345393446232.jpg</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">        extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    // </span><br><span class="line">    transient int size = 0;</span><br><span class="line"></span><br><span class="line">    // 首节点  </span><br><span class="line">    transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    // 尾节点  </span><br><span class="line">    transient Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public LinkedList() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        this();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用参数作为首节点  </span><br><span class="line">    private void linkFirst(E e) &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first; // 获取当前首节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 使用参数创建节点，next指向f即原首节点</span><br><span class="line">        first = newNode; // 设置首节点</span><br><span class="line">        if (f == null) // 维护双向链表</span><br><span class="line">            last = newNode;</span><br><span class="line">        else</span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++; // 维护链表大小</span><br><span class="line">        modCount++;// 记录被改动次数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    void linkLast(E e) &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">        last = newNode;</span><br><span class="line">        if (l == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将参数e插入节点succ前面  </span><br><span class="line">    void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">        // assert succ != null;</span><br><span class="line">        final Node&lt;E&gt; pred = succ.prev;// 获取succ的prev节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);// 使用参数新建节点，并把prev指向pred，next指向succ</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        if (pred == null) </span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     //删除首节点并返回删除前首节点的值，内部使用  </span><br><span class="line">    private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">        // assert f == first &amp;&amp; f != null;</span><br><span class="line">        final E element = f.item;</span><br><span class="line">        final Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = null;</span><br><span class="line">        f.next = null; // help GC</span><br><span class="line">        first = next;</span><br><span class="line">        if (next == null)</span><br><span class="line">            last = null;</span><br><span class="line">        else</span><br><span class="line">            next.prev = null;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除尾节点并返回删除前尾节点的值，内部使用  </span><br><span class="line">    private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">        // assert l == last &amp;&amp; l != null;</span><br><span class="line">        final E element = l.item;</span><br><span class="line">        final Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = null;</span><br><span class="line">        l.prev = null; // help GC</span><br><span class="line">        last = prev;</span><br><span class="line">        if (prev == null)</span><br><span class="line">            first = null;</span><br><span class="line">        else</span><br><span class="line">            prev.next = null;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除指定节点并返回被删除的元素值  </span><br><span class="line">    E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        // assert x != null;</span><br><span class="line">        final E element = x.item;</span><br><span class="line">        final Node&lt;E&gt; next = x.next;</span><br><span class="line">        final Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        if (prev == null) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = null;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public E getFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        if (f == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public E getLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        if (l == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return l.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public E removeFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        if (f == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public E removeLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        if (l == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public void addFirst(E e) &#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public void addLast(E e) &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o) != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除指定元素  </span><br><span class="line">    public boolean remove(Object o) &#123;// 遍历删除</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">                if (x.item == null) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">                if (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        return addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从index处开始添加集合  </span><br><span class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        if (numNew == 0)</span><br><span class="line">            return false;// c为空返回false</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; pred, succ; // 声明两个变量，pred是记录index之前的一个节点，succ是记录index位置的节点。</span><br><span class="line">        if (index == size) &#123;</span><br><span class="line">            succ = null;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历集合，将集合中的元素一个一个的添加到pred节点后面</span><br><span class="line">        for (Object o : a) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">            if (pred == null)</span><br><span class="line">                first = newNode;</span><br><span class="line">            else</span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        // 加上succ节点，如果succ节点为空，则刷新last节点，否则直接添加succ即可</span><br><span class="line">        if (succ == null) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        // Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span><br><span class="line">        // - helps a generational GC if the discarded nodes inhabit</span><br><span class="line">        //   more than one generation</span><br><span class="line">        // - is sure to free memory even if there is a reachable Iterator</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = null;</span><br><span class="line">            x.next = null;</span><br><span class="line">            x.prev = null;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = null;</span><br><span class="line">        size = 0;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        E oldVal = x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        return oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        if (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        else</span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    private boolean isElementIndex(int index) &#123;</span><br><span class="line">        return index &gt;= 0 &amp;&amp; index &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    private boolean isPositionIndex(int index) &#123;</span><br><span class="line">        return index &gt;= 0 &amp;&amp; index &lt;= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    private String outOfBoundsMsg(int index) &#123;</span><br><span class="line">        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkElementIndex(int index) &#123;</span><br><span class="line">        if (!isElementIndex(index))</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkPositionIndex(int index) &#123;</span><br><span class="line">        if (!isPositionIndex(index))</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回链表index位置的Node节点， </span><br><span class="line">    Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        // assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">        if (index &lt; (size &gt;&gt; 1)) &#123; // 二分遍历</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            for (int i = 0; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            return x;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        int index = 0;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">                if (x.item == null)</span><br><span class="line">                    return index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">                if (o.equals(x.item))</span><br><span class="line">                    return index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public int lastIndexOf(Object o) &#123;</span><br><span class="line">        int index = size;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                if (x.item == null)</span><br><span class="line">                    return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                if (o.equals(x.item))</span><br><span class="line">                    return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //提供普通队列和双向队列的功能，当然，也可以实现栈，FIFO，FILO</span><br><span class="line">    //出队（从前端），获得第一个元素，不存在会返回null，不会删除元素（节点）</span><br><span class="line">    public E peek() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        return (f == null) ? null : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出队（从前端），不删除元素，若为null会抛出异常而不是返回null   </span><br><span class="line">    public E element() &#123;</span><br><span class="line">        return getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出队（从前端），如果不存在会返回null，存在的话会返回值并移除这个元素（节点）  </span><br><span class="line">    public E poll() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        return (f == null) ? null : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出队（从前端），如果不存在会抛出异常而不是返回null，存在的话会返回值并移除这个元素（节点）  </span><br><span class="line">    public E remove() &#123;</span><br><span class="line">        return removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入队（从后端），始终返回true  </span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        return add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Deque operations</span><br><span class="line">    //入队（从前端），始终返回true  </span><br><span class="line">    public boolean offerFirst(E e) &#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入队（从后端），始终返回true  </span><br><span class="line">    public boolean offerLast(E e) &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出队（从前端），获得第一个元素，不存在会返回null，不会删除元素（节点）  </span><br><span class="line">    public E peekFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        return (f == null) ? null : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出队（从后端），获得最后一个元素，不存在会返回null，不会删除元素（节点）  </span><br><span class="line">    public E peekLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        return (l == null) ? null : l.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出队（从前端），获得第一个元素，不存在会返回null，会删除元素（节点）  </span><br><span class="line">    public E pollFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        return (f == null) ? null : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出队（从后端），获得最后一个元素，不存在会返回null，会删除元素（节点）</span><br><span class="line">    public E pollLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        return (l == null) ? null : unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈，从前面添加  </span><br><span class="line">    public void push(E e) &#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈，返回栈顶元素，从前面移除（会删除）  </span><br><span class="line">    public E pop() &#123;</span><br><span class="line">        return removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法删除指定元素第一次出现在该列表中(遍历从头部到尾部列表时)。如果列表中不包含该元素，它是不变的。  </span><br><span class="line">    public boolean removeFirstOccurrence(Object o) &#123;</span><br><span class="line">        return remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法删除指定元素第一次出现在该列表中(遍历从尾部到头部列表时)。如果列表中不包含该元素，它是不变的。  </span><br><span class="line">    public boolean removeLastOccurrence(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">                if (x.item == null) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">                if (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回迭代器  </span><br><span class="line">    public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        return new ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 迭代器的类 关于ListIterator 和 Iterator的区别可以访问 http://zhongyp.me/2018/01/12/listirerator/</span><br><span class="line">    private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">        private Node&lt;E&gt; lastReturned = null;</span><br><span class="line">        private Node&lt;E&gt; next;</span><br><span class="line">        private int nextIndex;</span><br><span class="line">        private int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        ListItr(int index) &#123;</span><br><span class="line">            // assert isPositionIndex(index);</span><br><span class="line">            next = (index == size) ? null : node(index);</span><br><span class="line">            nextIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return nextIndex &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E next() &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            if (!hasNext())</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">            return lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasPrevious() &#123;</span><br><span class="line">            return nextIndex &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E previous() &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            if (!hasPrevious())</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            lastReturned = next = (next == null) ? last : next.prev;</span><br><span class="line">            nextIndex--;</span><br><span class="line">            return lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int nextIndex() &#123;</span><br><span class="line">            return nextIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int previousIndex() &#123;</span><br><span class="line">            return nextIndex - 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            if (lastReturned == null)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">            Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">            unlink(lastReturned);</span><br><span class="line">            if (next == lastReturned)</span><br><span class="line">                next = lastNext;</span><br><span class="line">            else</span><br><span class="line">                nextIndex--;</span><br><span class="line">            lastReturned = null;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void set(E e) &#123;</span><br><span class="line">            if (lastReturned == null)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned.item = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void add(E e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned = null;</span><br><span class="line">            if (next == null)</span><br><span class="line">                linkLast(e);</span><br><span class="line">            else</span><br><span class="line">                linkBefore(e, next);</span><br><span class="line">            nextIndex++;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final void checkForComodification() &#123;</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item = element;</span><br><span class="line">            this.next = next;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法返回一个迭代器在此双端队列以逆向顺序的元素  </span><br><span class="line">    public Iterator&lt;E&gt; descendingIterator() &#123;</span><br><span class="line">        return new DescendingIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    private class DescendingIterator implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        private final ListItr itr = new ListItr(size());</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return itr.hasPrevious();</span><br><span class="line">        &#125;</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            return itr.previous();</span><br><span class="line">        &#125;</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            itr.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // LinkedList的 Clone方法只是简单的将原来每个 node的 item放到克隆后的对象中，和 ArrayList的 clone方法一样， LinkedList的 Clone方法也只是浅复制，如果元素为引用类型，那么修改原 list的值会影响克隆的 list的值。</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private LinkedList&lt;E&gt; superClone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (LinkedList&lt;E&gt;) super.clone();// 调用底层c++ 获取克隆对象</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"></span><br><span class="line">        // Put clone into &quot;virgin&quot; state</span><br><span class="line">        clone.first = clone.last = null;</span><br><span class="line">        clone.size = 0;</span><br><span class="line">        clone.modCount = 0;</span><br><span class="line"></span><br><span class="line">        // Initialize clone with our elements</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">            clone.add(x.item);</span><br><span class="line"></span><br><span class="line">        return clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        Object[] result = new Object[size];</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        if (a.length &lt; size)</span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                    a.getClass().getComponentType(), size);</span><br><span class="line">        int i = 0;</span><br><span class="line">        Object[] result = a;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line"></span><br><span class="line">        if (a.length &gt; size)</span><br><span class="line">            a[size] = null;</span><br><span class="line"></span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列化</span><br><span class="line">     */</span><br><span class="line">    private static final long serialVersionUID = 876323262645176354L;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">            throws java.io.IOException &#123;</span><br><span class="line">        // Write out any hidden serialization magic</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        // Write out size</span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        // Write out all elements in the proper order.</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">            s.writeObject(x.item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">            throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        // Read in any hidden serialization magic</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        // Read in size</span><br><span class="line">        int size = s.readInt();</span><br><span class="line"></span><br><span class="line">        // Read in all elements in the proper order.</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            linkLast((E)s.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vector源码解析</title>
      <link href="/2018/01/12/java/2018-01-12-Vector/"/>
      <url>/2018/01/12/java/2018-01-12-Vector/</url>
      <content type="html"><![CDATA[<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><pre><code>Vector源码解析的不太细致，因为大多数和ArrayList类似，只不过加了Syncchronized同步</code></pre><p>Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。</p><p>Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。</p><p>Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</p><p>Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。</p><p>ArrayList和Vector不同，Vector中的操作是线程安全的；但是，Vector不支持序列化，即没有实现java.io.Serializable接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br></pre></td><td class="code"><pre><span class="line">public class Vector&lt;E&gt;</span><br><span class="line">        extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    // 数据存储数组  </span><br><span class="line">    protected Object[] elementData;</span><br><span class="line"></span><br><span class="line">    // 元素数量  </span><br><span class="line">    protected int elementCount;</span><br><span class="line"></span><br><span class="line">    // 容量增长系数  </span><br><span class="line">    protected int capacityIncrement;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    private static final long serialVersionUID = -2767605614048989439L;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">        super();</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">        this.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public Vector(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public Vector() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public Vector(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        elementCount = elementData.length;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 复制数组  </span><br><span class="line">    public synchronized void copyInto(Object[] anArray) &#123;</span><br><span class="line">        System.arraycopy(elementData, 0, anArray, 0, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 缩小数组至元素数量大小  </span><br><span class="line">    public synchronized void trimToSize() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        if (elementCount &lt; oldCapacity) &#123;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 确定数组最小容量&gt;minCapacity  </span><br><span class="line">    public synchronized void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &gt; 0) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            ensureCapacityHelper(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 确定数组最小容量&gt;minCapacity    </span><br><span class="line">    private void ensureCapacityHelper(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line">    // 数组容量的增长方式</span><br><span class="line">    private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                capacityIncrement : oldCapacity);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断minCapacity是否大于Max_ARRAY_SIZE，大于=Integer.MAX_VALUE。</span><br><span class="line">    private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">                Integer.MAX_VALUE :</span><br><span class="line">                MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 指定数组容量  </span><br><span class="line">    public synchronized void setSize(int newSize) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        if (newSize &gt; elementCount) &#123;</span><br><span class="line">            ensureCapacityHelper(newSize);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">                elementData[i] = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized int capacity() &#123;</span><br><span class="line">        return elementData.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized int size() &#123;</span><br><span class="line">        return elementCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized boolean isEmpty() &#123;</span><br><span class="line">        return elementCount == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回“Vector中全部元素对应的Enumeration”  </span><br><span class="line">    public Enumeration&lt;E&gt; elements() &#123;</span><br><span class="line">        return new Enumeration&lt;E&gt;() &#123;</span><br><span class="line">            int count = 0;</span><br><span class="line"></span><br><span class="line">            public boolean hasMoreElements() &#123;</span><br><span class="line">                return count &lt; elementCount;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public E nextElement() &#123;</span><br><span class="line">                synchronized (Vector.this) &#123;</span><br><span class="line">                    if (count &lt; elementCount) &#123;</span><br><span class="line">                        return elementData(count++);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                throw new NoSuchElementException(&quot;Vector Enumeration&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o, 0) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        return indexOf(o, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized int indexOf(Object o, int index) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = index ; i &lt; elementCount ; i++)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = index ; i &lt; elementCount ; i++)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized int lastIndexOf(Object o) &#123;</span><br><span class="line">        return lastIndexOf(o, elementCount-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized int lastIndexOf(Object o, int index) &#123;</span><br><span class="line">        if (index &gt;= elementCount)</span><br><span class="line">            throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot;+ elementCount);</span><br><span class="line"></span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = index; i &gt;= 0; i--)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = index; i &gt;= 0; i--)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized E elementAt(int index) &#123;</span><br><span class="line">        if (index &gt;= elementCount) &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized E firstElement() &#123;</span><br><span class="line">        if (elementCount == 0) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        return elementData(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized E lastElement() &#123;</span><br><span class="line">        if (elementCount == 0) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        return elementData(elementCount - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized void setElementAt(E obj, int index) &#123;</span><br><span class="line">        if (index &gt;= elementCount) &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +</span><br><span class="line">                    elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[index] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized void removeElementAt(int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        if (index &gt;= elementCount) &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +</span><br><span class="line">                    elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (index &lt; 0) &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        &#125;</span><br><span class="line">        int j = elementCount - index - 1;</span><br><span class="line">        if (j &gt; 0) &#123;</span><br><span class="line">            System.arraycopy(elementData, index + 1, elementData, index, j);</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount--;</span><br><span class="line">        elementData[elementCount] = null;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized void insertElementAt(E obj, int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        if (index &gt; elementCount) &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index</span><br><span class="line">                    + &quot; &gt; &quot; + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureCapacityHelper(elementCount + 1);</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);</span><br><span class="line">        elementData[index] = obj;</span><br><span class="line">        elementCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized void addElement(E obj) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + 1);</span><br><span class="line">        elementData[elementCount++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized boolean removeElement(Object obj) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int i = indexOf(obj);</span><br><span class="line">        if (i &gt;= 0) &#123;</span><br><span class="line">            removeElementAt(i);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized void removeAllElements() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        // Let gc do its work</span><br><span class="line">        for (int i = 0; i &lt; elementCount; i++)</span><br><span class="line">            elementData[i] = null;</span><br><span class="line"></span><br><span class="line">        elementCount = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized Object clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone();</span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">            v.modCount = 0;</span><br><span class="line">            return v;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized Object[] toArray() &#123;</span><br><span class="line">        return Arrays.copyOf(elementData, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public synchronized &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        if (a.length &lt; elementCount)</span><br><span class="line">            return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());</span><br><span class="line"></span><br><span class="line">        System.arraycopy(elementData, 0, a, 0, elementCount);</span><br><span class="line"></span><br><span class="line">        if (a.length &gt; elementCount)</span><br><span class="line">            a[elementCount] = null;</span><br><span class="line"></span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Positional Access Operations</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized E get(int index) &#123;</span><br><span class="line">        if (index &gt;= elementCount)</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">        return elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized E set(int index, E element) &#123;</span><br><span class="line">        if (index &gt;= elementCount)</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized boolean add(E e) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + 1);</span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        return removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        insertElementAt(element, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized E remove(int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        if (index &gt;= elementCount)</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        int numMoved = elementCount - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--elementCount] = null; // Let gc do its work</span><br><span class="line"></span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Bulk Operations</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized boolean containsAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return super.containsAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">        System.arraycopy(a, 0, elementData, elementCount, numNew);</span><br><span class="line">        elementCount += numNew;</span><br><span class="line">        return numNew != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return super.removeAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return super.retainAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        if (index &lt; 0 || index &gt; elementCount)</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        ensureCapacityHelper(elementCount + numNew);</span><br><span class="line"></span><br><span class="line">        int numMoved = elementCount - index;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                    numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">        elementCount += numNew;</span><br><span class="line">        return numNew != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized boolean equals(Object o) &#123;</span><br><span class="line">        return super.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized int hashCode() &#123;</span><br><span class="line">        return super.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized String toString() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">        return Collections.synchronizedList(super.subList(fromIndex, toIndex),</span><br><span class="line">                this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    protected synchronized void removeRange(int fromIndex, int toIndex) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved = elementCount - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                numMoved);</span><br><span class="line"></span><br><span class="line">        // Let gc do its work</span><br><span class="line">        int newElementCount = elementCount - (toIndex-fromIndex);</span><br><span class="line">        while (elementCount != newElementCount)</span><br><span class="line">            elementData[--elementCount] = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">            throws java.io.IOException &#123;</span><br><span class="line">        final java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br><span class="line">        final Object[] data;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            fields.put(&quot;capacityIncrement&quot;, capacityIncrement);</span><br><span class="line">            fields.put(&quot;elementCount&quot;, elementCount);</span><br><span class="line">            data = elementData.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        fields.put(&quot;elementData&quot;, data);</span><br><span class="line">        s.writeFields();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; elementCount)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);</span><br><span class="line">        return new ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized ListIterator&lt;E&gt; listIterator() &#123;</span><br><span class="line">        return new ListItr(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    public synchronized Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        int cursor;       // index of next element to return</span><br><span class="line">        int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">        int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            // Racy but within spec, since modifications are checked</span><br><span class="line">            // within or after synchronization in next/previous</span><br><span class="line">            return cursor != elementCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E next() &#123;</span><br><span class="line">            synchronized (Vector.this) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                int i = cursor;</span><br><span class="line">                if (i &gt;= elementCount)</span><br><span class="line">                    throw new NoSuchElementException();</span><br><span class="line">                cursor = i + 1;</span><br><span class="line">                return elementData(lastRet = i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet == -1)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            synchronized (Vector.this) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                Vector.this.remove(lastRet);</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final void checkForComodification() &#123;</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    final class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">        ListItr(int index) &#123;</span><br><span class="line">            super();</span><br><span class="line">            cursor = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasPrevious() &#123;</span><br><span class="line">            return cursor != 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int nextIndex() &#123;</span><br><span class="line">            return cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int previousIndex() &#123;</span><br><span class="line">            return cursor - 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E previous() &#123;</span><br><span class="line">            synchronized (Vector.this) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                int i = cursor - 1;</span><br><span class="line">                if (i &lt; 0)</span><br><span class="line">                    throw new NoSuchElementException();</span><br><span class="line">                cursor = i;</span><br><span class="line">                return elementData(lastRet = i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void set(E e) &#123;</span><br><span class="line">            if (lastRet == -1)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            synchronized (Vector.this) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                Vector.this.set(lastRet, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void add(E e) &#123;</span><br><span class="line">            int i = cursor;</span><br><span class="line">            synchronized (Vector.this) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                Vector.this.add(i, e);</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = i + 1;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ArrayList源码解析</title>
      <link href="/2018/01/10/java/2018-01-11-ArrayList/"/>
      <url>/2018/01/10/java/2018-01-11-ArrayList/</url>
      <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList源码中多次用到Arrays.copyOf()和System.arraycopy(),本文不对这两个方法进行解读，详细了解可以访问<a href="http://blog.csdn.net/shijinupc/article/details/7827507" target="_blank" rel="noopener">Arrays.copyof(···)与System.arraycopy(···)区别</a></p><p>ArrayList继承AbstractList类，实现List，RandomAccess，Cloneable，Serializable接口。AbstractList提供 List 接口的骨干实现，从而最大限度地减少了实现由“随机访问”数据存储（如数组）支持的接口所需的工作。对于连续的访问数据（如链表），应优先使用AbstractSequentialList，而非此类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 概述：</span><br><span class="line"> *  List接口可调整大小的数组实现。实现所有可选的List操作，并允许所有元素，包括null，元素可重复。</span><br><span class="line"> *  除了列表接口外，该类提供了一种方法来操作该数组的大小来存储该列表中的数组的大小。</span><br><span class="line"> * </span><br><span class="line"> * 时间复杂度：</span><br><span class="line"> *  方法size、isEmpty、get、set、iterator和listIterator的调用是常数时间的。</span><br><span class="line"> *  添加删除的时间复杂度为O(N)。其他所有操作也都是线性时间复杂度。</span><br><span class="line"> *</span><br><span class="line"> * 容量：</span><br><span class="line"> *  每个ArrayList都有容量，容量大小至少为List元素的长度，默认初始化为10。</span><br><span class="line"> *  容量可以自动增长。</span><br><span class="line"> *  如果提前知道数组元素较多，可以在添加元素前通过调用ensureCapacity()方法提前增加容量以减小后期容量自动增长的开销。</span><br><span class="line"> *  也可以通过带初始容量的构造器初始化这个容量。</span><br><span class="line"> *</span><br><span class="line"> * 线程不安全：</span><br><span class="line"> *  ArrayList不是线程安全的。</span><br><span class="line"> *  如果需要应用到多线程中，需要在外部做同步</span><br><span class="line"> *</span><br><span class="line"> * modCount：</span><br><span class="line"> *  定义在AbstractList中：protected transient int modCount = 0;</span><br><span class="line"> *  已从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表，从而使正在进行的迭代产生错误的结果。</span><br><span class="line"> *  此字段由iterator和listiterator方法返回的迭代器和列表迭代器实现使用。</span><br><span class="line"> *  如果意外更改了此字段中的值，则迭代器（或列表迭代器）将抛出concurrentmodificationexception来响应next、remove、previous、set或add操作。</span><br><span class="line"> *  在迭代期间面临并发修改时，它提供了快速失败 行为，而不是非确定性行为。</span><br><span class="line"> *  fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</span><br><span class="line"> *  子类是否使用此字段是可选的。</span><br><span class="line"> *  如果子类希望提供快速失败迭代器（和列表迭代器），则它只需在其 add(int,e)和remove(int)方法（以及它所重写的、导致列表结构上修改的任何其他方法）中增加此字段。</span><br><span class="line"> *  对add(int, e)或remove(int)的单个调用向此字段添加的数量不得超过 1，否则迭代器（和列表迭代器）将抛出虚假的 concurrentmodificationexceptions。</span><br><span class="line"> *  如果某个实现不希望提供快速失败迭代器，则可以忽略此字段。</span><br><span class="line"> *</span><br><span class="line"> * transient：</span><br><span class="line"> *  默认情况下,对象的所有成员变量都将被持久化.在某些情况下,如果你想避免持久化对象的一些成员变量,你可以使用transient关键字来标记他们,transient也是java中的保留字(JDK 1.8)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">//</span><br><span class="line">    private static final long serialVersionUID = 8683452581122892189L;</span><br><span class="line"></span><br><span class="line">    // 默认初始化长度</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">    // 当使用new ArrayList()创建对象时，返回EMPTY_ELEMENTDATA这个数组对象。</span><br><span class="line">    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 不可序列化的数组声明</span><br><span class="line">    private transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        super();</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public ArrayList() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">     public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        size = elementData.length;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);//此处使用Arrays工具类的copyOf复制数组</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //调整ArrayList实例为当前容量大小。</span><br><span class="line">    public void trimToSize() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        if (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用指定参数设置数组容量</span><br><span class="line">    public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">        int minExpand = (elementData != EMPTY_ELEMENTDATA)</span><br><span class="line">            // any size if real element table</span><br><span class="line">            ? 0</span><br><span class="line">            // larger than default for empty table. It&apos;s already supposed to be</span><br><span class="line">            // at default size.</span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        if (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//用于添加元素时，确保数组容量</span><br><span class="line">    private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        if (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">//如果参数大于数组容量，就增加数组容量</span><br><span class="line">    private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数组的最大容量，可能会导致内存溢出(VM内存限制)</span><br><span class="line">    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line"></span><br><span class="line">    //增加容量，以确保它可以至少持有由参数指定的元素的数目</span><br><span class="line">    private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 新的空间大小为老空间+ 老空间大小二进制左移一位，举例比如老空间为15,15&gt;&gt;1，结果为7，大致是1/2</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//检查是否溢出，若没有溢出，返回最大整数值(java中的int为4字节，所以最大为0x7fffffff)或默认最大值</span><br><span class="line">    private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public int lastIndexOf(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();</span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = 0;</span><br><span class="line">            return v;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回Object[]</span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回一个数组，使用运行时确定类型，该数组包含在这个列表中的所有元素（从第一到最后一个元素）</span><br><span class="line">    //返回的数组容量由参数和本数组中较大值确定</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        if (a.length &lt; size)</span><br><span class="line">            // Make a new array of a&apos;s runtime type, but my contents:</span><br><span class="line">            return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">        if (a.length &gt; size)</span><br><span class="line">            a[size] = null;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Positional Access Operations</span><br><span class="line"></span><br><span class="line">// 返回指定位置的值，因为是数组，所以速度特别快</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回指定位置的值，因为是数组，所以速度特别快</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        return elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置制定未知的值</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 新添加值</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 新增加指定未知的值</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除指定位置的值</span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        rangeCheck(index);// 检查index范围</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);// 查找index位置上的值</span><br><span class="line"></span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        // 如果index不是最后位置的索引，则从原列表index+1位置复制numMoved个数值到新列表从index开始</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除list中第一个值为o的对象</span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (elementData[index] == null) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不需要判断index是否存在且不用返回旧值</span><br><span class="line">    private void fastRemove(int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空数组，赋值为null，方便垃圾回收，size归0</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        // clear to let GC do its work</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            elementData[i] = null;</span><br><span class="line"></span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加集合到末端，当集合为空时返回false</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line">        System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        return numNew != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //  从指定未知开始添加集合</span><br><span class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line"></span><br><span class="line">        int numMoved = size - index;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        return numNew != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除指定范围的元素</span><br><span class="line">    protected void removeRange(int fromIndex, int toIndex) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        // clear to let GC do its work</span><br><span class="line">        int newSize = size - (toIndex-fromIndex);</span><br><span class="line">        for (int i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = null;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查index是否超出size</span><br><span class="line">    private void rangeCheck(int index) &#123;</span><br><span class="line">        if (index &gt;= size)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查是否溢出列表范围</span><br><span class="line">    private void rangeCheckForAdd(int index) &#123;</span><br><span class="line">        if (index &gt; size || index &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 抛出异常详情</span><br><span class="line">    private String outOfBoundsMsg(int index) &#123;</span><br><span class="line">        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除c集合中包含的元素</span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return batchRemove(c, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 仅保留c集合内存在的元素</span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return batchRemove(c, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据complement标识决定是否批量仅 保留/删除 集合c中包含的元素</span><br><span class="line">    private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</span><br><span class="line">        final Object[] elementData = this.elementData;</span><br><span class="line">        int r = 0, w = 0;</span><br><span class="line">        boolean modified = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (; r &lt; size; r++)</span><br><span class="line">                if (c.contains(elementData[r]) == complement)// 如果complement=false,仅保留非c集合中的元素，为true时，仅保留c集合中的元素。</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // Preserve behavioral compatibility with AbstractCollection,</span><br><span class="line">            // even if c.contains() throws.</span><br><span class="line">            if (r != size) &#123;// 如果r没有遍历到size-1，则把从r到size-1的值复制到新数组，这个地方不知道什么时候会运行，有待探究</span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            if (w != size) &#123;// c集合小于当前集合时，都会运行</span><br><span class="line">                // clear to let GC do its work</span><br><span class="line">                for (int i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = null;// 将w到size-1列表上的值置空，方便垃圾回收</span><br><span class="line">                modCount += size - w;//记录改动的次数</span><br><span class="line">                size = w;</span><br><span class="line">                modified = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 序列化写</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException&#123;</span><br><span class="line">        // Write out element count, and any hidden stuff</span><br><span class="line">        int expectedModCount = modCount;// 用于判断在写入流期间是否被更改的标识</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        // Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        // Write out all elements in the proper order.</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (modCount != expectedModCount) &#123;// 将列表写入IO流后，判断在此期间列表是否别更改，如果被更改则报错。</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从流中读取值放到新建的数组对象中</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;// 先声明一个空数组</span><br><span class="line"></span><br><span class="line">        // Read in size, and any hidden stuff</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        // Read in capacity</span><br><span class="line">        s.readInt(); // ignored</span><br><span class="line"></span><br><span class="line">        if (size &gt; 0) &#123;</span><br><span class="line">            // be like clone(), allocate array based upon size not capacity</span><br><span class="line">            ensureCapacityInternal(size);// 读空数组扩容</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            // Read in all elements in the proper order.</span><br><span class="line">            for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回ListIterator index</span><br><span class="line">    public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);</span><br><span class="line">        return new ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回ListIterator 0</span><br><span class="line">    public ListIterator&lt;E&gt; listIterator() &#123;</span><br><span class="line">        return new ListItr(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   // Itr类，用于Iterator遍历</span><br><span class="line">    private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        int cursor;       // index of next element to return</span><br><span class="line">        int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">        int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            int i = cursor;</span><br><span class="line">            if (i &gt;= size)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">            if (i &gt;= elementData.length)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            cursor = i + 1;</span><br><span class="line">            return (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ArrayList.this.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -1;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final void checkForComodification() &#123;</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ListItrerator 不同于Itr,可向前向后遍历，在遍历期间可以修改，</span><br><span class="line">    private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">        ListItr(int index) &#123;</span><br><span class="line">            super();</span><br><span class="line">            cursor = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasPrevious() &#123;</span><br><span class="line">            return cursor != 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int nextIndex() &#123;</span><br><span class="line">            return cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int previousIndex() &#123;</span><br><span class="line">            return cursor - 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E previous() &#123;</span><br><span class="line">            checkForComodification(); //检查是否被修改</span><br><span class="line">            int i = cursor - 1;</span><br><span class="line">            if (i &lt; 0)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.this.elementData;// 此处这样复制引用而不是直接调用，原因是：内部类是通过保留指向外部类的指针访问外部类字段的，显式写出来就是ltr.ArrayList.this.elementData，复制引用就是为了减少多次指针引用</span><br><span class="line">            if (i &gt;= elementData.length)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            cursor = i;</span><br><span class="line">            return (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void set(E e) &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ArrayList.this.set(lastRet, e);</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void add(E e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                int i = cursor;</span><br><span class="line">                ArrayList.this.add(i, e);</span><br><span class="line">                cursor = i + 1;</span><br><span class="line">                lastRet = -1;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回指定范围的子数组</span><br><span class="line">    // JDK中，List接口有一个实例方法List&lt;E&gt; subList(int fromIndex, int toIndex)，</span><br><span class="line">    // 其作用是返回一个以fromIndex为起始索引（包含），以toIndex为终止索引（不包含）的子列表（List）。 </span><br><span class="line">    // 但值得注意的是，返回的这个子列表的幕后其实还是原列表；</span><br><span class="line">    // 也就是说，修改这个子列表，将导致原列表也发生改变；反之亦然。</span><br><span class="line">    public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        return new SubList(this, 0, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123;</span><br><span class="line">        if (fromIndex &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);</span><br><span class="line">        if (toIndex &gt; size)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);</span><br><span class="line">        if (fromIndex &gt; toIndex)</span><br><span class="line">            throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +</span><br><span class="line">                                               &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123;</span><br><span class="line">        private final AbstractList&lt;E&gt; parent;</span><br><span class="line">        private final int parentOffset;</span><br><span class="line">        private final int offset;</span><br><span class="line">        int size;</span><br><span class="line"></span><br><span class="line">        SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">                int offset, int fromIndex, int toIndex) &#123;</span><br><span class="line">            this.parent = parent;</span><br><span class="line">            this.parentOffset = fromIndex;</span><br><span class="line">            this.offset = offset + fromIndex;</span><br><span class="line">            this.size = toIndex - fromIndex;</span><br><span class="line">            this.modCount = ArrayList.this.modCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E set(int index, E e) &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            E oldValue = ArrayList.this.elementData(offset + index);</span><br><span class="line">            ArrayList.this.elementData[offset + index] = e;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E get(int index) &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            return ArrayList.this.elementData(offset + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int size() &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            return this.size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void add(int index, E e) &#123;</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            parent.add(parentOffset + index, e);</span><br><span class="line">            this.modCount = parent.modCount;</span><br><span class="line">            this.size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E remove(int index) &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            E result = parent.remove(parentOffset + index);</span><br><span class="line">            this.modCount = parent.modCount;</span><br><span class="line">            this.size--;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected void removeRange(int fromIndex, int toIndex) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            parent.removeRange(parentOffset + fromIndex,</span><br><span class="line">                               parentOffset + toIndex);</span><br><span class="line">            this.modCount = parent.modCount;</span><br><span class="line">            this.size -= toIndex - fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">            return addAll(this.size, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            int cSize = c.size();</span><br><span class="line">            if (cSize==0)</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            checkForComodification();</span><br><span class="line">            parent.addAll(parentOffset + index, c);</span><br><span class="line">            this.modCount = parent.modCount;</span><br><span class="line">            this.size += cSize;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">            return listIterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ListIterator&lt;E&gt; listIterator(final int index) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            final int offset = this.offset;</span><br><span class="line"></span><br><span class="line">            return new ListIterator&lt;E&gt;() &#123;</span><br><span class="line">                int cursor = index;</span><br><span class="line">                int lastRet = -1;</span><br><span class="line">                int expectedModCount = ArrayList.this.modCount;</span><br><span class="line"></span><br><span class="line">                public boolean hasNext() &#123;</span><br><span class="line">                    return cursor != SubList.this.size;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                public E next() &#123;</span><br><span class="line">                    checkForComodification();</span><br><span class="line">                    int i = cursor;</span><br><span class="line">                    if (i &gt;= SubList.this.size)</span><br><span class="line">                        throw new NoSuchElementException();</span><br><span class="line">                    Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">                    if (offset + i &gt;= elementData.length)</span><br><span class="line">                        throw new ConcurrentModificationException();</span><br><span class="line">                    cursor = i + 1;</span><br><span class="line">                    return (E) elementData[offset + (lastRet = i)];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public boolean hasPrevious() &#123;</span><br><span class="line">                    return cursor != 0;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                public E previous() &#123;</span><br><span class="line">                    checkForComodification();</span><br><span class="line">                    int i = cursor - 1;</span><br><span class="line">                    if (i &lt; 0)</span><br><span class="line">                        throw new NoSuchElementException();</span><br><span class="line">                    Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">                    if (offset + i &gt;= elementData.length)</span><br><span class="line">                        throw new ConcurrentModificationException();</span><br><span class="line">                    cursor = i;</span><br><span class="line">                    return (E) elementData[offset + (lastRet = i)];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public int nextIndex() &#123;</span><br><span class="line">                    return cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public int previousIndex() &#123;</span><br><span class="line">                    return cursor - 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public void remove() &#123;</span><br><span class="line">                    if (lastRet &lt; 0)</span><br><span class="line">                        throw new IllegalStateException();</span><br><span class="line">                    checkForComodification();</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        SubList.this.remove(lastRet);</span><br><span class="line">                        cursor = lastRet;</span><br><span class="line">                        lastRet = -1;</span><br><span class="line">                        expectedModCount = ArrayList.this.modCount;</span><br><span class="line">                    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                        throw new ConcurrentModificationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public void set(E e) &#123;</span><br><span class="line">                    if (lastRet &lt; 0)</span><br><span class="line">                        throw new IllegalStateException();</span><br><span class="line">                    checkForComodification();</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        ArrayList.this.set(offset + lastRet, e);</span><br><span class="line">                    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                        throw new ConcurrentModificationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public void add(E e) &#123;</span><br><span class="line">                    checkForComodification();</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        int i = cursor;</span><br><span class="line">                        SubList.this.add(i, e);</span><br><span class="line">                        cursor = i + 1;</span><br><span class="line">                        lastRet = -1;</span><br><span class="line">                        expectedModCount = ArrayList.this.modCount;</span><br><span class="line">                    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                        throw new ConcurrentModificationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final void checkForComodification() &#123;</span><br><span class="line">                    if (expectedModCount != ArrayList.this.modCount)</span><br><span class="line">                        throw new ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">            subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">            return new SubList(this, offset, fromIndex, toIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void rangeCheck(int index) &#123;</span><br><span class="line">            if (index &lt; 0 || index &gt;= this.size)</span><br><span class="line">                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void rangeCheckForAdd(int index) &#123;</span><br><span class="line">            if (index &lt; 0 || index &gt; this.size)</span><br><span class="line">                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private String outOfBoundsMsg(int index) &#123;</span><br><span class="line">            return &quot;Index: &quot;+index+&quot;, Size: &quot;+this.size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void checkForComodification() &#123;</span><br><span class="line">            if (ArrayList.this.modCount != this.modCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Set常用集合类源码解读</title>
      <link href="/2018/01/10/java/2018-01-10-Set/"/>
      <url>/2018/01/10/java/2018-01-10-Set/</url>
      <content type="html"><![CDATA[<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet继承AbstractSet类，实现Set、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。Set接口是一种不包括重复元素的Collection，它维持它自己的内部排序，所以随机访问没有任何意义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">    // 序列化的ID</span><br><span class="line">    static final long serialVersionUID = -5024744406713321676L;</span><br><span class="line"></span><br><span class="line">    // 声明不可序列化的HashMap，不可序列化的原因是因为在存储值的时候，value存储的是Object对象，Object不可序列化。因此只能使用自己的序列化方法。</span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    // Dummy value to associate with an Object in the backing Map</span><br><span class="line">    // 定义map value的Object对象</span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public HashSet(int initialCapacity) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 访问为包权限，主要是用来支持LinkedHashSet的</span><br><span class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)==null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        return map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            return newSet;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //序列化的写</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException &#123;</span><br><span class="line">        // Write out any hidden serialization magic</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        // Write out HashMap capacity and load factor</span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        // Write out size</span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        // Write out all elements in the proper order.</span><br><span class="line">        for (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //序列化的读</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        // Read in any hidden serialization magic</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        // Read in HashMap capacity and load factor and create backing HashMap</span><br><span class="line">        int capacity = s.readInt();</span><br><span class="line">        float loadFactor = s.readFloat();</span><br><span class="line">        map = (((HashSet)this) instanceof LinkedHashSet ?</span><br><span class="line">               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               new HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        // Read in size</span><br><span class="line">        int size = s.readInt();</span><br><span class="line"></span><br><span class="line">        // Read in all elements in the proper order.</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            E e = (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## LinkedHashSet</span><br><span class="line"></span><br><span class="line">LinkedHashSet是具有可预知迭代顺序的Set接口的哈希表和链接列表实现。此实现与HashSet的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</span><br></pre></td></tr></table></figure><p>private static final long serialVersionUID = -2851667679971038690L;</p><pre><code>public LinkedHashSet(int initialCapacity, float loadFactor) {    super(initialCapacity, loadFactor, true);}public LinkedHashSet(int initialCapacity) {    super(initialCapacity, .75f, true);}public LinkedHashSet() {    super(16, .75f, true);}public LinkedHashSet(Collection&lt;? extends E&gt; c) {    super(Math.max(2*c.size(), 11), .75f, true);    addAll(c);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## TreeSet</span><br><span class="line"></span><br><span class="line">TreeMap是一个有序的二叉树，那么同理TreeSet同样也是一个有序的，它的作用是提供有序的Set集合。通过源码我们知道TreeSet基础AbstractSet，实现NavigableSet、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。NavigableSet是扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。Cloneable支持克隆，Serializable支持序列化。</span><br></pre></td></tr></table></figure><p>public class TreeSet<e> extends AbstractSet<e><br>    implements NavigableSet<e>, Cloneable, java.io.Serializable<br>{</e></e></e></p><pre><code>private transient NavigableMap&lt;E,Object&gt; m;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();TreeSet(NavigableMap&lt;E,Object&gt; m) {    this.m = m;}public TreeSet() {    this(new TreeMap&lt;E,Object&gt;());}public TreeSet(Comparator&lt;? super E&gt; comparator) {    this(new TreeMap&lt;&gt;(comparator));}public TreeSet(Collection&lt;? extends E&gt; c) {    this();    addAll(c);}public TreeSet(SortedSet&lt;E&gt; s) {    this(s.comparator());    addAll(s);}public Iterator&lt;E&gt; iterator() {    return m.navigableKeySet().iterator();}// 返回在此 set 元素上按降序进行迭代的迭代器。public Iterator&lt;E&gt; descendingIterator() {    return m.descendingKeySet().iterator();}// 返回此 set 中所包含元素的逆序视图。public NavigableSet&lt;E&gt; descendingSet() {    return new TreeSet&lt;&gt;(m.descendingMap());}public int size() {    return m.size();}public boolean isEmpty() {    return m.isEmpty();}public boolean contains(Object o) {    return m.containsKey(o);}public boolean add(E e) {    return m.put(e, PRESENT)==null;}public boolean remove(Object o) {    return m.remove(o)==PRESENT;}public void clear() {    m.clear();}public  boolean addAll(Collection&lt;? extends E&gt; c) {    // Use linear-time version if applicable    if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp;        c instanceof SortedSet &amp;&amp;        m instanceof TreeMap) {        SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;        TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;        Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator();        Comparator&lt;? super E&gt; mc = map.comparator();        if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) {            map.addAllForTreeSet(set, PRESENT);            return true;        }    }    return super.addAll(c);}// 返回此 set 的部分视图public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,                              E toElement,   boolean toInclusive) {    return new TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive,                                   toElement,   toInclusive));}//  返回此 set 的部分视图public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {    return new TreeSet&lt;&gt;(m.headMap(toElement, inclusive));}// 返回此 set 的部分视图public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {    return new TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));}// 返回此 set 的部分视图public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {    return subSet(fromElement, true, toElement, false);}// 返回此 set 的部分视图，其元素严格小于 toElement。public SortedSet&lt;E&gt; headSet(E toElement) {    return headSet(toElement, false);}// 返回此 set 的部分视图public SortedSet&lt;E&gt; tailSet(E fromElement) {    return tailSet(fromElement, true);}public Comparator&lt;? super E&gt; comparator() {    return m.comparator();}// 返回此 set 中当前第一个（最低）元素。public E first() {    return m.firstKey();}// 返回此 set 中当前最后（最高）一个元素public E last() {    return m.lastKey();}// NavigableSet API methods// 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。public E lower(E e) {    return m.lowerKey(e);}// 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。public E floor(E e) {    return m.floorKey(e);}// 返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。public E ceiling(E e) {    return m.ceilingKey(e);}// 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。public E higher(E e) {    return m.higherKey(e);}// 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。public E pollFirst() {    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();    return (e == null) ? null : e.getKey();}// 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。public E pollLast() {    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();    return (e == null) ? null : e.getKey();}public Object clone() {    TreeSet&lt;E&gt; clone = null;    try {        clone = (TreeSet&lt;E&gt;) super.clone();    } catch (CloneNotSupportedException e) {        throw new InternalError();    }    clone.m = new TreeMap&lt;&gt;(m);    return clone;}private void writeObject(java.io.ObjectOutputStream s)    throws java.io.IOException {    // Write out any hidden stuff    s.defaultWriteObject();    // Write out Comparator    s.writeObject(m.comparator());    // Write out size    s.writeInt(m.size());    // Write out all elements in the proper order.    for (E e : m.keySet())        s.writeObject(e);}private void readObject(java.io.ObjectInputStream s)    throws java.io.IOException, ClassNotFoundException {    // Read in any hidden stuff    s.defaultReadObject();    // Read in Comparator    Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject();    // Create backing TreeMap    TreeMap&lt;E,Object&gt; tm;    if (c==null)        tm = new TreeMap&lt;&gt;();    else        tm = new TreeMap&lt;&gt;(c);    m = tm;    // Read in size    int size = s.readInt();    tm.readTreeSet(size, s, PRESENT);}private static final long serialVersionUID = -2479143000061671589L;</code></pre><p>}</p><p><code>`</code></p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式原理及应用场景</title>
      <link href="/2018/01/10/java/2018-01-10-Pattern/"/>
      <url>/2018/01/10/java/2018-01-10-Pattern/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/zhongyp/Demo/tree/master/src/main/java/com/zhongyp/advanced/pattern" target="_blank" rel="noopener">本篇博客中涉及的所有设计模式源码都这在里，点击即可访问</a></p><h2 id="深入浅出设计模式遵循的设计模式原则："><a href="#深入浅出设计模式遵循的设计模式原则：" class="headerlink" title="深入浅出设计模式遵循的设计模式原则："></a>深入浅出设计模式遵循的设计模式原则：</h2><ul><li><p>封装变化： 找出应用中可能需要变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。</p></li><li><p>合成服用原则：多用组合，少用继承，组合使系统具有弹性，不仅可以将算法封装成类，还可以在运行是动态的改变行为。</p></li><li><p>依赖倒转原则：针对接口编程，不针对实现编程， 程序利用多态针对超类型（supertype）编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上。</p></li><li><p>接口隔离原则：为交互对象之间的松耦合设计而努力</p></li><li><p>里式代换原则：任何基类可以出现的地方，子类一定可以出现。</p></li><li><p>开闭原则OCP：类应该对扩展开放，对修改关闭</p></li><li><p>依赖抽象，不要依赖具体类。</p></li><li><p>最少知道原则：只和朋友交谈。 </p></li><li><p>类应该只有一个改变的理由。</p></li></ul><h2 id="策略模式-stragety"><a href="#策略模式-stragety" class="headerlink" title="策略模式(stragety)"></a>策略模式(stragety)</h2><p>定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。体现封装变化、多用组合少用继承、针对接口编程，不针对实现编程。</p><p>Strategy模式有下面的一些优点：</p><ul><li><p>相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为。 继承有助于析取出这些算法中的公共功能。</p></li><li><p>提供了可以替换继承关系的办法： 继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类，从而给它以不同的行为。但这会将行为硬行编制到 Context中，而将算法的实现与Context的实现混合起来,从而使Context难以理解、难以维护和难以扩展，而且还不能动态地改变算法。最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。 将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。</p></li><li><p>消除了一些if else条件语句 ：Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 ,很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句。含有许多条件语句的代码通常意味着需要使用Strategy模式。</p></li><li><p>实现的选择 Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间 /空间权衡取舍要求从不同策略中进行选择。</p></li></ul><p>Strategy模式缺点:</p><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类:  本模式有一个潜在的缺点，就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。</p></li><li><p>Strategy和Context之间的通信开销 ：无论各个ConcreteStrategy实现的算法是简单还是复杂, 它们都共享Strategy定义的接口。因此很可能某些 ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；简单的 ConcreteStrategy可能不使用其中的任何信息！这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。</p></li><li><p>策略模式将造成产生很多策略类：可以通过使用享元模式在一定程度上减少对象的数量。 增加了对象的数目 Strategy增加了一个应用中的对象的数目。有时你可以将 Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由 Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的 Strategy不应在各次调用之间维护状态。</p></li></ul><p>应用场景：比较器Comparator和布局管理器LayoutManager</p><ul><li><p>在该比较架构中，Comparator就是一个抽象的策略；一个类实现该结构，并实现里面的compare方法，该类成为具体策略类；Collections类就是环境角色，他将集合的比较封装成静态方法对外提供api。</p></li><li><p>在Java SE开发中，用户需要对容器对象Container中的成员对象如按钮、文本框等GUI控件进行布局(Layout)，在程序运行期间由客户端动态决定一个Container对象如何布局，Java语言在JDK中提供了几种不同的布局方式，封装在不同的类中，如BorderLayout、FlowLayout、GridLayout、GridBagLayout和CardLayout等。</p></li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖他的对象都会收到通知并自动更新。体现封装变化、针对接口编程、多用组合，少用继承、交互对象之间的松耦合设计</p><p>类图：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/observer.png?raw=true" alt="观察者模式"></p><p>JDK自带的观察者实现：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jdkobserver.png?raw=true" alt="观察者模式"></p><p>源码见博文最上方源码连接。</p><p>观察者模式的效果有以下的优点：</p><ul><li><p>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。</p></li><li><p>由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。</p></li><li><p>观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知，</p></li></ul><p>观察者模式有下面的缺点：</p><ul><li><p>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</p></li><li><p>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。</p></li><li><p>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。</p></li><li><p>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。</p></li></ul><p>应用场景：</p><p>spring的事件驱动模型使用的是观察者模式，通过ApplicationEvent抽象类和ApplicationListener接口,可以实现ApplicationContext事件处理，监听器在处理Event时,通常会进行判断传入的Event是不是自己所想要处理的,使用instanceof关键字，ApplicationEventMulticaster事件广播器实现了监听器的注册,一般不需要我们实现,只需要显示的调用applicationcontext.publisherEvent方法即可。</p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>动态的将责任附加到对象上，若要扩展功能，装饰者提供了比集成更具有弹性的替代方案。</p><p>优点：</p><ul><li>动态的给一个对象添加一些额外的职责，就扩展功能而言，比生成子类方式更为灵活。</li></ul><p>缺点：</p><ul><li>利用装饰器模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。</li></ul><p>应用场景</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/IO.png?raw=true" alt="IO"></p><p>FileInputStream、StringBufferInputStream、ByteArrayInputStream为被装饰的组件类。</p><p>PushbackInputStream、BufferInputStream、DataInputStream、LineNumberInputStream为具体装饰者类。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>三种形态：</p><ul><li>简单工厂模式：又称静态工厂方法 (对于增加新的产品，无能为力)</li></ul><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/simplefactory.png?raw=true" alt="类图"></p><ul><li>工厂方法模式：又称多态性工厂模式或虚拟构造子模式 (支持增加任意产品)</li></ul><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/functionfactory.png?raw=true" alt="类图"></p><ul><li>抽象工厂模式：又称工具箱模式 (对于增加新的产品，无能为力；支持增加产品族)</li></ul><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/abstractfactory.png?raw=true" alt="类图"></p><h2 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h2><p>确保一个类只有一个实例，并提供全局访问点。</p><p>单例模式的几种实现方式<br>单例模式的实现有多种方式，如下所示：</p><ul><li>懒汉式，线程不安全</li></ul><p>是否 Lazy 初始化：是</p><p>是否多线程安全：否</p><p>实现难度：易</p><p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p><p>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</p><ul><li>懒汉式，线程安全</li></ul><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p><p>优点：第一次调用才初始化，避免内存浪费。</p><p>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</p><p>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>饿汉式</li></ul><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式比较常用，但容易产生垃圾对象。</p><p>优点：没有加锁，执行效率会提高。</p><p>缺点：类加载时就初始化，浪费内存。</p><p>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双检锁/双重校验锁（DCL，即 double-checked locking）</li></ul><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：较复杂</p><p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><p>getInstance() 的性能对应用程序很关键。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getSingleton() &#123;  </span><br><span class="line">    if (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">        if (singleton == null) &#123;  </span><br><span class="line">            singleton = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>登记式/静态内部类</li></ul><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：一般</p><p>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p><p>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">    return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举</li></ul><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</p><p>不能通过 reflection attack 来调用私有构造方法。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumTest &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    private Test test;</span><br><span class="line"></span><br><span class="line">    private EnumTest()&#123;</span><br><span class="line">        test = new Test();</span><br><span class="line">    &#125;</span><br><span class="line">    public Test getInstance()&#123;</span><br><span class="line">        return test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://zhongyp.me/2018/02/04/ENUM/">详细了解</a></p><p>经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/command.png?raw=true" alt="类图"></p><p>优点</p><ul><li>类间解耦：调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command 抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。</li><li>可扩展性：Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严 重的代码耦合。</li><li>命令模式结合其他模式会更优秀：命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少 Command子类的膨胀问题。</li></ul><p>缺点</p><ul><li>命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来 了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项 目中慎重考虑使用。</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/facade.png?raw=true" alt="类图"></p><p>优点</p><ul><li><p>松散耦合</p></li><li><p>使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；</p></li><li><p>简单易用</p></li><li><p>客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟Facade类交互即可。</p></li><li><p>更好的划分访问层次</p></li><li><p>有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。</p></li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使用子类可以在不改变算法结构的情况下，重新定义算法中的步骤。</p><p>优点</p><ul><li><p>封装不变部分，扩展可变部分。把认为不变部分的算法封装到父类中实现，而可变部分的则可以通过继承来继续扩展。</p></li><li><p>提取公共部分代码，便于维护。</p></li><li><p>行为由父类控制，子类实现。</p></li></ul><p>缺点</p><ul><li>按照设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类负责完成具体的事务属性和方法，但是模板方式正好相反，子类执行的结果影响了父类的结果，会增加代码阅读的难度。</li></ul><p>模板方法模式是通过父类建立框架，子类在重写了父类部分方法之后，在调用从父类继承的方法，产生不同的效果，通过修改子类，影响父类行为的结果，模板方法在一些开源框架中应用非常多，它提供了一个抽象类，然后开源框架写了一堆子类，如果需要扩展功能，可以继承此抽象类，然后覆写protected基本方法，然后在调用一个类似TemplateMethod()的模板方法，完成扩展开发。</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><p>应用实例：JAVA 中的 iterator。</p><p>优点：</p><ul><li><p>它支持以不同的方式遍历一个聚合对象。</p></li><li><p>迭代器简化了聚合类。 </p></li><li><p>在同一个聚合上可以有多个遍历。 </p></li><li><p>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p></li></ul><p>缺点：</p><ul><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li></ul><p>使用场景： </p><ul><li><p>访问一个聚合对象的内容而无须暴露它的内部表示。 </p></li><li><p>需要为聚合对象提供多种遍历方式。 </p></li><li><p>为遍历不同的聚合结构提供一个统一的接口。</p></li></ul><p>注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象及对象组合。</p><p>应用实例： </p><ul><li><p>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 </p></li><li><p>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p></li></ul><p>优点：</p><ul><li><p>高层模块调用简单。</p></li><li><p>节点自由增加。</p></li></ul><p>缺点：</p><ul><li>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</li></ul><p>使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。</p><p>注意事项：定义时为具体类。</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>抽象变化，封装各自变化</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/bridge.png?raw=true" alt="类图"></p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/state.png?raw=true" alt="类图"></p><p>State模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中, 所以通过定义新的子类可以很容易的增加新的状态和转换。另一个方法是使用数据值定义内部状态并且让 Context操作来显式地检查这些数据。但这样将会使整个Context的实现中遍布看起来很相似的条件if else语句或switch case语句。增加一个新的状态可能需要改变若干个操作, 这就使得维护变得复杂了。State模式避免了这个问题, 但可能会引入另一个问题, 因为该模式将不同状态的行为分布在多个State子类中。这就增加了子类的数目，相对于单个类的实现来说不够紧凑。但是如果有许多状态时这样的分布实际上更好一些, 否则需要使用巨大的条件语句。正如很长的过程一样，巨大的条件语句是不受欢迎的。它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。 State模式提供了一个更好的方法来组织与特定状态相关的代码。决定状态转移的逻辑不在单块的 i f或s w i t c h语句中, 而是分布在State子类之间。将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。</p><p>优点：</p><ul><li><p>它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p></li><li><p>它使得状态转换显式化: 当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且, State对象可保证Context不会发生内部状态不一致的情况，因为从 Context的角度看，状态转换是原子的—只需重新绑定一个变量(即Context的State对象变量)，而无需为多个变量赋值</p></li><li><p>State对象可被共享 如果State对象没有实例变量—即它们表示的状态完全以它们的类型来编码—那么各Context对象可以共享一个State对象。当状态以这种方式被共享时, 它们必然是没有内部状态, 只有行为的轻量级对象。</p></li></ul><p>缺点:</p><ul><li><p>状态模式的使用必然会增加系统类和对象的个数。</p></li><li><p>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</p></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为另一个对象提供一个替身或者占位符以控制对这个对象的访问。</p><p>优点：</p><ul><li>只有真正去调用的时候才会创建实例。有些情况下，程序不会真正的调用被调用对象的某个方法时，这种情况无需去创建被调用这对象的实例。在这种情况下，代理模式可以调程序的性能。宏观上减少了系统开销。</li></ul><p>应用：hibernate延时加载</p><p>动态代理模式类图</p><p><a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">代理模式</a></p><h2 id="复合模式"><a href="#复合模式" class="headerlink" title="复合模式"></a>复合模式</h2><p>复合模式结合两个或以上的模式，组合一个解决方案，解决一再发生的一般性问题</p><p><a href="http://blog.csdn.net/yujin753/article/details/45675375" target="_blank" rel="noopener">详细了解</a></p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="https://www.cnblogs.com/littlejava/p/5701935.html" target="_blank" rel="noopener">参考博文</a></p><p><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">参考博文</a></p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法（Algorithm）</title>
      <link href="/2018/01/10/algorithm/2018-01-10-Algorithm/"/>
      <url>/2018/01/10/algorithm/2018-01-10-Algorithm/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/zhongyp/Demo/tree/master/src/main/java/com/zhongyp/algorithm" target="_blank" rel="noopener">本文的所有算法代码均在github上保存，点击此链接即可访问</a></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 先序、中序遍历二叉树</span><br><span class="line"> * 先序：根左右</span><br><span class="line"> * 中序：左根右</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// 标记先序索引位置</span><br><span class="line">int count = 0;</span><br><span class="line">public  Tree buildTreeByPreMid(int[] a, int s1, int e1,int[] b, int s2, int e2)&#123;</span><br><span class="line"></span><br><span class="line">    if(s1&gt;e1||s2&gt;e2)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree tree = new Tree();</span><br><span class="line">     tree.value = a[count];</span><br><span class="line">    // index为a[s1]在b中的索引</span><br><span class="line">    int index = getIndex(b, a[count]);</span><br><span class="line">    count++;</span><br><span class="line">    // count标识左子树先序的起点，s1+index为左子树先序的终点，s2,index-1分别为左子树中序的起点和终点</span><br><span class="line">    tree.left = buildTreeByPreMid(a, count, s1+index, b, s2, index-1);</span><br><span class="line">    tree.right = buildTreeByPreMid(a, count, s1+e2-index, b, index+1, e2);</span><br><span class="line"></span><br><span class="line">    return tree;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 中序、后序 构建二叉树</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">int count1 = 7;</span><br><span class="line">public Tree buildTreeByMidLast(int[] a, int s1, int e1,int[] b, int s2, int e2)&#123;</span><br><span class="line">    if(s1&gt;e1||s2&gt;e2)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree tree = new Tree();</span><br><span class="line">    tree.value = a[e1];</span><br><span class="line">    int index = getIndex(b, a[e1]);</span><br><span class="line">    count1--;</span><br><span class="line">    tree.right = buildTreeByMidLast(a, count1+index-e2+1, count1, b, index+1, e2);</span><br><span class="line">    tree.left = buildTreeByMidLast(a, s1, count1, b, s2, index-1);</span><br><span class="line">    return tree;</span><br><span class="line">&#125;</span><br><span class="line">private int getIndex(int[] b,int value)&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for(int tmp:b)&#123;</span><br><span class="line">        if(tmp==value)&#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 先序</span><br><span class="line">public void printPre(Tree tree)&#123;</span><br><span class="line">    if(tree != null)&#123;</span><br><span class="line">        System.out.print(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        printPre(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        printPre(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 中序</span><br><span class="line">public void printMid(Tree tree)&#123;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        printMid(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (tree != null)&#123;</span><br><span class="line">        System.out.print(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        printMid(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 后序</span><br><span class="line">public void printLast(Tree tree)&#123;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        printLast(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        printLast(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">    if (tree != null)&#123;</span><br><span class="line">        System.out.print(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 1.将节点放入队列</span><br><span class="line"> * 2.取出队列第一个节点</span><br><span class="line"> * 3.将取出的节点的左右节点一次放入队列</span><br><span class="line"> * 递归</span><br><span class="line"> */</span><br><span class="line">public void printLevel(Tree tree)&#123;</span><br><span class="line">    if(tree == null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree current;</span><br><span class="line">    LinkedList list = new LinkedList();</span><br><span class="line">    list.offer(tree);</span><br><span class="line">    while(!list.isEmpty())&#123;</span><br><span class="line">        current = (Tree)list.poll();</span><br><span class="line">        System.out.print(current.value);</span><br><span class="line">        if(current.left != null)&#123;</span><br><span class="line">            list.offer(current.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(current.right != null)&#123;</span><br><span class="line">            list.offer(current.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 二叉树叶子节点个数</span><br><span class="line">int count2 = 0;</span><br><span class="line">public void sumLeaf(Tree tree)&#123;</span><br><span class="line">    if(tree.left == null&amp;&amp;tree.right == null)&#123;</span><br><span class="line">        count2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        sumLeaf(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        sumLeaf(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 二叉树的高度</span><br><span class="line">public int hightTree(Tree tree)&#123;</span><br><span class="line">    if(tree == null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.left == null &amp;&amp; tree.right == null)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int l_hight = hightTree(tree.left);</span><br><span class="line">    int r_hight = hightTree(tree.right);</span><br><span class="line">    return l_hight&gt;r_hight?l_hight+1:r_hight+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求两个节点的最近公共祖先</span><br><span class="line">public void commonParent(int value1, int value2)&#123;</span><br><span class="line">    if(root == null || p == root || q == root) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tree l = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    Tree r = lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">    if(l!= null &amp;&amp; r!= null) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return l != null?l:r;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 路径值</span><br><span class="line">Stack&lt;Integer&gt; stack = new Stack();</span><br><span class="line">public void FindPath(Tree tree, int sum, int current)&#123;</span><br><span class="line">    if(tree==null)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current+=tree.value;</span><br><span class="line">    stack.push(tree.value);</span><br><span class="line">    if(current==sum)&#123;</span><br><span class="line">        System.out.println(&quot;PATH:&quot;);</span><br><span class="line">        for(int val : stack)&#123;</span><br><span class="line">            System.out.print(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current&lt;sum)&#123;</span><br><span class="line">        if(tree.left != null)&#123;</span><br><span class="line">            FindPath(tree.left,sum,current);</span><br><span class="line">        &#125;</span><br><span class="line">        if(tree.right != null)&#123;</span><br><span class="line">            FindPath(tree.right,sum,current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current -= tree.value;</span><br><span class="line">    stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>链表逆序（不可使用其他空间）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 非递归</span><br><span class="line"> */</span><br><span class="line">public Node reverse(Node node)&#123;</span><br><span class="line">    Node init = null;</span><br><span class="line">    while(node != null)&#123;</span><br><span class="line">        Node node1 = init;</span><br><span class="line">        Node node2 = node;</span><br><span class="line">        node = node.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        init = node2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归方式</span><br><span class="line"> * @param node1</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Node reverse1(Node node1)&#123;</span><br><span class="line"></span><br><span class="line">    Node init = node1.next;</span><br><span class="line">    if(init != null)&#123;</span><br><span class="line">        Node node2= reverse1(init);</span><br><span class="line">        Node tmp = getLastNode(node2);</span><br><span class="line">        node1.next = null;</span><br><span class="line">        tmp.next = node1;</span><br><span class="line">        return node2;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h2><ul><li>插入排序： 直接插入，希尔排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 直接插入排序算法的空间复杂度为O(1)。</span><br><span class="line">     * 最好的情况，要比较的无序序列原本就是顺序有序的，那么要比较的次数是n-1，移动了0次，时间复杂度O(n)。</span><br><span class="line">     * 最坏的情况，要比较的无序序列原本就是逆序有序的，那么要比较的次数是(n+2)(n-1)/2，移动的次数(n+4)(n-1)/2，时间复杂度O(n²)。</span><br><span class="line">     * 直接插入排序的平均复杂度为O(n²)。</span><br><span class="line">     * 直接插入排序是稳定的。</span><br><span class="line">     * @param num</span><br><span class="line">     */</span><br><span class="line">public void directInsert(int[] num)&#123;</span><br><span class="line">    for(int i=1; i&lt;num.length; i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">            if(num[i]&lt;num[j])&#123;</span><br><span class="line">                int a = num[j];</span><br><span class="line">                num[j] = num[i];</span><br><span class="line">                num[i] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int val:num)&#123;</span><br><span class="line">        System.out.print(val + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">     * 希尔排序在最坏的情况下的运行时间是O(n²)，平均时间复杂度为O(n^1.3)。</span><br><span class="line">     * 希尔排序对于多达几千个数据项的，中等大小规模的数组排序表现良好。</span><br><span class="line">     * 希尔排序不像快速排序和其它时间复杂度为O(nlog2n)的排序算法那么快，因此对非常大的文件排序，它不是最优选择。</span><br><span class="line">     * 但是，希尔排序比选择排序和插入排序这种时间复杂度为O(n²)的排序算法还是要快得多，并且它非常容易实现。</span><br><span class="line">     * 它在最坏情况下的执行效率和在平均情况下的执行效率相比没有差很多。</span><br><span class="line">     * 此外希尔排序是不稳定的(指在多次插入排序中，相同元素可能在插入排序中移动，导致稳定性被破坏)。</span><br><span class="line">     * @param num</span><br><span class="line">     */</span><br><span class="line">public void hillSort(int[] num)&#123;</span><br><span class="line">    int gap = 5;</span><br><span class="line">    while(gap&gt;0)&#123;</span><br><span class="line">        for(int i=0; i&lt;num.length-gap; i++)&#123;</span><br><span class="line">            if(num[i]&gt;num[i+gap])&#123;</span><br><span class="line">                int a = num[i];</span><br><span class="line">                num[i] = num[i+gap];</span><br><span class="line">                num[i+gap] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = gap/2;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int val:num)&#123;</span><br><span class="line">        System.out.print(val + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>选择排序： 简单选择排序，堆排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 选择排序</span><br><span class="line">     * @param num</span><br><span class="line">     */</span><br><span class="line">    public void simpleSort(int[] num)&#123;</span><br><span class="line">        for(int i=0;i&lt;num.length;i++)&#123;</span><br><span class="line">            int index = i;</span><br><span class="line">            for(int j=i;j&lt;num.length-1;j++)&#123;</span><br><span class="line">                if(num[index]&gt;num[j+1])&#123;</span><br><span class="line">                    index = j+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int a = num[i];</span><br><span class="line">            num[i] = num[index];</span><br><span class="line">            num[index] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int val:num)&#123;</span><br><span class="line">            System.out.print(val + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 堆排序</span><br><span class="line">     *</span><br><span class="line">     * 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</span><br><span class="line">     *</span><br><span class="line">     * @param num</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public void heapSort(int[] num, int index)&#123;</span><br><span class="line"></span><br><span class="line">        for(int i=index/2;i&gt;-1;i--)&#123;</span><br><span class="line">            if((2*i)&lt;index&amp;&amp;num[i]&lt;num[2*i])&#123;</span><br><span class="line">                int a = num[i];</span><br><span class="line">                num[i] = num[2*i];</span><br><span class="line">                num[2*i] = a;</span><br><span class="line">            &#125;</span><br><span class="line">            if((2*i+1)&lt;index&amp;&amp;num[i]&lt;num[2*i+1])&#123;</span><br><span class="line">                int a = num[i];</span><br><span class="line">                num[i] = num[2*i+1];</span><br><span class="line">                num[2*i+1] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int a = num[index];</span><br><span class="line">        num[index] = num[0];</span><br><span class="line">        num[0] = a;</span><br><span class="line">        index = index-1;</span><br><span class="line">        if(index&gt;0)&#123;</span><br><span class="line">            heapSort(num,index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>交换排序： 冒泡排序，快速排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    // 冒泡排序</span><br><span class="line">    public static void bubbleSort()&#123;</span><br><span class="line">//        int[] arr = &#123;3,5,7,1,4&#125;;</span><br><span class="line">        int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">        int i,j,temp,len=arr.length;</span><br><span class="line">        //是否已经完成排序的标志</span><br><span class="line">        boolean flag;</span><br><span class="line">        //排序</span><br><span class="line">        for(i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            for(j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">                if(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    flag = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                System.out.println(&quot;第&quot; + (i+1) + &quot;趟结束了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出数组</span><br><span class="line">        for(int o:arr)&#123;</span><br><span class="line">            System.out.print(&quot; &quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 快速排序</span><br><span class="line">    public static void quickSort(int[] num,int start, int end)&#123;</span><br><span class="line">            int sys = num[start];</span><br><span class="line">            int left = start;</span><br><span class="line">            int right = end;</span><br><span class="line"></span><br><span class="line">            while(start&lt;end)&#123;</span><br><span class="line">                if(num[end]&lt;sys)&#123;</span><br><span class="line">                    num[start] = num[end];</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    end--;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(sys&lt;num[start])&#123;</span><br><span class="line">                    num[end] = num[start];</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num[start] = sys;</span><br><span class="line">            if(left&lt;start-1)&#123;</span><br><span class="line">                quickSort(num,left,start-1);</span><br><span class="line">            &#125;</span><br><span class="line">            if(right&gt;end+1)&#123;</span><br><span class="line">                quickSort(num,end+1,right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>归并排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">static int[] sort(int[] a, int start, int end)&#123;</span><br><span class="line"></span><br><span class="line">    int mid ;</span><br><span class="line">    if(start&lt;end)&#123;</span><br><span class="line">        mid = (start + end)/2;</span><br><span class="line">        a = sort(a, start, mid);</span><br><span class="line">        a = sort(a, mid+1, end);</span><br><span class="line">        a = merge(a, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int[] merge(int[] a, int start, int mid, int end)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    int[] c = new int[a.length];</span><br><span class="line">    while((start+i)&lt;=mid&amp;&amp;(mid+1+j)&lt;=end)&#123;</span><br><span class="line">        if(a[start+i]&gt;a[mid+1+j])&#123;</span><br><span class="line">            c[i+j] = a[mid+1+j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            c[i+j] = a[start+i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    while((start+i)&lt;=mid)&#123;</span><br><span class="line">        c[i+j] = a[start+i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while((mid+1+j)&lt;=end)&#123;</span><br><span class="line">        c[i+j] = a[mid+1+j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int k=0;k&lt;=(i+j-1);k++)&#123;</span><br><span class="line">        a[start+k] = c[k];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基数排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int[] radixSort(int[] A, int n) &#123;</span><br><span class="line">    int length = n;</span><br><span class="line">    int divisor = 1;// 定义每一轮的除数，1,10,100...</span><br><span class="line">    int[][] bucket = new int[10][length];// 定义了10个桶，以防每一位都一样全部放入一个桶中</span><br><span class="line">    int[] count = new int[10];// 统计每个桶中实际存放的元素个数</span><br><span class="line">    int digit;// 获取元素中对应位上的数字，即装入那个桶</span><br><span class="line">    for (int i = 1; i &lt;= 3; i++) &#123;// 经过4次装通操作，排序完成</span><br><span class="line">        for (int temp : A) &#123;// 计算入桶</span><br><span class="line">            digit = (temp / divisor) % 10;</span><br><span class="line">            bucket[digit][count[digit]++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = 0;// 被排序数组的下标</span><br><span class="line">        for (int b = 0; b &lt; 10; b++) &#123;// 从0到9号桶按照顺序取出</span><br><span class="line">            if (count[b] == 0)// 如果这个桶中没有元素放入，那么跳过</span><br><span class="line">            continue;</span><br><span class="line">            for (int w = 0; w &lt; count[b]; w++) &#123;</span><br><span class="line">                A[k++] = bucket[b][w];</span><br><span class="line">            &#125;</span><br><span class="line">            count[b] = 0;// 桶中的元素已经全部取出，计数器归零</span><br><span class="line">        &#125;</span><br><span class="line">        divisor *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指offfer-所有算法"><a href="#剑指offfer-所有算法" class="headerlink" title="剑指offfer 所有算法"></a>剑指offfer 所有算法</h2><p>第01-10题</p><p>【剑指Offer学习】【面试题02：实现Singleton 模式——七种实现方式】</p><p>【剑指Offer学习】【面试题03：二维数组中的查找】</p><p>【剑指Offer学习】【面试题04：替换空格】</p><p>【剑指Offer学习】【面试题05：从尾到头打印链表】</p><p>【剑指Offer学习】【面试题06：重建二叉树】</p><p>【剑指Offer学习】【面试题07：用两个栈实现队列】</p><p>【剑指Offer学习】【面试题08：旋转数组的最小数字】</p><p>【剑指Offer学习】【面试题09：斐波那契数列】</p><p>【剑指Offer学习】【面试题10：二进制中1 的个数】</p><p>第11-20题</p><p>【剑指Offer学习】【面试题11：数值的整数次方】</p><p>【剑指Offer学习】【面试题12：打印1 到最大的n 位数】</p><p>【剑指Offer学习】【面试题13：在O（1）时间删除链表结点】</p><p>【剑指Offer学习】【面试题14：调整数组顺序使奇数位于偶数前面】</p><p>【剑指Offer学习】【面试题15：链表中倒数第k个结点】</p><p>【剑指Offer学习】【面试题16：反转链表】</p><p>【剑指Offer学习】【面试题17：合并两个排序的链表】</p><p>【剑指Offer学习】【面试题18：树的子结构】</p><p>【剑指Offer学习】【面试题19：二叉树的镜像】</p><p>【剑指Offer学习】【面试题20：顺时针打印矩阵】</p><p>第21-30题</p><p>【剑指Offer学习】【面试题21：包含min函数的钱】</p><p>【剑指Offer学习】【面试题22：栈的压入、弹出序列】</p><p>【剑指Offer学习】【面试题23：从上往下打印二叉树】</p><p>【剑指Offer学习】【面试题24：二叉搜索树的后序遍历序列】</p><p>【剑指Offer学习】【面试题25：二叉树中和为某一值的路径】</p><p>【剑指Offer学习】【面试题26：复杂链表的复制】</p><p>【剑指Offer学习】【面试题27：二叉搜索树与双向链表】</p><p>【剑指Offer学习】【面试题28：字符串的排列】</p><p>【剑指Offer学习】【面试题29：数组中出现次数超过一半的数字】</p><p>【剑指Offer学习】【面试题30：最小的k个数】</p><p>第31-40题</p><p>【剑指Offer学习】【面试题31：连续子数组的最大和】</p><p>【剑指Offer学习】【面试题32：求从1到n的整数中1出现的次数】</p><p>【剑指Offer学习】【面试题33：把数组排成最小的数】</p><p>【剑指Offer学习】【面试题34：丑数】</p><p>【剑指Offer学习】【面试题35：第一个只出现一次的字符】</p><p>【剑指Offer学习】【面试题36：数组中的逆序对】</p><p>【剑指Offer学习】【面试题37：两个链表的第一个公共结点】</p><p>【剑指Offer学习】【面试题38：数字在排序数组中出现的次数】</p><p>【剑指Offer学习】【面试题39：二叉树的深度】</p><p>【剑指Offer学习】【面试题40：数组中只出现一次的数字】</p><p>第41-50题</p><p>【剑指Offer学习】【面试题41：和为s 的两个数字vs 和为s 的连续正数序列】</p><p>【剑指Offer学习】【面试题42：翻转单词顺序vs左旋转字符串】</p><p>【剑指Offer学习】【面试题43 : n 个锻子的点数】</p><p>【剑指Offer学习】【面试题44：扑克牌的顺子】</p><p>【剑指Offer学习】【面试题45：圆圈中最后剩下的数字(约瑟夫环问题)】</p><p>【剑指Offer学习】【面试题47：不用加减乘除做加法】</p><p>【剑指Offer学习】【面试题49：把字符串转换成整数】</p><p>【剑指Offer学习】【面试题50：树中两个结点的最低公共祖先】</p><p>第51-60题</p><p>【剑指Offer学习】【面试题51：数组中重复的数字】</p><p>【剑指Offer学习】【面试题52：构建乘积数组】</p><p>【剑指Offer学习】【面试题53：正则表达式匹配】</p><p>【剑指Offer学习】【面试题54：表示数值的字符串】</p><p>【剑指Offer学习】【面试题55：字符流中第一个不重复的字符】</p><p>【剑指Offer学习】【面试题56：链表中环的入口结点】</p><p>【剑指Offer学习】【面试题57：删除链表中重复的结点】</p><p>【剑指Offer学习】【面试题58：二叉树的下一个结点】</p><p>【剑指Offer学习】【面试题59：对称的二叉树】</p><p>【剑指Offer学习】【面试题60：把二叉树打印出多行】</p><p>第61-67题</p><p>【剑指Offer学习】【面试题61：按之字形顺序打印二叉树】</p><p>【剑指Offer学习】【面试题62：序列化二叉树】</p><p>【剑指Offer学习】【面试题63：二叉搜索树的第k个结点】</p><p>【剑指Offer学习】【面试题64：数据流中的中位数】</p><p>【剑指Offer学习】【面试题65：滑动窗口的最大值】</p><p>【剑指Offer学习】【面试题66：矩阵中的路径】</p><p>【剑指Offer学习】【面试题67：机器人的运动范围】</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>并查集</p></li><li><p>KMP</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DD面试总结</title>
      <link href="/2018/01/09/interfaceview/2018-01-09-DDInterview/"/>
      <url>/2018/01/09/interfaceview/2018-01-09-DDInterview/</url>
      <content type="html"><![CDATA[<p>结论：两次的打脸，足以说明问题！</p>]]></content>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TT面试总结</title>
      <link href="/2018/01/08/interfaceview/2018-01-08-TTInterview/"/>
      <url>/2018/01/08/interfaceview/2018-01-08-TTInterview/</url>
      <content type="html"><![CDATA[<p>最近在找工作，可能来不及自己整理，先贴一下别人的博客博文地址。</p><p>单链表在不使用新空间的情况下倒序，<br><a href="http://blog.csdn.net/cangchen/article/details/45040259" target="_blank" rel="noopener">原文地址：</a></p><p>zk高可用算法</p><p><a href="http://blog.csdn.net/huangjinsheng1988/article/details/52494080" target="_blank" rel="noopener">原文地址</a></p><p>NIO，BIO</p><p><a href="http://bbym010.iteye.com/blog/2100868" target="_blank" rel="noopener">原文地址</a></p><p>sql，左连接，右连接</p><p><a href="https://www.cnblogs.com/zxlovenet/p/4005256.html" target="_blank" rel="noopener">原文地址</a></p><p>分布式锁</p><p><a href="https://www.cnblogs.com/liuyang0/p/6744076.html" target="_blank" rel="noopener">原文地址</a></p><p>dubbo的基础协议</p><p><a href="http://blog.csdn.net/tanga842428/article/details/52717217" target="_blank" rel="noopener">原文地址</a></p><p>current包和collection工具类转化的并发类有什么区别。</p><p><a href="http://blog.csdn.net/zcc_0015/article/details/46932667" target="_blank" rel="noopener">原文地址</a></p><p>linux 基础命令回顾</p><p><a href="https://www.cnblogs.com/nulige/p/6679972.html" target="_blank" rel="noopener">原文地址</a></p><p><a href="https://www.cnblogs.com/zdz8207/p/linux-log-tail-cat-tac.html" target="_blank" rel="noopener">https://www.cnblogs.com/zdz8207/p/linux-log-tail-cat-tac.html</a></p><p>mysql数据库索引</p><p><a href="">原文地址</a></p><p>结论：细致、深入、强化</p>]]></content>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合框架</title>
      <link href="/2018/01/06/java/2018-01-06-Collection/"/>
      <url>/2018/01/06/java/2018-01-06-Collection/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/collections.png?raw=true" alt="集合框架"></p><p><a href="https://github.com/zhongyp/jekyll.github.io/blob/master/files/collections.png?raw=true" target="_blank" rel="noopener">点击放大</a></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li><p><a href="http://zhongyp.me/2018/01/10/Set">Set源码解析：http://zhongyp.me/2018/01/10/Set</a></p><ul><li><p>HashSet：底层实现是HashMap，没有特殊的特性。</p></li><li><p>LinkedHashSet：底层实现LinkedHashMap,特性为维护了一个单链表，访问顺序为插入顺序。</p></li><li><p>TreeSet：底层基于TreeMap, 特性为是一个有序的，它的作用是提供有序的Set集合。同时实现NavigableSet接口，该接口扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项，如：lower，floor,ceiling等方法。</p></li></ul></li></ul><ul><li><p>List源码解析</p><ul><li><p><a href="http://zhongyp.me/2018/01/10/ArrayList/">ArrayList</a> ：底层数组，特性为实现RandomAccess接口，可以对元素进行快速访问。</p></li><li><p><a href="http://zhongyp.me/2018/01/12/LinkedList/">LinkedList</a> ：是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。实现 List 接口，能对它进行队列操作。实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 是非同步的。</p></li><li><p><a href="http://zhongyp.me/2018/01/12/Vector/">Vector</a> ：底层数组，不过是ArrayList的同步版本。不过不能序列化，没有实现Serializable的readObject方法。</p></li></ul></li><li><p><a href="">Queue源码解析：</a></p><ul><li><p>PriorityQueue </p></li><li><p><a href="http://zhongyp.me/2018/01/12/LinkedList/">LinkedList</a> ：是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。实现 List 接口，能对它进行队列操作。实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 是非同步的。</p></li><li><p>ArrayQueue</p></li></ul></li></ul><h2 id="Map源码解析"><a href="#Map源码解析" class="headerlink" title="Map源码解析"></a><a href="">Map源码解析</a></h2><ul><li><p>EnumMap</p></li><li><p>IdentityHashMap</p></li><li><p>HashMap </p></li><li><p>HashTable</p></li><li><p><a href="https://www.cnblogs.com/zaizhoumo/p/7709755.html" target="_blank" rel="noopener">ConcurrentHashMap</a></p></li><li><p>LinkedHashMap</p></li><li><p>WeakHashMap</p></li><li><p>TreeMap</p></li></ul><h2 id="Concurrent源码解析："><a href="#Concurrent源码解析：" class="headerlink" title="Concurrent源码解析："></a><a href="">Concurrent源码解析：</a></h2><ul><li><p>阻塞队列 BlockingQueue</p></li><li><p>数组阻塞队列 ArrayBlockingQueue</p></li><li><p>延迟队列 DelayQueue</p></li><li><p>链阻塞队列 LinkedBlockingQueue</p></li><li><p>具有优先级的阻塞队列 PriorityBlockingQueue</p></li><li><p>同步队列 SynchronousQueue</p></li><li><p>阻塞双端队列 BlockingDeque</p></li><li><p>链阻塞双端队列 LinkedBlockingDeque</p></li><li><p>并发 Map(映射) ConcurrentMap</p></li><li><p>并发导航映射 ConcurrentNavigableMap</p></li><li><p>闭锁 CountDownLatch</p></li><li><p>栅栏 CyclicBarrier</p></li><li><p>交换机 Exchanger</p></li><li><p>信号量 Semaphore</p></li><li><p>执行器服务 ExecutorService</p></li><li><p>线程池执行者 ThreadPoolExecutor</p></li><li><p>定时执行者服务 ScheduledExecutorService</p></li><li><p>使用 ForkJoinPool 进行分叉和合并</p></li><li><p>锁 Lock</p></li><li><p>读写锁 ReadWriteLock</p></li><li><p>原子性布尔 AtomicBoolean</p></li><li><p>原子性整型 AtomicInteger </p></li><li><p>原子性长整型 AtomicLong</p></li><li><p>原子性引用型 AtomicReference</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿里电话面试总结</title>
      <link href="/2018/01/06/interfaceview/2018-01-06-AliInterview/"/>
      <url>/2018/01/06/interfaceview/2018-01-06-AliInterview/</url>
      <content type="html"><![CDATA[<p>2018年元旦后，打算跳槽换家互联网公司发展，就投了阿里娱乐一份简历，接着就经历了人生第一次电面。</p><p>以下就是人生最黑暗的几分钟（可能记录的不完全一样，大致差不多）：</p><p>嘟…</p><p>我：喂，您好！</p><p>阿里大牛：喂，你好，是钟**么？</p><p>我：对，您是？</p><p>阿里大牛：我是阿里…(什么部门)技术…（什么职位），这里收到一份你的简历，请问你是一直在做Java开发么？</p><p>我：是。</p><p>阿里大牛： …(呜啦啦，忘了说的啥了，就记得最后一句)，你所做的项目你最满意或者印象最深的项目？</p><p>我：和同事一块开发啥啥…（细节的东西，我记得我说的不是很细，就说了用了dubbo的分布式框架和一些中间件开发过一个文件交换通道）</p><p>…(省略一些关于提问关于这个项目的细节)</p><p>阿里大牛： 我这有一个HashMap,其中key是有序的，你用集合框架中的那些方法或者工具可以将hashmap根据key值有序输出。</p><p>我：想了一会，就直接说对Map不熟（其实到这我已经懵逼了，说实话以前学的时候确实了解过，不过对于当时的我，脑子已经废掉了）</p><p>阿里大牛： 既然对Map不熟，那你给我说下你在项目中用的一些设计模式或者说在JDK中用的一些设计模式或者比较好的设计。</p><p>我：…(忘了说啥了，脑子完全慌了)</p><p>…(省略一部分，太紧张，已经懵掉了，不记得了)</p><p>阿里大牛： 有什么想问我的么？</p><p>我：我就说阿里问的太细了，很多这些可能以前整理过，现在忘掉了，或者有的用过没整理，….（后面呜啦啦说了好多，自己都没法组织语言了，我已经放弃了，鄙视自己1万次）</p><p>阿里大牛： 我多说两句，其实我一直在引导你把自己最成功的部分说出来，而你却一直被动的回应，没有主动把握主动权，平时多总结，在面试的时候要主动引导面试官往你擅长的方向。…（后面忘了，不过还是非常感谢这位Ali的技术大牛，希望以后能在阿里再次见到你）</p><p>我：非常感谢！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主观原因：</p><ul><li>知识体系在脑子中没有呈现。</li><li>平时总结没有落实到字面上，导致一些总结过的东西遗忘，或者根本不记得。</li><li>没有时刻准备着，既然投了简历，就要时刻准备着，对自己负责，对对方负责。</li></ul><p>客观原因：</p><ul><li>由于第一次接到电话面试，对方又是阿里的，自己心理素质未过关，太慌张，导致问题都没问清楚。</li><li>对自己放弃的太早，没有把握机会，比如说，大牛让自己有什么问题的时候，完全可以说明原因，争取机会，让自己放松去面对这次机会。（其实也是心理问题导致）</li></ul><p>##关于面试中的问题解答：</p><p>1.将hashmap有序输出？</p><p>目前自己有两种想法，第一个是使用LinkedHashMap,因为LinkedHashMap本身就对key有序，所以就解决了。第二个是用TreeMap,把hashmap的key存入TreeMap,因为TreeSet本身存入key的时候会排成有序的。</p><p>2.一些好的设计或者设计模式在JDK中的体现？</p><p>这个回答我打算放到Java基础回顾的时候，放到设计模式章节中说。整理完成后会将链接贴在此处。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>1.回顾知识体系，结果以博客文章形式体现。</p><p>2.充实自己，了解的更多，才能在遇到机会是把握住。</p>]]></content>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 基础知识总结</title>
      <link href="/2018/01/06/java/2018-01-06-Java/"/>
      <url>/2018/01/06/java/2018-01-06-Java/</url>
      <content type="html"><![CDATA[<ul><li><p><a href="http://zhongyp.me/2018/01/06/Collection/">Java集合框架</a></p></li><li><p><a href="">IO和NIO、AIO</a></p></li><li><p><a href="">多线程、线程池</a></p></li><li><p><a href="">阻塞、非阻塞、异步网络通信</a></p></li><li><p><a href="">反射、动态代理</a></p></li><li><p><a href="http://zhongyp.me/2018/01/10/Pattern/">设计模式</a></p></li><li><p><a href="http://zhongyp.me/2018/01/10/Algorithm/">算法</a></p></li><li><p><a href="">泛型和动态代理</a></p></li><li><p><a href="">JVM</a></p></li></ul><p>运行时确定数据类型泛型</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Semaphore--Java信号灯</title>
      <link href="/2018/01/04/concurrent/2018-03-04-Semaphore/"/>
      <url>/2018/01/04/concurrent/2018-03-04-Semaphore/</url>
      <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u011613354/article/details/51150248" target="_blank" rel="noopener">引用博文：https://blog.csdn.net/u011613354/article/details/51150248</a></p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存模型和Volatile</title>
      <link href="/2018/01/04/concurrent/2018-03-04-Volatile/"/>
      <url>/2018/01/04/concurrent/2018-03-04-Volatile/</url>
      <content type="html"><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/jvm.png?raw=true" alt="Java 内存模型"></p><p>Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p>举个简单的例子：在java中，执行下面这个语句：</p><p><code>i  = 10++;</code></p><p>1) 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p><p>2) 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p><p>3) 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</p><p>4) 最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p><pre><code>那么如何确保共享变量在多线程访问时能够正确输出结果呢？</code></pre><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。</p><ul><li><p>Java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p></li><li><p>在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p><p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p><p>假如某个时刻变量inc的值为10，</p><p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p><p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p><p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p><p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p><p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p><p>解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。</p><p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>即程序执行的顺序按照代码的先后顺序执行。Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//线程1:</span><br><span class="line"> </span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line"> //线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">   sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p><p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p><ul><li>在 Java 中 volatile、synchronized 和 final 实现可见性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//线程1</span><br><span class="line">boolean stop = false;</span><br><span class="line">while(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//线程2</span><br><span class="line">stop = true;</span><br></pre></td></tr></table></figure><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p><h2 id="Volatile-详解"><a href="#Volatile-详解" class="headerlink" title="Volatile 详解"></a>Volatile 详解</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>2）禁止进行指令重排序。</p><p>Volatile原理实现：</p><p>1.可见性</p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据读到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p><p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p><p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p><p>2.有序性</p><p>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;         //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure><p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p><p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><h2 id="Volatile-关键字的应用"><a href="#Volatile-关键字的应用" class="headerlink" title="Volatile 关键字的应用"></a>Volatile 关键字的应用</h2><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p><p>1）对变量的写操作不依赖于当前值</p><p>2）该变量没有包含在具有其他变量的不变式中</p><p>下面列举几个Java中使用volatile的几个场景。</p><ul><li>状态标记量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">volatile boolean flag = false;</span><br><span class="line"> //线程1</span><br><span class="line">while(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  //线程2</span><br><span class="line">public void setFlag() &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据状态标记，终止线程。</p><ul><li>单例模式中的double check</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line"> </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance==null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance==null)</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>为什么要使用volatile 修饰instance？</code></pre><p>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p><ol><li><p>给 instance 分配内存</p></li><li><p>调用 Singleton 的构造函数来初始化成员变量</p></li><li><p>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p></li></ol><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><h2 id="Java内存模型的先天有序性"><a href="#Java内存模型的先天有序性" class="headerlink" title="Java内存模型的先天有序性"></a>Java内存模型的先天有序性</h2><p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p><p>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ol><li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p></li><li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</p></li><li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p></li></ol><p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p><p>下面我们来解释一下前4条规则：</p><p>对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p><p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p><p>第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p><p>第四条规则实际上就是体现happens-before原则具备传递性。</p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p><a href="http://www.importnew.com/24082.html" target="_blank" rel="noopener">参考博文（1）：http://www.importnew.com/24082.html</a></p><p><a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">参考博文（2）：http://www.importnew.com/24082.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于SSO的单点登录实现</title>
      <link href="/2017/10/15/work/2017-10-15-SSO/"/>
      <url>/2017/10/15/work/2017-10-15-SSO/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式锁</title>
      <link href="/2017/10/15/work/2017-10-15-Distribute-Lock/"/>
      <url>/2017/10/15/work/2017-10-15-Distribute-Lock/</url>
      <content type="html"><![CDATA[<h2 id="分布式锁是什么"><a href="#分布式锁是什么" class="headerlink" title="分布式锁是什么"></a>分布式锁是什么</h2><p>目前大多数网站及应用都是分布式部署的，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。</p><p>为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为分布式锁。</p><h2 id="分布式锁作用"><a href="#分布式锁作用" class="headerlink" title="分布式锁作用"></a>分布式锁作用</h2><ul><li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</li></ul><h2 id="分布式锁的几种实现方式"><a href="#分布式锁的几种实现方式" class="headerlink" title="分布式锁的几种实现方式"></a>分布式锁的几种实现方式</h2><pre><code>基于数据库表</code></pre><ol><li><p>基于表的数据操作锁，当我们要加锁是，创建一条记录；释放锁时，删除这条记录。</p></li><li><p>基于数据库排他锁，利用数据库自带的排他锁机制。select for update。</p></li></ol><p>该方案强依赖于数据库的可用性。数据库是单点，一旦挂掉，将导致整个业务不可用。（1,2）</p><p>该锁不是阻塞的。依赖insert操作，一旦失败直接返回。没有获得锁的线程不会进入队列，要想获取锁，只能再次发起insert。（1）</p><p>天生是阻塞的。for update失败会一直处于阻塞状态。数据库宕机，则锁自动释放（2）</p><p>该锁没有失效时间。一旦delete失败，锁就永远存在了。（1）</p><p>该锁不是可重入锁。（1,2）</p><pre><code>基于缓存实现基于Zookeeper实现</code></pre><p>基于Zookeeper临时有序节点实现分布式锁。 </p><p>大体原理：当每个客户端对某个方法加锁时，在Zookeeper的对应目录下，会生成一个唯一的瞬态的有序的znode。 </p><p>判断是否获得锁，只要判断自己是不是目录下最小的znode。 </p><p>如果不是，注册对比自己小的znode的监听。当比自己小的znode删除时，收到消息，判断自己是不是最小的。</p><p>当某个客户端获取锁后，突然挂掉。没关系，对应的znode会被自动删除，不会出现锁释放不了的问题。 </p><p>是阻塞锁 </p><p>可重入 </p><p>集群部署</p><p>使用zookeeper还是比较靠谱的，而且可以直接使用第三方包Curator，这个包直接封装了一个可重入的锁服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean tryLock(long timeout, TimeUnit unit) throws Exception &#123;</span><br><span class="line">        return interProcessMutex.acquire(timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line">public void unlock() throws Exception &#123;</span><br><span class="line">        interProcessMutex.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Curator的interProcessMutex.acquire获取锁，release释放锁。</p><p>只是性能上要比基于缓存差一点。 </p><p>但是生产环境上还是推荐zookeeper。</p><h2 id="Redis-分布式锁存在的问题和解决方案"><a href="#Redis-分布式锁存在的问题和解决方案" class="headerlink" title="Redis 分布式锁存在的问题和解决方案"></a>Redis 分布式锁存在的问题和解决方案</h2><pre><code>分布式锁存在的问题</code></pre><p>均可能存在多进程拥有锁的情况。redis锁主要是expire时间与代码执行时间的问题，zk锁的问题在于zk是通过心跳监控进程存活状态，如果进程进行GC pause或者因为网络原因导致很长时间没与zk联系，则将导致zk认为进程已挂，而后锁自动释放，而此时进程并未挂任然在执行。<br>Redlock锁的时间问题。由于redis的expire的实现是通过pexpireat，如果某个节点发生时钟跳跃，则该节点可能过早释放锁导致一系列问题。</p><pre><code>解决方案</code></pre><p>获取锁时提供一个fencing token(两种说法，一种说需要有序，一种说随机值就可以，我觉得随机值就可以)，在进程获取锁后对数据进行操作时，数据所在的资源服务器需要去锁中查看当前token，如果token对的才执行，不对则放弃执行。<br>我觉得对于放弃执行的应该在我们的代码块中增加类似事物的rollback的操作。因此如果资源服务器拒绝了我们的操作则表明此时起码已经存在了另外一个进程拥有锁了，为了保证数据安全性不能继续执行，因此需要回滚到执行代码块之前而继续去竞争锁。<br>至于Redis锁的时间问题，Antirez说在运维层面是可以控制时钟跳跃的区间的，只要能控制跳跃区间与expire的比例就没问题，详细可看《基于Redis的分布式锁真的安全吗？》</p>]]></content>
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程池底层实现机制及应用</title>
      <link href="/2017/08/04/concurrent/2017-08-04-ThreadPool/"/>
      <url>/2017/08/04/concurrent/2017-08-04-ThreadPool/</url>
      <content type="html"><![CDATA[<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>java.util.concurrent.Executosr是线程池的静态工厂，我们通常使用它方便地生产各种类型的线程池，主要的方法有三种：</p><ul><li><p>newSingleThreadExecutor()——创建一个单线程的线程池</p></li><li><p>newFixedThreadPool(int n)——创建一个固定大小的线程池</p></li><li><p>newCachedThreadPool()——创建一个可缓存的线程池</p></li></ul><h2 id="线程参数"><a href="#线程参数" class="headerlink" title="线程参数"></a>线程参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,//corePoolSize线程池中的核心线程数。</span><br><span class="line">                          int maximumPoolSize,//maximumPoolSize线程池中的最大线程数。</span><br><span class="line">                          long keepAliveTime,//keepAliveTime线程池中的线程存活时间，即回收时间</span><br><span class="line">                          TimeUnit unit,//参数keepAliveTime的时间单位</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,//workQueue一个阻塞队列，用来存储等待执行的任务。</span><br><span class="line">                          ThreadFactory threadFactory,//threadFactory线程工厂，主要用来创建线程。</span><br><span class="line">                          RejectedExecutionHandler handler//任务拒绝策略，当运行线程数已达到maximumPoolSize，队列也已经装满时会调用该参数拒绝任务，有默认实现。</span><br><span class="line">                          ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>corePoolSize 核心线程数</code></pre><ul><li><p>核心线程会一直存活，及时没有任务需要执行</p></li><li><p>当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理</p></li><li><p>设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭</p></li></ul><p>确定线程数： 线程数=CPU可用核心数/(1-阻塞系数)，通常IO密集型=2Ncpu，计算密集型=Ncpu+1。</p><pre><code>keepAliveTime</code></pre><p>   当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize</p><p>   如果allowCoreThreadTimeout=true，则会直到线程数量=0</p><pre><code>TimeUnit</code></pre><ul><li><p>TimeUnit.DAYS;    //天</p></li><li><p>TimeUnit.HOURS;    //小时</p></li><li><p>TimeUnit.MINUTES;    //分钟</p></li><li><p>TimeUnit.SECONDS;    //秒</p></li><li><p>TimeUnit.MILLISECONDS;    //毫秒</p></li><li><p>TimeUnit.MICROSECONDS;    //微妙</p></li><li><p>TimeUnit.NANOSECONDS;    //纳秒</p></li></ul><p>TimeUnit是java.util.concurrent包下面的一个类，TimeUnit提供了可读性更好的线程暂停操作，通常用来替换Thread.sleep()，在很长一段时间里Thread的sleep()方法作为暂停线程的标准方式。</p><pre><code>BlockingQueue用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</code></pre><ul><li><p>ArrayBlockingQueue 有界队列</p><p>  有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</p></li><li><p>LinkedBlockingQueue 无界队列</p><p>  适用于FixedThreadPool与SingleThreadExcutor。基于链表的阻塞队列，创建的线程数不会超过corePoolSizes（maximumPoolSize值与其一致），当线程正忙时，任务进入队列等待。按照FIFO原则对元素进行排序，吞吐量高于ArrayBlockingQueue。</p></li><li><p>priorityBlockingQuene 具有优先级的无界阻塞队列</p><p>  是一个特殊的无界队列，可以根据自身任务的优先级顺序先后执行，而LinkedBlockingQuene和ArrayBlockingQuene都是按照先进先出的方式处理的。</p></li><li><p>SynchronousQueue 直接提交策略</p></li></ul><p>   适用于CachedThreadPool。它将任务直接提交给线程而不保持它们。如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求最大的 maximumPoolSize 以避免拒绝新提交的任务（正如CachedThreadPool这个参数的值为Integer.MAX_VALUE）。当任务以超过队列所能处理的量、连续到达时，此策略允许线程具有增长的可能性。吞吐量较高。</p><p>.</p><pre><code>threadFactory</code></pre><p> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。</p><pre><code>handler </code></pre><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p><ul><li><p>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </p></li><li><p>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </p></li><li><p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务，只要线程池未关闭，该策略直接在调用者线程中运行当前被丢弃的任务。显然这样不会真的丢弃任务，但是，调用者线程性能可能急剧下降。 </p></li></ul><p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。    </p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>旅行</title>
      <link href="/2017/07/05/life/2017-7-5-Journey/"/>
      <url>/2017/07/05/life/2017-7-5-Journey/</url>
      <content type="html"><![CDATA[<h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>旅行让我能望得辽远，想得细密，理解人生的遗憾，与这世界的好处。</p><h2 id="生活的城市"><a href="#生活的城市" class="headerlink" title="生活的城市"></a>生活的城市</h2><ul><li><p><a href="#滕州2013-9">滕州（~2013-9）</a></p></li><li><p><a href="#烟台2013-92016-7">烟台（2013-9~2016-7）</a></p></li><li><p><a href="#北京2016-7">北京（2016-7~）</a></p></li></ul><h2 id="那些值得纪念的地方"><a href="#那些值得纪念的地方" class="headerlink" title="那些值得纪念的地方"></a>那些值得纪念的地方</h2><ul><li><p><a href="#日照2010-8">日照（2010-8）</a></p></li><li><p><a href="#廊坊2012-7">廊坊（2012-7）</a></p></li><li><p><a href="#蓬莱2013-10">蓬莱（2013-10）</a></p></li><li><p><a href="#威海2015-10">威海（2015-10）</a></p></li><li><p><a href="#长岛2017-5">长岛（2017-5）</a></p></li><li><p><a href="#乌兰布统2017-7">乌兰布统（2017-7）</a></p></li></ul><h3 id="生活的城市-1"><a href="#生活的城市-1" class="headerlink" title="生活的城市"></a>生活的城市</h3><h3 id="滕州（-2013-9）"><a href="#滕州（-2013-9）" class="headerlink" title="滕州（~2013-9）"></a>滕州（~2013-9）</h3><h3 id="烟台（2013-9-2016-7）"><a href="#烟台（2013-9-2016-7）" class="headerlink" title="烟台（2013-9~2016-7）"></a>烟台（2013-9~2016-7）</h3><p>大学四年（其实只呆过三年）生活的地方。四年也没去过多少地方，大都时间都在瞎忙，等过了最闲暇的时光，才知道自己错过太多。</p><h3 id="北京（2016-7-）"><a href="#北京（2016-7-）" class="headerlink" title="北京（2016-7~）"></a>北京（2016-7~）</h3><h3 id="那些值得纪念的地方-1"><a href="#那些值得纪念的地方-1" class="headerlink" title="那些值得纪念的地方"></a>那些值得纪念的地方</h3><h3 id="日照（2010-8）"><a href="#日照（2010-8）" class="headerlink" title="日照（2010-8）"></a>日照（2010-8）</h3><h3 id="廊坊（2012-7）"><a href="#廊坊（2012-7）" class="headerlink" title="廊坊（2012-7）"></a>廊坊（2012-7）</h3><h3 id="蓬莱（2013-10）"><a href="#蓬莱（2013-10）" class="headerlink" title="蓬莱（2013-10）"></a>蓬莱（2013-10）</h3><h3 id="威海（2015-10）"><a href="#威海（2015-10）" class="headerlink" title="威海（2015-10）"></a>威海（2015-10）</h3><h3 id="长岛（2017-5）"><a href="#长岛（2017-5）" class="headerlink" title="长岛（2017-5）"></a>长岛（2017-5）</h3><h3 id="乌兰布统（2017-7）"><a href="#乌兰布统（2017-7）" class="headerlink" title="乌兰布统（2017-7）"></a>乌兰布统（2017-7）</h3>]]></content>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis(转载)</title>
      <link href="/2017/07/02/redis/2017-07-02-Redis/"/>
      <url>/2017/07/02/redis/2017-07-02-Redis/</url>
      <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/wyy123/p/6078593.html" target="_blank" rel="noopener">尊重原创：https://www.cnblogs.com/wyy123/p/6078593.html</a></p><h2 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么"></a>redis是什么</h2><p>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。</p><h2 id="学会安装redis"><a href="#学会安装redis" class="headerlink" title="学会安装redis"></a>学会安装redis</h2><p>从redis.io下载最新版redis-X.Y.Z.tar.gz后解压，然后进入redis-X.Y.Z文件夹后直接make即可，安装非常简单。</p><p>make成功后会在src文件夹下产生一些二进制可执行文件，包括redis-server、redis-cli等等：<br>代码如下:<br>$ find . -type f -executable<br>./redis-benchmark //用于进行redis性能测试的工具<br>./redis-check-dump //用于修复出问题的dump.rdb文件<br>./redis-cli //redis的客户端<br>./redis-server //redis的服务端<br>./redis-check-aof //用于修复出问题的AOF文件<br>./redis-sentinel //用于集群管理</p><h2 id="学会启动redis"><a href="#学会启动redis" class="headerlink" title="学会启动redis"></a>学会启动redis</h2><p>启动redis非常简单，直接./redis-server就可以启动服务端了，还可以用下面的方法指定要加载的配置文件：<br>代码如下:<br>./redis-server ../redis.conf</p><p>默认情况下，redis-server会以非daemon的方式来运行，且默认服务端口为6379。</p><h2 id="redis数据结构-–-简介"><a href="#redis数据结构-–-简介" class="headerlink" title="redis数据结构 – 简介"></a>redis数据结构 – 简介</h2><p>redis是一种高级的key:value存储系统，其中value支持五种数据类型：</p><p>1.字符串（strings）</p><p>2.字符串列表（lists）</p><p>3.字符串集合（sets）</p><p>4.有序字符串集合（sorted sets）</p><p>5.哈希（hashes）</p><p>而关于key，有几个点要提醒大家：</p><p>1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；<br>2.key也不要太短，太短的话，key的可读性会降低；<br>3.在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</p><h2 id="redis数据结构-–-strings"><a href="#redis数据结构-–-strings" class="headerlink" title="redis数据结构 – strings"></a>redis数据结构 – strings</h2><p>有人说，如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么，redis就和memcache非常非常的像了。这说明strings类型是一个很基础的数据类型，也是任何存储系统都必备的数据类型。</p><p> 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set mystr &quot;hello world!&quot; //设置字符串类型</span><br><span class="line">get mystr //读取字符串类型</span><br></pre></td></tr></table></figure><p>字符串类型的用法就是这么简单，因为是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储。</p><p>另外，我们还可以通过字符串类型进行数值操作：<br>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set mynum &quot;2&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr mynum</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>看，在遇到数值操作时，redis会将字符串类型转换成数值。</p><p></p><p style="color:red">由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果。</p>假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。不少网站都利用redis的这个特性来实现业务上的统计计数需求。<p></p><h2 id="redis数据结构-–-lists"><a href="#redis数据结构-–-lists" class="headerlink" title="redis数据结构 – lists"></a>redis数据结构 – lists</h2><p>redis的另一个重要的数据结构叫做lists，翻译成中文叫做“列表”。</p><p>首先要明确一点，redis中的lists在底层实现上并不是数组，而是链表，也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。</p><p>虽然lists有这样的优势，但同样有其弊端，那就是，链表型lists的元素定位会比较慢，而数组型lists的元素定位就会快得多。</p><p>lists的常用操作包括LPUSH、RPUSH、LRANGE等。我们可以用LPUSH在lists的左侧插入一个新元素，用RPUSH在lists的右侧插入一个新元素，用LRANGE命令从lists中指定一个范围来提取元素。</p><p>应用场景：</p><p>1.我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序。<br>2.利用LRANGE还可以很方便的实现分页的功能。<br>3.在博客系统中，每片博文的评论也可以存入一个单独的list中。</p><h2 id="redis数据结构-–-集合（set）"><a href="#redis数据结构-–-集合（set）" class="headerlink" title="redis数据结构 – 集合（set）"></a>redis数据结构 – 集合（set）</h2><p>redis的集合，是一种无序的集合，集合中的元素没有先后顺序。</p><p>集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。</p><p>对于集合的使用，也有一些常见的方式，比如，QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。</p><h2 id="redis数据结构-–-有序集合-sort-set"><a href="#redis数据结构-–-有序集合-sort-set" class="headerlink" title="redis数据结构 – 有序集合(sort-set)"></a>redis数据结构 – 有序集合(sort-set)</h2><p>redis不但提供了无需集合（sets），还很体贴的提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。</p><p>很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等</p><h2 id="redis数据结构-–-哈希"><a href="#redis数据结构-–-哈希" class="headerlink" title="redis数据结构 – 哈希"></a>redis数据结构 – 哈希</h2><p>最后要给大家介绍的是hashes，即哈希。哈希是从redis-2.0.0版本之后才有的数据结构。</p><p>hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HMSET user:001 username antirez password P1pp0 age 34 </span><br><span class="line">OK</span><br><span class="line">//列出哈希的内容</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:001 </span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;antirez&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;P1pp0&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;34&quot;</span><br><span class="line">//更改哈希中的某一个值</span><br><span class="line">127.0.0.1:6379&gt; HSET user:001 password 12345 </span><br><span class="line">(integer) 0</span><br><span class="line">//再次列出哈希的内容</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:001 </span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;antirez&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;12345&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;34&quot;</span><br></pre></td></tr></table></figure><h2 id="聊聊redis持久化-–-两种方式"><a href="#聊聊redis持久化-–-两种方式" class="headerlink" title="聊聊redis持久化 – 两种方式"></a>聊聊redis持久化 – 两种方式</h2><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p><p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</p><p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p><p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p><p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p><h2 id="聊聊redis持久化-–-RDB"><a href="#聊聊redis持久化-–-RDB" class="headerlink" title="聊聊redis持久化 – RDB"></a>聊聊redis持久化 – RDB</h2><p>RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。</p><p>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</p><p>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p><p>虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</p><h2 id="聊聊redis持久化-–-AOF"><a href="#聊聊redis持久化-–-AOF" class="headerlink" title="聊聊redis持久化 – AOF"></a>聊聊redis持久化 – AOF</h2><p>AOF，英文是Append Only File，即只允许追加不允许改写的文件。</p><p>如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。</p><p>我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</p><p>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</p><p>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。</p><p>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</p><p>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。</p><p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p><p>虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p><p>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</p><p>如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</p><p>1.备份被写坏的AOF文件<br>2.运行redis-check-aof –fix进行修复<br>3.用diff -u来看下两个文件的差异，确认问题点<br>4.重启redis，加载修复后的AOF文件</p><h2 id="聊聊redis持久化-–-AOF重写"><a href="#聊聊redis持久化-–-AOF重写" class="headerlink" title="聊聊redis持久化 – AOF重写"></a>聊聊redis持久化 – AOF重写</h2><p>在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p><p>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p><p>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p><p>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</p><h2 id="聊聊redis持久化-–-如何选择RDB和AOF"><a href="#聊聊redis持久化-–-如何选择RDB和AOF" class="headerlink" title="聊聊redis持久化 – 如何选择RDB和AOF"></a>聊聊redis持久化 – 如何选择RDB和AOF</h2><p>对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。</p><h2 id="聊聊主从-–-用法"><a href="#聊聊主从-–-用法" class="headerlink" title="聊聊主从 – 用法"></a>聊聊主从 – 用法</h2><p>像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。</p><p>主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。</p><p>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。</p><p>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</p><p>在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</p><h2 id="聊聊主从-–-同步原理"><a href="#聊聊主从-–-同步原理" class="headerlink" title="聊聊主从 – 同步原理"></a>聊聊主从 – 同步原理</h2><p>从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。</p><p>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</p><p>另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。</p><p>主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把“希望同步的主服务器ID”和“希望请求的数据的偏移位置（replication offset）”发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查“请求的偏移位置”是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。</p><p>增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。</p><h2 id="聊聊redis的事务处理"><a href="#聊聊redis的事务处理" class="headerlink" title="聊聊redis的事务处理"></a>聊聊redis的事务处理</h2><p>在聊redis事务处理之前，要先和大家介绍四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。</p><p>1.MULTI用来组装一个事务；</p><p>2.EXEC用来执行一个事务；</p><p>3.DISCARD用来取消一个事务；</p><p>4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。</p><p>我们来看一个MULTI和EXEC的例子：<br>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis&gt; MULTI //标记事务开始</span><br><span class="line">OK</span><br><span class="line">redis&gt; INCR user_id //多条命令按顺序入队</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC //执行</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 2</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) PONG</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们看到了QUEUED的字样，这表示我们在用MULTI组装事务时，每一个命令都会进入到内存队列中缓存起来，如果出现QUEUED则表示我们这个命令成功插入了缓存队列，在将来执行EXEC时，这些被QUEUED的命令都会被组装成一个事务来执行。</p><p>对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，我们可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。</p><p>有关事务，大家经常会遇到的是两类错误：</p><p>1.调用EXEC之前的错误<br>2.调用EXEC之后的错误</p><p>“调用EXEC之前的错误”，有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，redis会忽略那些入队失败的命令，只执行那些入队成功的命令）。我们来看一个这样的例子：<br>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; haha //一个明显错误的指令</span><br><span class="line">(error) ERR unknown command &apos;haha&apos;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">//redis无情的拒绝了事务的执行，原因是“之前出现了错误”</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>而对于“调用EXEC之后的错误”，redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。我们也来看一个例子：</p><p> 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 23</span><br><span class="line">QUEUED</span><br><span class="line">//age不是集合，所以如下是一条明显错误的指令</span><br><span class="line">127.0.0.1:6379&gt; sadd age 15 </span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set age 29</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec //执行事务时，redis不会理睬第2条指令执行错误</span><br><span class="line">1) OK</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">&quot;29&quot; //可以看出第3条指令被成功执行了</span><br></pre></td></tr></table></figure><p>好了，我们来说说最后一个指令“WATCH”，这是一个很好用的指令，它可以帮我们实现类似于“乐观锁”的效果，即CAS（check and set）。</p><p>WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。<br>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set age 23</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch age //开始监视age</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 24 //在EXEC之前，age的值被修改了</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 25</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec //触发EXEC</span><br><span class="line">(nil) //事务无法被执行</span><br></pre></td></tr></table></figure><h2 id="教你看懂redis配置-–-简介"><a href="#教你看懂redis配置-–-简介" class="headerlink" title="教你看懂redis配置 – 简介"></a>教你看懂redis配置 – 简介</h2><p>我们可以在启动redis-server时指定应该加载的配置文件，方法如下：<br>代码如下:</p><p>$ ./redis-server /path/to/redis.conf<br>接下来，我们就来讲解下redis配置文件的各个配置项的含义，注意，本文是基于redis-2.8.4版本进行讲解的。</p><p>redis官方提供的redis.conf文件，足有700+行，其中100多行为有效配置行，另外的600多行为注释说明。</p><p>在配置文件的开头部分，首先明确了一些度量单位：<br>代码如下:</p><h1 id="1k-gt-1000-bytes"><a href="#1k-gt-1000-bytes" class="headerlink" title="1k =&gt; 1000 bytes"></a>1k =&gt; 1000 bytes</h1><h1 id="1kb-gt-1024-bytes"><a href="#1kb-gt-1024-bytes" class="headerlink" title="1kb =&gt; 1024 bytes"></a>1kb =&gt; 1024 bytes</h1><h1 id="1m-gt-1000000-bytes"><a href="#1m-gt-1000000-bytes" class="headerlink" title="1m =&gt; 1000000 bytes"></a>1m =&gt; 1000000 bytes</h1><h1 id="1mb-gt-1024-1024-bytes"><a href="#1mb-gt-1024-1024-bytes" class="headerlink" title="1mb =&gt; 1024*1024 bytes"></a>1mb =&gt; 1024*1024 bytes</h1><h1 id="1g-gt-1000000000-bytes"><a href="#1g-gt-1000000000-bytes" class="headerlink" title="1g =&gt; 1000000000 bytes"></a>1g =&gt; 1000000000 bytes</h1><h1 id="1gb-gt-102410241024-bytes"><a href="#1gb-gt-102410241024-bytes" class="headerlink" title="1gb =&gt; 102410241024 bytes"></a>1gb =&gt; 1024<em>1024</em>1024 bytes</h1><p>可以看出，redis配置中对单位的大小写不敏感，1GB、1Gb和1gB都是相同的。由此也说明，redis只支持bytes，不支持bit单位。</p><p>redis支持“主配置文件中引入外部配置文件”，很像C/C++中的include指令，比如：<br> 代码如下:</p><p>include /path/to/other.conf<br>如果你看过redis的配置文件，会发现还是很有条理的。redis配置文件被分成了几大块区域，它们分别是：</p><p>1.通用（general）<br>2.快照（snapshotting）<br>3.复制（replication）<br>4.安全（security）<br>5.限制（limits)<br>6.追加模式（append only mode)<br>7.LUA脚本（lua scripting)<br>8.慢日志（slow log)<br>9.事件通知（event notification）</p><h2 id="教你看懂redis配置-通用"><a href="#教你看懂redis配置-通用" class="headerlink" title="教你看懂redis配置 -通用"></a>教你看懂redis配置 -通用</h2><h2 id="教你看懂redis配置-–-快照"><a href="#教你看懂redis配置-–-快照" class="headerlink" title="教你看懂redis配置 – 快照"></a>教你看懂redis配置 – 快照</h2><h2 id="教你看懂redis配置-–-复制"><a href="#教你看懂redis配置-–-复制" class="headerlink" title="教你看懂redis配置 – 复制"></a>教你看懂redis配置 – 复制</h2><h2 id="教你看懂redis配置-–-安全"><a href="#教你看懂redis配置-–-安全" class="headerlink" title="教你看懂redis配置 – 安全"></a>教你看懂redis配置 – 安全</h2><h2 id="教你看懂redis配置-限制"><a href="#教你看懂redis配置-限制" class="headerlink" title="教你看懂redis配置 -限制"></a>教你看懂redis配置 -限制</h2><h2 id="教你看懂redis配置-–-追加模式"><a href="#教你看懂redis配置-–-追加模式" class="headerlink" title="教你看懂redis配置 – 追加模式"></a>教你看懂redis配置 – 追加模式</h2><h2 id="教你看懂redis配置-–-LUA脚本"><a href="#教你看懂redis配置-–-LUA脚本" class="headerlink" title="教你看懂redis配置 – LUA脚本"></a>教你看懂redis配置 – LUA脚本</h2><h2 id="教你看懂redis配置-–-慢日志"><a href="#教你看懂redis配置-–-慢日志" class="headerlink" title="教你看懂redis配置 – 慢日志"></a>教你看懂redis配置 – 慢日志</h2><h2 id="教你看懂redis配置-–-事件通知"><a href="#教你看懂redis配置-–-事件通知" class="headerlink" title="教你看懂redis配置 – 事件通知"></a>教你看懂redis配置 – 事件通知</h2><h2 id="教你看懂redis配置-–-高级配置"><a href="#教你看懂redis配置-–-高级配置" class="headerlink" title="教你看懂redis配置 – 高级配置"></a>教你看懂redis配置 – 高级配置</h2>]]></content>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>乐观锁，悲观锁</title>
      <link href="/2017/03/08/mysql/2017-03-08-Locking/"/>
      <url>/2017/03/08/mysql/2017-03-08-Locking/</url>
      <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/coderMark/p/5599508.html" target="_blank" rel="noopener">原文地址</a></p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p> 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库 性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。 而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p>实现方式：大多数基于数据版本记录机制实现，即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。  </p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;hibernate-mapping &gt;  </span><br><span class="line"> &lt;class name=&quot;org.hibernate.sample.TUser&quot; table=&quot;t_user&quot; dynamic-update=&quot;true&quot; dynamic-insert=&quot;true&quot; optimistic-lock=&quot;version&quot;&gt;  </span><br><span class="line"> &lt;/class&gt;  </span><br><span class="line">&lt;/hibernate-mapping &gt;</span><br></pre></td></tr></table></figure><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。</p><p>数据库锁机制:</p><ul><li><p>未提交读（read uncommitted）</p></li><li><p>提交读（read committed）</p></li><li><p>重复读（repeatable read）</p></li><li><p>序列化（serializable）</p></li></ul><p>锁机制：</p><p>   共享锁：其他事务可以读，但不能修改。</p><p>   排他锁：其他事务不能读取。</p><p>锁粒度：一般分为：行锁、表锁、库锁</p><p>解释：</p><ul><li><p>未提交读（read uncommitted）</p><pre><code>一个更新数据库的事务A在未commit的情况下，另一个事务B正在读取事务A更新的记录，会产生脏读现象，这是因为A事务在开启 DB Transaction后，做一些DML操作时，记录会保存在内存中，这时B事务读取了A事务提交在内存中的数据，产生了脏读。</code></pre></li><li><p>提交读（read committed）</p><pre><code>数据的修改只有在commit之后，才会被读取。和1 相反。</code></pre></li><li><p>重复读（repeatable read）</p><pre><code>当数据库隔离级别设置成 repeatable read后，事务A中的select的过程中事务B可以修改A读取部分的数据，当A第2次执行同样的sql时，返回和上次相同的数据 ，消除不可重复读。</code></pre><p>  注：个人认为只是应为A事务采用这种隔离级别后，读取的是数据库在事务开始时间点的映象，在这个时间点后的所有操作都不会对A事务中的查询产生影响，依据是本文后续的实验，如果有疑问，请指出。</p></li><li><p>序列化（serializable）</p><pre><code>当数据库隔离级别设置成Serializeable后，事务A中的select 会以共享锁锁定相关的数据（在select 返回的数据结果集），这些数据不可以被修改（可以被读取），若事务B对这些数据做UPDATE操作，会处于等待状态，消除幻读。</code></pre><p>   注：事务B可以UPDATE 事务A中为锁定的数据，后面的实验可以证明。</p></li></ul><p>实现方式：</p><p>悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>Hibernate的加锁模式有：<br>Ø LockMode.NONE ： 无锁机制。<br>Ø LockMode.WRITE ：Hibernate在Insert和Update记录的时候会自动<br>获取。<br>Ø LockMode.READ ： Hibernate在读取记录的时候会自动获取。<br>以上这三种锁机制一般由Hibernate内部使用，如Hibernate为了保证Update<br>过程中对象不会被外界修改，会在save方法实现中自动为目标对象加上WRITE锁。<br>Ø LockMode.UPGRADE ：利用数据库的for update子句加锁。<br>Ø LockMode. UPGRADE_NOWAIT ：Oracle的特定实现，利用Oracle的for update nowait子句实现加锁。</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> String hqlStr  =   &quot; from TUser as user where user.name=’Erica’ &quot; ;</span><br><span class="line"> Query query  =  session.createQuery(hqlStr);</span><br><span class="line"> query.setLockMode( &quot; user &quot; ,LockMode.UPGRADE);  // 加锁  </span><br><span class="line"> List userList  =  query.list(); // 执行查询，</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">获取数据 query.setLockMode 对查询语句中特定别名所对应的记录进行加锁（我们为 TUser类指定了一个别名“user”），这里也就是对返回的所有user记录进行加锁。 观察运行期Hibernate生成的SQL语句：</span><br></pre></td></tr></table></figure><p>select tuser0_.id as id, tuser0_.name as name, tuser0_.group_id as group_id, tuser0_.user_type as user_type, tuser0_.sex as sex from t_user tuser0_ where (tuser0_.name = ’Erica’ )  for  update<br><code>`</code><br>这里Hibernate通过使用数据库的for update子句实现了悲观锁机制。</p><p>上面这两种锁机制是我们在应用层较为常用的，加锁一般通过以下方法实现：<br>Criteria.setLockMode<br>Query.setLockMode<br>Session.lock<br>注意，只有在查询开始之前（也就是Hiberate 生成SQL 之前）设定加锁，才会 真正通过数据库的锁机制进行加锁处理，否则，数据已经通过不包含for update 子句的Select SQL加载进来，所谓数据库加锁也就无从谈起。</p><p>三种并发容易遇到的问题。</p><ul><li><p>脏读：一个事务读取到了另外一个事务没有提交的数据。</p></li><li><p>不可重复度：在同一事务中，两次读取同一数据，得到内容不同。举例：事务A查询一条数据，事务B更新事务A查询的这条数据，事务A再次查询这条数据，数据却不一样，出现了不可重复读错误。</p></li><li><p>幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同。举例：事务A查询第一次查询出一条记录，事务B插入一条数据，事务A再次查询，查询出两条记录，出现了幻读。</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 数据存储 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式事务（转载）</title>
      <link href="/2017/03/04/spring/2018-03-04-Distributed-Transaction/"/>
      <url>/2017/03/04/spring/2018-03-04-Distributed-Transaction/</url>
      <content type="html"><![CDATA[<p>写的非常不错的一篇博客，过段时间稳定后向大佬看齐，<a href="https://www.cnblogs.com/binyue/p/3678390.html" target="_blank" rel="noopener">对分布式事务的理解</a></p>]]></content>
      
      
        <tags>
            
            <tag> 数据存储 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库事务</title>
      <link href="/2017/02/28/mysql/2018-02-28-Transaction/"/>
      <url>/2017/02/28/mysql/2018-02-28-Transaction/</url>
      <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zhangqian1031/p/6542037.html" target="_blank" rel="noopener">原文地址：https://www.cnblogs.com/zhangqian1031/p/6542037.html</a></p><p>什么是事务、事务特性、事务隔离级别</p><h2 id="什么是事务："><a href="#什么是事务：" class="headerlink" title="什么是事务："></a>什么是事务：</h2><p>事务是程序中一系列严密的操作，所有操作执行必须成功完成，否则在每个操作所做的更改将会被撤销，这也是事务的原子性（要么成功，要么失败）。</p><h2 id="事务特性："><a href="#事务特性：" class="headerlink" title="事务特性："></a>事务特性：</h2><p>事务特性分为四个：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）简称ACID。</p><ul><li><p>原子性（Atomicity）:事务是数据库逻辑工作单元，事务中包含的操作要么都执行成功，要么都执行失败。</p></li><li><p>一致性（Consistency）：事务执行的结果必须是使数据库数据从一个一致性状态变到另外一种一致性状态。当事务执行成功后就说数据库处于一致性状态。如果在执行过程中发生错误，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这是数据库就处于不一致状态。</p></li><li><p>隔离性（Isolation）：一个事务的执行过程中不能影响到其他事务的执行，即一个事务内部的操作及使用的数据对其他事务是隔离的，并发执行各个事务之间无不干扰。</p></li><li><p>持续性（Durability）：即一个事务执一旦提交，它对数据库数据的改变是永久性的。之后的其它操作不应该对其执行结果有任何影响。</p></li></ul><h2 id="事务的隔离级别："><a href="#事务的隔离级别：" class="headerlink" title="事务的隔离级别："></a>事务的隔离级别：</h2><p>事务的隔离级别也分为四种，由低到高依次分别为：read uncommited（未提交读）、read commited（提交读）、read repeatable（重复读）、serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><ul><li><p>read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。</p></li><li><p>read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</p></li><li><p>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。</p></li><li><p>serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。</p></li></ul><p>脏读、不可重复读、幻象读概念说明：</p><ul><li>脏读：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。</li></ul><ul><li>不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。</li></ul><ul><li>幻象读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 数据存储 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017书单</title>
      <link href="/2017/01/01/life/2017-1-1-books/"/>
      <url>/2017/01/01/life/2017-1-1-books/</url>
      <content type="html"><![CDATA[<h2 id="书架"><a href="#书架" class="headerlink" title="书架"></a>书架</h2><p>–2017书单</p><h2 id="greate-minds：source"><a href="#greate-minds：source" class="headerlink" title="greate minds：source"></a>greate minds：<a href="https://github.com/camda/mybook/tree/master/minds" target="_blank" rel="noopener">source</a></h2><pre><code>+ 深入浅出设计模式+ 人月神话+ 代码整洁之道+ 程序员修炼之道+ 编程之美：微软技术面试心得+ 编程珠玑+ 编程珠玑（续）+ 设计模式+ Java程序员修炼之道+ 算法导论3</code></pre><h2 id="java：source"><a href="#java：source" class="headerlink" title="java：source"></a>java：<a href="https://github.com/camda/mybook/tree/master/java" target="_blank" rel="noopener">source</a></h2><pre><code>+ Java_TCPIP_Socket网络编程</code></pre><h2 id="smart：source"><a href="#smart：source" class="headerlink" title="smart：source"></a>smart：<a href="https://github.com/camda/mybook/tree/master/smart" target="_blank" rel="noopener">source</a></h2><pre><code>+ 周志华-机器学习+ 周志华-数据挖掘与机器学习</code></pre><h2 id="framework：source"><a href="#framework：source" class="headerlink" title="framework：source"></a>framework：<a href="https://github.com/camda/mybook/tree/master/framework" target="_blank" rel="noopener">source</a></h2><pre><code>+ Hibernate开发指南+ SpringGuide+ Spring源码深度解析+ dubbo源码解析2.0+ ZooKeeper</code></pre><h2 id="other-source"><a href="#other-source" class="headerlink" title="other: source"></a>other: <a href="https://github.com/camda/mybook/tree/master/other" target="_blank" rel="noopener">source</a></h2><pre><code>+ 产品经理手册+ 经济学原理+ 你要如何衡量你的人生+ 牛津通识精选+ 三体2 黑暗森林+ 手把手教你读财报+ More Effective C++</code></pre>]]></content>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Knockout.js笔记</title>
      <link href="/2016/12/16/javascript/2016-12-16-Knockout/"/>
      <url>/2016/12/16/javascript/2016-12-16-Knockout/</url>
      <content type="html"><![CDATA[<h1 id="1-Knockout-js简介"><a href="#1-Knockout-js简介" class="headerlink" title="1.Knockout.js简介"></a>1.Knockout.js简介</h1><p>Knockout是一个轻量级的UI类库，通过应用MVVM模式使JavaScript前端UI简单化。</p><p>Knockout有如下4大重要概念：</p><ul><li>声明式绑定 (Declarative Bindings)：使用简明易读的语法很容易地将模型(model)数据关联到DOM元素上。</li><li>UI界面自动刷新 (Automatic UI Refresh)：当您的模型状态(model state)改变时，您的UI界面将自动更新。</li><li>依赖跟踪 (Dependency Tracking)：为转变和联合数据，在你的模型数据之间隐式建立关系。</li><li>模板 (Templating)：为您的模型数据快速编写复杂的可嵌套的UI。</li></ul><p>重要特性:</p><ul><li>优雅的依赖追踪- 不管任何时候你的数据模型更新，都会自动更新相应的内容。</li><li>声明式绑定- 浅显易懂的方式将你的用户界面指定部分关联到你的数据模型上。</li><li>灵活全面的模板- 使用嵌套模板可以构建复杂的动态界面。</li><li>轻易可扩展- 几行代码就可以实现自定义行为作为新的声明式绑定。</li></ul><p>额外的好处：</p><ul><li>纯JavaScript类库 – 兼容任何服务器端和客户端技术</li><li>可添加到Web程序最上部 – 不需要大的架构改变</li><li>简洁的 – Gzip之前大约25kb</li><li>兼容任何主流浏览器 (IE 6+、Firefox 2+、Chrome、Safari、其它)</li><li>Comprehensive suite of specifications （采用行为驱动开发） - 意味着在新的浏览器和平台上可以很容易通过验证。</li></ul><p>注：MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点</p><ol><li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li><li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。</li><li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li></ol><p>Knockout是一个以数据模型（data model）为基础的能够帮助你创建富文本，响应显示和编辑用户界面的JavaScript类库。任何时候如果你的UI需要自动更新（比如：更新依赖于用户的行为或者外部数据源的改变），KO能够很简单的帮你实现并且很容易维护。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS模块化之路RequireJS</title>
      <link href="/2016/12/15/javascript/2016-12-15-RequireJS/"/>
      <url>/2016/12/15/javascript/2016-12-15-RequireJS/</url>
      <content type="html"><![CDATA[<h2 id="1-1-RequireJS是什么？"><a href="#1-1-RequireJS是什么？" class="headerlink" title="1.1 RequireJS是什么？"></a>1.1 RequireJS是什么？</h2><p>RequireJS的目标是鼓励代码的模块化，它使用了不同于传统<code>&lt;script&gt;</code>标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。</p><h2 id="1-2-使用RequireJS"><a href="#1-2-使用RequireJS" class="headerlink" title="1.2 使用RequireJS"></a>1.2 使用RequireJS</h2><h3 id="1-2-1-加载JavaScript文件"><a href="#1-2-1-加载JavaScript文件" class="headerlink" title="1.2.1 加载JavaScript文件"></a>1.2.1 加载JavaScript文件</h3><p>RequireJS以一个相对于baseUrl的地址加载所有的js代码，baseUrl设置有两种方式：</p><h4 id="1-2-1-1-data-main属性"><a href="#1-2-1-1-data-main属性" class="headerlink" title="1.2.1.1 data-main属性"></a>1.2.1.1 data-main属性</h4><p>一个是用<code>&lt;scirpt&gt;</code>标签的data-main属性，例如：<br><code>&lt;script data-main=&quot;script/main.js&quot; src=&quot;script/require.js&quot;&gt;&lt;/script&gt;</code><br>页面在加载require.js后会自动加载main.js里的内容。此时的baseUrl的地址为<code>script/</code>。注：data-main是异步加载的，所以如果你在其他页面配置了其他的JS加载，则不能保证他们所依赖的JS已经加载成功。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script data-main=&quot;scripts/main&quot; src=&quot;scripts/require.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;scripts/other.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// contents of main.js:</span><br><span class="line">require.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        foo: &apos;libs/foo-1.1.3&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// contents of other.js:</span><br><span class="line"></span><br><span class="line">// This code might be called before the require.config() in main.js</span><br><span class="line">// has executed. When that happens, require.js will attempt to</span><br><span class="line">// load &apos;scripts/foo.js&apos; instead of &apos;scripts/libs/foo-1.1.3.js&apos;</span><br><span class="line">require( [&apos;foo&apos;], function( foo ) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-2-1-2-配置函数"><a href="#1-2-1-2-配置函数" class="headerlink" title="1.2.1.2 配置函数"></a>1.2.1.2 配置函数</h4><p>baseUrl亦可通过配置函数手动配置。如果没有显式指定config及data-main，则默认的baseUrl为包含RequireJS的那个HTML页面的所属目录。如果你需要修改RequireJS的默认配置来使用自己的配置，可以使用require.config函数，require.config函数需要传入一个可选的参数对象，如下是可以使用的配置参数选项。</p><ul><li>baseUrl–用于加载模块的根路径</li><li>paths–用于映射不存在于根路径下的模块路径</li><li>shims–配置在脚本/模块外面并没有使用RequireJS的函数依赖并且初始化函数。假设underscore并没有使用  RequireJS定义，但是你还是想通过RequireJS来使用它，那么你就需要在配置中把它定义为一个shim。</li><li>deps–加载依赖关系数组</li><li>exports–exports值（输出的变量名），表明这个模块外部调用时的名称</li></ul><p>一般来说，最好还是使用baseUrl及”paths” config去设置module ID。它会给你带来额外的灵活性，如便于脚本的重命名、重定位等。 同时，为了避免凌乱的配置，最好不要使用多级嵌套的目录层次来组织代码，而是要么将所有的脚本都放置到baseUrl中，要么分置为项目库/第三方库的一个扁平结构，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- www/</span><br><span class="line">  - index.html</span><br><span class="line">  - js/</span><br><span class="line">    - app/</span><br><span class="line">  -sub.js </span><br><span class="line">    - lib/</span><br><span class="line">  -jquery.js</span><br><span class="line">  -cancas.js</span><br><span class="line">  -app.js</span><br></pre></td></tr></table></figure></p><p>index.html</p><p><code>&lt;script data-main=&quot;js/app.js&quot; src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</code></p><p>app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">requirejs.config(&#123;</span><br><span class="line">    //By default load any module IDs from js/lib</span><br><span class="line">    baseUrl: &apos;js/lib&apos;,</span><br><span class="line">    //except, if the module ID starts with &quot;app&quot;,</span><br><span class="line">    //load it from the js/app directory. paths</span><br><span class="line">    //config is relative to the baseUrl, and</span><br><span class="line">    //never includes a &quot;.js&quot; extension since</span><br><span class="line">    //the paths config could be for a directory.</span><br><span class="line">    paths: &#123;</span><br><span class="line">        app: &apos;../app&apos;</span><br><span class="line">    &#125;</span><br><span class="line">shim: &#123;</span><br><span class="line">        &apos;backbone&apos;: &#123;</span><br><span class="line">            //The underscore script dependency should be loaded before loading backbone.js</span><br><span class="line">            deps: [&apos;underscore&apos;],</span><br><span class="line">            // use the global &apos;Backbone&apos; as the module name.</span><br><span class="line">            exports: &apos;Backbone&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Start the main app logic.</span><br><span class="line">requirejs([&apos;jquery&apos;, &apos;canvas&apos;, &apos;app/sub&apos;],</span><br><span class="line">function   ($, canvas, sub) &#123;</span><br><span class="line">    //jQuery, canvas and the app/sub module are all</span><br><span class="line">    //loaded and can be used here now.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="1-2-2-用RequireJS定义模块"><a href="#1-2-2-用RequireJS定义模块" class="headerlink" title="1.2.2 用RequireJS定义模块"></a>1.2.2 用RequireJS定义模块</h3><p>模块是进行了内部实现封装、暴露接口和合理限制范围的对象。ReuqireJS提供了define函数用于定义模块。按章惯例每个Javascript文件只应该定义一个模块。define函数接受一个依赖数组和一个包含模块定义的函数。通常模块定义函数会把前面的数组中的依赖模块按顺序做为参数接收。例如，下面是一个简单的模块定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define([&quot;logger&quot;], function(logger) &#123;        </span><br><span class="line">        return &#123;</span><br><span class="line">             firstName: “John&quot;,</span><br><span class="line">             lastName: “Black“,</span><br><span class="line">             sayHello: function () &#123;</span><br><span class="line">                logger.log(‘hello’);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>我们看，一个包含了logger的模块依赖数组被传给了define函数,该模块后面会被调用。同样我们看所定义的模块中有一个名为logger的参数，它会被设置为logger模块。每一个模块都应该返回它的API.这个示例中我们有两个属性(firstName和lastName)和一个函数(sayHello)。然后，只要你后面定义的模块通过ID来引用这个模块，你就可以使用其暴露的API。</p><h3 id="1-2-3-使用require函数"><a href="#1-2-3-使用require函数" class="headerlink" title="1.2.3 使用require函数"></a>1.2.3 使用require函数</h3><p>在RequireJS中另外一个非常有用的函数是require函数。require函数用于加载模块依赖但并不会创建一个模块。例如：下面就是使用require定义了能够使用jQuery的一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;jquery&apos;], function ($) &#123;</span><br><span class="line">    //jQuery was loaded and can be used now</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2015/08/04/algorithm/2015-08-04-BubbleSort/"/>
      <url>/2015/08/04/algorithm/2015-08-04-BubbleSort/</url>
      <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>冒泡排序是依次比较数列相邻的两个数字的大小，按照从大到小或者从小到大的规则进行交换，重复遍历数列直至没有可交换的数列，排序完成。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>数列：[3,5,1,7,4]</p><p>规则：从小到大</p><p>排序：</p><ul><li>比较3-5，5大于3，不交换，数列不变[3,5,1,7,4]</li><li>比较5-1,5大于1，交换，数列变化[3,1,5,7,4]</li><li>比较5-7,7大于5，不交换，数列不变[3,1,5,7,4]</li><li>比较7-4,7大约4，交换，数列变化[3,1,5,4,7]</li><li>然后重复遍历数列,直至最后没有可以交换的数列。</li></ul><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    public static void bubbleSort()&#123;</span><br><span class="line">//        int[] arr = &#123;3,5,7,1,4&#125;;</span><br><span class="line">        int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">        int i,j,temp,len=arr.length;</span><br><span class="line">        //是否已经完成排序的标志</span><br><span class="line">        boolean flag;</span><br><span class="line">        //排序</span><br><span class="line">        for(i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            for(j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">                if(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    flag = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                System.out.println(&quot;第&quot; + (i+1) + &quot;趟结束了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出数组</span><br><span class="line">        for(int o:arr)&#123;</span><br><span class="line">            System.out.print(&quot; &quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>最坏情况下：第1趟排序需要比较(n-1)次，… 第(n-1)趟比较1次，O(n)=((n-1)+1)<em>(n-1)/2=n</em>(n-1)/2=n^2。</p><p>最好情况下：比较(n-1)次。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
