<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Redis 设计与实现</title>
      <link href="/zhongyp.github.io/redis/2019-06-21-redis/"/>
      <url>/zhongyp.github.io/redis/2019-06-21-redis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据结构与对象"><a href="#1-数据结构与对象" class="headerlink" title="1. 数据结构与对象"></a>1. 数据结构与对象</h2><h3 id="1-1-简单动态字符串（SDS）"><a href="#1-1-简单动态字符串（SDS）" class="headerlink" title="1.1 简单动态字符串（SDS）"></a>1.1 简单动态字符串（SDS）</h3><p>Redis没有使用C语言传统的字符串表示，而是构建了一种简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。Redis只会使用C字符串作为字面量。<br>除了用来保存数据库中的字符串值之外，SDS还被用做缓冲区(buffer): AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是SDS实现的。</p><h4 id="1-1-1-SDS的定义"><a href="#1-1-1-SDS的定义" class="headerlink" title="1.1.1 SDS的定义"></a>1.1.1 SDS的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    // 记录buf数组中已使用字节的数量</span><br><span class="line">    // 等于SDS所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    // 记录buf数组中未使用字节的数量</span><br><span class="line">    int free;</span><br><span class="line">    // 字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/15611092689335.jpg" alt="SDS示例"></p><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。</p><h4 id="1-1-2-与C字符串的区别"><a href="#1-1-2-与C字符串的区别" class="headerlink" title="1.1.2 与C字符串的区别"></a>1.1.2 与C字符串的区别</h4><ol><li>获取字符串长度复杂度：C字符串不记录长度信息，所以获取字符串长度复杂度为O(N)，SDS为O(1)。</li><li>杜绝缓冲区溢出：<code>strcat</code>函数可以将src字符串中的内容拼接到dest字符串的末尾:<br><code>char *strcat(char *dest, const char *src)</code><br>因为C字符创不记录自身的长度，所以<code>strcat</code>假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立，就会产生缓冲区溢出。SDS在执行拼接操作之前检查s的长度是否足够，在发现s目前的空间不足以拼接时，sdscat就会扩展s的空间，然后执行拼接操作。</li><li>减少修改字符串时带来的内存重分配次数：b中说道每次拼接字符串时，C字符串都要对C字符串进行一次内存重分配操作（即：在拼接操作，需要扩展空间大小，否则缓冲区溢出；在截断操作，需要释放多余空间，否则内存泄漏），因为重分配是比较耗时的操作，所以为了避免频繁修改字符串对性能造成的影响，SDS通过未使用空间接触了字符串长度和底层数组长度之间的关联：SDS中，buf的长度不一定是字符数量+1，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</li></ol><blockquote><p>空间预分配</p><ul><li>如果对SDS进行修改之后，SDS的长度小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。</li><li>如果对SDS修改之后，SDS的长度大于1MB，那么程序会分配1MB的未使用空间。</li></ul><p>惰性空间释放</p><ul><li>当 SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录下来，并等待将来使用。同时SDS提供了相应的API，在有需要时，释放SDS未使用的空间，这样就可以避免惰性空间释放策略会造成内存浪费。</li></ul></blockquote><h4 id="1-1-3-二进制安全"><a href="#1-1-3-二进制安全" class="headerlink" title="1.1.3 二进制安全"></a>1.1.3 二进制安全</h4><p>C语言字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符串，所以C字符串只能保存文本数据，不能保存二进制数据。<br>SDS的API都是二进制安全(binary-safe)的。</p><h4 id="1-1-4-兼容部分C字符串的函数"><a href="#1-1-4-兼容部分C字符串的函数" class="headerlink" title="1.1.4 兼容部分C字符串的函数"></a>1.1.4 兼容部分C字符串的函数</h4><p>虽然SDS的API都是二进制安全的，但是API总会将SDS保存的数据的末尾设置为空字符串，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数。</p><h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><p>当一个列表键包含数量比较多的元素，又或者包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区(output buffer)。</p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li><li>带链表长度的计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h3 id="1-3-字典"><a href="#1-3-字典" class="headerlink" title="1.3 字典"></a>1.3 字典</h3><h4 id="1-3-1-结构"><a href="#1-3-1-结构" class="headerlink" title="1.3.1 结构"></a>1.3.1 结构</h4><p>字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair)的抽象数据结构。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><p>字典结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">    // 类型特定函数</span><br><span class="line">    dicType *type;</span><br><span class="line">    </span><br><span class="line">    // 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line">    </span><br><span class="line">    // 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    </span><br><span class="line">    // rehash索引</span><br><span class="line">    // 当rehash不在进行时，值为-1</span><br><span class="line">    in threhash; /* rehashing not in progress if rehashidx == -1 */</span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。<br>pridata属性则保存了需要传给那些类型特定函数的可选参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dicType&#123;</span><br><span class="line"></span><br><span class="line">// 计算哈希值的函数</span><br><span class="line">unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">// 复制键的函数</span><br><span class="line">void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">// 对比键的函数</span><br><span class="line">int (*keyCompare)(void *privdata,const void *key1,const void *key);</span><br><span class="line"></span><br><span class="line">// 销毁键</span><br><span class="line">(*keyDestructor)(void *privdata,void *key);</span><br><span class="line"></span><br><span class="line">// 复制值</span><br><span class="line">void(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">// 销毁值</span><br><span class="line">void(*valDestructor)(void *privdata,void *obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ht属性是一个包含两个项的数组，数组的每项都是dictht哈希表，一般情况下只是用ht[0]，ht[1]只会在对ht[0]哈希表进行rehash时使用。<br>除ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有进行rehash，那么它的值为-1。<br><img src="/media/article/dicht.png" alt="dic"></p><h4 id="1-3-2-哈希算法"><a href="#1-3-2-哈希算法" class="headerlink" title="1.3.2 哈希算法"></a>1.3.2 哈希算法</h4><p>Redis使用的是<a href="http://code.google.com/p/smhasher/" target="_blank" rel="noopener">MurmurHash2</a>算法。</p><ol><li>算出hash值：hash=dict-&gt;type-&gt;hashFunction(key);</li><li>根据hash值计算索引值：index = hash &amp; dict-&gt;ht[x].sizemask;//x是0或1</li></ol><h4 id="1-3-4-键冲突"><a href="#1-3-4-键冲突" class="headerlink" title="1.3.4 键冲突"></a>1.3.4 键冲突</h4><p>Redis的哈希表使用链地址法(separate chaining)来解决冲突，每个哈希表节点都有一个next指针，多个哈希表节点就可以用next指针构成一个单项链表。速度考虑，最新节点添加到表头位置，复杂度O(1)。</p><h4 id="1-3-5-rehash"><a href="#1-3-5-rehash" class="headerlink" title="1.3.5 rehash"></a>1.3.5 rehash</h4><blockquote><p><strong>为什么无论是HashMap还是Redis，扩容/收缩时容量大小都是2的幂？</strong></p><ul><li>减少碰撞次数，比如1111&amp;1110=1110，1110&amp;1110=1110；</li><li>容量*2不至于分配空间过大造成浪费；</li></ul></blockquote><p>Redis对字典的rehash步骤如下：</p><ol><li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量：</li></ol><ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n；</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^2；</li></ul><ol start="2"><li>将保存在ht[0]中的所有键值对rehash到ht[1]上:rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li></ol><p><strong> 哈希表的扩展与收缩 </strong></p><p>当以下条件中的任意一个呗满足时，程序会自动开始对哈希表执行扩展操作：</p><ul><li>服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子=哈希表已保存节点数量/哈希表大小</span><br><span class="line">load_factor = ht[0].used/ht[0].size</span><br></pre></td></tr></table></figure><p>执行BGSAVE或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，大多数操作系统都采用写时复制(copy-on-write)技术优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子。<br>当哈希表的负载因子小于0.1时，程序自动开始执行收缩操作。</p><h4 id="1-3-6-渐进式rehash"><a href="#1-3-6-渐进式rehash" class="headerlink" title="1.3.6 渐进式rehash"></a>1.3.6 渐进式rehash</h4><p>rehash动作不是一次性、集中式的完成，而是分多次、渐进式的完成。<br>渐进式rehash步骤:</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序出了执行指定的操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash值ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作完成。</li></ol><p>在渐进式rehash期间，字典的删除、查找、更新等操作会在两个哈希表上进行。如果新加到字典的键值对一律被保存到ht[1]里面。</p><h3 id="1-4-跳跃表"><a href="#1-4-跳跃表" class="headerlink" title="1.4 跳跃表"></a>1.4 跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p><h4 id="1-4-1-结构"><a href="#1-4-1-结构" class="headerlink" title="1.4.1 结构"></a>1.4.1 结构</h4><p><img src="/media/article/skiplist.png" alt="skiplist"><br>上图展示了一个跳跃表示例，左边是zskiplist结构：</p><ul><li>header: 指向跳跃表的表头节点</li><li>tail: 指向跳跃表的结尾节点</li><li>level: 记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length: 记录跳跃表的长度，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>右侧是zskiplistNode结构：</p><ul><li>level: 节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，以此类推。每层两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，跨度则记录了前进指针所指向节点和当前节点的距离。</li><li>backward: 节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>score: 各个节点中的1.0、2.0、和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排序。</li><li>obj: 各个节点中的o1、o2和o3时节点所保存的成员对象。</li></ul><h3 id="1-5-整数集合"><a href="#1-5-整数集合" class="headerlink" title="1.5 整数集合"></a>1.5 整数集合</h3><p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。<br>整数集合是Redis用于保存整数值的集合抽象数据结构，他可以保存集合类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    // 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    // 集合包含的元素</span><br><span class="line">    uint32_t length;</span><br><span class="line">    // 保存元素的数据</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现:整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小从小打到有序的排列，并且数组中不包含任何重复项。</p><h4 id="1-5-1-整数集合升级"><a href="#1-5-1-整数集合升级" class="headerlink" title="1.5.1 整数集合升级"></a>1.5.1 整数集合升级</h4><p>每当我们将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合先进行升级，然后添加到整数集合里面。</p><p>升级步骤：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，放置元素过程中，需要维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><h3 id="1-6-压缩列表"><a href="#1-6-压缩列表" class="headerlink" title="1.6 压缩列表"></a>1.6 压缩列表</h3><p>当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><p>压缩列表是为了节约内存开发的，是由一系列特殊编码的连续内存块组织的顺序(sequential)数据结构。</p><p><img src="/media/article/ziplist.png" alt="ziplist"><br><img src="/media/article/ziplistintroduce.png" alt="ziplistintroduce"></p><p>节点content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><h4 id="1-6-1-连锁更新"><a href="#1-6-1-连锁更新" class="headerlink" title="1.6.1 连锁更新"></a>1.6.1 连锁更新</h4><p>连锁更新最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最快复杂度为O(N)，所以更新的最快复杂度为O(N^2)。</p><h3 id="1-7-快速列表-quicklist"><a href="#1-7-快速列表-quicklist" class="headerlink" title="1.7 快速列表(quicklist)"></a>1.7 快速列表(quicklist)</h3><p>quicklist是一个ziplist的双向链表（双向链表是由多个节点Node组成的）。也就是说quicklist的每个节点都是一个ziplist。ziplist本身也是一个能维持数据项先后顺序的列表（按插入位置），而且是一个各个数据项在内存上前后相邻的列表。<br>结构如下:</p><p><img src="/media/article/quicklist.png" alt="quicklist"><br>图片来自<a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a></p><p>quicklist基于空间和时间的考虑，结合双向链表和ziplist的优点。</p><blockquote><p>双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。<br>ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。<br>摘自<a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau Redis源码剖析–quicklist</a></p></blockquote><h3 id="1-8-对象"><a href="#1-8-对象" class="headerlink" title="1.8 对象"></a>1.8 对象</h3><p>Redis并没有 直接使用SDS、双端链表、字典、压缩列表、整数集合这些数据结构实现键值对数据库，而是基于这些数据结构创建了一个对象系统。对象系统包含：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。<br>Redis的对象系统实现了基于引用计数计数的内存回收机制，当程序 不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外Redis还通过引用计数技术实现了对象共享机制，这种机制在适当情况下，通过让多个数据库键共享同一个对象来节约内存。<br>Redis对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能情况下，空转时长较大的那些键可能会优先被服务器删除。</p><h4 id="1-8-1-对象的类型与编码"><a href="#1-8-1-对象的类型与编码" class="headerlink" title="1.8.1 对象的类型与编码"></a>1.8.1 对象的类型与编码</h4><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，一个对象用作键值对的值。</p><p>Redis中的每个对象都由一个RedisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    </span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    </span><br><span class="line">    // 指向底层实现数据结构的指针</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>type记录了对象的类型：</p><ul><li>REDIS_STRING:字符串对象</li><li>REDIS_LIST:列表对象</li><li>REDIS_HASH:哈希对象</li><li>REDIS_SET:集合对象</li><li>REDIS_ZSET:有序集合对象</li></ul><blockquote><p>字符串键指的是这个数据库键所对应的值得字符串对象<br>列表键指的是数据库键所对应的值为列表对象</p></blockquote><p>ptr指针指向对象的底层实现数据结构，这些数据结构由对象的encoding属性决定。encoding记录对象使用的编码：</p><p><img src="/media/article/encoding-type.png" alt="encoding"><br>除上述列表外，还有一个是REDIS_ENCODING_QUICKLIST编码，快速列表。</p><p>每种类型的对象都至少使用了两种不同编码，下表列出了每种类型的对象可以使用的编码。</p><p><img src="/media/article/type-encoding.png" alt="type-encoding"></p><p>除上述列表外，还有一个是REDIS_LIST对应REDIS_ENCODING_QUICKLIST。</p><h4 id="1-8-2-字符串对象"><a href="#1-8-2-字符串对象" class="headerlink" title="1.8.2 字符串对象"></a>1.8.2 字符串对象</h4><p>字符串对象的编码可以是int、raw或者embstr。<br>如果字符串对象保存的是整数值，将字符串对象的编码设置为int。<br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度大于32字节，字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为raw。<br>raw结构：<br><img src="/media/article/raw.png" alt="raw"><br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度小于32字节，字符串对象将使用embstr编码的方式保存这个字符串值。<br>embstr内存块结构：<br><img src="/media/article/embstr.png" alt="embstr"><br><strong>raw和embstr区别：</strong></p><ul><li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li><li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码字符串对象比起来raw编码的字符串能够更好地利用缓存带来的优势。</li></ul><p>字符串对象保存各类型值得编码方式:</p><p><img src="/media/article/string-type-value.png" alt="string"></p><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。<br>Redis没有为embstr编码的字符串对象编写任何响应的修改程序，所以embstr编码的字符串对象实际上是只读的。</p><p><img src="/media/article/string-order-implement.png" alt="string"></p><h4 id="1-8-3-列表对象"><a href="#1-8-3-列表对象" class="headerlink" title="1.8.3 列表对象"></a>1.8.3 列表对象</h4><p>列表对象的编码可以使ziplist或者linkedlist。<br>ziplist结构如下：<br><img src="/media/article/ziplist-store.png" alt="ziplist"></p><p>linkedlist结构如下：</p><p><img src="/media/article/linkedlist-store.png" alt="linkedlist"></p><p>StringObject结构：</p><p><img src="/media/article/string-obj-store.png" alt="string-object"></p><p>当列表对象满足如下条件时，使用ziplist编码：<br>列表对象保存的所有字符串元素的长度都小于64字节；<br>列表对象保存的元素数量小于512个；</p><p><strong>列表命令的实现：</strong><br><img src="/media/article/list-order-implement.png" alt="list-order"></p><h4 id="1-8-4-哈希对象"><a href="#1-8-4-哈希对象" class="headerlink" title="1.8.4 哈希对象"></a>1.8.4 哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值得压缩列表节点推入到压缩列表表尾：</p><ul><li>因此保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;HSET profile name &quot;Tom&quot;</span><br><span class="line">&gt;HSET profile age 25</span><br><span class="line">&gt;HSET profile career &quot;Programmer&quot;</span><br></pre></td></tr></table></figure></p><p>哈希对象的压缩列表底层实现：</p><p><img src="/media/article/hash-ziplist-implement.png" alt="hash-ziplist-implement"></p><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><p>如果上述例子不是ziplist而是hashtable，则结构如下：</p><p><img src="/media/article/hashtable-implement.png" alt="hashtable-implement"></p><p>如果哈希对象满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值得字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；</li></ul><p><strong>hash命令：</strong></p><p><img src="/media/article/hash-order.png" alt="hash-order"></p><h4 id="1-8-5-集合对象"><a href="#1-8-5-集合对象" class="headerlink" title="1.8.5 集合对象"></a>1.8.5 集合对象</h4><p>集合对象编码可以是intset或者hashtable。</p><p><strong>集合命令：</strong></p><p><img src="/media/article/set-order.png" alt="set-order"><br><img src="/media/article/set-order1.png" alt="set-order"></p><h4 id="1-8-6-有序集合对象"><a href="#1-8-6-有序集合对象" class="headerlink" title="1.8.6 有序集合对象"></a>1.8.6 有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist。</p><p><strong>ziplist的的存储结构：</strong></p><p><img src="/media/article/sorted-set-ziplist.png" alt="sorted-set-ziplist"><br><img src="/media/article/sorted-set-ziplist1.png" alt="sorted-set-ziplist"></p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset&#123;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点保存了一个集合元素:跳跃表节点的Object属性保存了元素的成员，而跳跃表的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，如<code>ZRANK</code>、<code>ZRANGE</code>等命令就是基于跳跃表API来实现的。</p><p>除此之外，zset结构中的dict字典为有序集合创建了一个从成员的分值的映射，字典中的每个键值对都保存了一个集合元素:字典的键保存了元素的成员，而字典的值保存了元素的分值。通过这个字典，程序可以O(1)复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的。</p><p>虽然zset结构同时使用跳跃表和字典来保存有序集合元素，而这两种数据机构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或分值，也不会浪费额外内存。</p><blockquote><p><strong>为什么有序集合需要同时使用跳跃表和字典来实现？</strong><br>如果我们只是用字典来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p></blockquote><p><strong>skiplist结构：</strong></p><p><img src="/media/article/sorted-set-skiplist.png" alt="sorted-set-skiplist"></p><p><strong><em>注意：字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p><strong>命令实现：</strong></p><p><img src="/media/article/sorted-set-order.png" alt="sorted-set-order"></p><h4 id="1-8-7-类型检查与命令多态"><a href="#1-8-7-类型检查与命令多态" class="headerlink" title="1.8.7 类型检查与命令多态"></a>1.8.7 类型检查与命令多态</h4><p>Redis中用于操作键的命令基本上可以分为两种类型。<br>一种可以对任何类型键执行；另一种只能对特定类型的键执行。</p><p>Redis在执行一个类型特定的命令之前，会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。<br>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的:</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需类型，如果是的话执行。</li><li>否则，拒绝执行，返回类型错误。</li></ul><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。如llen：</p><p><img src="/media/article/llen-order.png" alt="llen-order"></p><h4 id="1-8-8-内存回收"><a href="#1-8-8-内存回收" class="headerlink" title="1.8.8 内存回收"></a>1.8.8 内存回收</h4><p>因为C不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数(reference counting)技术实现的内存回收机制。</p><h4 id="1-8-9-对象共享"><a href="#1-8-9-对象共享" class="headerlink" title="1.8.9 对象共享"></a>1.8.9 对象共享</h4><p>Redis对象的引用计数属性还带有对象共享的作用（多个键共享同一个值对象）。<br>这些共享对象不单单只有字符串键可以使用，那些数据结构中嵌套了字符串对象的对象都可以使用这些共享对象。</p><p>Redis只对包含整数值的字符串对象进行共享。</p><h4 id="1-8-10-对象的空转时长"><a href="#1-8-10-对象的空转时长" class="headerlink" title="1.8.10 对象的空转时长"></a>1.8.10 对象的空转时长</h4><p>除了type、encoding、ptr和refcount四个属性外，redisObject结构包含的最后一个属性为lru属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    unsigned lru:22;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>OBJECT IDLETIME命令可以打印出键的空转时长，计算方式：当前时间-lru。</p><h2 id="2-单机数据库实现"><a href="#2-单机数据库实现" class="headerlink" title="2. 单机数据库实现"></a>2. 单机数据库实现</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p><p><strong>数据库结构示例：</strong><br><img src="/media/article/redis-db.png" alt="db"></p><p>redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典成为键空间：</p><p><strong>数据库键空间示例：</strong><br><img src="/media/article/redis-db-keyspace.png" alt="db"></p><p>键空间的键也就是数据库的键，每个键都是一个字符串对象。<br>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。<br>数据库的键空间是一个字典。</p><p><strong> 读写空间时的维护操作</strong></p><ul><li>读取一个键后，服务器会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>读取一个键后，服务器会更新键的LRU时间，可以使用OBJECT idletime <key> 命令查看键key的闲置时间。</key></li><li>如果服务器在读取一个键时发现该键过期，服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果客户端使用watch命令监视了某个键，那么服务器在对被监视的键进行修改后，会将这个键标记为脏(dirty)。</li><li>服务器每次修改一个键后，都会对(dirty)键计数器的值增1，这个计数器会触发服务器的持久化及复制操作。</li><li>如果服务器开启了数据库通知功能，那么对键进行修改之后，服务器将按配置发送响应的数据库通知。</li></ul><h3 id="2-1-过期时间"><a href="#2-1-过期时间" class="headerlink" title="2.1 过期时间"></a>2.1 过期时间</h3><p>Redis有四种不同的命令可以用于设置键的生存时间或过期时间:</p><ul><li><code>EXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl秒。</li><li><code>PEXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl毫秒。</li><li><code>EXPIREAT&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp秒数时间戳。</li><li><code>PEXPIRE&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp毫秒数时间戳。</li></ul><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典:</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><p>PERSIST命令可以移除一个键的过期时间。</p><p>TTL命令以秒级单位返回键的剩余生存时间，PTTL命令以毫秒为单位返回键的剩余生存时间。</p><h3 id="2-2-过期键删除策略"><a href="#2-2-过期键删除策略" class="headerlink" title="2.2 过期键删除策略"></a>2.2 过期键删除策略</h3><p>定时删除: 在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作。<br>惰性删除: 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。<br>定期删除: 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><h4 id="2-2-1-定时删除"><a href="#2-2-1-定时删除" class="headerlink" title="2.2.1 定时删除"></a>2.2.1 定时删除</h4><p>定时删除对内存友好，对CPU时间不友好，在过期键比较多的情况下，删除过期键这一行为可能会占用相同一部分CPU时间。</p><h4 id="2-2-2-惰性删除"><a href="#2-2-2-惰性删除" class="headerlink" title="2.2.2 惰性删除"></a>2.2.2 惰性删除</h4><p>惰性删除策略对CPU友好，对内存不友好。有内存泄漏的风险。</p><h4 id="2-2-3-定期删除"><a href="#2-2-3-定期删除" class="headerlink" title="2.2.3 定期删除"></a>2.2.3 定期删除</h4><p>定期删除操作的难点在于如果确定删除操作的时长和频率。</p><h4 id="2-2-4-Redis的过期删除策略"><a href="#2-2-4-Redis的过期删除策略" class="headerlink" title="2.2.4 Redis的过期删除策略"></a>2.2.4 Redis的过期删除策略</h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略。</p><h4 id="2-2-5-AOF、RDB和复制功能对过期键的处理"><a href="#2-2-5-AOF、RDB和复制功能对过期键的处理" class="headerlink" title="2.2.5 AOF、RDB和复制功能对过期键的处理"></a>2.2.5 AOF、RDB和复制功能对过期键的处理</h4><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件是，程序会对数据库中的键进行检查，已过期的键不会保存到新建的RDB文件中。</p><p><strong>RDB文件载入：</strong></p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模型运行，那么载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过主从服务器在进行数据同步时，从服务器的数据库会被清空。</li></ul><p>AOF重写的过程中，会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><p>当服务器在复制模式下时，从服务器的过期键删除动作有主服务器控制:</p><ul><li>主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告诉从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，及时碰到过期键也不会将过期键删除，而继续像处理未过期的键一样处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令后，才会删除过期键。</li></ul><h4 id="2-2-6-数据库通知"><a href="#2-2-6-数据库通知" class="headerlink" title="2.2.6 数据库通知"></a>2.2.6 数据库通知</h4><p>数据库通知时Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>监听索引为0的键空间key为message所有操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SUBSCRIBE __keyspace@0__:message</span><br></pre></td></tr></table></figure></p><h3 id="2-3-RDB持久化"><a href="#2-3-RDB持久化" class="headerlink" title="2.3 RDB持久化"></a>2.3 RDB持久化</h3><h4 id="2-3-1-RDB文件的创建与载入"><a href="#2-3-1-RDB文件的创建与载入" class="headerlink" title="2.3.1 RDB文件的创建与载入"></a>2.3.1 RDB文件的创建与载入</h4><p>Redis命令可用于生成RDB文件，一个是SAVE，另一个是BGSAVE。<br>SAVE会阻塞Redis服务进程，知道RDB文件创建完毕，阻塞期间，服务器不能处理任何命令请求。<br>BGSAVE命令会派生除一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求。<br>BGSAVE命令正在执行，客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕后执行。<br>BGREWRITEAOF正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</p><blockquote><p>如果开启了AOF持久化功能，服务器会优先使用AOF文件还原数据库状态。<br>只有AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</p></blockquote><h4 id="2-3-2-自动间隔性保存"><a href="#2-3-2-自动间隔性保存" class="headerlink" title="2.3.2 自动间隔性保存"></a>2.3.2 自动间隔性保存</h4><h4 id="2-3-3-RDB文件结构"><a href="#2-3-3-RDB文件结构" class="headerlink" title="2.3.3 RDB文件结构"></a>2.3.3 RDB文件结构</h4><p><img src="/media/article/rdb-structure.png" alt="rdb"></p><p>REDIS部分用来校验是否为RDB文件。<br>db_version长度为4字节，记录RDB文件的版本号。<br>databases部分包含着两个或者任意多个数据库，以及各个数据库中的键值对数据。<br>EOF标志着RDB文件的正文结束。<br>check_sum保存着一个校验和，由REDIS、db_version、databases、EOF计算得出。校验RDB文件是否出错或者损坏。</p><p>database部分保存任意多个非空数据库，如下图所示，每个非空数据库可以保存SELECTDB、db_number、key_value_pairs:</p><p><img src="/media/article/rdb-structure1.png" alt="rdb"><br><img src="/media/article/rdb-database.png" alt="rdb"></p><p>SELEECT表示数据库号码。<br>db_number保存一个数据库号码。<br>key_value_pairs保存数据库中的所有键值对数据。</p><p><img src="/media/article/rdb-file-structure.png" alt="rdb"></p><p>key_values_pairs保存了一个以上的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。<br>不过期时间的键值对由TYPE、key、value组成。<br>TYPE:</p><ul><li>REDIS_RDB_TYPE_STRING</li><li>REDIS_RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_ZIPLIST</li></ul><p>过期时间的键值对在RDB文件中结构:<br><img src="/media/article/rdb-expire-structure.png" alt="rdb"></p><h3 id="2-4-AOF持久化"><a href="#2-4-AOF持久化" class="headerlink" title="2.4 AOF持久化"></a>2.4 AOF持久化</h3><p>AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤。</p><h4 id="2-4-1-命令追加"><a href="#2-4-1-命令追加" class="headerlink" title="2.4.1 命令追加"></a>2.4.1 命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-2-文件写入与同步"><a href="#2-4-2-文件写入与同步" class="headerlink" title="2.4.2 文件写入与同步"></a>2.4.2 文件写入与同步</h4><p>Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def eventLoop():</span><br><span class="line">    while True:</span><br><span class="line">        # 处理文件事件，接收命令请求以及发送命令回复</span><br><span class="line">        # 处理命令请求时可能会有新内容被追加到aof_buf缓冲区中</span><br><span class="line">        processFileEvents()</span><br><span class="line">        </span><br><span class="line">        # 处理时间事件</span><br><span class="line">        processTimeEvents()</span><br><span class="line">        </span><br><span class="line">        # 考虑是否将aof_buf中的内容写入和保存到AOF文件里面</span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定，各个不同值产生的行为如表:<br><img src="/media/article/appendfsycn.png" alt="appendfsync"></p><h4 id="2-4-3-AOF重写"><a href="#2-4-3-AOF重写" class="headerlink" title="2.4.3 AOF重写"></a>2.4.3 AOF重写</h4><p>因为AOF通过保存执行的写命令来记录数据库状态，所以可能造成AOF文件过大。为了解决这个问题，Redis提供了AOF文件重写功能。通过创建一个新的AOF文件替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF通常比旧AOF小得多。<br>重写功能通过读取服务器当前的数据状态来实现的。因为aof——rewirte函数生成的新的AOF只包含还原当前数据库状态所必需的的命令，所以新AOF文件不会浪费任何硬盘空间。</p><p><strong>注意:</strong><br>在实际中，为了避免执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查所包含的元素数量，如果元素数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值。</p><p>aof_rewrite会长时间阻塞，所以Redis将AOF重写程序放到子进程里执行:</p><ul><li>子进程进行AOF重写期间，服务器进程可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>AOF重写期间，客户端命令可能对现有数据库状态修改，造成当前数据库状态和AOF文件不一致的情况。</p><p>为了解决不一致的情况，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令后，它同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>AOF完成重写后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作:</p><ul><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子的覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ul><p>AOF后台重写过程中，只有信号处理函数执行时会对服务器进程造成阻塞，其他时候，AOF不会阻塞父进程。</p><h3 id="2-5-事件"><a href="#2-5-事件" class="headerlink" title="2.5 事件"></a>2.5 事件</h3><p>Redis服务器是一个事件驱动程序:</p><ul><li>文件事件: Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信产生响应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件: Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h4 id="2-5-1-文件事件"><a href="#2-5-1-文件事件" class="headerlink" title="2.5.1 文件事件"></a>2.5.1 文件事件</h4><p>Redis基于Reactor模式开发了自己的网络事件处理器: 这个处理器被称为文件事件处理器:</p><ul><li>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><h4 id="2-5-2-时间事件"><a href="#2-5-2-时间事件" class="headerlink" title="2.5.2 时间事件"></a>2.5.2 时间事件</h4><p>Redis的时间事件分为以下两类:</p><ul><li>定时事件: 让一段程序在指定的时间之后执行一次。</li><li>周期性时间: 让一段程序每隔指定时间执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成:</p><ul><li>id: 服务器为时间事件创建的全局唯一ID。从小到大递增。</li><li>when: 毫秒级精度的UNIX时间戳，记录了时间事件的到达时间。</li><li>timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件: 该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性事件: 当一个时间事件到达之后，服务器会根据事件处理器返回的值，对事件事件的when属性进行更新，这个事件在一段时间之后再次到达，并以这种方式一致更新并运行下去。</li></ul><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行，这些定期操作由redis.c/serverCron函数负责执行，主要工作包括:</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF和RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><h4 id="2-5-3-事件调度与执行"><a href="#2-5-3-事件调度与执行" class="headerlink" title="2.5.3 事件调度与执行"></a>2.5.3 事件调度与执行</h4><p>事件调度和执行由ae.c/aeProcessEvents函数负责。</p><blockquote><p>processFileEvent这个函数并不存在，在实际中，处理已产生文件事件的代码是直接写在aeProcessEvents函数里面。</p></blockquote><p>事件调度和执行规则:</p><ol><li>aeApiPoll函数的最大阻塞时间由到达时间最近当前时间的时间事件决定，这个方法既可以避免服务器对事件事件进行频繁的轮询，也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何事件事件到达，那么服务器将再次等待处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件。</li><li>对文件事件和时间事件的处理都是同步、有序、原子的执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此不管是文件事件的处理器，还是时间事件的处理器，也不会对事件进行抢占，一次不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可的减少程序阻塞时间，并在有需要时主动让出执行权，从而降低造成时间饥饿的可能性。另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li><li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间晚一些。</li></ol><h2 id="3-多机数据库实现"><a href="#3-多机数据库实现" class="headerlink" title="3. 多机数据库实现"></a>3. 多机数据库实现</h2><h2 id="4-独立功能的实现"><a href="#4-独立功能的实现" class="headerlink" title="4. 独立功能的实现"></a>4. 独立功能的实现</h2><h3 id="4-1-事务"><a href="#4-1-事务" class="headerlink" title="4.1 事务"></a>4.1 事务</h3><p>Redis 通过MULTI、EXEC、WATCH等命令来说实现事务。<br>事务在执行期间，服务器不会中断事务处理其他请求。</p><h4 id="4-1-1-事务的实现"><a href="#4-1-1-事务的实现" class="headerlink" title="4.1.1 事务的实现"></a>4.1.1 事务的实现</h4><p>一个事务从开始时到结束通常经历3个阶段:</p><ol><li>事务开始: MULTI</li><li>命令入队: <command></li><li>事务执行: EXEC</li></ol><h4 id="4-1-2-WATCH-命令的实现"><a href="#4-1-2-WATCH-命令的实现" class="headerlink" title="4.1.2 WATCH 命令的实现"></a>4.1.2 WATCH 命令的实现</h4><p>WATCH命令是一个乐观锁(optimistic locking)，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少少有一个已经被修改过了，如果是，则拒绝执行事务，并向客户端返回代表事务执行失败的空回复。<br>每个Redis数据库都保存着一个watched_keys字典，这个字典的键时某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。<br>如果有修改命令对数据库键修改过，那么touchWatchKey函数将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，标识该客户端的事务安全性被破坏。</p><p><img src="/media/article/watch-transaction.png" alt="watch"></p><h4 id="4-1-3-事务的ACID性质"><a href="#4-1-3-事务的ACID性质" class="headerlink" title="4.1.3 事务的ACID性质"></a>4.1.3 事务的ACID性质</h4><p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕。</p><p>Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性，从而确保事务的一致性。以下介绍Redis事务可能出错的地方，并说明Redis是如何妥善处理这些错误。</p><ol><li>入队错误：服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被带有入队错误的事务影响。</li><li>执行错误：</li></ol><ul><li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时触发。</li><li>即使在事务的执行过程中发生错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令不会被出错的命令影响。</li></ul><ol start="3"><li>服务器停机：</li></ol><ul><li>如果Redis服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。</li><li>如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，空白的总是一致的。</li><li>如果服务器运行在AOF模式下，那么事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>BGSAVE 是否会存执行BGSAVE命令后客户端请求的命令？</li><li>假如说每秒执行一次AOF持久化，那么Redis从aof缓冲区写入AOF文件时，服务端处理的命令是否会存入缓冲区，是否会进入AOF文件？</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong><em>文中的列表和图片大都引用自<a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a></em></strong></p><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a><br><a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau-Redis源码解析-quicklist</a><br><a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>How to Write Doc Comments for the Javadoc Tool</title>
      <link href="/zhongyp.github.io/java/2019-05-19-javadoc-guide/"/>
      <url>/zhongyp.github.io/java/2019-05-19-javadoc-guide/</url>
      
        <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.oracle.com/technetwork/articles/javase/index-137868.html" target="_blank" rel="noopener">How to Write Doc Comments for the Javadoc Tool</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 泛型</title>
      <link href="/zhongyp.github.io/java/2019-05-06-java-generics/"/>
      <url>/zhongyp.github.io/java/2019-05-06-java-generics/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote><p><strong>其他参数术语：</strong><br>参数化的类型(parameterized type)：<code>List&lt;String&gt;</code><br>实际类型参数(type arguments)：<code>String</code><br>泛型(generic type)：<code>List&lt;E&gt;</code><br>形式类型参数(formal parameter types)：<code>E</code><br>无限制通配符类型(unbounded wildcards)：<code>List&lt;?&gt;</code><br>原生态类型(raw type)：<code>List</code><br>有限制类型参数(bounded type parameter)：<code>&lt;E extends Number&gt;</code><br>递归类型限制(recursive type restriction)：<code>&lt;T extends Comparable&lt;T&gt;&gt;</code><br>有限制通配符类型(bounded wildcards)：<code>List&lt;? extends Number&gt;</code><br>泛型方法(generic method)：<code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code><br>类型令牌(type token)：<code>String.class</code></p><p>– 摘自《Effective Java》</p></blockquote><p>Java集合有个缺点：集合对元素类型没有任何限制，这样就会引发一些问题，例如：创建一个只保存Dog对象的集合，但是程序也能将Cat对象放进去。由于把对象放进集合时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此去除集合元素后通常还需要进行强制类型转换。</p><p>为了解决上述问题，从JDK1.5之后，Java引入了“参数化类型（parameterized type）”的概念，Java的参数化类型被称为泛型（Generic）。</p><p>所谓泛型：就是允许在定义类、接口时指定类型形参（type parameters），这个类型形参将在声明变量、创建对象时确定。泛型的作用就是在编译时保证类型安全。</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>定义泛型接口、类示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义接口时指定一个类型形参</span><br><span class="line">public interface List&lt;E&gt;&#123;</span><br><span class="line">    //在接口里，E可以作为类型使用</span><br><span class="line">    void add(E x);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    E asList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>注意：</em></strong></p><ul><li>包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参(type arguments)，从而可以动态生成无数多个逻辑上的子类，但这种子类在物理上并不存在。</li><li>当创建泛型声明的自定义类，为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明。例如：为<code>Apple&lt;T&gt;</code>类定义构造器，其构造器名依然是<code>Apple</code>，而不是<code>Apple&lt;T&gt;</code>，但调用构造器时可以使用<code>Apple&lt;T&gt;</code>，此时T应该为实参类型。</li></ul><h3 id="2-1-从泛型类派生子类"><a href="#2-1-从泛型类派生子类" class="headerlink" title="2.1 从泛型类派生子类"></a>2.1 从泛型类派生子类</h3><p>当创建子类使用泛型接口或类时，不能再包含类型形参。如下代码时错误的：<br><code>public class A extends Apple&lt;T&gt;{}</code><br>正确方式如下：<br><code>public class A extends Apple&lt;String&gt;{}</code></p><p>类的静态变量和方法在所有的实例间共享，所以在静态方法、静态初始化或者静态变量的声明和初始化中不允许使用类型形参。原因见<a href="#4-3-不能声明静态字段的类型为类型参数">4.3 不能声明静态字段的类型为类型参数</a></p><p>由于系统对于泛型类或接口并不会生成真正的泛型类或接口（即逻辑上的子类，并不是生成真正的子类），所以instanceof运算符后不能使用泛型类。（具体原因见<a href="#4-4-不能使用参数化类型强制类型转换或者instanceof">4.4 不能使用参数化类型强制类型转换或者instanceof</a>）如下的代码时错误的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = new ArrayList&lt;String&gt;();</span><br><span class="line">if(cs instanceof List&lt;String&gt;)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-类型通配符"><a href="#2-2-类型通配符" class="headerlink" title="2.2 类型通配符"></a>2.2 类型通配符</h3><p>类型通配符既可以在方法签名中定义形参的类型，也可以用于定义变量的类型。使用通配符比显式声明通配符声明类型形参更加清晰准确，所以在可能的情况下，使用通配符更好。</p><h4 id="2-2-1-不受约束的通配符"><a href="#2-2-1-不受约束的通配符" class="headerlink" title="2.2.1 不受约束的通配符"></a>2.2.1 不受约束的通配符</h4><p>通配符可用于各种情况：作为参数，字段或局部变量的类型;有时作为返回类型（虽然更好的编程实践更具体）。通配符从不用作泛型方法调用，泛型类实例创建或超类型的类型参数。</p><p>如果满足下面的条件任意一个，就可以使用不受约束通配符：</p><ul><li>如果你正在编写可以<strong>使用Object类中提供的方法实现</strong>的方法。</li><li>当代码使用在泛型类中不依赖类型参数方法时。例如：List.size 或者 List.clear。 事实上，Class&lt;?&gt;经常被使用，因为Class<t>中的大多数方法不依赖T。</t></li></ul><p>使用通配符时，不能将元素放入未知类型的集合中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aaa&quot;);//这行代码引起编译时错误。因为不知道list的类型，所以不能往里面放任何元素，除了null。</span><br></pre></td></tr></table></figure><h4 id="2-2-2-上限通配符"><a href="#2-2-2-上限通配符" class="headerlink" title="2.2.2 上限通配符"></a>2.2.2 上限通配符</h4><p>使用<code>? extend type</code>表示所有type泛型类的子类（包含type本身）。</p><h4 id="2-2-3-下限通配符"><a href="#2-2-3-下限通配符" class="headerlink" title="2.2.3 下限通配符"></a>2.2.3 下限通配符</h4><p>使用<code>? super type</code>表示所有type泛型类的父类（包含type本身）。<del>只能用于泛型方法（有待验证）。</del></p><h4 id="2-2-4-通配符捕获和Helper方法"><a href="#2-2-4-通配符捕获和Helper方法" class="headerlink" title="2.2.4 通配符捕获和Helper方法"></a>2.2.4 通配符捕获和Helper方法</h4><p>在一些情况下，编译器会推断一个通配符的类型。例如，一个列表可以被定义为<code>List&lt;?&gt;</code>，当评估一个表达式时，编译器会从代码中推断一个特定类型。此方案称为通配符捕获。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardError &#123;</span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.set(0, i.get(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>i.set</code>方法编译异常，类型参数<code>List&lt;?&gt;</code>为不确定类型参数，所以<code>i.get(0)</code>获取的类型参数不确定，因此<code>i.set</code>方法不能将未知类型放入<code>i</code>中。（其中i.set默认是i.set(Integer,Object)，因为不确定i.get(0)的类型，所以产生编译问题）解决方案如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardFixed &#123;</span><br><span class="line"></span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // Helper method created so that the wildcard can be captured</span><br><span class="line">    // through type inference.</span><br><span class="line">    private &lt;T&gt; void fooHelper(List&lt;T&gt; l) &#123;</span><br><span class="line">        l.set(0, l.get(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-通配符和子类型"><a href="#2-2-5-通配符和子类型" class="headerlink" title="2.2.5 通配符和子类型"></a>2.2.5 通配符和子类型</h4><p>如泛型，继承和子类型中所述，泛型类或接口仅仅因为它们的类型不同而无关。但是，您可以使用通配符在泛型类或接口之间创建关系。下图是Number和Integer之间的继承关系：<br><img src="/media/article/15579245029350.jpg" alt=""></p><h3 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c)&#123;</span><br><span class="line">    for(T o:a)&#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面示例中，定义了一个泛型方法，该泛型方法中定义了一个T类型形参，这个T类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型形参不同的是，方法声明中定义的形参只能在该方法里使用，而接口、类声明中的定义的类型形参则可以在整个接口、类中使用。<br>与类、接口中使用泛型参数不同的是，方法中的泛型参数无需显式传入实际类型参数，根据实参推断类型形参的值。如果编译器不能推断你希望它拥有的类型，可以通过一个显示的类型参数（explicit type parameter）来告诉它要使用哪种类型。<br>泛型方法的用法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,S&gt; 返回值类型 方法名（形参列表）&#123;</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><em>提示：</em></strong><br>如果某个方法中一个形参（a）的类型或返回值类型依赖于另一个形参（b）的类型，则形参（b）的类型声明不应该使用通配符，因为形参（a）、或返回值与该形参（b）的类型，如果形参（b）的类型无法确定，程序无法定义形参（a）的类型。在这种情况下，<strong><em>只能考虑使用在方法签名中声明类型形参</em></strong>。</p></blockquote><p>类型通配符与显式声明类型形参区别：</p><ul><li>类型通配符即可在方法签名中定义形参的类型，也可以用于定义变量的类型。但泛型方法中类型形参必须在对应方法中显式声明。</li><li><strong><em>泛型方法允许类型形参用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系。如果没有这样的依赖关系，不应该使用泛型方法。</em></strong></li></ul><h3 id="2-4-泛型使用准则"><a href="#2-4-泛型使用准则" class="headerlink" title="2.4 泛型使用准则"></a>2.4 泛型使用准则</h3><blockquote><p>“in”变量：in变量向代码提供数据。想象复制方法有两个参数：<code>copy(src, dest)</code>。<code>src</code>参数提供复制数据，因此时”in”参数。<br>“out”变量：out变量保存数据以供其他地方使用。在复制的例子中，<code>copy(src, dest)</code>，<code>dest</code>参数接受数据，因此时”out”参数。</p></blockquote><ul><li>使用<code>extends</code>关键字定义带有上限通配符的“in”变量。</li><li>使用<code>super</code>关键字定义带有下限通配符的“out”变量。</li><li>在可以使用Object类中定义的方法访问“in”变量的情况下，使用无界通配符。</li><li>在代码需要作为“in”和“out”变量访问的情况下，不要使用通配符。</li></ul><h2 id="3-泛型的擦除与转换"><a href="#3-泛型的擦除与转换" class="headerlink" title="3. 泛型的擦除与转换"></a>3. 泛型的擦除与转换</h2><p>泛型被引入Java语言，以便在编译时提供更严格的类型检查并支持通用编程（向上兼容）。为了实现泛型，Java编译器将类型擦除应用于：</p><ul><li>使用边界替换所有在泛型中的类型参数或者如果类型参数是无界的则使用<code>Object</code>替换。因此生成的字节码只包含通用的类，接口和方法。</li><li>如果必要，插入类型强制转换来保证类型安全。</li><li>生成桥接方法以保留扩展泛型类型中的多态性。</li></ul><p>对于以上3点，1和3可能在<a href="#3-1-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E6%93%A6%E9%99%A4">3.1</a>和<a href="#3-2-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E6%A1%A5%E6%96%B9%E6%B3%95">3.2</a>中会详细说明，但是第二点可能不是那么清楚，如果有必要，类型擦除时，会进行强制类型转换。一般这种情况包括：</p><ul><li>方法的返回类型是类型参数；</li><li>在访问数据域时，域的类型是一个类型参数。</li></ul><p>例如：<br>项目中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println(list1.get(0));</span><br></pre></td></tr></table></figure></p><p>编译后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list1 = new ArrayList();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println((String)list1.get(0));</span><br></pre></td></tr></table></figure></p><p>字节码，字节码命令请参阅<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Chapter 6. The Java Virtual Machine Instruction Set</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">       0: new           #3                  // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #4                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #5                  // String Hell</span><br><span class="line">      11: invokeinterface #6,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      16: pop</span><br><span class="line">      17: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: iconst_0</span><br><span class="line">      22: invokeinterface #8,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">      27: checkcast     #9                  // class java/lang/String 强制类型转换校验是否为String类型</span><br><span class="line">      30: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      33: return</span><br></pre></td></tr></table></figure></p><p>上面的例子说明，编译器在擦除泛型代码时，确实保留了List<string>的相关信息，但是你无法找到列表对象本身的T=String，参阅自<a href="https://stackoverflow.com/questions/339699/java-generics-type-erasure-when-and-what-happens/339708#339708" target="_blank" rel="noopener">Java generics type erasure: when and what happens?</a>Jon Skeet的answer。</string></p><p>详细了解请参阅<a href="https://stackoverflow.com/questions/55084504/insert-type-casts-if-necessary-to-preserve-type-safety" target="_blank" rel="noopener">Insert type casts if necessary to preserve type safety</a></p><h3 id="3-1-泛型方法的擦除"><a href="#3-1-泛型方法的擦除" class="headerlink" title="3.1 泛型方法的擦除"></a>3.1 泛型方法的擦除</h3><p>Java编译器也会擦除泛型方法中的类型参数。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static &lt;T&gt; int count(T[] anArray, T elem)&#123;</span><br><span class="line"></span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(T e : anArray)&#123;</span><br><span class="line">        if(e.equals(elem))&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为T是无限制的，所以Java编译器会使用Object代替它，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int count(Object[] anArray, Object elem) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (Object e : anArray)</span><br><span class="line">        if (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-类型擦除的影响和桥方法"><a href="#3-2-类型擦除的影响和桥方法" class="headerlink" title="3.2 类型擦除的影响和桥方法"></a>3.2 类型擦除的影响和桥方法</h3><p>在编译扩展参数化类或实现参数化接口的类或接口时，编译器可能需要创建一个称为桥接方法的合成方法，作为类型擦除过程的一部分。您通常不需要担心桥接方法，但如果出现在堆栈跟踪中，您可能会感到困惑。</p><p>生成桥接方法以保留扩展泛型类型中的多态性。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T data;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = mn;            // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);     </span><br><span class="line">Integer x = mn.data;    // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>类型擦除后, 代码变成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);</span><br><span class="line">Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>代码执行逻辑如下：</p><p><code>n.setData(&quot;Hello&quot;)</code>使得MyNode类对象中的<code>setData(Object)</code>被执行。<br>在<code>setData(Object)</code>方法体内，对象的数据字段引用被分配为String。<br>通过mn引用的相同对象数据字段，可以访问、且期望是Interger类型。<br>尝试分配String到Integer造成ClassCastException。</p><p>类型擦除后代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    public Object data;</span><br><span class="line"></span><br><span class="line">    public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类型擦除之后，方法签名不匹配。 Node方法变为setData（Object），MyNode方法变为setData（Integer）。因此，MyNode setData方法不会覆盖Node setData方法。 为了解决这个问题并在类型擦除后保留泛型类型的多态性，Java编译器会生成一个桥接方法，以确保子类型按预期工作。对于MyNode类，编译器为setData生成以下桥接方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    // Bridge method generated by the compiler</span><br><span class="line">    //</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>桥接方法与类型擦除后的Node类的setData方法具有相同的方法签名，委托给原始的setData方法(桥接方法在字节码中可见，<code>javap -c class</code>)。</p><h3 id="3-3-不可具体化类型"><a href="#3-3-不可具体化类型" class="headerlink" title="3.3 不可具体化类型"></a>3.3 不可具体化类型</h3><p>可具体化类型是在运行时类型信息完全可用的一种类型。包括基本类型，非泛型类型，原始类型，无界的通配符调用。唯一可具体化参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<br>不可具体化类型是类型信息在编译时通过类型擦除被删除————调用未定义为无界通配符的泛型类型。不可具体化的类型在运行时不是所有信息都可用。不可具体化类型的示例是<code>List &lt;String&gt;</code>和<code>List &lt;Number&gt;</code>; JVM无法在运行时区分这些类型。如<a href="#4-泛型的限制">4 泛型的限制</a>中所示，在某些情况下，不能使用不可具体化的类型：例如，在<code>instanceof</code>表达式的实例中，或作为数组中的元素。</p><h3 id="3-4-堆污染"><a href="#3-4-堆污染" class="headerlink" title="3.4 堆污染"></a>3.4 堆污染</h3><p>堆污染发生在当参数化类型的变量引用不是该参数化类型的对象时。如果程序执行某些操作，在编译时产生未经检查的警告，则会出现这种情况。如果在编译时（在编译时类型检查规则的限制内）或在运行时，一个包含参数化类型操作的正确性不能被验证，则会生成未经检查的警告。例如，在混合原始类型和参数化类型时，或者在执行未经检查的强制转换时，会发生堆污染。</p><p>在通常情况下，当所有代码在相同时间被编译，编译器为潜在的堆污染产生一个未经检查警告来引起你的注意。如果你分开编译代码的各个部分，很难检查出堆污染的潜在风险。如果你确保你的代码编译没有警告，则不会有堆污染可以发生。</p><h3 id="3-5-使用不可具体化形参的可变参数方法的潜在漏洞"><a href="#3-5-使用不可具体化形参的可变参数方法的潜在漏洞" class="headerlink" title="3.5 使用不可具体化形参的可变参数方法的潜在漏洞"></a>3.5 使用不可具体化形参的可变参数方法的潜在漏洞</h3><p>包含可变输入参数泛型方法可以造成堆污染。<br>考虑如下class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBuilder &#123;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) &#123;</span><br><span class="line">    for (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void faultyMethod(List&lt;String&gt;... l) &#123;</span><br><span class="line">    Object[] objectArray = l;     // Valid</span><br><span class="line">    objectArray[0] = Arrays.asList(42);</span><br><span class="line">    String s = l[0].get(0);       // ClassCastException thrown here</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下例子，<code>HeapPollutionExample</code>使用<code>ArrayBuilder</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HeapPollutionExample &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stringListA = new ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; stringListB = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.addToList(stringListA, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;);</span><br><span class="line">    ArrayBuilder.addToList(stringListB, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listOfStringLists =</span><br><span class="line">      new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    ArrayBuilder.addToList(listOfStringLists,</span><br><span class="line">      stringListA, stringListB);</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译时，如下<code>ArrayBuilder.addToList</code>方法的定义将产生warning：<br><code>warning: [varargs] Possible heap pollution from parameterized vararg type T</code><br>当编译器遇到一个可变参数方法，它转换可变形参为数组。然而，Java编程语言不允许参数化类型数组的创建。在<code>ArrrayBuilder.addToList</code>方法中，编译器转换可变形参<code>T...</code>要素为<code>T[]</code>要素。因为类型擦除，编译器转换可变形参为<code>Object[]</code>要素。所以，有堆污染的可能性。<br>如下声明分配可变形参给对象数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray = l;</span><br></pre></td></tr></table></figure></p><p>这种声明可能引起堆污染。可以将与可变形参<code>l</code>的参数化类型匹配的值分配给变量objectArray，因此可以分配给<code>l</code>。然而，在此声明中，编译器不能生成一个未经检查警告。编译器早已在转换可变形参<code>List&lt;String&gt;...l</code> 到形参<code>List[] l</code>时生成警告。这个声明是有效的；<code>l</code>变量的类型是<code>List[]</code>，是<code>Object[]</code>的子类型。</p><p>因此，如果将任何类型的List对象分配给objectArray数组的任何数组组件，编译器不会发出警告或错误，如下所示：<br><code>ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</code><br>在运行时，JVM在以下语句中抛出<code>ClassCastException</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ClassCastException thrown here</span><br><span class="line">String s = l[0].get(0);</span><br></pre></td></tr></table></figure></p><p>存储在变量<code>l</code>的第一个数组组件中的对象具有<code>List&lt;Integer&gt;</code>类型，但此语句需要一个<code>List &lt;String&gt;</code>类型的对象。</p><h3 id="3-6-使用不可具体化的形参防止可变参数方法发出警告"><a href="#3-6-使用不可具体化的形参防止可变参数方法发出警告" class="headerlink" title="3.6 使用不可具体化的形参防止可变参数方法发出警告"></a>3.6 使用不可具体化的形参防止可变参数方法发出警告</h3><p>如果声明具有参数化类型参数的可变参数方法，并确保方法体不会因可变参数形参处理不当而抛出<code>ClassCastException</code>或其他类似异常，你可以通过给静态和非构造方法声明添加如下的注解防止编译器给这些可变参数方法生成警告：<br><code>@SafeVarargs</code><br><code>@SafeVarargs</code>注解是方法约定的记录部分;这个注释断言该方法的实现不会不正确地处理可变形参。<br> 尽管不太可取，但通过在方法声明中添加以下内容来消除此类警告也是可以的：<br><code>@SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})</code><br>但是，此方法不会消除从方法的调用点生成的警告。如果您不熟悉<code>@SuppressWarnings</code>语法，请参阅注释。</p><h2 id="4-泛型的限制"><a href="#4-泛型的限制" class="headerlink" title="4 泛型的限制"></a>4 泛型的限制</h2><h3 id="4-1-不能使用基本类型实例化通用类型"><a href="#4-1-不能使用基本类型实例化通用类型" class="headerlink" title="4.1 不能使用基本类型实例化通用类型"></a>4.1 不能使用基本类型实例化通用类型</h3><p>考虑如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public Pair(K key, V value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当创建一个<code>Pair</code>对象，你不能为类型参数<code>K</code>或者<code>V</code>替换成基本类型：<br><code>Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);  // compile-time error</code><br>你仅可以为类型参数<code>K</code>或者<code>V</code>替换非基本类型：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);</code><br>Java编译器自动装箱<code>8</code>为<code>Integer.valueOf(8)</code>和<code>a</code>为<code>Character(&#39;a&#39;)</code>：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character(&#39;a&#39;));</code></p><h3 id="4-2-不能创建类型参数实例"><a href="#4-2-不能创建类型参数实例" class="headerlink" title="4.2 不能创建类型参数实例"></a>4.2 不能创建类型参数实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">    E elem = new E();  // compile-time error</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种解决方案，你可以创建一个类型参数对象通过反射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">    E elem = cls.newInstance();   // OK</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以调用<code>append</code>方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = new ArrayList&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure></p><h3 id="4-3-不能声明静态字段的类型为类型参数"><a href="#4-3-不能声明静态字段的类型为类型参数" class="headerlink" title="4.3 不能声明静态字段的类型为类型参数"></a>4.3 不能声明静态字段的类型为类型参数</h3><p>类的静态字段是类等级变量，被当前类的所有非静态对象共享。因此，类型参数的静态字段是不允许的。考虑如下类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MobileDevice&lt;T&gt; &#123;</span><br><span class="line">    private static T os;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类型参数的静态字段被允许，如下的代码将会混乱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MobileDevice&lt;Smartphone&gt; phone = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;Pager&gt; pager = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;TabletPC&gt; pc = new MobileDevice&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>因为静态字段<code>os</code>被<code>phone</code>,<code>pager</code>和<code>pc</code>共享，什么是<code>os</code>的真实类型？在相同的时间它不可能是<code>Smartphone</code>，<code>Pager</code>，和<code>TablePc</code>。因此你不能创建类型参数静态字段。</p><h3 id="4-4-不能使用参数化类型强制类型转换或者instanceof"><a href="#4-4-不能使用参数化类型强制类型转换或者instanceof" class="headerlink" title="4.4 不能使用参数化类型强制类型转换或者instanceof"></a>4.4 不能使用参数化类型强制类型转换或者<code>instanceof</code></h3><p>因为Java编译器在泛型代码中擦除所有类型参数，您无法验证在运行时使用泛型类型的参数化类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>传递到<code>rtti</code>方法的参数化类型集合是：<br><code>S = { ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, ... }</code><br>运行时不保持对类型参数的跟踪，因此它不能告诉<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>之间的不同。你最多是使用无限通配符来验证列表是否为ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;?&gt;) &#123;  // OK; instanceof requires a reifiable type</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通常，你不能强制转换参数化类型，除非它通过无限制通配符参数化。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  // compile-time error</span><br></pre></td></tr></table></figure></p><p>但是，在一些情况下，编译器知道类型参数总是有效的，允许强制类型转换。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  // OK</span><br></pre></td></tr></table></figure></p><h3 id="4-5-不能创建参数化类型的数组"><a href="#4-5-不能创建参数化类型的数组" class="headerlink" title="4.5 不能创建参数化类型的数组"></a>4.5 不能创建参数化类型的数组</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</span><br></pre></td></tr></table></figure></p><p>如下代码说明在不同类型插入列表是发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] strings = new String[2];</span><br><span class="line">strings[0] = &quot;hi&quot;;   // OK</span><br><span class="line">strings[1] = 100;    // An ArrayStoreException is thrown.</span><br></pre></td></tr></table></figure></p><p>如果你使用泛型列表尝试相同的事情，将会有如下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&apos;s allowed</span><br><span class="line">stringLists[0] = new ArrayList&lt;String&gt;();   // OK</span><br><span class="line">stringLists[1] = new ArrayList&lt;Integer&gt;();  // An ArrayStoreException should be thrown,</span><br><span class="line">                                            // but the runtime can&apos;t detect it.</span><br></pre></td></tr></table></figure></p><p> 如果参数化列表数组是允许的，之前的代码将失败抛出<code>ArrayStoreException</code>。</p><h3 id="4-6-不能创建、捕获或者抛出参数化类型对象"><a href="#4-6-不能创建、捕获或者抛出参数化类型对象" class="headerlink" title="4.6 不能创建、捕获或者抛出参数化类型对象"></a>4.6 不能创建、捕获或者抛出参数化类型对象</h3><p>泛型类也不能直接或间接继承自Throwable。原因是因为在编译期和运行时都必须知道异常的确切类型。例如如下类将不编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Extends Throwable indirectly</span><br><span class="line">class MathException&lt;T&gt; extends Exception &#123; /* ... */ &#125;    // compile-time error</span><br><span class="line"></span><br><span class="line">// Extends Throwable directly</span><br><span class="line">class QueueFullException&lt;T&gt; extends Throwable &#123; /* ... */ // compile-time error</span><br></pre></td></tr></table></figure></p><p>一个方法不能捕获一个类型参数的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (J job : jobs)</span><br><span class="line">            // ...</span><br><span class="line">    &#125; catch (T e) &#123;   // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，你可以在一个<code>throws</code>子句中使用类型参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parser&lt;T extends Exception&gt; &#123;</span><br><span class="line">    public void parse(File file) throws T &#123;     // OK</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出上述泛化的代码。</p><h3 id="4-7-不能重载形式类型参数擦除后相同原始类型的方法"><a href="#4-7-不能重载形式类型参数擦除后相同原始类型的方法" class="headerlink" title="4.7 不能重载形式类型参数擦除后相同原始类型的方法"></a>4.7 不能重载形式类型参数擦除后相同原始类型的方法</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public void print(Set&lt;String&gt; strSet) &#123; &#125;</span><br><span class="line">    public void print(Set&lt;Integer&gt; intSet) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重载将共享相同的类文件表示，并将生成编译时错误。</p><h2 id="5-泛型与数组"><a href="#5-泛型与数组" class="headerlink" title="5. 泛型与数组"></a>5. 泛型与数组</h2><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型<code>Sub[]</code>就是<code>Super[]</code>的子类型。<br>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h2 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h2><p>如果以上都看完了，可以访问<a href="https://docs.oracle.com/javase/tutorial/java/generics/QandE/generics-questions.html" target="_blank" rel="noopener">Questions</a>试试自己是否真的懂了。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a><br><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">Effective Java</a><br><a href="https://docs.oracle.com/javase/tutorial/java/generics/" target="_blank" rel="noopener">Java Document Generic</a><br><a href="http://www.jiangjun.name/thinking-in-java/chapter15" target="_blank" rel="noopener">第十五章 泛型</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective Java</title>
      <link href="/zhongyp.github.io/java/2019-05-02-effective-java/"/>
      <url>/zhongyp.github.io/java/2019-05-02-effective-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘自《Effective Java》</p></blockquote><h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><h2 id="一、创建和销毁对象"><a href="#一、创建和销毁对象" class="headerlink" title="一、创建和销毁对象"></a>一、创建和销毁对象</h2><h3 id="1-考虑使用静态工厂方法替代构造器"><a href="#1-考虑使用静态工厂方法替代构造器" class="headerlink" title="1.考虑使用静态工厂方法替代构造器"></a>1.考虑使用静态工厂方法替代构造器</h3><ul><li>静态工厂方法与构造器不同的第一大优势在于，它们有名称，不必和类名相同。</li><li>静态工厂方法与构造器不同的第二大优势在于不必在每次调用他们的时候都创建一个新的对象。</li><li>静态工厂方法与构造器不同的第三大优势在于他们可以返回原类型的任何子类型对象。</li><li>静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们是代码变得更加简洁。</li><li>静态工厂方法的主要缺点在于类如果不含公有的活着受保护的构造器，就不能被子类化。</li><li>静态工厂方法第二个缺点在于它们与其他的静态方法实际上没有任何区别。</li></ul><h3 id="2-遇到多个构造器参数时要考虑用构建器"><a href="#2-遇到多个构造器参数时要考虑用构建器" class="headerlink" title="2.遇到多个构造器参数时要考虑用构建器"></a>2.遇到多个构造器参数时要考虑用构建器</h3><h3 id="3-用私有构造器或着枚举类强化Singleton属性"><a href="#3-用私有构造器或着枚举类强化Singleton属性" class="headerlink" title="3.用私有构造器或着枚举类强化Singleton属性"></a>3.用私有构造器或着枚举类强化Singleton属性</h3><h3 id="4-通过私有构造器强化不可实例化的能力"><a href="#4-通过私有构造器强化不可实例化的能力" class="headerlink" title="4.通过私有构造器强化不可实例化的能力"></a>4.通过私有构造器强化不可实例化的能力</h3><h3 id="5-避免创建不必要的对象"><a href="#5-避免创建不必要的对象" class="headerlink" title="5.避免创建不必要的对象"></a>5.避免创建不必要的对象</h3><h3 id="6-消除过期的对象引用"><a href="#6-消除过期的对象引用" class="headerlink" title="6.消除过期的对象引用"></a>6.消除过期的对象引用</h3><ul><li>只要类是自己管理内存，程序员就应该警惕内存泄露问题。</li><li>内存泄漏的另一个常见来源是缓存。</li><li>内存的第三个常见来源是监听器和其他回调。确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用。</li></ul><h3 id="7-避免使用终结方法"><a href="#7-避免使用终结方法" class="headerlink" title="7.避免使用终结方法"></a>7.避免使用终结方法</h3><ul><li>终结方法（finalizer）通常是不可预测的，也是危险的，一般情况下是不必要的。</li><li>使用终结方法有非常严重的（Severe）性能损失。</li></ul><h2 id="二、对于所有对象都通用的方法"><a href="#二、对于所有对象都通用的方法" class="headerlink" title="二、对于所有对象都通用的方法"></a>二、对于所有对象都通用的方法</h2><h3 id="8-覆盖equals时请遵守通用约定"><a href="#8-覆盖equals时请遵守通用约定" class="headerlink" title="8.覆盖equals时请遵守通用约定"></a>8.覆盖equals时请遵守通用约定</h3><ul><li>类的每个实例本质都是唯一的。</li><li>不关心类是否提供了“逻辑相等（logical equality）“的测试功能。</li><li>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。</li><li>类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用。</li><li>在覆盖equals方法时，必须遵守：<strong>自反性（reflexive）、对称性（symmetric）、传递性（transitive）、一致性（consistent）和对于任何非null的引用，equals(null)必须返回false</strong>。</li></ul><blockquote><p>里氏替换原则（Liskov substitution principle）认为，一个类型的任何重要属性也将适用它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行的很好。</p></blockquote><ul><li>覆盖equals时总要覆盖hashCode。</li><li>不要企图让equals方法过于智能。</li><li>不要将equals声明中的Object对象替换为其他的类型。</li></ul><h3 id="9-覆盖equals总要覆盖hashCode"><a href="#9-覆盖equals总要覆盖hashCode" class="headerlink" title="9.覆盖equals总要覆盖hashCode"></a>9.覆盖equals总要覆盖hashCode</h3><ul><li>在应用程序的执行期间，只要对象的equals方法比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li><li>如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。<strong>（违反第二条）</strong></li><li>如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定产生不同的整数结果。但是程序猿应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列（hash table）的性能。</li></ul><h3 id="10-始终要覆盖toString"><a href="#10-始终要覆盖toString" class="headerlink" title="10.始终要覆盖toString()"></a>10.始终要覆盖toString()</h3><h3 id="11-谨慎覆盖clone"><a href="#11-谨慎覆盖clone" class="headerlink" title="11.谨慎覆盖clone()"></a>11.谨慎覆盖clone()</h3><ul><li>如果专门为了继承而设计的类，覆盖了clone方法，覆盖版本的clone方法就应该模拟Object.clone的行为：他应该声明为protected、抛出CloneNotSupportedException异常，并且该类不应该实现Cloneable接口。</li><li>如果用线程安全的类实现Cloneable接口，要记得它的clone方法必须得到同步。</li><li>任何实现Cloneable接口的类都应该用一个公有的方法覆盖clone，首先调用super.clone，再修正任何需要修正的域。</li><li>另一种实现对象拷贝的好方法是提供一个拷贝构造器(copy constructor)或者拷贝工厂(copy factory)。</li></ul><h3 id="12-考虑实现Comparable接口"><a href="#12-考虑实现Comparable接口" class="headerlink" title="12.考虑实现Comparable接口"></a>12.考虑实现Comparable接口</h3><h2 id="三、类和接口"><a href="#三、类和接口" class="headerlink" title="三、类和接口"></a>三、类和接口</h2><h3 id="13-使类和成员的可访问性最小化"><a href="#13-使类和成员的可访问性最小化" class="headerlink" title="13.使类和成员的可访问性最小化"></a>13.使类和成员的可访问性最小化</h3><ul><li>尽可能的使每个类或者成员不被外界访问。</li><li>实例域绝不能使公有的。</li><li>类具有共有的静态final数组域，或者返回这种域的访问方法，这种几乎总是错误的。</li><li>公有类都不应该包含公有域，除了公有静态final域的特殊情形外。</li><li>确保公有静态final域所引用的对象都是不可变的。</li></ul><h3 id="14-在公有类中使用访问方法而非公有域"><a href="#14-在公有类中使用访问方法而非公有域" class="headerlink" title="14.在公有类中使用访问方法而非公有域"></a>14.在公有类中使用访问方法而非公有域</h3><ul><li>如果类可以在它所在的包的外部进行访问，就提供访问方法。</li><li>如果类是包级私有的，或者私有的嵌套类，直接暴露它的数据域并没有本质的错误。</li></ul><h3 id="15-使可变性最小化"><a href="#15-使可变性最小化" class="headerlink" title="15.使可变性最小化"></a>15.使可变性最小化</h3><p>不可变类只是实例不能被修改的类。每个实例中包含的信息都必须在创建该实例的时候提供，并在对象的整个生命周期固定不变。</p><ul><li>不要提供任何会修改对象状态的方法。</li><li>保证类不被扩展。</li><li>使所有的域都是final的。</li><li>使所有的域都成为私有的。</li><li>确保对于任何可变组件的互斥访问。</li></ul><h3 id="16-复合优先于继承"><a href="#16-复合优先于继承" class="headerlink" title="16.复合优先于继承"></a>16.复合优先于继承</h3><ul><li>与方法调用不同的是，继承打破了封装性。</li></ul><h3 id="17-要么为继承而设计，并提供文档说明，要么就禁止继承。"><a href="#17-要么为继承而设计，并提供文档说明，要么就禁止继承。" class="headerlink" title="17.要么为继承而设计，并提供文档说明，要么就禁止继承。"></a>17.要么为继承而设计，并提供文档说明，要么就禁止继承。</h3><ul><li>构造器绝不能调用可被覆盖的方法。</li><li>无论是clone还是readObject，都不可以调用可覆盖的方法，不管是以直接还是间接的方式。</li></ul><h3 id="18-接口优于抽象类"><a href="#18-接口优于抽象类" class="headerlink" title="18.接口优于抽象类"></a>18.接口优于抽象类</h3><ul><li>现有的类可以很容易被更新，以实现新的接口。</li><li>接口是定义mixin(混合类型)的理想选择。</li><li>接口允许构造非层次结构的类型框架。</li><li>接口使得安全的增强类的功能成为可能。</li><li>通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的优点结合起来。</li></ul><h3 id="19-接口只用于定义类型"><a href="#19-接口只用于定义类型" class="headerlink" title="19.接口只用于定义类型"></a>19.接口只用于定义类型</h3><ul><li>常量接口模式是对接口的不良使用。</li></ul><h3 id="20-类层级优于标签类"><a href="#20-类层级优于标签类" class="headerlink" title="20.类层级优于标签类"></a>20.类层级优于标签类</h3><h3 id="21-用函数对象表示策略"><a href="#21-用函数对象表示策略" class="headerlink" title="21.用函数对象表示策略"></a>21.用函数对象表示策略</h3><p>策略模式</p><h3 id="22-优先考虑静态成员类"><a href="#22-优先考虑静态成员类" class="headerlink" title="22.优先考虑静态成员类"></a>22.优先考虑静态成员类</h3><p>静态类成员：Map中的Entry<br>非静态类成员：Iterator<br>匿名类：无法实例化，无法声明实现接口，扩展类，无法调用任何成员除了从它的超类继承的，必须简洁，常用来作为函数对象，即函数表达式；另一种是创建过程对象（Runable）<br>局部类：声明局部变量的地方都可以声明局部类。</p><p>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中。</p><h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h3 id="23-请不要在新代码中使用原生态类型"><a href="#23-请不要在新代码中使用原生态类型" class="headerlink" title="23.请不要在新代码中使用原生态类型"></a>23.请不要在新代码中使用原生态类型</h3><ul><li>如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。</li><li>泛型有子类化的规则，虽然可以将List<string>传递给List的参数，但是不能将它传给类型List<object>的参数。</object></string></li><li>如果使用像List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<object>这样的参数化类型，则不会。</object></li><li>在类文字中必须使用原生态类型。</li><li>在参数化类型而非无限制通配符类型上使用instanceof操作法是非法的。</li></ul><h3 id="24-消除非受检警告"><a href="#24-消除非受检警告" class="headerlink" title="24.消除非受检警告"></a>24.消除非受检警告</h3><ul><li>尽可能消除每一个非受检警告</li><li>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，只有这种情况下可以用@SuppressWarnings(“unchecked”)注解来禁止这条警告。</li><li>应该在尽可能小的范围内使用SuppressWarnings注解。</li><li>每当使用SuppressWarnings注解，都要增加注释，说明为什么这么做是安全的。</li></ul><h3 id="25-列表优于数组"><a href="#25-列表优于数组" class="headerlink" title="25.列表优于数组"></a>25.列表优于数组</h3><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型。<br><strong>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</strong></p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p><strong>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</strong></p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型时无限制通配符类型，如List&lt;?&gt;和Map&lt;?,?&gt;。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h3 id="26-优先考虑泛型"><a href="#26-优先考虑泛型" class="headerlink" title="26.优先考虑泛型"></a>26.优先考虑泛型</h3><ul><li>不能创建不可具体化的（non-reifiable）类型的数组。解决方案是新建Object数组强制转换为不可具体化类型，确保未受检的转换是安全的，就要尽可能小的范围中禁止警告。</li></ul><h3 id="27-优先考虑泛型方法"><a href="#27-优先考虑泛型方法" class="headerlink" title="27.优先考虑泛型方法"></a>27.优先考虑泛型方法</h3><h3 id="28-利用有限制通配符来提升API的灵活性"><a href="#28-利用有限制通配符来提升API的灵活性" class="headerlink" title="28.利用有限制通配符来提升API的灵活性"></a>28.利用有限制通配符来提升API的灵活性</h3><ul><li>为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。</li><li>如果类型参数只在方法声明中出现一次，就可以用通配符取代它，如果是无限制的类型参数，就用无限制的通配符取代它。</li><li>如果类的用户必须考虑通配符类型，类的API或许就会出错。</li><li>不要用通配符类型作为返回类型，除了为用户提供额外的灵活性之外，它还会强制用户在客户端代码中使用通配符类型。</li></ul><h3 id="29-优先考虑类型安全的异构容器"><a href="#29-优先考虑类型安全的异构容器" class="headerlink" title="29.优先考虑类型安全的异构容器"></a>29.优先考虑类型安全的异构容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Favorites&#123;</span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);</span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不像普通的map，它的<strong>所有键都是不同类型</strong>的，因此Favorites称作类型安全的异构容器（typesafe heterogeneous container）。</p><p>集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数，但是可以通过将类型参数放在键上而不是容器上来避开这一限制。</p><h2 id="五、枚举和注解"><a href="#五、枚举和注解" class="headerlink" title="五、枚举和注解"></a>五、枚举和注解</h2><h3 id="30-用enum代替int常量"><a href="#30-用enum代替int常量" class="headerlink" title="30.用enum代替int常量"></a>30.用enum代替int常量</h3><p>只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。</p><p>如果多个枚举常量同时共享相同的行为，则考虑策略枚举（strategy enum）。</p><h3 id="31-用实例代替序数索引"><a href="#31-用实例代替序数索引" class="headerlink" title="31.用实例代替序数索引"></a>31.用实例代替序数索引</h3><p>永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Ensemble&#123;</span><br><span class="line">    SOLO(1),DUET(2);</span><br><span class="line">    private final int numberOfMusicians;</span><br><span class="line">    Ensemble(int size)&#123;this.numberOfMusicians = size;&#125;</span><br><span class="line">    public int numberOfMusicians()&#123;return numberOfMusicians;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="32-用EnumSet代替位域"><a href="#32-用EnumSet代替位域" class="headerlink" title="32.用EnumSet代替位域"></a>32.用EnumSet代替位域</h3><h3 id="33-用EnumMap代替序数索引"><a href="#33-用EnumMap代替序数索引" class="headerlink" title="33.用EnumMap代替序数索引"></a>33.用EnumMap代替序数索引</h3><h3 id="34-用接口模拟可伸缩的枚举"><a href="#34-用接口模拟可伸缩的枚举" class="headerlink" title="34.用接口模拟可伸缩的枚举"></a>34.用接口模拟可伸缩的枚举</h3><h3 id="35-注解优先于命名模式"><a href="#35-注解优先于命名模式" class="headerlink" title="35.注解优先于命名模式"></a>35.注解优先于命名模式</h3><h3 id="36-坚持使用Override注解"><a href="#36-坚持使用Override注解" class="headerlink" title="36.坚持使用Override注解"></a>36.坚持使用Override注解</h3><h3 id="37-用标记接口定义类型"><a href="#37-用标记接口定义类型" class="headerlink" title="37.用标记接口定义类型"></a>37.用标记接口定义类型</h3><h2 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h2><h3 id="38-检查参数的有效性"><a href="#38-检查参数的有效性" class="headerlink" title="38.检查参数的有效性"></a>38.检查参数的有效性</h3><p>每当编写方法或者构造器时，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显示的检查来实施这些限制。<br>非公有的方法通常应该使用断言（assertion）来检查它们的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(long a[], int offset, int length)&#123;</span><br><span class="line">    assert a != null;</span><br><span class="line">    assert offset &gt;= 0 &amp;&amp; offset &lt;= a.length;</span><br><span class="line">    assert length &gt;= 0 &amp;&amp; length &lt;= a.length - offset;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="39-必要时进行保护性拷贝"><a href="#39-必要时进行保护性拷贝" class="headerlink" title="39.必要时进行保护性拷贝"></a>39.必要时进行保护性拷贝</h3><p>对于构造器的每个可变参数进行保护性拷贝（defensive copy）是必要的。<br>保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    this.start = start;</span><br><span class="line">    this.end = end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中虽然增加约束条件，但是Date在此对象外部还是可以被修改的，因为Date是引用传递，所以为避免这种问题，使用备份对象，而不是使用原始对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    this.start = new Date(start.getTime);</span><br><span class="line">    this.end = new Date(end.getTime);</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。<br>如果类中提供了对其可变内部成员的访问能力，则使它返回可变内部域的保护性拷贝即可。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date start = new Date();</span><br><span class="line">Date end = new Date();</span><br><span class="line">Period p = new Period(start, end);</span><br><span class="line">p.end().setYear(78);//end()方法返回Date对象，Period中提供setYear改变Date属性。</span><br></pre></td></tr></table></figure><p>为了保证传入Period中的start或者end不被改变，只需要修改Period中获取start和end的访问方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Date start()&#123;</span><br><span class="line">    return new Date(start.getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Date end()&#123;</span><br><span class="line"></span><br><span class="line">    return new Date(end.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数的保护性拷贝不仅仅针对不可变类。如果客户端提供的对象是可变的且该对象不允许在你的类对象中变化，就必须对该对象进行保护性拷贝。</p><p>如果拷贝成本受到限制，并且信任它的客户端不会不恰当的修改组件，就可以在文档中声明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。</p><h3 id="40-谨慎设计方法签名"><a href="#40-谨慎设计方法签名" class="headerlink" title="40.谨慎设计方法签名"></a>40.谨慎设计方法签名</h3><p>谨慎的选择方法的名称；<br>不要过于追求提供便利的方法。只有当一项操作被经常用到的时候，才考虑为它提供快捷方式（shorthand）。如果不确定还是不提供快捷为好；<br>避免过长的参数列表；</p><h3 id="41-慎用重载"><a href="#41-慎用重载" class="headerlink" title="41.慎用重载"></a>41.慎用重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionClassifier&#123;</span><br><span class="line"></span><br><span class="line">    public static String classify(Set&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;set&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(List&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;list&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(Collection&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;unknow&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">            new HashSet&lt;String&gt;(),</span><br><span class="line">            new ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">            new HashMap&lt;String, String&gt;().value()</span><br><span class="line">        &#125;;</span><br><span class="line">        for(Collection&lt;?&gt; c : collections)</span><br><span class="line">            System.out.println(classify(c)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果是打印“unknow”三次。</p><h3 id="42-慎用可变参数"><a href="#42-慎用可变参数" class="headerlink" title="42.慎用可变参数"></a>42.慎用可变参数</h3><p>定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用，使用不当，将产生混乱的结果。</p><h3 id="43-返回零长度的数组或者集合，而不是null"><a href="#43-返回零长度的数组或者集合，而不是null" class="headerlink" title="43.返回零长度的数组或者集合，而不是null"></a>43.返回零长度的数组或者集合，而不是null</h3><h3 id="44-为所有导出的API元素编写文档注释"><a href="#44-为所有导出的API元素编写文档注释" class="headerlink" title="44.为所有导出的API元素编写文档注释"></a>44.为所有导出的API元素编写文档注释</h3><h2 id="七、通用程序设计"><a href="#七、通用程序设计" class="headerlink" title="七、通用程序设计"></a>七、通用程序设计</h2><h3 id="45-将局部变量的作用域最小化"><a href="#45-将局部变量的作用域最小化" class="headerlink" title="45.将局部变量的作用域最小化"></a>45.将局部变量的作用域最小化</h3><p>要使用局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。<br>几乎每个局部变量的声明都应该包含一个初始化表达式。</p><h3 id="46-for-each循环优先于传统的for循环"><a href="#46-for-each循环优先于传统的for循环" class="headerlink" title="46.for-each循环优先于传统的for循环"></a>46.for-each循环优先于传统的for循环</h3><p>虽然for-each循环在简洁性和预防bug方面比传统的for循环有优势，且没有性能损失。但是有三种常见情况无法使用for-each:</p><ul><li>过滤： 如果需要遍历集合，并且删除选定的元素，就需要使用显式的迭代器。</li><li>转换： 如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引。</li><li>平行迭代： 如果需要并行的遍历多个集合，就需要显式的控制迭代器或者索引变量。</li></ul><h3 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47.了解和使用类库"></a>47.了解和使用类库</h3><p>每个程序员都应该熟悉java.lang、java.util、java.io中的内容。</p><h3 id="48-如果需要精确的答案，请避免使用float和double"><a href="#48-如果需要精确的答案，请避免使用float和double" class="headerlink" title="48.如果需要精确的答案，请避免使用float和double"></a>48.如果需要精确的答案，请避免使用float和double</h3><p>使用BigDecimal、int或者long进行计算。如果数值防伪不超过9位十进制数字，就可以使用int；如果不超过18位就可以使用long；如果数值超过18位就必须使用BigDecimal。</p><p>BigDecimal缺点：不方便，慢。</p><h3 id="49-基本类型优先于装箱基本类型"><a href="#49-基本类型优先于装箱基本类型" class="headerlink" title="49.基本类型优先于装箱基本类型"></a>49.基本类型优先于装箱基本类型</h3><p>基本类型与装箱基本类型之间主要区别：</p><ul><li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。</li><li>基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值之外，还有非功能值：null。</li><li>基本类型通常比装箱基本类型更节省空间和时间。</li></ul><p>第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型（在代码中不用自己去装箱，如果把基本类型放入集合中，集合会自动把基本类型装箱）。不能放在集合中的原因是：基本类型存放在栈上，集合中的引用则存在堆或方法取上。</p><p>在参数化类型中，必须使用装箱基本类型作为参数，Java不允许使用基本类型，因为Java泛型要求使用的是对象类型，基本类型不是对象类型。</p><h3 id="50-如果其他类型更适合，则尽量避免使用字符串"><a href="#50-如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="50.如果其他类型更适合，则尽量避免使用字符串"></a>50.如果其他类型更适合，则尽量避免使用字符串</h3><p>字符串不适合代替其他的值类型。<br>字符串不适合代替枚举类型。<br>字符串不适合代替聚集类型。<br>字符串也不适合代替能力表。</p><h3 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51.当心字符串连接的性能"></a>51.当心字符串连接的性能</h3><h3 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52.通过接口引用对象"></a>52.通过接口引用对象</h3><p>如果有适合的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。</p><p>如果没有合适的接口存在，完全可以用类而不是接口来引用对象：</p><ul><li>如果具体类没有相关联的接口，不管它是否表示一个值，你都没有别的选择，只有通过它的类来引用它的对象。</li><li>对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架（class-based</li><li>framework），就应该用相关的积累（base class）来引用这个对象，而不是用它的实现类。</li></ul><h3 id="53-接口优先于反射机制"><a href="#53-接口优先于反射机制" class="headerlink" title="53.接口优先于反射机制"></a>53.接口优先于反射机制</h3><p>反射机制：</p><ul><li>丧失了编译时类型检查的好处，包括异常检查。如果程序企图用反射方式调用不存在的活不可访问的方法，在运行时它将会失败，除非采用了特别的预防措施。</li><li>执行反射访问所需的代码非常笨拙和冗长。编写这样的代码非常乏味，阅读起来也很困难。</li><li>性能损失。反射方法调用比普通方法调用慢了许多。</li></ul><p>通常普通应用程序在运行时不应该以反射方式访问对象。<br>对于有些程序，它们必须用到在编译时无法获取的类，但是在编译时存在适当的接口或者超类，通过它们可以引用这个类。如果是这种情况，就可以以反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例。如果适当的构造器不带参数，甚至根本不需要使用<code>java.lang.reflect</code>；<code>Class.newInstance</code>方法就已经提供了所需的功能。</p><h3 id="54-谨慎的使用本地方法"><a href="#54-谨慎的使用本地方法" class="headerlink" title="54.谨慎的使用本地方法"></a>54.谨慎的使用本地方法</h3><h3 id="55-谨慎的优化"><a href="#55-谨慎的优化" class="headerlink" title="55.谨慎的优化"></a>55.谨慎的优化</h3><blockquote><p>很多计算上的过失都被归咎于效率（没有必要达到的效率），而不是任何其他的原因—甚至包括盲目的做傻事。<br>不要取计较效率上的一些小小的得失，在97%的情况下，不成熟的优化才是一切问题的根源。<br>在优化方面，我们应该遵守两条规则：<br>规则1: 不要进行优化。<br>规则2: 还是不要进行优化—也就是说，在你还没有绝对清晰的未优化方案之前，请不要优化。</p></blockquote><p>不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。好的程序体现了信息隐藏的原则：只要有可能，它们就会把设计决策几种在单个模块中，因此，可以改变单个决策，而不会影响到系统的其他部分。</p><p>在设计的过程中考虑性能问题。努力避免限制性能的设计决策。</p><h3 id="56-遵守普遍接受的命名惯例"><a href="#56-遵守普遍接受的命名惯例" class="headerlink" title="56.遵守普遍接受的命名惯例"></a>56.遵守普遍接受的命名惯例</h3><h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><h3 id="57-只针对异常的情况才使用异常"><a href="#57-只针对异常的情况才使用异常" class="headerlink" title="57.只针对异常的情况才使用异常"></a>57.只针对异常的情况才使用异常</h3><p>异常机制的设计初衷是用于不正常的情形，所以很少会有JVM实现试图对它们进行优化，使得与显式的测试一样快速。</p><p>把代码放在try-catch块中反而阻止了现代JVM实现本来可能要执行的某些特定的优化。</p><p>对数组进行遍历的标准模式并不会导致冗余的检查。有些现代的JVM实现会将它们优化掉。</p><h3 id="58-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#58-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="58.对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>58.对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><h3 id="59-避免不必要的使用受检异常"><a href="#59-避免不必要的使用受检异常" class="headerlink" title="59.避免不必要的使用受检异常"></a>59.避免不必要的使用受检异常</h3><h3 id="60-优先使用标准异常"><a href="#60-优先使用标准异常" class="headerlink" title="60.优先使用标准异常"></a>60.优先使用标准异常</h3><p><img src="/media/article/15583547431411.jpg" alt=""></p><h3 id="61-抛出域抽象相对应的异常"><a href="#61-抛出域抽象相对应的异常" class="headerlink" title="61.抛出域抽象相对应的异常"></a>61.抛出域抽象相对应的异常</h3><p>更高层次的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。<br>如果不能阻止或者处理来自低层的异常，一般做法是使用异常转译，除非低层方法碰巧可以保证它抛出的所有异常对高层也合适才可以将异常从低层传播到高层。异常链对高层和低层异常都提供了最佳功能：它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析。</p><h3 id="62-每个方法抛出的异常都要有文档"><a href="#62-每个方法抛出的异常都要有文档" class="headerlink" title="62.每个方法抛出的异常都要有文档"></a>62.每个方法抛出的异常都要有文档</h3><p>始终要单独的声明受检异常，并且利用Javadoc的@throws标记，准确的记录下抛出的每个异常的条件。</p><p>使用Javadoc的@throws标签记录下一个方法可能抛出的每个受检异常，但是不要使用throws关键字将未受检异常包含在方法的声明中。</p><p>如果一个类中的许多方法处于同样的原因而抛出同一个异常，则该类的文档注释中对这个异常建立文档，是可以接受的。</p><h3 id="63-在细节消息中包含能捕获失败的信息"><a href="#63-在细节消息中包含能捕获失败的信息" class="headerlink" title="63.在细节消息中包含能捕获失败的信息"></a>63.在细节消息中包含能捕获失败的信息</h3><p>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。</p><h3 id="64-努力使失败保持原子性"><a href="#64-努力使失败保持原子性" class="headerlink" title="64.努力使失败保持原子性"></a>64.努力使失败保持原子性</h3><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p><h3 id="65-不要忽略异常"><a href="#65-不要忽略异常" class="headerlink" title="65.不要忽略异常"></a>65.不要忽略异常</h3><h2 id="九、并发"><a href="#九、并发" class="headerlink" title="九、并发"></a>九、并发</h2><h3 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66.同步访问共享的可变数据"></a>66.同步访问共享的可变数据</h3><p>Java语言规范保证读或写一个变量是原子的，除非这个变量的类型为long或者double[JLS，17.4.7]。对于这句话不要误解，虽然语言规范保证了线程在读取原子数据的时候，不会看到任意的数值，但是它并不保证一个线程写入的值对于另一个线程将是可见的。为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。</p><h3 id="67-避免过度同步"><a href="#67-避免过度同步" class="headerlink" title="67.避免过度同步"></a>67.避免过度同步</h3><p>为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法，要尽量限制同步区域内部的工作量。</p><h3 id="68-executor和task优先于线程"><a href="#68-executor和task优先于线程" class="headerlink" title="68.executor和task优先于线程"></a>68.executor和task优先于线程</h3><h3 id="69-并发工具优先于wait和notify"><a href="#69-并发工具优先于wait和notify" class="headerlink" title="69.并发工具优先于wait和notify"></a>69.并发工具优先于wait和notify</h3><p>java.util.concurrent中更高级的的工具分成三类：Execcutor Framework、并发集合（Concurrent Collection）以及同步器（Synchronizer）。</p><p>同步器是一些使线程能够等待另一个线程的对象，允许它们协调动作。常用的是CountDownLatch和Semaphore。不常用的是CyclicBarrier和Exchanger。</p><p>对于间歇式的定时，始终应该优先使用System.nanoTime，而不是使用System.currentTimeMills。System.nanoTime更加准确也更加精确，它不受系统的实时时钟的调整所影响。</p><p>如果你在维护使用wait和notify的代码，务必确保始终是利用标准的模式从while循环内部调用wait。一般情况下，你应该优先使用notifyAll，而不是使用notify。如果使用notify，请一定小心，以确保程序的活性。</p><h3 id="70-线程安全性的文档化"><a href="#70-线程安全性的文档化" class="headerlink" title="70.线程安全性的文档化"></a>70.线程安全性的文档化</h3><p>一个类为了可被多个线程安全的使用，必须在文档中清楚的说明它所支持的线程安全级别。</p><ul><li>不可变的（immutable）这个类是不可变的。所以不需要外部同步。例如：String、Long、BigInteger。</li><li>无条件的线程安全（unconditionally thread-safe）这个类的实例是可变的，但是这个类有着足够的内部同步，所以，它的实例可以被并发使用，无需任何外部同步。例如：Random、ConcurrentHashMap。</li><li>有条件的线程安全（conditionally thread-safe）除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。例如：Collections.synchronized包装返回的集合，它们的迭代器（iterator）要求外部同步。</li><li>非线程安全（not thread-safe）这个类的实例是可变的。为了并发地使用它们，客户端必须利用自己选择的外部同步包围每个方法调用。例如：ArrayList、HashMap。</li><li>线程对立（thread-hostile）这个类不能安全的被多个线程并发使用，即使所有的方法调用都被外部同步包围。</li></ul><h3 id="71-慎用延迟初始化"><a href="#71-慎用延迟初始化" class="headerlink" title="71.慎用延迟初始化"></a>71.慎用延迟初始化</h3><p>延迟初始化（lazy initialization）是延迟到需要域的值时才将它初始化的这种行为。<br>大多数的域应该正常地进行初始化，而不是延迟初始化。如果为了达到性能目的，或者为了破坏有害的初始化循环，必须延迟初始化一个域则：<br>对于实例域，就使用双重检查模式（double-check idiom）；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            result = field;</span><br><span class="line">            if(result == null)&#123;</span><br><span class="line">                field = result = computeFieldValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于静态域，则使用lazy initialization holder class idiom；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class FieldHolder&#123;</span><br><span class="line">    static final FieldType field = computeFieldValue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static FieldType getField()&#123;return FieldHolder.field;&#125;</span><br></pre></td></tr></table></figure></p><p>对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式（single-check idiom）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line"></span><br><span class="line">private FieldType getField()&#123;</span><br><span class="line"></span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        field = result = computeFieldValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="72-不要依赖于线程调度器"><a href="#72-不要依赖于线程调度器" class="headerlink" title="72.不要依赖于线程调度器"></a>72.不要依赖于线程调度器</h3><h3 id="73-避免使用线程组"><a href="#73-避免使用线程组" class="headerlink" title="73.避免使用线程组"></a>73.避免使用线程组</h3><p>线程组的初衷是作为一种隔离applet的机制，当然是出于安全的考虑。线程组并没有提供太多有用的功能，而且它们提供的许多功能还都是有缺陷的。</p><h2 id="十、序列化"><a href="#十、序列化" class="headerlink" title="十、序列化"></a>十、序列化</h2><h3 id="74-谨慎的实现Serializable接口"><a href="#74-谨慎的实现Serializable接口" class="headerlink" title="74.谨慎的实现Serializable接口"></a>74.谨慎的实现Serializable接口</h3><p>实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。</p><p>如果接受了默认的序列化形式，并且以后要改变这个类的内部表示法，结果可能导致序列化形式的不兼容。</p><p>第二个代价是，它增加了出现Bug和安全漏洞的可能性。</p><p>实现Serializable第三个代价是，随着类发行新的版本，相关的测试负担也增加了。</p><p>为了继承而设计的类应该尽可能少的趋势线Serializable接口，用户的接口也应该尽可能少的继承Serializable接口。如果违反了这条规则，扩展这个类或者实现该接口的程序员就会背上沉重的负担。然而有些情况下，这条规则确实适合的。例如：如果一个类或者接口存在的目的主要是为了参加到某个框架中，该框架要求所有的参与者都必须实现Serializable接口，那么对于类或者接口来说实现扩展Serializable是有意义的。</p><p>如果一个专门为了继承而设计的类不是可序列化的，就不可能编写出可序列化的子类。特别是，如果超类没有提供可访问的无参构造器，子类也不可能做到序列化。对于未继承而设计的不可序列化的类，你应该提供一个无参构造器。</p><h3 id="75-考虑使用自定义的序列化形式"><a href="#75-考虑使用自定义的序列化形式" class="headerlink" title="75.考虑使用自定义的序列化形式"></a>75.考虑使用自定义的序列化形式</h3><p>如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Name implements Serializable&#123;</span><br><span class="line">    private final String lastName;</span><br><span class="line">    </span><br><span class="line">    private final String firstName;</span><br><span class="line">    </span><br><span class="line">    private final String middleName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使你确定了默认的序列化形式是合适的，通常还必须提供一个readObject方法保证约束关系和安全性。</p><p>当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下4个缺点：</p><ul><li>它使这个类的导出API永远地束缚在该类的内部表示法上。</li><li>它会消耗过多的时间。</li><li>它会消耗过多空间。</li><li>它会引起栈溢出。</li></ul><p>如果所有的实例域都是瞬时的（transient），从技术角度而言，不调用DefaultWriteObject和defaultReadObject也是允许的，但是不推荐这样做。<br>在决定将一个域做成非transient的之前，请一定要确信它的值将是该对象逻辑状态的一部分。<br>如果在读取整个对象状态的任何其他方法上强制任何同步，则也必须在对象序列化上强制这种同步。<br>不管你选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显式的序列版本UID（serial version UID）。</p><h3 id="76-保护性的编写readObject方法"><a href="#76-保护性的编写readObject方法" class="headerlink" title="76.保护性的编写readObject方法"></a>76.保护性的编写readObject方法</h3><p><strong><em>记得回来看反序列化代码</em></strong></p><p>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。保护性拷贝在有效性检查之前进行。</p><p>不要使用writeUnshared和readUnshared方法。</p><p>对于非final的可序列化类，readObject方法不可以调用可被覆盖的方法，无论是直接调用还是间接调用都不可以。如果违反了规则，并覆盖了该方法，被覆盖的方法将在子类的状态被序列化之前先运行，程序很可能失败。</p><p>readObject方法指导：</p><ul><li>对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别。</li><li>对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li><li>如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。</li><li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li></ul><h3 id="77-对于实例控制，枚举类型优先于readResolve"><a href="#77-对于实例控制，枚举类型优先于readResolve" class="headerlink" title="77.对于实例控制，枚举类型优先于readResolve"></a>77.对于实例控制，枚举类型优先于readResolve</h3><p>如果这个类的声明加上了“implements Serializable”的字样，它就不再是一个单例类。无论使用默认的序列化形式，还是自定义的序列化形式，都会返回一个新建的实例，这个新建实例不用于该类初始化时创建的实例。</p><p>readResolve特性允许你用readObject创建的实例代替另一个实例。对于一个正在被序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化后，新建对象上的readResolve方法就会被调用，该方法返回的对象引用将被返回，取代新建对象，指向新建对象的引用不需要再被保留，因此立即成为垃圾回收对象。</p><p>如果readResolve方法忽略被反序列化的对象，只返回该类初始化时创建的实例。如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient的。</p><p>readResolve的可访问性很重要。如果把readResolve方法放在一个final类上，它就应该是私有的。如果吧readResolve方法放在一个非final类上，就必须考虑它的可访问性。</p><p>尽可能的使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控（instance-controlled）的类，就必须提供一个readResolve方法，并确保该类的所有实例域都为基本类型，或者是transient的。</p><h3 id="78-考虑用序列化代理代替序列化实例"><a href="#78-考虑用序列化代理代替序列化实例" class="headerlink" title="78.考虑用序列化代理代替序列化实例"></a>78.考虑用序列化代理代替序列化实例</h3><p>每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。要想文件的带有重要约束条件的对象序列化，这种模式可能是最容易的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 枚举类</title>
      <link href="/zhongyp.github.io/java/2019-05-01-java-enum/"/>
      <url>/zhongyp.github.io/java/2019-05-01-java-enum/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java枚举类笔记，摘自《疯狂Java讲义》</p></blockquote><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在早期代码中，可能会直接使用简单的静态常量表示枚举，例如如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final int SEASON_SPRING = 1;</span><br><span class="line">public static final int SEASON_SUMMER = 2;</span><br><span class="line">public static final int SEASON_FALL = 3;</span><br><span class="line">public static final int SEASON_WINTER = 4;</span><br></pre></td></tr></table></figure><p>但是这种方式定义会存在如下问题：</p><ul><li>类型不安全：可能存在SEASON_SPRING + SEASON_FALL。</li><li>没有命名空间：当需要使用季节时，必须在SPRING钱使用SEASON_前缀，否则程序可能与其他类中的静态常量混淆。</li><li>打印输出的意义不明确：当输出某个季节时，实际的输出值时数字。</li></ul><p>JDK1.5 之后新增了enum关键字，用来定义枚举类。枚举类是一种特殊类，有自己的成员变量、方法，可以实现一个或者多个接口，可以定义自己的构造器。一个Java源文件中最多只能定一个public访问权限的枚举类，且该Java源文件必须和该枚举类的类名相同。和普通类区别如下：</p><ul><li>使用enum定义的默认枚举类默认继承了java.lang.Enum类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。</li><li>使用enum定义、<strong>非抽象</strong>的枚举类默认会使用final修饰，因此不能派生子类。</li><li>枚举类的构造器只能使用private访问控制符。</li><li>枚举类所有的实例必须在枚举类的第一行显示列出，否则这个枚举类永远都不能产生实例。</li></ul><p>Java枚举类型基本思想：通过公有的静态final域为每个枚举常量到处实例的类。因为没有可以访问的构造器，枚举类型是真正的final。</p><h3 id="1-枚举类的成员变量、方法和构造器"><a href="#1-枚举类的成员变量、方法和构造器" class="headerlink" title="1. 枚举类的成员变量、方法和构造器"></a>1. 枚举类的成员变量、方法和构造器</h3><p>枚举类也是一种比较特殊的类。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;),FEMALE(&quot;女&quot;);</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看出，枚举类中列出枚举值时，实际上就是调用构造器创建枚举类对象，只是这里不是使用new关键字，也无需显式调用构造器。</p><p>上面<code>MALE(&quot;男&quot;),FEMALE(&quot;女&quot;)</code>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void final Gender MALE = new Gender(&quot;男&quot;)；</span><br><span class="line">public static void final Gender FEMALE = new Gender(&quot;女&quot;)；</span><br></pre></td></tr></table></figure></p><h3 id="2-实现接口的枚举类"><a href="#2-实现接口的枚举类" class="headerlink" title="2. 实现接口的枚举类"></a>2. 实现接口的枚举类</h3><p>接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface GenderDesc&#123;</span><br><span class="line">    void info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;men&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,FEMALE(&quot;女&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;women&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong>并非所有的枚举类都使用final修饰，非抽象的枚举类才默认使用final修饰。对于一个抽象的枚举类，系统默认使用abstract修饰，而不是final。</p><h3 id="3-包含抽象方法的抽象类"><a href="#3-包含抽象方法的抽象类" class="headerlink" title="3. 包含抽象方法的抽象类"></a>3. 包含抽象方法的抽象类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public enum Operation&#123;</span><br><span class="line"></span><br><span class="line">    PLUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x-y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x*y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x/y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    public abstract double eval(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Serializable</title>
      <link href="/zhongyp.github.io/java/2019-04-27-java-serializable/"/>
      <url>/zhongyp.github.io/java/2019-04-27-java-serializable/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java序列化笔记，摘自《疯狂Java讲义》</p></blockquote><h2 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h2><h3 id="1-序列化的含义和意义"><a href="#1-序列化的含义和意义" class="headerlink" title="1.序列化的含义和意义"></a>1.序列化的含义和意义</h3><p>对象序列化指将一个Java对象写入IO流中。<br>对象支持序列化则必须让它的类是可序列化的。该类必须实现如下两个接口之一</p><ul><li><code>Serializable</code></li><li><code>Externalizable</code></li></ul><p>建议：JavaBean类都实现Serializable。</p><h3 id="2-使用对象流实现序列化"><a href="#2-使用对象流实现序列化" class="headerlink" title="2.使用对象流实现序列化"></a>2.使用对象流实现序列化</h3><ul><li>反序列化读取的仅仅是Java对象的数据，而不是Java类，因此采用反序列化恢复Java对象时，必须提供该Java对象所属类的class文件，否则将会引发ClassNotFoundException异常。</li><li>反序列化无需通过构造器来初始化Java对象。</li><li>如果使用序列化机制向文件中写入了多个Java对象，使用反序列化机制恢复对象时必须按实际写入顺序读取。</li><li>当一个可序列化类有多个父类时，这些父类要么有无参数构造器，要么也是可序列化的，否则抛出InvalidClassException。</li><li>如果父类时不可序列化的，只带有无参数构造器，则该父类中定义的成员变量值不会序列化到二进制流中。（反序列化时会调用父类的无参构造器，重新实例化父类对象）</li></ul><h3 id="3-对象引用的序列化"><a href="#3-对象引用的序列化" class="headerlink" title="3.对象引用的序列化"></a>3.对象引用的序列化</h3><p>Java序列化机制算法：</p><ul><li>所有保存到磁盘中的对象都有一个序列化编号。</li><li>当程序试图序列化一个对象时，程序将先检查该对象是否已经被序列化过，只有该对象从未被序列化过，系统才会将该对象转换成字节序列并输出。</li><li>如果某个对象已经序列化过，程序将直接输出一个序列化编号，而不是再次重新序列化该对象。</li></ul><p>注：当程序序列化一个可变对象时，只有第一次writeObject()方法输出时才会将该对象转换成字节序列并输出，当再次调用writeObject()方法时，程序只是输出前面的序列化编号，即使后面该对象的实例变量值已被改变，改变的实例变量值也不会被输出。</p><h3 id="4-自定义序列化"><a href="#4-自定义序列化" class="headerlink" title="4.自定义序列化"></a>4.自定义序列化</h3><blockquote><p>当对某个对象进行序列化时，系统会自动把该对象的所有实例变量依次进行序列化，如果某个实例变量引用另一个对象，则被引用的对象也会被序列化；如果被引用的对象实例变量也引用了其他对象，则被引用的对象也会被序列化，这种情况被称为递归序列化。</p></blockquote><h4 id="4-1-transient关键字"><a href="#4-1-transient关键字" class="headerlink" title="4.1 transient关键字"></a>4.1 transient关键字</h4><p>在实例变量前使用transient关键字修饰，可以指定Java序列化时无需理会该实例变量。<br>transient关键字只能用于修饰实例变量，不能用于修饰Java程序中的其他成分。<br>transient关键字修饰实例变量将被完全隔离在序列化机制之外，这样导致在反序列化恢复Java对象时无法取得该实例的变量值。</p><h4 id="4-2-自定义序列化"><a href="#4-2-自定义序列化" class="headerlink" title="4.2 自定义序列化"></a>4.2 自定义序列化</h4><p>在类中提供如下方法，这些方法用以实现自定义序列化。</p><ul><li><code>private void writeObject(java.io.ObjectOutputStream out)throws IOException</code></li><li><code>private void readObject(java.io.ObjectInputStream in)throws IOException,ClassNotFoundException</code></li><li><code>private void readObjectNoData()throws ObjectStreamException</code></li></ul><p>注：writeObject的顺序与readObject的顺序一致，否则不能正常恢复Java对象。</p><p>writeReplace方法由序列化机制调用，只要该方法存在。在序列化某个对象前，先调用该对象writeReplace()方法，如果该方法返回另一个Java对象，则系统转化序列化另一个对象。<br>与writeReplace方法相对的是，readResolve()，这个方法在readObject()后被调用，该方法的返回值将代替原来反序列化的对象，原来的对象被丢弃。<br>readResolve()在序列化单例类和枚举类时尤其有用。所有的单例类和枚举类在实现序列化时都应该提供readResolve方法，这样才能保证反序列化的正常。</p><h3 id="5-自定义序列化机制"><a href="#5-自定义序列化机制" class="headerlink" title="5.自定义序列化机制"></a>5.自定义序列化机制</h3><p>Java除了Serializable，还提供了另一种序列化机制，这种序列化方式完全由程序员决定存储和恢复对象数据。要实现该目标，Java必须实现Externalizable接口，接口中方法如下：</p><ul><li><code>void readExternal(ObjectInput in)</code>：需要实现readExternal方法实现反序列化。</li><li><code>void writeExternal(ObjectOutput out)</code>：需要实现writeExternal方法来保存对象状态。</li></ul><p>两种序列化机制的对比：</p><p>Serializable</p><ul><li>系统自动保存必要信息</li><li>Java内建支持，易于实现，只需实现该接口即可，无需任何代码支持（也可以自定义）</li><li>性能略差</li></ul><p>Externalizable</p><ul><li>程序员决定存储哪些信息</li><li>仅仅提供空方法，必须自定义实现序列化</li><li>性能略高</li></ul><blockquote><p><strong>注意</strong></p><ul><li>对象的类名、属性（基本类型、数组、对其他对象的引用）都会被序列化；方法、static属性、transient属性都不会被序列化。</li><li>实现Serializable接口的类如果需要想让某个属性不被序列化，可在属性前加transient修饰符，而不是加static。</li><li>保证序列化对象的属性的类型也是可序列化的，否则需要使用transient关键字来修饰该属性，要不然，则该类是不可序列化的。</li><li>反序列化对象时必须有序列化对象的class文件。</li></ul></blockquote><h3 id="6-版本"><a href="#6-版本" class="headerlink" title="6.版本"></a>6.版本</h3><p>反序列化Java对象时必须提供该对象的class文件，如果项目升级，Java如何保证两个class文件的兼容性？</p><p>Java序列化机制允许为序列化类提供一个private static final的serialVersionUID属性值，该属性值用于表示该Java类的序列化版本。</p><ul><li>如果修改类时仅仅修改了方法，则反序列化完全不受任何影响，类定义无需修改serialVersionUID的属性值。</li><li>如果修饰类时仅仅修改了静态属性或瞬态属性，则反序化不受任何影响，类定义无需修改serialVersionUID属性值。</li><li>如果修改类时修饰了非静态、非瞬态属性，则可能导致序列化版本不兼容，如果对象流中的对象和新类中包含同名的属性，而属性类型不同，则反序列化失败，类定义应该更新serialVersionUID属性值。如果对象流中对象比新类中包含更多的属性，则多处的属性值被忽略，序列化版本可以兼容，类定义可以不更新serialVersionUID属性值；但反序列化得到的新对象中多处的属性值都是null（引用类型属性）或0（基本类型属性）。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Transaction Management(译文)</title>
      <link href="/zhongyp.github.io/transaction/2019-03-07-spring-transaction-management/"/>
      <url>/zhongyp.github.io/transaction/2019-03-07-spring-transaction-management/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-事务管理"><a href="#Spring-事务管理" class="headerlink" title="Spring 事务管理"></a>Spring 事务管理</h1><p>翻译自<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-motivation" target="_blank" rel="noopener">spring/docs/4.2.x</a></p><p>翻译过程中使用工具：google翻译，欧路词典</p><p>名词解释：<br>JTA：Java Transaction API<br>JPA：Java Persistence API<br>JDO：Java Data Object<br>CMT： Container Managed Transactions<br>JNDI：Java Naming and Directory Interface<br>JMS： Java Message Service<br>JCA： Java EE Connector Architecture</p><h2 id="1-事务管理"><a href="#1-事务管理" class="headerlink" title="1. 事务管理"></a>1. 事务管理</h2><h2 id="1-1-Spring框架事务管理介绍"><a href="#1-1-Spring框架事务管理介绍" class="headerlink" title="1.1 Spring框架事务管理介绍"></a>1.1 Spring框架事务管理介绍</h2><p>全方面的事务支持是使用Spring框架的最引人注目的原因之一。Spring框架为事务管理提供一致性抽象提供了如下好处：</p><ul><li>一致性编程模型横跨不同的事务APIs，例如 JTA，JPA，JDO。</li><li>支持声明式事务管理</li><li>和复杂编程事务APIs（例如JTA）相比，Spring提供更简单的编程事务管理的API。</li><li>与Spring的数据访问抽象有良好的集成。</li></ul><p>下面的部分描述Spring框架的事务value-adds和技术。(这部分也包含对于最好事务管理的实践，应用服务器集成和常见问题解决方案的讨论)</p><ul><li><a href="#1-2-Spring框架事务支持模型的优势">Spring框架事务支持模型的优势</a>描述你为什么会使用Spring框架的事务抽象，而不是选择EJB的容器管理事务或者通过专有的API（例如Hibernate）驱动本地事务。</li><li><a href="#1-3-理解Spring框架事务抽象">理解Spring框架的事务抽象</a>概述核心类和描述怎样配置和怎样从各种类型的数据源中获取数据源。</li><li><a href="#1-4-将资源与事务同步">将资源与事务同步</a>描述应用代码怎样确保资源的创建，复用和正确的清理。</li><li><a href="#1-5-声明式事务管理">声明式事务管理</a>描述支持声明式事务管理。</li><li><a href="#1-6-编程事务管理">编程事务管理</a>包含支持编程事务管理。</li><li><a href="#1-8-事务约束事件">事务约束事件</a>描述你可以怎样在事务中使用应用程序事件。</li></ul><h2 id="1-2-Spring框架事务支持模型的优势"><a href="#1-2-Spring框架事务支持模型的优势" class="headerlink" title="1.2 Spring框架事务支持模型的优势"></a>1.2 Spring框架事务支持模型的优势</h2><p>传统上，Java EE的开发者对于事务管理有两种选择：全局或者本地事务管理，这两种都有很大的局限性。全局和本地事务管理将在下面的两小节中回顾，接着是Spring框架管理支持解决全局和本地事务管理模型局限性的讨论。</p><h3 id="1-2-1-全局事务"><a href="#1-2-1-全局事务" class="headerlink" title="1.2.1 全局事务"></a>1.2.1 全局事务</h3><p>全部事务管理允许你和多个事务资源一块运行，事务资源一般是关系型数据库和消息队列。应用服务器通过JTA管理全局事务，JTA是一个用起来笨重的API（部分是由于它的异常模型决定的）。此外，JTA<code>UserTransaction</code>正常来说需要JNDI引入资源，意味着为了使用JTA你还需要使用JNDI。显然，全局事务的使用将会限制应用代码潜在的复用，同时JTA只能在应用服务器环境中可用。<br>先前，使用全局事务比较好的方式是通过EJB的容器管理事务：CMT是一张声明式事务管理表（对于编程事务管理也同样好用）。EJB CMT删除了关联事务JNDI的查找，尽管EJB自己必须要使用JNDI。它消除了编写Java代码以控制事务的大部分但不是全部的需要。CMT最大的缺陷是捆绑JTA和应用的服务器环境。同时，CMT只有在EJBs里实现业务逻辑才可用，或者至少在一个事务EJB facade之前。通常EJB的负面影响太大以致于这不是一个有吸引力的方案，尤其是面对声明式事务管理的引人注目的备选方案。</p><h3 id="1-2-2-本地事务"><a href="#1-2-2-本地事务" class="headerlink" title="1.2.2 本地事务"></a>1.2.2 本地事务</h3><p>本地事务是特定于资源的，比如一个事务关联一个JDBC连接。本地事务可能使用简单，但是有明显的缺陷：它们不能在多个事务资源上工作。举个例子，使用JDBC连接的管理事务代码不能在全局JTA事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个数据源的正确性。（值得注意的是，大多数应用使用单个事务资源）另一个缺陷是本地事务在编程模型中是侵入式的。</p><h3 id="1-2-3-Spring框架的一致性编程模型"><a href="#1-2-3-Spring框架的一致性编程模型" class="headerlink" title="1.2.3 Spring框架的一致性编程模型"></a>1.2.3 Spring框架的一致性编程模型</h3><p>Spring 解决了全局和本地事务的缺陷。它允许程序员在任何环境中使用一致性编程模型。你写一次代码，它可以在不同环境中的不同事务管理策略中受益。Spring框架提供声明和编程事务管理。大多数用户使用在大多数情况下被推荐使用的声明式事务模型。<br>对于编程式事务管理，开发者将使用Spring 框架的事务抽象，它可以在底层的事务基础设施上运行。对于声明式模型，开发经常写一点或者没有代码去关联事务管理，因此不依赖Spring框架的事务API或者其他的事务API。</p><blockquote><p><b>对于事务管理，你是否需要应用服务器？</b><br>Spring 框架事务管理支持当企业Java应用需要应用服务器时修改传统规则。<br>尤其，你只是需要通过EJBs声明事务而不是需要应用服务器。事实上，<strong>即使你的应用服务器有的JTA能</strong>力，对比EJB CMT，你可能决定使用Spring框架的声明式事务提供更多能力和一个富有成效的编程模型。<br>通常你需要使用应用服务器的JTA能力仅仅因为你的应用需要跨多个资源去处理事务，这种情况对于许多应用是不需要的，许多高端应用使用一个高扩展性的数据库（如：Oracle RAC）代替多个资源。独立事务管理如 Atomikos Transactions 和 JOTM是其他选择。当然，你可能需要其他应用服务器能力，如Java消息服务和JCA。<br>Spring框架给你当需要扩展你的应用去完整加载应用服务器的选择，替代使用EJB CMT或者JTA的唯一方式是使用本地事务（如：JDBC连接）写代码的日子一去不复返了，如果你需要在全局或者CMT中运行该本地事务代码将会面对大量的返工。使用Spring框架，你仅仅需要在配置文件中定义一些bean，而不是需要去修改代码。</p></blockquote><h2 id="1-3-理解Spring框架事务抽象"><a href="#1-3-理解Spring框架事务抽象" class="headerlink" title="1.3 理解Spring框架事务抽象"></a>1.3 理解Spring框架事务抽象</h2><p><strong>spring框架事务抽象的关键是事务策略的概念</strong>，通过<code>org.springframework.transaction.PlatformTransactionManager</code>接口定义事务策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager&#123;</span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition) throws TransactionException;</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个主要是Java的服务提供发现机制，尽管可以从应用代码中以编程方式使用。因为<code>PlatformTransactionManager</code>是一个接口，它可以在被需要是很容易的仿制或者存根。它和类似JNDI的查找策略无关。<br>定义<code>PlatformTransactionManager</code>的接口实现和spring IoC容器中的其他对象（或bean）相同。即使你使用JTA，仅此一项好处也使得Sping框架事务值得被抽象。相比于直接使用JTA，使用Spring事务抽象可以让测试事务代码更简单。<br>可以被任何<code>PlatformTransactionManager</code>接口的实现方法抛出的非检查（继承<code>java.lang.RuntimeException</code>的类）的<code>TransactionException</code>再次符合Spring的理念。事务基础设施的故障几乎总是致命的。应用代码在极少数情况下可以从事务失败中恢复，应用开发者可以选择捕获和处理<code>TransactionException</code>。重点是开发者不必强制去这样做。<br><code>getTransaction(..)</code>方法返回<code>TransactionStatus</code>对象，依赖一个<code>TransactionDefinition</code>参数。返回的<code>Transaction</code>可能代表一个新事务，或者可以代表一个已经存在的事务如果此事务在当前调用栈中存在匹配的事务。后者的意义是在Java EE事务上下文中，一个线程的执行和一个<code>TransactionStatus</code>相关联。<code>TransactionDefinition</code>接口指定：</p><ul><li>Isolation: 当前事务和其他事务在工作中的隔离程度。例如： 此事务是否可以看到来自其他事务的未提交的写入？</li><li>Propagation: 通常，在事务范围内运行的所有代码都将在此事务中运行。但是，你可以选择在事务上下文已经存在且执行事务方法的事件中指定行为。例如：代码可以在已存在的事务中继续运行（常见情况）;或者挂起已存在的事务，新建事务。Spring提供了EJB CMT中熟悉的所有事务传播选择。了解Spring中关于事务传播语义，<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#tx-propagation" target="_blank" rel="noopener">事务传播</a>。</li><li>Timeout: 在超时和底层事务基础设施自动回滚事务之前，事务可以运行多久？</li><li>Read-only status: 当你的代码读取但是不修改数据数据时可以使用只读事务。只读事务在某些情况下是有用的优化，例如当你使用Hibernate时。</li></ul><p>这些事务反映出了标准的事务概念，如果需要，请参阅讨论事务隔离等级和其他核心事务概念的资源。理解这些概念对使用Spring框架或者其他事务管理的解决方案是很必要的。</p><p><code>TransactionStatus</code>接口提供简单的事务代码去控制事务执行和查询事务状态。这些概念应该是熟悉的，它们对所有事务APIs都是通用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager&#123;</span><br><span class="line">    boolean isNewTransaction();</span><br><span class="line">    boolean hasSavepoint();</span><br><span class="line">    void setRollbackOnly();</span><br><span class="line">    boolean isRollbackOnly();</span><br><span class="line">    void flush();</span><br><span class="line">    boolean isCompleted();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论你在Spring中选择声明式事务还是编程式事务管理，定义正确的<code>PlatformTransactionManager</code>实现是绝对必要的。通常通过依赖注入定义这个实现。</p><p><code>PlatformTransactionManager</code>实现通常需要了解他们运行的环境：JDBC，JTA，Hibernate等等。下面的例子展示你怎样定义一个本地的<code>PlatformTransactionManager</code>实现。（这个例子适用普通的JDBC。）<br>定义一个JDBC<code>DataSource</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>相关<code>PlatformTransactionManager</code>的bean定义将有一个<code>DataSource</code>定义的引用。它看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>如果你在Java EE容器中使用JTA，你将使用通过容器从JNDI中获取的<code>DataSource</code>，和Spring的JtaTransactionManager相关联。这就是JTA和JNDI查找版本的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/jee</span><br><span class="line">        http://www.springframework.org/schema/jee/spring-jee.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;jdbc/jpetstore&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><code>JtaTransactionManager</code>不需要知道<code>DataSource</code>或者其他指定的资源，因为它使用容器的全局事务管理基础设施。</p><blockquote><p>以上定义的<code>dataSource</code>bean使用<code>jee</code>命名空间的<code>&lt;jdni-lookup/&gt;</code>标签。对于<code>schema-based</code>的更多配置信息，<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html" target="_blank" rel="noopener">Chapter40, XML Schema-based 配置</a>，对于<code>&lt;jee/&gt;</code>标签的更多信息，请看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html#xsd-config-body-schemas-jee" target="_blank" rel="noopener">Section 40.2.3</a></p></blockquote><p>你也可以使用轻松的使用Hibernate本地事务，正如在下面展示的例子。这种情况，你需要定义一个Hibernate<code>LocalSessionFactoryBean</code>，你的代码将使用它去获取Hibernate<code>Session</code>实例。</p><p><code>DataSource</code>bean定义和之前示例本地JDBC例子相似，所以下面不在展示。</p><blockquote><p>如果<code>DataSource</code>被任何非JTA事务管理使用，将通过JNDI查找，Java EE容器管理，然后它将是非事务性的，因为是使用Spring框架管理事务，而不是Java EE容器。</p></blockquote><p><code>txManager</code>bean 在这种情况下是属于<code>HibernateTransactionManager</code>类型。以相同的方式，正如<code>DataSourceTransactionManager</code>需要引用<code>DataSource</code>，<code>HiberanteTransactionManager</code>需要引用<code>SessionFactory</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;mappingResources&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;hibernateProperties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            hibernate.dialect=$&#123;hibernate.dialect&#125;</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果你使用Hibernate和Java EE容器管理JTA事务，你应该使用与之前JDBC的JTA例子相同的<code>JtaTransactionManager</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果你使用JTA，你的事务管理定义将看起来一样，而不管你用了什么数据访问技术，是JDBC，Hibernate JPA或者其他支持的技术。这个是确定的事实，JTA 事务是全局事务，可以加入任何的事务资源。</p></blockquote><p>对于以上所有情况，应用代码不需要 改变。你可以通过改变配置来改变如何管理事务，即使你从本地事务改为全局事务，反之亦然。</p><h2 id="1-4-将资源与事务同步"><a href="#1-4-将资源与事务同步" class="headerlink" title="1.4 将资源与事务同步"></a>1.4 将资源与事务同步</h2><p>现在你应该很清楚如何创建不同的事务管理，和它们怎样和需要被同步事务相关资源链接（例如：<code>DataSourceTransactionManager</code>链接JDBC<code>DataSource</code>，<code>HibernateTransactionManager</code>链接Hibernate<code>SessionFactory</code>，等等。）这个章节描述应用代码怎样直接或者非直接使用持久API，如JDBC，Hibernate，或者JDO，确保这些资源被创建，复用，和正确的清理。这个章节也讨论事务同步怎样通过相应的<code>PlatformTransactionManager</code>触发。</p><h3 id="1-4-1-高级同步方式"><a href="#1-4-1-高级同步方式" class="headerlink" title="1.4.1 高级同步方式"></a>1.4.1 高级同步方式</h3><p>首选方法是使用Spring基于高级模板的持久性集成APIs或者使用本地ORM APIs与transacton-aware工厂bean或者代理一起使用，来管理本地资源工厂。transaction-aware解决方案在内部处理资源的创建，复用，清理，资源的可选事务同步和异常映射。因此用户数据访问代码不必解决这些任务，但是可以完全关注于非样板持久逻辑。通常，你使用本地ORM API或者使用模版方式通过使用<code>JdbcTemplate</code>进行JDBC访问。这些解决方案在本参考文档的随后章节中有详细说明。</p><h3 id="1-4-2-低级同步方式"><a href="#1-4-2-低级同步方式" class="headerlink" title="1.4.2 低级同步方式"></a>1.4.2 低级同步方式</h3><p>类例如：<code>DataSourceUtils</code>（JDBC），<code>EntityManagerFactoryUtils</code>(JPA)，<code>SessionFactoryUtils</code>（Hibernate），<code>PersistenceManagerFactoryUtils</code>(JDO)，等类存在于较低级别。<br>本地持久化APIs，你使用这些类去确保Spring框架管理的实例被正确获取，事务被同步（可选），在进程中发生的异常正确的被映射到一致的API。<br>例如，在JDBC的情况下，而不是在<code>DataSource</code>调用<code>getConnection()</code>方法的传统的JDBC方式,你替换使用Spring的<code>org.springframework.jdbc.datasource.DataSourceUtils</code>类，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DataSourceUtils.getConnection(dataSource);</span><br></pre></td></tr></table></figure></p><p>如果一个已经存在的事务有一个链接和它同步，这个实例将被返回。否则，这个方法调用出方法新链接的创建，这个链接（可选）被同步到已经任何已存在的事务上，使得在随后的同一事务中重复调用。 如上所述，任何<code>SQLException</code>在Spring框架<code>CannotGetJdbcConnectionException</code>中是被包括的，是Spring框架非校验数据访问异常之一。这个方式提供了比你从<code>SQLException</code>中轻松获的更多的信息，确保跨数据库的可移植性，设置跨不同的持久化技术。</p><p>这种方式运行也没有Spring事务管理（事务同步时可选的），所以无论你是否使用Spring事务管理，你都可以使用它。</p><p>当然，一旦你使用了Spring的JDBC支持，JPA支持或者Hibernate支持，你通常更喜欢不使用<code>DataSourceUtils</code>或者其他的类，因为相比于直接使用相关的APIs，通过Spring抽象你将工作的更快乐。例如：你使用Spring<code>JdbcTemplate</code>或者<code>jdbc.object</code>包去简化你使用的JDBC，在幕后发生的链接恢复，你将不在需要写任何特定代码。</p><h3 id="1-4-3-TransactionAwareDataSourceProxy"><a href="#1-4-3-TransactionAwareDataSourceProxy" class="headerlink" title="1.4.3 TransactionAwareDataSourceProxy"></a>1.4.3 TransactionAwareDataSourceProxy</h3><p><code>TransactionAwareDataSourceProxy</code>类作为一个低级存在。这是一个<code>DataSource</code>的代理，它包装目标DataSource以增加对Spring管理的事务的认识。在这个方面，它类似于通过Java EE服务器提供的事务JNDI<code>DataSource</code>。</p><p>使用这个累根本不需要或者不可取，除非当已存在的代码必须被调用和传递了一个标准JDBC<code>DataSource</code>接口实现。在这种情况下，代码可能有用，但是参与Spring的事务管理。最好是通过使用上面提到的高级抽象去写新代码。</p><h2 id="1-5-声明式事务管理"><a href="#1-5-声明式事务管理" class="headerlink" title="1.5 声明式事务管理"></a>1.5 声明式事务管理</h2><blockquote><p>大多数Spring框架用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。</p></blockquote><p>使用Spring切面编程的Spring 框架的声明式事务管理成为可能。但是，由于事务切面代码随Spring Framework发行版一起提供并且可能以样板方式使用，因此通常没必要理解AOP概念来有效地使用此代码。</p><p>Spring 框架的声明式事务管理和 EJB CMT在给单个方法级别指定（缺少）事务的行为是相似的。在需要的情况下，不使用事务上下文调用<code>setRollbackOnly()</code>是可能的。两种事务管理类型的不同点是：</p><ul><li>和 EJB CMT不一样，绑定JTA，Spring框架的声明式事务管理可以在任何环境中运行。也可以通过调整配置文件使用JTA事务或者使用JDBC，JPA，Hibernate或者JDO本地事务。</li><li>你可以对任意类用Spring框架声明式事务管理，不仅仅是对于像EJBs的特殊类。</li><li>Spring框架提供声明式回滚规则，没有和EJB等效的功能。提供编程式和声明式两种回滚规则支持。</li><li>Spring框架允许通过使用AOP自定义事务行为。例如，你可以在事务回滚的情况下插入自定义行为。你随着事务advice也可以添加任意advice。使用EJB CMT，除了<code>setRollbackOnly</code>你无法影响容器的事务管理。</li><li>Spring框架和高端服务器一样不支持跨远程调用事务上下文传播特性。如果你需要使用这种特性，我们建议你使用EJB。但是，使用这种特性之前考略清楚，因为一般来说，不想支持事务的跨远程调用。</li></ul><blockquote><p><b>TransactionProxyFactoryBean在哪？</b><br>   在Sping的2.0版本及以上版本的声明事务配置和以前的Spring版本有很大的区别。主要的不同是不在需要配置<code>TransactionProxyFactoryBean</code>beans。<br>   Spring2.0版本之前的配置依然是100%有效的配置；将新<code>&lt;tx:tags/&gt;</code>视为代表你简单的定义<code>TransactionProxyFactoryBean</code> beans。   </p></blockquote><p>回滚规则的概念是重要的：它们允许你头指定哪种异常（或者抛出）应该造成自动的回滚。你以声明的方式指定它，在配置中，不在Java代码中。因此，尽管你可以始终在<code>TransactionStatus</code>对象上调用<code>setRollbackOnly</code>方法去回滚当前事务，但是大多数你常常可以指定<code>MyApplicationException</code>必须总是造成回滚的规则。这个选择对的重大优势是业务对象不依赖事务基础设施。例如，它们通常需要导入Spring 事务APIs或者其他Spring APIs。</p><p>尽管EJB容器默认行为在系统异常（通常是运行时异常）中自动回滚事务，EJB CMT在应用异常（除<code>java.rmi.RemoteException</code>外的检查时异常）中不自动回滚事务。虽然Spring声明式事务管理的默认行为遵循EJB约定（仅仅在非检查异常时自动回滚），但是，自定义这个行为是经常有用的。</p><h3 id="1-5-1-理解声明式事务管理实现"><a href="#1-5-1-理解声明式事务管理实现" class="headerlink" title="1.5.1 理解声明式事务管理实现"></a>1.5.1 理解声明式事务管理实现</h3><p>简单的告诉你去使用<code>@Transactional</code>注解去注解你的类，在配置中添加<code>@EnableTransactionMangement</code>，然后期待你理解它全部怎样运行的是不足够的。这个章节解释在发生与事务相关的问题时Spring的声明式事务基础设施内部工作原理。<br>关于Spring框架的说明书事务支持最重要的概念是通过AOP代理启用这个支持，事务advice由元数据（目前基于XML或者注解）驱动。事务元数据和AOP的组合生成一个代理，这个代理使用<code>TransactionInterceptor</code>和适当的<code>PlatfromTransactionManager</code>实现来驱动围绕方法调用的事务。</p><blockquote><p>Spring AOP 包含在<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring.</a></p></blockquote><p>从概念上讲，调用在一个事务代理上的一个方法像这样：</p><p><img src="media/15528176890745.png" alt=""></p><h3 id="1-5-2-声明式事务实现的例子"><a href="#1-5-2-声明式事务实现的例子" class="headerlink" title="1.5.2 声明式事务实现的例子"></a>1.5.2 声明式事务实现的例子</h3><p>考虑下面的接口，和随后的实现。这个例子使用<code>Foo</code>和<code>Bar</code>类作为标志符，以便于你可以不用管不住特殊域模型，只集中关注事务的使用。对于这个例子的目的，在每一个实现方法体内，<code>DefaultFooService</code>类抛出<code>UnsupportedOperationException</code>实例的事实是好的；它允许你查看创建的事务和然后回滚来响应<code>UnsupportedOperationException</code>实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public interface FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName, String barName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<code>FooService</code>接口的前面两个方法，<code>getFoo(String)</code>和<code>getFoo(String, String)</code>，必须在一个带有只读语义事务的上下文中执行，和其他的方法，<code>insertFoo(Foo)</code>和<code>updateFoo(Foo)</code>，必须在带有只读语义事务上下文中执行。如下配置在下面的几段中被详细解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the transactional advice (what &apos;happens&apos;; see the &lt;aop:advisor/&gt; bean below) --&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;!-- the transactional semantics... --&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!-- all methods starting with &apos;get&apos; are read-only --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;!-- other methods use the default transaction settings (see below) --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ensure that the above transactional advice runs for any execution</span><br><span class="line">        of an operation defined by the FooService interface --&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;fooServiceOperation&quot; expression=&quot;execution(* x.y.service.FooService.*(..))&quot;/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;fooServiceOperation&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- don&apos;t forget the DataSource --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;scott&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;tiger&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- similarly, don&apos;t forget the PlatformTransactionManager --&gt;</span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>检查前面的配置。你想创建一个服务对象，<code>fooService</code>bean。要应用的事务语义被封装在<code>&lt;tx:advice/&gt;</code>定义中。<code>&lt;tx:advice/&gt;</code>定义读作“在只读事务上下文中所有要执行的方法以<code>get</code>开头，所有其他要执行的方法带有默认事务语义。“<code>&lt;tx:advice/&gt;</code>标签的<code>transaction-manager</code>属性被设置为将要驱动事务的<code>PlatformTransactionManager</code>bean 的name，在当前的配置文件中，是<code>txManager</code>bean。</p><blockquote><p>如果你想设置<code>PlatformTransactionManager</code>bean的name为<code>transactionManager</code>，你可以忽略事务advice的<code>transaction-manager</code>属性。如果你想使用任何其他的name给<code>PlatformTransactionManager</code>bean，正如在之前的例子中，你之后必须明确的使用<code>transaction-manager</code>属性。</p></blockquote><p><code>&lt;aop:config/&gt;</code>的定义确保在程序中适当的点执行通过<code>txAdvice</code>bean定义的事务advice。首先你定义一个切入点，切入点与在<code>FooService</code>接口（<code>fooServiceOperation</code>）中定义的任何操作执行的相匹配。然后使用advisor关联切入点和txAdvice。结果表明在执行<code>fooServiceOperation</code>时，通过<code>txAdvice</code>定义的advice将会运行。</p><p>在<code>&lt;aop:pointcut/&gt;</code>元素中定义的表达式，是一个AspectJ切入点表达式；查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring</a>了解更多有关Spring中的切入点表达式的详细信息。</p><p>一个常见的需求时创建一个全部服务层的事务。实现这种需求的最好方式是只修改切入点表达式去匹配在你服务层的所有操作。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;fooServiceMethods&quot; expression=&quot;execution(* x.y.service.*.*(..))&quot;/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;fooServiceMethods&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中：它假设你所有服务接口在<code>x.y.service</code>包中定义；查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring </a>了解更多信息。</p></blockquote><p>现在，我们已经分析了配置，你可能会问你自己，“这所有的配置实际上做了什么？”。</p><p>以上配置将被用来去创建一个事务代理围绕从<code>fooService</code>bean 定义创建的对象。这个代理将使用事务advice配置，以便于在代理上调用一个适当的方法时，一个事务开始，挂起，被标记为只读等等，取决于与该方法关联的事务配置。考虑一下测试驱动以上配置的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Boot &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;context.xml&quot;, Boot.class);</span><br><span class="line">        FooService fooService = (FooService) ctx.getBean(&quot;fooService&quot;);</span><br><span class="line">        fooService.insertFoo (new Foo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码的输出将类似下面的。（为清楚起见，Log4J输出和DefaultFooService类的insertFoo（..）方法抛出的UnsupportedOperationException的堆栈跟踪已被截断。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- the Spring container is starting up... --&gt;</span><br><span class="line">[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean &apos;fooService&apos; with 0 common interceptors and 1 specific interceptors</span><br><span class="line"></span><br><span class="line">&lt;!-- the DefaultFooService is actually proxied --&gt;</span><br><span class="line">[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]</span><br><span class="line"></span><br><span class="line">&lt;!-- ... the insertFoo(..) method is now being invoked on the proxy --&gt;</span><br><span class="line">[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo</span><br><span class="line"></span><br><span class="line">&lt;!-- the transactional advice kicks in here... --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]</span><br><span class="line">[DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction</span><br><span class="line"></span><br><span class="line">&lt;!-- the insertFoo(..) method from DefaultFooService throws an exception... --&gt;</span><br><span class="line">[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException</span><br><span class="line">[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]</span><br><span class="line"></span><br><span class="line">&lt;!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp.PoolableConnection@a53de4]</span><br><span class="line">[DataSourceTransactionManager] - Releasing JDBC Connection after transaction</span><br><span class="line">[DataSourceUtils] - Returning JDBC Connection to DataSource</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)</span><br><span class="line">&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;</span><br><span class="line">at $Proxy0.insertFoo(Unknown Source)</span><br><span class="line">at Boot.main(Boot.java:11)</span><br></pre></td></tr></table></figure><h3 id="1-5-3-回滚一个声明式事务"><a href="#1-5-3-回滚一个声明式事务" class="headerlink" title="1.5.3 回滚一个声明式事务"></a>1.5.3 回滚一个声明式事务</h3><p>上面的章节概述了如何在你的应用中给类（通常是服务层类）声明式的指定事务设置。这个章节描述如果以一种简单的声明式方式控制事务回滚。<br>向Spring框架的事务基础设施表明回滚一个事务的推荐的方式是在当前一个事务上下文从执行的代码中抛出<code>Exception</code>。Spring框架事务基础设施代码将捕获所有未处理异常，因为它会调用堆栈，做出判定是否标记回滚事务标识。</p><p>在它的默认配置中，Spring框架的事务基础设施代码仅仅在runtime，unchecked异常时标记回滚事务；也就是说，当抛出的异常是一个实例或者RuntimeException的子类。（Errors在默认配置下也会回滚）。在一个事务方法中抛出的已检查异常在默认配置下不会造成回滚。</p><p>你可以准确的配置哪些类型的异常标记事务回滚，包括已检查的异常。下面的XML片段演示你怎样给已检查和应用指定异常类型配置回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; rollback-for=&quot;NoProductInStockException&quot;/&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>如果当抛出一个异常的时候，你不想事务回滚，你也可以指定‘不回滚规则’。下面的列子告诉你Spring框架的事务基础设施即使面对未处理的InstrumentNotFoundException也要提交<strong>伴随</strong>事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;updateStock&quot; no-rollback-for=&quot;InstrumentNotFoundException&quot;/&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>当Spring框架的事务基础设施缓存一个异常，参考回滚配置规则来决定是否标记回滚事务时，强匹配规则胜利。因此，在下面配置的这种情况，除<code>InstrumentNotFoundException</code>以外的所有异常都会造成伴随事务的回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Throwable&quot; no-rollback-for=&quot;InstrumentNotFoundException&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>你可以表示一个需要编程式回滚。尽管非常简单，这个进程时侵入式的，Spring框架的事务基础设施将紧紧侵入你的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void resolvePosition() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // some business logic...</span><br><span class="line">    &#125; catch (NoProductInStockException ex) &#123;</span><br><span class="line">        // trigger rollback programmatically</span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有可能强烈推荐使用声明式途径回滚事务。编程式事务回滚应该在你绝对需要时使用，但是它的用法在实现基于POJO的清洁框架时很明显。</p><h3 id="1-5-4-给不同的bean配置不同的事务语义"><a href="#1-5-4-给不同的bean配置不同的事务语义" class="headerlink" title="1.5.4 给不同的bean配置不同的事务语义"></a>1.5.4 给不同的bean配置不同的事务语义</h3><p>考虑具有多个服务层对象的情况，并且您希望对每个对象应用完全不同的事务配置。使用不同的切入点和advice-ref属性值定义不同的&lt;aop：advisor /&gt;元素。作为比较，首先假设您的所有服务层类都在根x.y.service包中定义。要使所有作为在该包（或子包中）中定义的类的实例的bean以及以Service结尾的名称具有默认的事务配置，您将编写以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;serviceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service..*Service.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;serviceOperation&quot; advice-ref=&quot;txAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- these two beans will be transactional... --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;barService&quot; class=&quot;x.y.service.extras.SimpleBarService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ... and these two beans won&apos;t --&gt;</span><br><span class="line">    &lt;bean id=&quot;anotherService&quot; class=&quot;org.xyz.SomeService&quot;/&gt; &lt;!-- (not in the right package) --&gt;</span><br><span class="line">    &lt;bean id=&quot;barManager&quot; class=&quot;x.y.service.SimpleBarManager&quot;/&gt; &lt;!-- (doesn&apos;t end in &apos;Service&apos;) --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>下面的例子展示怎样使用两种完全不同的事务设置配置两种不同的bean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;defaultServiceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service.*Service.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;noTxServiceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service.ddl.DefaultDdlManager.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;defaultServiceOperation&quot; advice-ref=&quot;defaultTxAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;noTxServiceOperation&quot; advice-ref=&quot;noTxAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will be transactional (see the &apos;defaultServiceOperation&apos; pointcut) --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;</span><br><span class="line">    &lt;bean id=&quot;anotherFooService&quot; class=&quot;x.y.service.ddl.DefaultDdlManager&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;defaultTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;noTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot; propagation=&quot;NEVER&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-lt-tx-advice-gt-设置"><a href="#1-5-5-lt-tx-advice-gt-设置" class="headerlink" title="1.5.5 &lt;tx:advice/&gt;设置"></a>1.5.5 <code>&lt;tx:advice/&gt;</code>设置</h3><p>这个章节总结可以指定使用<code>&lt;tx:advice/&gt;标签的各种事务配置。默认的</code><a href="tx:advice/" target="_blank" rel="noopener">tx:advice/</a>`设置：</p><ul><li>传播特性是 <code>REQUIRED</code></li><li>隔离等级是 <code>DEFAULT</code></li><li>事务是读/写</li><li>事务超时默认为底层事务系统的默认超时，如果不支持超时则为none</li><li>任意<code>RuntimeException</code>触发回滚，任意的检查时异常不回滚。</li></ul><p>你可以改变这些默认设置；嵌套在<code>&lt;tx:advice/&gt;</code>和<code>&lt;tx:attributes/&gt;</code>标签中的<code>&lt;tx:method/&gt;</code>标签的各种属性总结如下：<br><a href="tx:method/" target="_blank" rel="noopener">tx:method/</a> 设置:<br><img src="media/15531331224039.jpg" alt=""></p><h3 id="1-5-6-使用-Transactional"><a href="#1-5-6-使用-Transactional" class="headerlink" title="1.5.6 使用@Transactional"></a>1.5.6 使用@Transactional</h3><p>除了基于XML的方式声明事务配置，你也可以使用基于注解的方式。直接在Java源代码中声明事务语义使声明更接近被作用的代码。没有太多过度耦合的危险，因为无论如何，以事务方式使用的代码几乎总是以这种方式部署。</p><blockquote><p>标准<code>javax.transaction.Transactional</code>注解支持使用Spring自己的注解直接替换。请参考JTA 1.2 文档了解更多详细资料。</p></blockquote><p>使用@Transactional注释所提供的易用性最好通过一个示例来说明，该示例将在后面的文本中进行说明。考虑以下类定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// the service class that we want to make transactional</span><br><span class="line">@Transactional</span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当上面的POJO被定义为Spring IoC容器中的bean时，可以通过仅添加一行XML配置来使bean实例成为事务性的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- from the file &apos;context.xml&apos; --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;&lt;!-- a PlatformTransactionManager is still required --&gt;</span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;!-- (this dependency is defined somewhere else) --&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果要连接的<code>PlatformTransactionManager</code>的bean的名字是<code>transactionManager</code>，你可以忽略<code>&lt;tx:annotation-driven</code>/&gt;的<code>transaction-manager</code>属性。如果你要依赖注入的<code>PlatformTransactionManager</code>bean有任何其他的名字，你必须和上面的例子一样明确的使用<code>transaction-manager</code>。<br>如果你基于Java配置，<code>@EnableTransactionManagement</code>注解提供有效的支持。只需添加<code>@Configuration</code>注解类。查看全部详细内容请看javadocs。</p></blockquote><blockquote><p><b>方法可见性和@Transaction</b><br>当使用代理时，仅仅对于public可见性的方法应用<code>@Transactional</code>注解。如果你对protected，private或者包内可见的方法使用<code>@Transactional</code>注解，虽然没有错误，但是这个已经注解的方法不展示已配置的事务配置。如果你需要直接非public的方法，可以考虑使用AspectJ（见下文）。</p></blockquote><p>你可以在一个接口定义，接口上的方法，类定义或者类上的public方法前面设置<code>@Transactional</code>。但是，只有<code>@Transactional</code>注解是不足以激活事务行为的。<code>@Transactional</code>注解是一个简单的元数据，它可以被一些运行时的基础设施消费，这个基础设施是<code>@Transactional</code>-aware和可以使用元数据配置具有事务行为的适当的bean。在上面的例子中，<code>&lt;tx:annotation-driven/&gt;</code>元素打开事务行为。</p><blockquote><p>Spring 推荐你只使用<code>@Transactional</code>注解具体类（和具体类的方法），而不是注解接口。你通常可以在一个接口（或者一个接口的方法）上配置<code>@Transactional</code>注解，但是，仅仅在你使用基于接口代理的方式时才能获得你期望的运行。Java注解不从接口继承Java注解的事实意味着如果你使用基于类的代理（<code>proxy-target-class=&quot;true&quot;</code>）或者基于切面织入（<code>mode=&quot;&quot;aspectj</code>），然后代理和织入的基础设施将不识别事务设置，并且这个对象不被包裹在事务代理中，这将是非常糟糕的。</p></blockquote><blockquote><p>在代理模式（默认）中，仅外部的方法通过代理调用进入会被拦截。这意味着自我调用，实际上，在目标对象的方法调用目标对象的其他方法将不会在运行时引起一个实际的事务，即使被调用的方法使用<code>@Transactional</code>标记。这个代理也必须完整的初始化去提供你期望的行为，因此，你不应该在你的初始化代码中依赖这个特性，即<code>@PostConstruct</code>。</p></blockquote><p>如果你希望自我调用也被包裹在事务中，可以考虑切面模式（在下面的表格中查看模式的属性）的使用。在这种情况下，首先不会有一个代理；相反，为了将<code>@Transactional</code>转换为任何类型方法上的运行时行为，目标类将被织入（它的字节码将被修改）。</p><p><table><tr><td>XML Attribute</td><td>Annotation Attribute</td><td>Default</td><td>Description</td></tr><tr><td><code>transaction-manger</code></td><td>N/A(查看<code>TransactionManagementConfigurer</code> javadocs)</td><td>transactionManager</td><td>要使用的事务管理器的名称。仅在如果事务管理器的名称不是<code>transactionManager</code>时需要，如上面的例子所示</td></tr><tr><td><code>mode</code></td><td><code>mode</code></td><td>proxy</td><td>默认模式“代理”进程使用Spring的AOP框架（以下代理语义，正如上面讨论的，仅适用于通过代理进入的方法调用）代理被注解的bean。替代模式“aspectj”代替使用Spring的AspectJ事务切面织入受影响的类，修改目标类字节码以应用任何类型的方法调用。AspectJ 织入需要spring-aspects.jar在classpath中，同时加载时织入（编译时织入）开启。（查看怎样设置加载时织入的详细内容，请访问<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-aj-ltw-spring" target="_blank" rel="noopener">Spring配置</a>）</td></tr><tr><td><code>proxy-target-class</code></td><td><code>proxyTargetClass</code></td><td>false</td><td>仅适用代理模式。控制给带有<code>@Transactional</code>注解的注解类创建什么类型的事务代理。如果<code>proxy-target-class</code>属性设置为<code>true</code>，基于类的代理将被创建。如果<code>proxy-target-class</code>为false或者这个属性被忽略，标准JDK基于接口的代理将被创建。（详细检查不同类型代理请查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-proxying）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;`order`&lt;/td&gt;&lt;td&gt;`order`&lt;/td&gt;&lt;td&gt;Ordered.LOWEST_PRECEDENCE&lt;/td&gt;&lt;td&gt;定义事务advice的order适用于带有`@Transaction`注解的bean。（关于有关AOP advice的规则的更多信息，查看[Advice ordering](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">10.6 代理机制</a>。）不指定ordering意味着AOP子系统决定advice的order</td></tr></table></p><blockquote><p><code>@EnableTransactionManagement</code>和<code>&lt;tx:annotation-driven/&gt;</code>只查找它们定义在相同应用上下文bean上的<code>@Transactional</code>。这意味着，如果你在一个<code>WebApplicationContext</code>中给一个<code>DispatcherServlet</code>添加注解驱动配置，它仅仅检查你controller带有<code>@Transactional</code>的bean，而不是你的service。了解更多信息查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/mvc.html#mvc-servlet" target="_blank" rel="noopener">The DispatcherServlet</a>。</p></blockquote><p>在评估方法的事务设置时，派生最多的位置优先。下面列子的这种情况，<code>DefaultFooService</code>类在类级别中使用只读事务设置注解，但是，在相同的类中，在<code>updateFoo(Foo)</code>方法上的<code>@Transactional</code>注解优先于类级别定义的事务设置。</p><blockquote><p><b>@Transactional 设置</b><br><code>@Transactional</code>注解是一个元数据，这个元数据指定一个接口，类或者方法必须有事务语义；例如，“当方法被调用时，开始一个全新的只读事务，中止任何已存在的事务“。默认的<code>@Transactional</code>设置如下：</p></blockquote><ul><li>传播特性设置是<code>PROPAGATION_REQUIRED</code>。</li><li>隔离等级是<code>ISOLATION_DEFAULT</code>。</li><li>事务是读/写。</li><li>事务超时默认是底层事务系统的默认超时，或者如果不支持超时为none。</li><li>任何<code>RuntimeException</code>触发回滚，任何已校验异常不会。</li></ul><p>这些默认设置可以改变；在下表中总结了<code>@Transactional</code>注解的各种属性：</p><p><table><tr><td>Property</td><td>Type</td><td>Description</td></tr><tr><td>value</td><td>String</td><td>可选限定符，指定要使用的事务管理器</td></tr><tr><td>propagation</td><td>enum:<code>Propagation</code></td><td>可选传播特性设置</td></tr><tr><td><code>isolation</code></td><td>enum:<code>Isolation</code></td><td>可选隔离级别</td></tr><tr><td><code>readOnly</code></td><td>boolean</td><td>读/写 vs 只读</td></tr><tr><td><code>timeout</code></td><td>int(秒粒度)</td><td>事务超时</td></tr><tr><td><code>rollbackFor</code></td><td>类的对象数组，必须从<code>Throwable</code>派生</td><td>可选异常类数组，这些异常必须造成回滚</td></tr><tr><td><code>rollbackForClassName</code></td><td>类的名称数组，类必须从<code>Throwable</code>派生</td><td>可选异常类名称数组，必须造成回滚</td></tr><tr><td><code>noRollbackFor</code></td><td>类的对象数组，必须从<code>Throwable</code>派生</td><td>可选异常类数组，这些异常必须不造成回滚</td></tr><tr><td><code>noRollbackForClassName</code></td><td>类的名称数组，类必须从<code>Throwable</code>派生</td><td>可选异常类名称数组，必须不造成回滚</td></tr></table><br>目前，你无法明确的掌控事务的名称，如果适用，其中<code>name</code>表示将在事务监视器中显示的事务名称，以及日志记录输出。对于声明式事务，事务名总是全量类名+“.”+事务的advised类的方法名。例如，如果<code>BusinessService</code>类的<code>handlePayment(...)</code>方法开始一个事务，事务名称将会是<code>com.foo.BusinessService.handlePayment</code>。</p><h4 id="使用-Transactional的多个事务管理"><a href="#使用-Transactional的多个事务管理" class="headerlink" title="使用@Transactional的多个事务管理"></a>使用@Transactional的多个事务管理</h4><p>大多数Spring应用仅仅需要单个事务管理，但是可能也会有在单个应用中你想多个独立事务管理的情况。<code>@Transactional</code>注解的属性值可以被用来选择性指定要使用的<code>PlatformTransactionManager</code>。这可以是bean的名称或者事务管理bean的值。例如，如下Java代码使用的限定符值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TransactionalService&#123;</span><br><span class="line"></span><br><span class="line">    @Transactional(&quot;order&quot;)</span><br><span class="line">    public void setSomething(String name)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    @Transactional(&quot;account&quot;)</span><br><span class="line">    public void doSomething()&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在应用上下文中和如下的事务管理bean声明组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tx:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;transactionManager1&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value=&quot;order&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;transactionManager2&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value=&quot;account&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>TransactionalService</code>的两个方法将在单独事务管理器下运行，通过“order”和“account”区分。如果没有找到指定限定符的<code>PlatformTransactionManager</code>的bean，将一直使用<code>&lt;tx:annotation-driven&gt;</code>默认的目标bean名称<code>transactionManager</code>。</p><h4 id="自定义快捷方式注解"><a href="#自定义快捷方式注解" class="headerlink" title="自定义快捷方式注解"></a>自定义快捷方式注解</h4><p>如果你发现你在许多不同方法上重复使用<code>@Transactional</code>的相同属性值，[Spring’s meta-annotaion support]允许你在你的指定使用情况下定义自定义快捷方式的注解。例如，如下注解的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;order&quot;)</span><br><span class="line">public @interface OrderTx &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;account&quot;)</span><br><span class="line">public @interface AccountTx &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许我们将上一小节的例子写为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TransactionalService&#123;</span><br><span class="line">    </span><br><span class="line">    @OrderTx</span><br><span class="line">    public void setSomething(String name)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    @AccountTx</span><br><span class="line">    public void doSomething()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了定义事务管理器的限定符语法，但是我们也可以包含传播特性行为，回滚规则，超时等等。</p><h3 id="1-5-7-事务传播特性"><a href="#1-5-7-事务传播特性" class="headerlink" title="1.5.7 事务传播特性"></a>1.5.7 事务传播特性</h3><p>这个章节描述在Spring中的事务传统特性的一些语义。请注意这个章节不是适当的一个事务传播特性介绍；二是详细描述在Spring中关于事务传播特性的一些语义。</p><p>在Spring管理的事务中，注意物理和逻辑事务的区别，和事务传播特性设置如何应用此差异。<br><img src="media/15534834588483.jpg" alt=""></p><p><code>PROPAGATION_REQUIRES_NEW</code>，与<code>PROPAGATION_REQUIRED</code>相比，为每一个事务作用域使用一个独立的事务。在那种情况下，底层的物理事务是不同的，因此可以独立的提交或者回滚，外部事务不受内部事务回滚状态的影响。</p><h4 id="Nested"><a href="#Nested" class="headerlink" title="Nested"></a>Nested</h4><p><code>PROPAGATION_NESTED</code>使用具有多个保存点的单个物理事务，它可以回滚到该事务。一些局部是回滚允许内部事务域在它的作用域触发回滚，使用外部事务可以继续物理事务而不用管一些已经回滚的操作。这个设置常用来映射JDBC的保存点。因此仅仅和JDBC资源事务一起工作。查看Spring的<code>DataSourceTransactionManager</code>。</p><h3 id="1-5-8-Advising-事务操作"><a href="#1-5-8-Advising-事务操作" class="headerlink" title="1.5.8 Advising 事务操作"></a>1.5.8 Advising 事务操作</h3><p>假如你想同时执行事务和一些基础剖析advice。你怎样在<code>&lt;tx:annotaion-driven/&gt;</code>的上下文中实现这点？</p><p>当你调用<code>updateFoo(Foo)</code>方法，你想看到如下动作：</p><ul><li>配置的剖析切面启动</li><li>事务advice执行</li><li>advised对象上的方法执行</li><li>事务提交</li><li>剖析切面精确报告整个事务方法调用期间</li></ul><blockquote><p>这个章节不关心详细介绍AOP（除非AOP适用于事务）。有关以下AOP配置和AOP的详细介绍，请参见<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10,Aspect Oriented Programming with Spring</a>。</p></blockquote><p>这是上面讨论简单剖析切面的代码。advice的排序由<code>Ordered</code>接口控制。了解advice 排序的全部详细内容，查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">the section called “Advice ordering”</a>..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package x.y;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.springframework.util.StopWatch;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line"></span><br><span class="line">public class SimpleProfiler implements Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private int order;</span><br><span class="line"></span><br><span class="line">    // allows us to control the ordering of advice</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return this.order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrder(int order) &#123;</span><br><span class="line">        this.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this method is the around advice</span><br><span class="line">    public Object profile(ProceedingJoinPoint call) throws Throwable &#123;</span><br><span class="line">        Object returnValue;</span><br><span class="line">        StopWatch clock = new StopWatch(getClass().getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            clock.start(call.toShortString());</span><br><span class="line">            returnValue = call.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            clock.stop();</span><br><span class="line">            System.out.println(clock.prettyPrint());</span><br><span class="line">        &#125;</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the aspect --&gt;</span><br><span class="line">    &lt;bean id=&quot;profiler&quot; class=&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        &lt;property name=&quot;order&quot; __value=&quot;1&quot;__/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; __order=&quot;200&quot;__/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">            &lt;!-- this advice will execute around the transactional advice --&gt;</span><br><span class="line">            &lt;aop:aspect id=&quot;profilingAspect&quot; ref=&quot;profiler&quot;&gt;</span><br><span class="line">                &lt;aop:pointcut id=&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                        expression=&quot;execution(!void x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">                &lt;aop:around method=&quot;profile&quot; pointcut-ref=&quot;serviceMethodWithReturnValue&quot;/&gt;</span><br><span class="line">            &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;scott&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;tiger&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>上述配置的结果是一个fooService bean，它具有按所需顺序应用于它的分析和事务切面。你可以以类似的方式配置任意数量的其他切面。</p><p>以下示例实现与上述相同的配置，但是使用纯粹的XML声明式途径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the profiling advice --&gt;</span><br><span class="line">    &lt;bean id=&quot;profiler&quot; class=&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        __&lt;property name=&quot;order&quot; value=&quot;1__&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;entryPointMethod&quot; expression=&quot;execution(* x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">        &lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;entryPointMethod&quot; __order=&quot;2__&quot;/&gt;</span><br><span class="line">        &lt;!-- order value is higher than the profiling aspect --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:aspect id=&quot;profilingAspect&quot; ref=&quot;profiler&quot;&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                    expression=&quot;execution(!void x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">            &lt;aop:around method=&quot;profile&quot; pointcut-ref=&quot;serviceMethodWithReturnValue&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions such as a DataSource and a PlatformTransactionManager here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>以上配置的结果是一个<code>fooService</code>bean，它具有适用于它的所需排序的剖析和事务切面。如果你想要在事务advice在进入之后，事务advice出去之前，执行的剖析advice，你只需简单的更换剖析切面bean的order属性值，使得它比事务advice的顺序值更高。</p><p>你使用类似的方式配置其他的切面。</p><h3 id="1-5-9-使用带有切面的-Transactional"><a href="#1-5-9-使用带有切面的-Transactional" class="headerlink" title="1.5.9 使用带有切面的@Transactional"></a>1.5.9 使用带有切面的@Transactional</h3><p>在一个Spring容器之外，通过AspectJ切面，也可能使用Spring框架的<code>@Transactional</code>的支持。如果这样做，你首先使用<code>@Transactional</code>注解你的类（和可选择的你的类方法），然后你使用定义在<code>spring-aspects.jar</code>的<code>org.springframework.transaction.aspectj.AnnotationTransactionAspect</code>连接（织入）你的应用。还必须使用事务管理器配置你的切面。你当然可以使用Spring框架的IoC容器去管理依赖注入切面。配置事务管理器切面的最简单方式是使用<code>&lt;tx:annotation-driven/&gt;</code>元素和给<code>aspectj</code>指定<code>mode</code>属性，正如在<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-annotations" target="_blank" rel="noopener">Section 16.5.6 Using @Transactional</a>。因为我们关注在一个Spring容器之外程序的运行，我们将会向你展示如何以编程的方式实现它。</p><blockquote><p> 在继续之前，你可能想要分别去读<a href="">Section 16.5.6 Using @Transactional</a>和<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring</a>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// construct an appropriate transaction manager</span><br><span class="line">DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());</span><br><span class="line"></span><br><span class="line">// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods</span><br><span class="line">AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);</span><br></pre></td></tr></table></figure><blockquote><p>当使用切面，你必须注解实现类（和/或 类里的方法），不是类实现的接口。<br>AspectJ 遵守Java的规则，不继承接口上的注解。</p></blockquote><p>在类上的<code>@Transactional</code>注解给在类里的任何方法的执行指定默认事务语义。<br>在在类里的方法上的<code>@Transactional</code>注解覆盖类提供注解（如果存在）的默认事务语义。不管是否可见，任何的方法可能被注解。</p><p>使用<code>AnnotationTransactionAspect</code>织入你的应用，你要么使用AspectJ（<a href="https://www.eclipse.org/aspectj/doc/released/devguide/index.html" target="_blank" rel="noopener">AspectJ Development Guide</a>）构建你的应用，要么使用加载时织入。使用AspectJ加载时织入的讨论请看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-aj-ltw" target="_blank" rel="noopener">Load-time weaving with AspectJ in the Spring Framework</a></p><h2 id="1-6-编程事务管理"><a href="#1-6-编程事务管理" class="headerlink" title="1.6 编程事务管理"></a>1.6 编程事务管理</h2><p>Spring框架提供两种编程事务管理工具：</p><ul><li>使用<code>TransactionTemplate</code>。</li><li>直接使用<code>PlatformTransactionManager</code>实现。</li></ul><p>对于编程式事务管理Spring团队通常建议使用<code>TransactionTemplate</code>。第二种相似途径是使用JTA<code>UserTransaction</code>API，虽然异常处理不是那么笨重。</p><h3 id="1-6-1-使用TransactionTemplate"><a href="#1-6-1-使用TransactionTemplate" class="headerlink" title="1.6.1 使用TransactionTemplate"></a>1.6.1 使用TransactionTemplate</h3><p><code>TransactionTemplate</code> 采用与其他Spring模版（例如<code>JdbcTemplate</code>）一样的方式。它使用一个回调的方法，使应用代码不必执行样板获取和释放事务资源，并产生驱动程序的代码，以便于被编写的代码仅关注开发人员想要做的事情。</p><blockquote><p>正如你将在如下的例子中看到的，使用<code>TransactionTemplate</code>绝对将你和Spring的事务基础架构和API结合在一起。</p></blockquote><p>应用代码必须在事务上下文中执行，明确的使用<code>TransactionTemplate</code>，看起来和如下的相似。你作为一个应用开发者，写一个<code>TransactionCallback</code>实现（通常表现为一个匿名内部类），这个实现包含在一个事务上下文中执行的代码。然后将自定义<code>TransactionCallback</code>的实例，传递给<code>TransactionTemplate</code>上公开的<code>execute(...)</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    // single TransactionTemplate shared amongst all methods in this instance</span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    // use constructor-injection to supply the PlatformTransactionManager</span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        Assert.notNull(transactionManager, &quot;The &apos;transactionManager&apos; argument must not be null.&quot;);</span><br><span class="line">        this.transactionTemplate = new TransactionTemplate(transactionManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object someServiceMethod() &#123;</span><br><span class="line">        return transactionTemplate.execute(new TransactionCallback() &#123;</span><br><span class="line">            // the code in this method executes in a transactional context</span><br><span class="line">            public Object doInTransaction(TransactionStatus status) &#123;</span><br><span class="line">                updateOperation1();</span><br><span class="line">                return resultOfUpdateOperation2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有返回值，方便的使用<code>TransactionCallbackWithoutResult</code>类和一个匿名内部类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        updateOperation1();</span><br><span class="line">        updateOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在回调中的代码可以通过提供的<code>TransactionStatus</code>对象上调用<code>setRollbackOnly()</code>方法回滚这个事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line"></span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            updateOperation1();</span><br><span class="line">            updateOperation2();</span><br><span class="line">        &#125; catch (SomeBusinessExeption ex) &#123;</span><br><span class="line">            status.setRollbackOnly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="指定事务设置"><a href="#指定事务设置" class="headerlink" title="指定事务设置"></a>指定事务设置</h4><p>你可以以编程方式或配置方式在TransactionTemplate上指定例如传播特性模式，隔离等级，超时等等的事务设置。默认的<code>TransactionTemplate</code>实例有<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-txadvice-settings" target="_blank" rel="noopener">默认事务设置</a>。如下的例子展示对于一个指定<code>TransactionTemplate</code>事务设置的编程式定制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        Assert.notNull(transactionManager, &quot;The &apos;transactionManager&apos; argument must not be null.&quot;);</span><br><span class="line">        this.transactionTemplate = new TransactionTemplate(transactionManager);</span><br><span class="line"></span><br><span class="line">        // the transaction settings can be set here explicitly if so desired</span><br><span class="line">        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);</span><br><span class="line">        this.transactionTemplate.setTimeout(30); // 30 seconds</span><br><span class="line">        // and so forth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下的例子定义了一个使用一些自定义事务设置的<code>TransactionTemplate</code>，使用Spring XML配置。然后可以将<code>sharedTransactionTemplate</code>注入到尽可能多的需要的服务中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sharedTransactionTemplate&quot;</span><br><span class="line">        class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;isolationLevelName&quot; value=&quot;ISOLATION_READ_UNCOMMITTED&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;timeout&quot; value=&quot;30&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>最后，<code>TransactionTemplate</code>类的实例是线程安全的，因为实力不保持任何会话状态。但是，<code>TransactionTemplate</code>实例会保持配置状态，因此当许多类可能共享一个<code>TransactionTemplate</code>的一个单例时，如果一个类需要使用一个带有不同设置（例如，不同隔离等级）的<code>TransactionTemplate</code>，你就需要去创建一个两个不同的<code>TransactionTemplate</code>实例。</p><h3 id="1-6-2-使用PlatformTransactionManager"><a href="#1-6-2-使用PlatformTransactionManager" class="headerlink" title="1.6.2 使用PlatformTransactionManager"></a>1.6.2 使用PlatformTransactionManager</h3><p>你也可以直接使用<code>org.springframework.transaction.PlatformTransactionManager</code>管理你的事务。简单的通过一个bean引用传递你正在用的<code>PlatformTransactionManager</code>的实现给你的bean。然后，使用<code>TransactionDefinition</code>和<code>TransactionStatus</code>对象你可以发起，回滚和提交事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultTransactionDefinition def = new DefaultTransactionDefinition();</span><br><span class="line">// explicitly setting the transaction name is something that can only be done programmatically</span><br><span class="line">def.setName(&quot;SomeTxName&quot;);</span><br><span class="line">def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">TransactionStatus status = txManager.getTransaction(def);</span><br><span class="line">try &#123;</span><br><span class="line">    // execute your business logic here</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex) &#123;</span><br><span class="line">    txManager.rollback(status);</span><br><span class="line">    throw ex;</span><br><span class="line">&#125;</span><br><span class="line">txManager.commit(status);</span><br></pre></td></tr></table></figure><h2 id="1-7-编程式和声明式事务管理器的选择"><a href="#1-7-编程式和声明式事务管理器的选择" class="headerlink" title="1.7 编程式和声明式事务管理器的选择"></a>1.7 编程式和声明式事务管理器的选择</h2><p>编程式事务管理仅仅在你如果有一个小数量的事务操作情况下才是一个好想法。例如，如果你有一个web应用需要仅仅主要是update操作的事务，你不可能想去使用Spring或者其他任何技术去设置事务代理。在这种情况下，使用<code>transactionTemplate</code>可能是一个好方法。可能明确的设置事务名称可以仅在使用编程式途径进行事务管理的情况下去做。</p><p>从另一方面，如果你的应用有很多事务操作，声明式事务管理通常是合算的。它保持事务管理摆脱业务逻辑，配置不困难。当使用Spring框架，而不是EJB CMT时，声明式事务配置的成本将大大降低。</p><h2 id="1-8-事务约束事件"><a href="#1-8-事务约束事件" class="headerlink" title="1.8 事务约束事件"></a>1.8 事务约束事件</h2><p>作为Spring 4.2，一个事件的监听可以被约束为事务的一个阶段。常用的例子是当事务已经成功的完成时去处理事件：当当前事务的结果对于监听器实际上很重要时，这允许事件被更灵活地使用。<br>注册一个常规的监听事件可以通过<code>@EventListener</code>注解。如果你需要和事务绑定它使用<code>@TransactionEventListener</code>。当你这样做时，监听器将默认约束事务提交阶段。<br>我们举个例子说明这个概念。</p><p>假设一个组件发布了一个订单创建的事件，我们想要定义一个监听器，该监听器只应该在事件成功提交时才处理该事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyComponent &#123;</span><br><span class="line"></span><br><span class="line">    @TransactionalEventListener</span><br><span class="line">    public void handleOrderCreatedEvent(CreationEvent&lt;Order&gt; creationEvent) &#123;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>TransactionalEventListener</code>注解暴露一个<code>phase</code>属性，这个属性允许自定义监听器应该约束事务的哪个phase。这个有效的phases是<code>BEFORE_COMMIT</code>，<code>AFTER_COMMIT</code>(default)，<code>AFTER_ROLLBACK</code>和<code>AFTER_COMPLETION</code>，它们聚合事务的完整性（是一个提交或者一个回滚）。</p><p>如果没有正在运行的事务，由于我们无法遵守所需的语义，监听器根本不会被调用。但是，它可能通过设置注解的<code>fallbackExecution</code>属性为true去覆盖该行为。</p><h2 id="1-9-指定应用服务器的集成"><a href="#1-9-指定应用服务器的集成" class="headerlink" title="1.9 指定应用服务器的集成"></a>1.9 指定应用服务器的集成</h2><p>Spring的事务抽象通常是应用服务器不可知。此外，Spring的<code>JtaTransactionManager</code>类，可以可选执行对于JTA<code>UserTransaction</code>和<code>TransactionManager</code>对象的JNDI查找，对于后者对象，自动检查地址，该地址因应用服务器而变化。访问JTA TransactionManager允许增强的事务语义，特别是支持事务暂停。了解详细请查看<code>JtaTransactionManager</code>javadocs。</p><p>Spring的<code>JtaTransactionManager</code>在Java EE应用服务器上运行的标准选择，并已知可以在所有常用的服务器上运行。高级功能（事务暂停）在很多服务器上运行很好，包括GlassFish，JBoss和Geronimo，不需要任何特殊配置。但是，对于完整的支持事务暂停和进一步的高级集成，Spring ship对于WebLogic服务器和WebSphere特殊适配。这些适配在如下章节讨论。</p><p>对于标准场景，包括Weblogic Server和WebSphere，考虑使用定制<code>&lt;tx:jta-trasaction-manager/&gt;</code>配置元素。当已配置时，这元素自动检查底层服务器和选择适用于该平台的最好的事务管理器。这意味着你将不需要必须显式的配置指定服务器适配类（在如下章节讨论）；相反，它们是自动选择的，标准的<code>JtaTransactionManager</code>是默认的后备。</p><h3 id="1-9-1-IBM-WebSphere"><a href="#1-9-1-IBM-WebSphere" class="headerlink" title="1.9.1 IBM WebSphere"></a>1.9.1 IBM WebSphere</h3><p>在WebSphere6.1.0.9及以上版本，建议Spring JTA事务管理器使用<code>WebSphereUowTransactionManager</code>。这个特殊的适配器利用了IBM’s <code>UOWManager</code> API，在WebSphere应用服务器6.0.2.19和以后版本，6.1.0.9和以后版本是适用的。使用这个适配器，驱动Spring事务暂停（暂停/恢复 由<code>PROPAGATION_REQUIRES_NEW</code>发起）是由IBM官方支持的。</p><h3 id="1-9-2-Oracle-WebLogic-Server"><a href="#1-9-2-Oracle-WebLogic-Server" class="headerlink" title="1.9.2 Oracle WebLogic Server"></a>1.9.2 Oracle WebLogic Server</h3><p>在Weblogic Server及以后版本中，你通常将使用<code>WebLogicJtaTransactionManager</code>而不是存<code>JtaTransactionManager</code>类。普通<code>JtaTransactionManager</code>的这个特殊的Weblogic特定的子类在Weblogic管理的事务环境中支持Spring的事务全部功能，超出标准的JTA语义：特性包括事务名称，每个事务的隔离等级，以及在所有的情况下正确的恢复事务。</p><h2 id="1-10-常见问题解决"><a href="#1-10-常见问题解决" class="headerlink" title="1.10 常见问题解决"></a>1.10 常见问题解决</h2><h3 id="1-10-1-对于特定数据源错误的事务管理器的使用"><a href="#1-10-1-对于特定数据源错误的事务管理器的使用" class="headerlink" title="1.10.1 对于特定数据源错误的事务管理器的使用"></a>1.10.1 对于特定数据源错误的事务管理器的使用</h3><p>正确的使用<code>PlatformTransactionManager</code>实现基于你事务技术和需求的选择。正确的使用，Spring框架仅提供一个简单直接和轻便的抽象。如果你正在使用全局事务，你必须使用<code>org.springframework.transaction.jta.JtaTransactionManager</code>类（或者一个指定的应用服务器子类）进行你所有的事务操作。否则事务基础设施在资源（例如容器的<code>DataSource</code>实例）上尝试使用本地事务。这样的本地事务没有意义，一个好的应用服务器把它们当作错误。</p><h2 id="1-11-集成资源"><a href="#1-11-集成资源" class="headerlink" title="1.11 集成资源"></a>1.11 集成资源</h2><p>了解更多关于Spring框架的事务支持信息：</p><ul><li><a href="http://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html" target="_blank" rel="noopener">Distributed transaction in Spring，with and without XA</a>是一个JavaWorld演示文稿，其中Spring的David Syer引导您在Spring应用程序中通过分布式事务的七种模式，其中三种模式使用XA，另外四种没有。</li><li><a href="http://www.infoq.com/minibooks/JTDS" target="_blank" rel="noopener">Java 事务设计策略</a>是一本从<a href="http://www.infoq.com/" target="_blank" rel="noopener">InfoQ</a>得到的书，InfoQ提供一个Java事务快速介绍。它还包括如何使用Spring Framework和EJB3配置和使用事务的并排示例。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> 译文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多线程通信</title>
      <link href="/zhongyp.github.io/concurrency/2018-12-06-thread-communication/"/>
      <url>/zhongyp.github.io/concurrency/2018-12-06-thread-communication/</url>
      
        <content type="html"><![CDATA[<h2 id="1-共享变量的可见性"><a href="#1-共享变量的可见性" class="headerlink" title="1. 共享变量的可见性"></a>1. 共享变量的可见性</h2><p>线程通信主要是通过对共享变量的读写来进行的，一般共享变量，我们会采用 a)使共享变量不可变、b)在任何访问状态变量的时候使用同步 两种措施共享。</p><h3 id="1-1-synchronized（内置锁）"><a href="#1-1-synchronized（内置锁）" class="headerlink" title="1.1 synchronized（内置锁）"></a>1.1 synchronized（内置锁）</h3><p>synchronized我们知道常常用来临界区互斥执行，但是除此之外，它还有最重要的功能：锁的内存语义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MonitorExample&#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    public synchronized void writer()&#123;// 1</span><br><span class="line">        a++; // 2</span><br><span class="line">    &#125; // 3</span><br><span class="line">    public synchronized void reader()&#123; // 4</span><br><span class="line">        int i=a; // 5</span><br><span class="line">    &#125; // 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设线程A<strong>先</strong>执行writer()方法，<strong>随后</strong>线程B执行reader()方法。根据JMM的happens-before规则，这段代码包含的happens-before关系可以分为3类。</p><p>1）根据程序次序规则，1 happens-before2, 2 happens-before 3; 4 happens-before 5, 5 happens-before 6。</p><p>2) 根据监视器锁规则，3 happens-before 4。<br>3) 根据happens-before的传递性，2 happens-before 5。</p><p><strong>注：</strong>happens-before规则保证了线程A执行后的结果对B可见，但是线程A的代码不一定在线程B之前执行。上面A与B线程是有先后顺序的，主要是为了方便解释锁的内存语义。 </p><p><img src="/media/article/happens-before-relation.jpg" alt="happens-beofre"><br>图片来自<a href="">Java并发编程艺术图3-24</a></p><p>锁释放和锁获取的内存语义：</p><p><strong>线程A释放一个锁，实质上是线程A向接下来将要获取的这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</strong></p><p><strong>线程B释放一个锁，实质上是线程B接收了之前某个线程发出的（释放这个锁之前对共享变量所做的修改的）消息。</strong></p><p><strong>线程A释放锁，线程B获取锁，这个过程实质上是线程A通过主内存向线程B发送消息。</strong></p><p><img src="/media/article/lock-acquire-state.png" alt="lock-acquire-state"><br>图片来自<a href="">Java并发编程艺术图3-26</a></p><h3 id="1-2-volatile"><a href="#1-2-volatile" class="headerlink" title="1.2 volatile"></a>1.2 volatile</h3><p>volatile我们熟知的特性是：</p><p>1.可见性</p><p>对一个volatile变量的读，总能看到任意线程对这个volatile变量最后的写入。</p><p>2.有序性</p><p>如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀。lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p><h3 id="1-3-final"><a href="#1-3-final" class="headerlink" title="1.3 final"></a>1.3 final</h3><h2 id="2-等待通知-wait-notify"><a href="#2-等待通知-wait-notify" class="headerlink" title="2. 等待通知(wait/notify)"></a>2. 等待通知(wait/notify)</h2><h2 id="3-管道通信"><a href="#3-管道通信" class="headerlink" title="3. 管道通信"></a>3. 管道通信</h2><h2 id="4-Thread-join"><a href="#4-Thread-join" class="headerlink" title="4. Thread.join()"></a>4. Thread.join()</h2><h2 id="5-ThreadLocal"><a href="#5-ThreadLocal" class="headerlink" title="5. ThreadLocal"></a>5. ThreadLocal</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="">Java并发编程实践</a><br><a href="">Java并发编程艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程安全</title>
      <link href="/zhongyp.github.io/concurrency/2018-12-06-thread-security/"/>
      <url>/zhongyp.github.io/concurrency/2018-12-06-thread-security/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全-读书笔记"><a href="#线程安全-读书笔记" class="headerlink" title="线程安全-读书笔记"></a>线程安全-读<a href="#引用">书</a>笔记</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>线程安全定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调动作，调用这个对象的行为都可以获得正确的结果，那这个<strong>对象就是线程安全的</strong>。摘至<a href="https://github.com/zhongyp/mybook/blob/master/java/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5.pdf" target="_blank" rel="noopener">《Java并发编程实践》</a><br>编写的线程安全的代码，本质上就是管理对状态（state）的访问，而且通常都是共享的、可变的状态。共享指一个变量可以被多个线程访问；可变变量的值在生命周期内可以改变。<br>无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。<br>保证对象线程安全的三种措施：</p><ul><li>不跨线程共享变量</li><li>使状态变量不可变</li><li>在任何访问状态变量的时候使用同步</li></ul><h2 id="2-Java线程安全"><a href="#2-Java线程安全" class="headerlink" title="2. Java线程安全"></a>2. Java线程安全</h2><h3 id="2-1-线程安全强弱等级"><a href="#2-1-线程安全强弱等级" class="headerlink" title="2.1 线程安全强弱等级"></a>2.1 线程安全强弱等级</h3><p>Java语言中操作各种共享的数据可根据安全程度分为以下5类：</p><h4 id="2-1-1-不可变"><a href="#2-1-1-不可变" class="headerlink" title="2.1.1 不可变"></a>2.1.1 不可变</h4><p>在Java线程里面，不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何的线程安全保障措施。</p><p>Java语言中，如果共享数据是一个基本数据类型，只要在定义时使用final关键字修饰它就可以保证它是不可变的；如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。只要一个不可变的对象被正确构建出来（没有发生<a href="https://www.cnblogs.com/straybirds/p/8640748.html" target="_blank" rel="noopener">this引用逃逸</a>的情况），那么其外部的可见状态也不会改变。保证对象的行为不影响自己状态的途径有很多种，最简单的就是把对象中带有状态的变量都声明为final。</p><h4 id="2-1-2-绝对线程安全"><a href="#2-1-2-绝对线程安全" class="headerlink" title="2.1.2 绝对线程安全"></a>2.1.2 绝对线程安全</h4><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p><h4 id="2-1-3-相对线程安全"><a href="#2-1-3-相对线程安全" class="headerlink" title="2.1.3 相对线程安全"></a>2.1.3 相对线程安全</h4><p>对象单独的操作时线程安全的，我们在调用的时候不需要做额外的保障措施，对于特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。例如：Vector、ConcurrentHashMap等。</p><h4 id="2-1-4-线程兼容"><a href="#2-1-4-线程兼容" class="headerlink" title="2.1.4 线程兼容"></a>2.1.4 线程兼容</h4><p>线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中安全地使用。例如：HashMap等。</p><h4 id="2-1-5-线程对立"><a href="#2-1-5-线程对立" class="headerlink" title="2.1.5 线程对立"></a>2.1.5 线程对立</h4><p>线程对立指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。例如：Thread类中的suspend(),resume()方法。</p><h3 id="2-2-Java线程安全实现"><a href="#2-2-Java线程安全实现" class="headerlink" title="2.2 Java线程安全实现"></a>2.2 Java线程安全实现</h3><h4 id="2-2-1-互斥同步"><a href="#2-2-1-互斥同步" class="headerlink" title="2.2.1 互斥同步"></a>2.2.1 互斥同步</h4><p>互斥同步(Mutual Exclusion &amp; Synchronization)是最常见的一种并发正确性保障手段，同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。是一种悲观的并发策略，无论是否并发都需要加锁。<br>手段：synchronized、ReentrantLock。<br>缺点：线程阻塞和唤醒带来的性能问题，因此互斥同步也称为阻塞同步(Blocking Synchronization)。</p><h4 id="2-2-2-非阻塞同步"><a href="#2-2-2-非阻塞同步" class="headerlink" title="2.2.2 非阻塞同步"></a>2.2.2 非阻塞同步</h4><p>非阻塞同步(Non-Blocking Synchronization)是基于冲突检测的乐观并发策略，通俗的讲就是先进行操作，如果没有其他线程争用共享数据，则操作成功，否则产生冲突，然后进行补偿措施（最常见的就是不断的重试，知道试成功为止）。<br>要求：硬件指令集的发展，需要操作和检测两个步骤具备原子性。<br>常见指令：测试并设置(Test-and-Set)、获取并增加(Fetch-and-Increment)、交换(Swap)、比较并交换(Compare-and-Swap,CAS)、加载链接/条件存储(Load-linked/Store-Conditional,LL/SC)。</p><h4 id="2-2-3-无同步方案"><a href="#2-2-3-无同步方案" class="headerlink" title="2.2.3 无同步方案"></a>2.2.3 无同步方案</h4><p>要保证线程同步，不一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时正确性的手段，如果有些代码不涉及共享数据，自然无需同步保证共享数据争用时的正确性。</p><ul><li>可重入代码（Reentrant Code）：这种代码也叫纯代码（Pure Code），可以在代码执行的任何时刻中断它，转去执行另外一段代码，而控制权回来后继续执行代码，程序不会出现任何错误。</li><li>线程本地存储（Thread Local Storage）：如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，无需同步也能实现线程之间不出现数据争用的问题。</li></ul><h2 id="3-Java锁优化"><a href="#3-Java锁优化" class="headerlink" title="3. Java锁优化"></a>3. Java锁优化</h2><p>为了在线程之间更高效地共享数据，以及解决数据竞争问题，JDK实现了各种锁的优化技术，如适应性自旋(Adaptive Spinning)、锁消除(Lock Elimination)、锁粗化(Lock Coarsening)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)等。</p><h4 id="3-1-自旋锁与自适应性自旋"><a href="#3-1-自旋锁与自适应性自旋" class="headerlink" title="3.1 自旋锁与自适应性自旋"></a>3.1 自旋锁与自适应性自旋</h4><p>互斥同步对性能最大的影响是阻塞的实现，挂起和恢复线程的操作都需要转入内核态完成，这些操作给并发性能带来很大的压力。如果获取共享数据锁时仅需要等待很短的时间，为了很短的时间去挂起和恢复线程并不值得。如果处理器有一个以上的处理器，我们可以线程让请求锁的线程忙循环，不放弃处理器的执行时间，这项技术就是所谓的自旋锁。<br>自适应自旋锁意味着自旋的时间不再固定，根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><h4 id="3-2-锁消除"><a href="#3-2-锁消除" class="headerlink" title="3.2 锁消除"></a>3.2 锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为是线程私有的，同步加锁自然无需执行。</p><h4 id="3-3-锁粗化"><a href="#3-3-锁粗化" class="headerlink" title="3.3 锁粗化"></a>3.3 锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体中。如果虚拟机探测到有这样一串零碎的操作都对一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只加锁一次就可以。</p><h4 id="3-4-轻量级锁"><a href="#3-4-轻量级锁" class="headerlink" title="3.4 轻量级锁"></a>3.4 轻量级锁</h4><p>轻量级锁是JDK1.6 中加入的新型锁机制，轻量级是相对于使用操作系统互斥量来实现传统锁而言，因此传统锁机制被称为重量级锁。轻量级锁本意指在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>HotSpot虚拟机的对象头(Object Header)分为两部分，第一用于存储自身的运行时数据，这部分数据的长度在32位和64位的虚拟机分别是32个和64个bits，官网称它为”Mark Word”。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还有一个额外的部分用于存储数组长度。<br><img src="/media/article/object-header.png" alt="mark word"><br>表摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，根据对象的状态复用自己的存储空间。<br>HotSpot 虚拟机对象头Mark Word不同状态下存储内容表：<br><img src="/media/article/markword.png" alt="mark word"><br>表摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>上表中存储内容列是Mark Word中除标志位外，其他的30bit空间的存储内容，状态列是指不同的锁状态，如：轻量级锁，重量级锁等等。具体内容存储占位如下图所示<br><img src="/media/article/markword-status.png" alt="mark word status"><br>表摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>轻量级锁的执行过程：在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word拷贝，如图：<br><img src="/media/article/markword-cas-before.png" alt="markword-cas-before"><br>图摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新成功了，那么该线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转为“00”，即表示该对象处于轻量级锁定状态。<br><img src="/media/article/markword-cas-after.png" alt="markword-cas-after"><br>图摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>如果更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了该对象的锁，可直接进入同步代码块继续执行，否则说明这个锁对象被其他线程抢占了。如果有两条以上（包括两条）的线程争用同一个锁，轻量级锁不再有效要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁的指针，后面等待的线程也要进入阻塞状态。<br>轻量级锁初始化及膨胀流程图：<br><img src="/media/article/lightweight-expand.png" alt="lightweight"><br>图摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍指向线程的锁记录，就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，同步完成。替换失败，有其他线程尝试获取该锁，此时锁已经膨胀，就要在释放锁的同时，唤醒被挂起的线程。</p><h4 id="3-5-偏向锁"><a href="#3-5-偏向锁" class="headerlink" title="3.5 偏向锁"></a>3.5 偏向锁</h4><p>偏向锁目的是消除数据在无竞争情况下的同步原语。<br>使用场景：锁不仅不存在多线程竞争，而且总是由同一线程多次获得。<br>偏向锁原理：当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”（Mark Word见3.4小节的表中），即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步时，虚拟机都可以不再进行任何同步操作，只需简单测试对象头的Mark Word是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁。如果测试失败，则需要在测试一下Mark Word中偏向锁的标识是否设置成”01”：如果没有设置，则使用CAS竞争锁，如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，继续执行同步块；如果竞争失败，则进行偏向锁撤销。如果设置了则尝试使用CAS将对象头的偏向锁指向当前线程。<br>偏向锁撤销（Revoke Bias）：当有另外一个线程尝试去获取这个锁时，偏向模式结束。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置成无锁状态；如果线程还活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。<br>偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图：<br><img src="/media/article/markword-change.png" alt="markword-change"><br>图摘自<a href="#偏向锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>偏向锁初始化及膨胀流程图：<br><img src="/media/article/bias-expand.png" alt="bias-expand"><br>图摘自<a href="#偏向锁">Java并发编程艺术 2.2小节</a></p><h4 id="3-6-轻量级锁、偏向锁、重量级锁对比"><a href="#3-6-轻量级锁、偏向锁、重量级锁对比" class="headerlink" title="3.6 轻量级锁、偏向锁、重量级锁对比"></a>3.6 轻量级锁、偏向锁、重量级锁对比</h4><p>偏向锁初始化及膨胀流程图：<br><img src="/media/article/lock-advantage-disadvantage.png" alt="lock"><br>图摘自<a href="#轻量级锁、偏向锁、重量级锁对比">Java并发编程艺术 2.2小节</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与实践</a><br><a href="">Java并发编程实践</a><br><a href="">Java并发编程艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程启动与终止</title>
      <link href="/zhongyp.github.io/concurrency/2018-12-04-thread-start-end/"/>
      <url>/zhongyp.github.io/concurrency/2018-12-04-thread-start-end/</url>
      
        <content type="html"><![CDATA[<h3 id="1-构造线程"><a href="#1-构造线程" class="headerlink" title="1. 构造线程"></a>1. 构造线程</h3><h4 id="1-1-构造线程的方式"><a href="#1-1-构造线程的方式" class="headerlink" title="1.1 构造线程的方式"></a>1.1 构造线程的方式</h4><p>Java构造一个线程有两种方式：</p><p>一种是声明子类继承Thread父类并重写父类的run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeThread extends Thread &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeThread(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeThread p = new PrimeThread(143);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure></p><p>另一种方式是声明子类实现Runnable接口，并实现run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeRun implements Runnable &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeRun(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeRun p = new PrimeRun(143);</span><br><span class="line">new Thread(p).start();</span><br></pre></td></tr></table></figure></p><p>两者其实在本质上是一致的，因为Thread类也继承了Runable接口，所以都实现/重写Runable中的run方法。Java将线程的执行和执行对象抽象开来，JDK中执行的是Thread类，Executor框架，可执行目标有Runable，Callable。对于构造线程的方式第一种方式并不推荐，因为继承Thread类限定了其基本行为，在设计上违反多用组合 少用继承的原则，所以一般构造线程使用第二种方式，实现Runable接口。</p><h4 id="1-2-构造线程的属性"><a href="#1-2-构造线程的属性" class="headerlink" title="1.2 构造线程的属性"></a>1.2 构造线程的属性</h4><p>构造线程时需要提供线程所需要的属性。一个新的（child）线程对象是由parent线程进行空间分配的，而child线程继承了parent是否为Daemon、优先级、和加载资源的contextClassLoader以及可继承的ThreadLocal等属性，同时分配唯一的ID来表示这个child线程。如果创建线程实例后需要修改线程属性，则可以通过Thread提供的一些修改属性的方法进行修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setPriority() // 优先级</span><br><span class="line">getPriority()</span><br><span class="line">setName()。// 线程名</span><br><span class="line">getName()</span><br><span class="line">setDaemon() // 守护线程</span><br><span class="line">isDaemon()</span><br><span class="line">getContextClassLoader()。// 资源加载</span><br><span class="line">setContextClassLoader()</span><br><span class="line">getStackTrace() </span><br><span class="line">getAllStackTraces()</span><br><span class="line">checkAccess()</span><br><span class="line">isCCLOverridden()</span><br><span class="line">auditSubclass() </span><br><span class="line">dumpThreads()</span><br><span class="line">getThreads()</span><br><span class="line">getId()</span><br><span class="line">getState()</span><br><span class="line">setDefaultUncaughtExceptionHandler()</span><br><span class="line">getDefaultUncaughtExceptionHandler()</span><br><span class="line">getUncaughtExceptionHandler()</span><br><span class="line">setUncaughtExceptionHandler()</span><br><span class="line">dispatchUncaughtException()</span><br><span class="line">processQueue()</span><br></pre></td></tr></table></figure></p><p>当然构造线程时有些属性还可以在创建线程实例时就设置，如线程组，栈大小，栈名称，权限控制上下文，可继承的ThreadLocal，下面是JDK初始化一个线程实例时的代码，摘至<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK8</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @param g</span><br><span class="line"> * @param target</span><br><span class="line"> * @param name</span><br><span class="line"> * @param stackSize 线程的栈大小 根据参数传递过程可以看出默认大小为零，即使用默认的线程栈大小</span><br><span class="line"> * @param acc 访问控制权限</span><br><span class="line"> * @param inheritThreadLocals // 可继承的ThreadLocal</span><br><span class="line"> *</span><br><span class="line"> * ThreadGroup 线程组（ThreadGroup）就是由线程组成的管理线程的类，</span><br><span class="line"> *     这个类是java.lang.ThreadGroup类。</span><br><span class="line"> *     定义一个线程组，通过以下代码可以实现。</span><br><span class="line"> *     ThreadGroup group=new ThreadGroup(&quot;group&quot;);</span><br><span class="line"> *     Thread thread=new Thread(group,&quot;the first thread of group&quot;);</span><br><span class="line"> *     ThreadGroup类中的某些方法，可以对线程组中的线程产生作用。例如，setMaxPriority()方法可以设定线程组中的所有线程拥有最大的优先权。</span><br><span class="line"> */</span><br><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                  long stackSize, AccessControlContext acc,</span><br><span class="line">                  boolean inheritThreadLocals) &#123;</span><br><span class="line">    if (name == null) &#123;// 线程名，可相同</span><br><span class="line">        throw new NullPointerException(&quot;name cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();// 获取当前线程，并作为父线程。</span><br><span class="line">    SecurityManager security = System.getSecurityManager();// 获取安全策略</span><br><span class="line">    if (g == null) &#123;</span><br><span class="line">        /* Determine if it&apos;s an applet or not */</span><br><span class="line"></span><br><span class="line">        /* If there is a security manager, ask the security manager</span><br><span class="line">           what to do. */</span><br><span class="line">        if (security != null) &#123;//如果存在安全管理器，则获取它重写的线程组</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If the security doesn&apos;t have a strong opinion of the matter</span><br><span class="line">           use the parent thread group. */</span><br><span class="line">        if (g == null) &#123;</span><br><span class="line">            g = parent.getThreadGroup();//使用父线程组</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* checkAccess regardless of whether or not threadgroup is</span><br><span class="line">       explicitly passed in. */</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Do we have the required permissions?</span><br><span class="line">     */</span><br><span class="line">    if (security != null) &#123;</span><br><span class="line">        if (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    this.group = g;</span><br><span class="line">    this.daemon = parent.isDaemon();//继承父线程的守护属性</span><br><span class="line">    this.priority = parent.getPriority();//继承父线程的优先级</span><br><span class="line">    //继承父线程加载资源的contextClassLoader</span><br><span class="line">    if (security == null || isCCLOverridden(parent.getClass()))</span><br><span class="line">        this.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    else</span><br><span class="line">        this.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    this.inheritedAccessControlContext =</span><br><span class="line">            acc != null ? acc : AccessController.getContext();</span><br><span class="line">    this.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    // 继承父线程可继承的ThreadLocal</span><br><span class="line">    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">        this.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    /* Stash the specified stack size in case the VM cares */</span><br><span class="line">    this.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    /* Set thread ID */</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-启动线程"><a href="#1-3-启动线程" class="headerlink" title="1.3 启动线程"></a>1.3 启动线程</h4><p>线程对象在初始化完成后，调用start方法就可以启动线程。<br><strong><em>注意：启动一个线程，最好为这个线程设置线程名称，这行有助于分析或者排查问题</em></strong></p><h3 id="2-中断线程"><a href="#2-中断线程" class="headerlink" title="2. 中断线程"></a>2. 中断线程</h3><h4 id="2-1-中断的原理"><a href="#2-1-中断的原理" class="headerlink" title="2.1 中断的原理"></a>2.1 中断的原理</h4><p>中断，可以理解为运行中的线程，是否被其他线程进行了中断操作。中断操作包含三个方法。interrupt(),interrupted(),isInterrupted()。下面我们将对这个方法进行详细了解。</p><h5 id="2-1-1-interrupt"><a href="#2-1-1-interrupt" class="headerlink" title="2.1.1 interrupt()"></a>2.1.1 interrupt()</h5><p>中断操作通过调用线程的interrupt()方法进行。例如线程A中断线程B，在线程A的代码中调用ThreadB.interrupt() 即可。</p><p>interrupt()方法不是直接将线程终止，而是针对于不同情况进行不同处理。</p><ol><li>除非终止的是当前线程（始终被允许），否则调用checkAccess方法，可能会导致抛出SecurityException异常。</li><li>如果调用Object类的wait(),wait(long)或者wait(long, int)等方法，或者调用此线程的join(),join(long),join(long, int), sleep(long), sleep(long, int)方法，<strong><em>此线程的中断状态将被清除，同时将抛出InterruptedException异常</em></strong>。</li><li>如果此线程在可中断通道的IO操作上，通道将被关闭，线程被设置中断状态，同时将抛出ClosedByInterruptException异常。</li><li>如果线程在选择器(Selector)阻塞，线程将被设置中断状态，立即从选择操作中返回，可能带有非零值，就像选择器唤醒方法被调用一样。</li><li>如果以上的条件都不满足，此线程将被设置中断状态。</li><li>中断不存活的线程不会有任何影响。</li></ol><p>翻译自<a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Java se7docs</a></p><p>注：Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。<br><strong><em>注意：</em></strong><br>对于会抛出异常的情况，异常一定要处理，一般子线程异常不能抛出非运行时异常，所以子线程我们需要抛出运行时异常，用于给父线程捕获。或者在catch块中使用 Thread.currentThread().interrupt() 重新抛出中断来保证调用栈的高层的代码知道当前线程的中断。</p><h5 id="2-1-2-interrupted"><a href="#2-1-2-interrupted" class="headerlink" title="2.1.2 interrupted()"></a>2.1.2 interrupted()</h5><p>interrupted()主要有以下两个功能：</p><ol><li>测试<strong><em>当前线程</em></strong>是否被中断,清除线程中断状态。换句话说就是，如果当前方法被成功调用两次，则返回false（除非当前线程在第一次调用此方法后第二次调用此方法前被再次中断）。</li><li>线程中断被忽略，在中断时线程处于不活动的状态将被此方法反映返回false。</li></ol><p>interrupted()不同于interrupt(),此方法用于测试当前线程是否被中断，并清除中断状态。代码示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread thread = new InterruptThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    SleepUtils.sleep(1);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">static class InterruptThread extends Thread&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       int count = 0;</span><br><span class="line">       while(true)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           if(Thread.currentThread().interrupted())&#123;//此处仅仅是为了示例</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-1-3-isInterrupted"><a href="#2-1-3-isInterrupted" class="headerlink" title="2.1.3 isInterrupted()"></a>2.1.3 isInterrupted()</h5><ol><li>isInterrupted虽然也是测试线程是否被中断，但是此方法不会更改线程的中断状态。</li><li>线程中断被忽略，在中断时线程处于不活动的状态将被此方法反映返回false。</li></ol><h3 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3. 终止线程"></a>3. 终止线程</h3><h4 id="3-1-过期的suspend-、resume-和stop"><a href="#3-1-过期的suspend-、resume-和stop" class="headerlink" title="3.1 过期的suspend()、resume()和stop()"></a>3.1 过期的suspend()、resume()和stop()</h4><p>在Java API中，suspend()、resume()和stop()三个方法是过期的，不建议使用的。<br>主要原因是：suspend()在调用后，线程不是放已经占有的资源比如说锁，而是占有着资源进入睡眠，这样容易引发死锁状态。stop()方法在终结一个线程时不会保证线程资源的释放，因此导致线程处于不确定的状态下。</p><p><strong><em>sleep和suspend区别：</em></strong><br>相同点：sleep和suspend都会持有占有的资源不释放。<br>不同点：sleep阻塞（TIMED_WAITING）后，经过一段时间自行恢复运行。而suspend必须使用resume()显示的恢复，如果不使用resume()或者resume()失败，很容易引起资源占用导致的死锁。</p><h4 id="3-2-安全的终止线程"><a href="#3-2-安全的终止线程" class="headerlink" title="3.2 安全的终止线程"></a>3.2 安全的终止线程</h4><p>在第2小节提到的中断是线程的一个标示位，中断操作是一种简便的线程间交互方式，这种交互方式适合用来取消和停止任务。除了中断，还可以使用同步变量来控制是否停止并终止该线程。<br><strong><em>线程的终止不是直接强制线程停止，而是引导线程运行结束。</em></strong></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" target="_blank" rel="noopener">Java 安全模型介绍</a><br><a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Class Thread</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程(1)-Thread类源码</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Class文件结构</title>
      <link href="/zhongyp.github.io/jvm/2018-11-22-class-structure/"/>
      <url>/zhongyp.github.io/jvm/2018-11-22-class-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="class结构"><a href="#class结构" class="headerlink" title="class结构"></a>class结构</h2><p>摘自<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">Chapter 4.The class File Format</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h3><p>用来识别class文件，固定值：0xCAFEBABE。关于0xCAFEBABE还有一个故事<a href="https://leokongwq.github.io/2016/12/31/java-magic-0xCAFEBABE.html" target="_blank" rel="noopener">java魔法之0xCAFEBABE</a></p><h3 id="minor-version-major-version"><a href="#minor-version-major-version" class="headerlink" title="minor_version, major_version"></a>minor_version, major_version</h3><p>The values of the minor_version and major_version items are the minor and major version numbers of this class file. Together, a major and a minor version number determine the version of the class file format. If a class file has major version number M and minor version number m, we denote the version of its class file format as M.m. Thus, class file format versions may be ordered lexicographically, for example, 1.5 &lt; 2.0 &lt; 2.1.</p><p>minor_version和major_version项的值是此类文件的次要版本号和主要版本号。主要版本号和次要版本号一起确定类文件格式的版本。如果类文件具有主版本号M和次版本号m，则我们将其类文件格式的版本表示为M.m.因此，类文件格式版本可以按字典顺序排序，例如，1.5 &lt;2.0 &lt;2.1。</p><p>A Java Virtual Machine implementation can support a class file format of version v if and only if v lies in some contiguous range Mi.0 ≤ v ≤ Mj.m. The release level of the Java SE platform to which a Java Virtual Machine implementation conforms is responsible for determining the range.</p><p>当且仅当v位于某个连续范围Mi.0≤v≤Mj.m时，Java虚拟机实现可以支持版本v的类文件格式。 Java SE平台的发行版级负责确定Java虚拟机实现符合的范围</p><p>Oracle’s Java Virtual Machine implementation in JDK release 1.0.2 supports class file format versions 45.0 through 45.3 inclusive. JDK releases 1.1.* support class file format versions in the range 45.0 through 45.65535 inclusive. For k ≥ 2, JDK release 1.k supports class file format versions in the range 45.0 through 44+k.0 inclusive.</p><p>JDK 1.0.2版中的Oracle Java虚拟机实现支持包含45.0到45.3类的类文件格式。 JDK发布的1.1.*支持类文件格式版本范围为45.0到45.65535（含）。对于k≥2，JDK版本1.k支持45.0到44 + k.0范围内的类文件格式版本。</p><h3 id="constant-pool-count"><a href="#constant-pool-count" class="headerlink" title="constant_pool_count"></a>constant_pool_count</h3><p>The value of the constant_pool_count item is equal to the number of entries in the constant_pool table plus one. A constant_pool index is considered valid if it is greater than zero and less than constant_pool_count, with the exception for constants of type long and double noted in §4.4.5.</p><p>constant_pool_count项的值等于constant_pool表中的条目数加1。如果constant_pool索引大于零且小于constant_pool_count，则认为它是有效的，§4.4.5中注明了long和double类型的常量。</p><h3 id="constant-pool"><a href="#constant-pool" class="headerlink" title="constant_pool[]"></a>constant_pool[]</h3><p>The constant_pool is a table of structures (§4.4) representing various string constants, class and interface names, field names, and other constants that are referred to within the ClassFile structure and its substructures. The format of each constant_pool table entry is indicated by its first “tag” byte.</p><p>The constant_pool table is indexed from 1 to constant_pool_count-1.</p><h3 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h3><p>The value of the access_flags item is a mask of flags used to denote access permissions to and properties of this class or interface. The interpretation of each flag, when set, is as shown in Table 4.1.</p><p>Table 4.1. Class access and property modifiers</p><p>Flag Name    Value    Interpretation<br>ACC_PUBLIC    0x0001    Declared public; may be accessed from outside its package.<br>ACC_FINAL    0x0010    Declared final; no subclasses allowed.<br>ACC_SUPER    0x0020    Treat superclass methods specially when invoked by the invokespecial instruction.<br>ACC_INTERFACE    0x0200    Is an interface, not a class.<br>ACC_ABSTRACT    0x0400    Declared abstract; must not be instantiated.<br>ACC_SYNTHETIC    0x1000    Declared synthetic; not present in the source code.<br>ACC_ANNOTATION    0x2000    Declared as an annotation type.<br>ACC_ENUM    0x4000    Declared as an enum type.<br>A class may be marked with the ACC_SYNTHETIC flag to indicate that it was generated by a compiler and does not appear in source code.</p><p>The ACC_ENUM flag indicates that this class or its superclass is declared as an enumerated type.</p><p>An interface is distinguished by its ACC_INTERFACE flag being set. If its ACC_INTERFACE flag is not set, this class file defines a class, not an interface.</p><p>If the ACC_INTERFACE flag of this class file is set, its ACC_ABSTRACT flag must also be set (JLS §9.1.1.1). Such a class file must not have its ACC_FINAL, ACC_SUPER or ACC_ENUM flags set.</p><p>An annotation type must have its ACC_ANNOTATION flag set. If the ACC_ANNOTATION flag is set, the ACC_INTERFACE flag must be set as well. If the ACC_INTERFACE flag of this class file is not set, it may have any of the other flags in Table 4.1 set, except the ACC_ANNOTATION flag. However, such a class file cannot have both its ACC_FINAL and ACC_ABSTRACT flags set (JLS §8.1.1.2).</p><p>The ACC_SUPER flag indicates which of two alternative semantics is to be expressed by the invokespecial instruction (§invokespecial) if it appears in this class. Compilers to the instruction set of the Java Virtual Machine should set the ACC_SUPER flag.</p><p>The ACC_SUPER flag exists for backward compatibility with code compiled by older compilers for the Java programming language. In Oracle’s JDK prior to release 1.0.2, the compiler generated ClassFile access_flags in which the flag now representing ACC_SUPER had no assigned meaning, and Oracle’s Java Virtual Machine implementation ignored the flag if it was set.</p><p>All bits of the access_flags item not assigned in Table 4.1 are reserved for future use. They should be set to zero in generated class files and should be ignored by Java Virtual Machine implementations.</p><h3 id="this-class"><a href="#this-class" class="headerlink" title="this_class"></a>this_class</h3><p>The value of the this_class item must be a valid index into the constant_pool table. The constant_pool entry at that index must be a CONSTANT_Class_info structure (§4.4.1) representing the class or interface defined by this class file.</p><h3 id="super-class"><a href="#super-class" class="headerlink" title="super_class"></a>super_class</h3><p>For a class, the value of the super_class item either must be zero or must be a valid index into the constant_pool table. If the value of the super_class item is nonzero, the constant_pool entry at that index must be a CONSTANT_Class_info structure (§4.4.1) representing the direct superclass of the class defined by this class file. Neither the direct superclass nor any of its superclasses may have the ACC_FINAL flag set in the access_flags item of its ClassFile structure.</p><p>If the value of the super_class item is zero, then this class file must represent the class Object, the only class or interface without a direct superclass.</p><p>For an interface, the value of the super_class item must always be a valid index into the constant_pool table. The constant_pool entry at that index must be a CONSTANT_Class_info structure representing the class Object.</p><h3 id="interfaces-count"><a href="#interfaces-count" class="headerlink" title="interfaces_count"></a>interfaces_count</h3><p>The value of the interfaces_count item gives the number of direct superinterfaces of this class or interface type.</p><h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces[]"></a>interfaces[]</h3><p>Each value in the interfaces array must be a valid index into the constant_pool table. The constant_pool entry at each value of interfaces[i], where 0 ≤ i &lt; interfaces_count, must be a CONSTANT_Class_info structure (§4.4.1) representing an interface that is a direct superinterface of this class or interface type, in the left-to-right order given in the source for the type.</p><h3 id="fields-count"><a href="#fields-count" class="headerlink" title="fields_count"></a>fields_count</h3><p>The value of the fields_count item gives the number of field_info structures in the fields table. The field_info structures (§4.5) represent all fields, both class variables and instance variables, declared by this class or interface type.</p><h3 id="fields"><a href="#fields" class="headerlink" title="fields[]"></a>fields[]</h3><p>Each value in the fields table must be a field_info (§4.5) structure giving a complete description of a field in this class or interface. The fields table includes only those fields that are declared by this class or interface. It does not include items representing fields that are inherited from superclasses or superinterfaces.</p><h3 id="methods-count"><a href="#methods-count" class="headerlink" title="methods_count"></a>methods_count</h3><p>The value of the methods_count item gives the number of method_info structures in the methods table.</p><h3 id="methods"><a href="#methods" class="headerlink" title="methods[]"></a>methods[]</h3><p>Each value in the methods table must be a method_info (§4.6) structure giving a complete description of a method in this class or interface. If neither of the ACC_NATIVE and ACC_ABSTRACT flags are set in the access_flags item of a method_info structure, the Java Virtual Machine instructions implementing the method are also supplied.</p><p>The method_info structures represent all methods declared by this class or interface type, including instance methods, class methods, instance initialization methods (§2.9), and any class or interface initialization method (§2.9). The methods table does not include items representing methods that are inherited from superclasses or superinterfaces.</p><h3 id="attributes-count"><a href="#attributes-count" class="headerlink" title="attributes_count"></a>attributes_count</h3><p>The value of the attributes_count item gives the number of attributes (§4.7) in the attributes table of this class.</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes[]"></a>attributes[]</h3><p>Each value of the attributes table must be an attribute_info (§4.7) structure.</p><p>The attributes defined by this specification as appearing in the attributes table of a ClassFile structure are the InnerClasses (§4.7.6), EnclosingMethod (§4.7.7), Synthetic (§4.7.8), Signature (§4.7.9), SourceFile (§4.7.10), SourceDebugExtension (§4.7.11), Deprecated (§4.7.15), RuntimeVisibleAnnotations (§4.7.16), RuntimeInvisibleAnnotations (§4.7.17), and BootstrapMethods (§4.7.21) attributes.</p><p>If a Java Virtual Machine implementation recognizes class files whose version number is 49.0 or above, it must recognize and correctly read Signature (§4.7.9), RuntimeVisibleAnnotations (§4.7.16), and RuntimeInvisibleAnnotations (§4.7.17) attributes found in the attributes table of a ClassFile structure of a class file whose version number is 49.0 or above.</p><p>If a Java Virtual Machine implementation recognizes class files whose version number is 51.0 or above, it must recognize and correctly read BootstrapMethods (§4.7.21) attributes found in the attributes table of a ClassFile structure of a class file whose version number is 51.0 or above.</p><p>A Java Virtual Machine implementation is required to silently ignore any or all attributes in the attributes table of a ClassFile structure that it does not recognize. Attributes not defined in this specification are not allowed to affect the semantics of the class file, but only to provide additional descriptive information (§4.7.1).</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发知识架构</title>
      <link href="/zhongyp.github.io/concurrency/2018-11-27-concurrency-structure/"/>
      <url>/zhongyp.github.io/concurrency/2018-11-27-concurrency-structure/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/article/concurrency.png" alt="Java并发架构图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git常用命令总结</title>
      <link href="/zhongyp.github.io/utils/2018-10-23-git/"/>
      <url>/zhongyp.github.io/utils/2018-10-23-git/</url>
      
        <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>系统系统性的学习Git，请移步<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Git中文学习文档</a>，这篇文章只是分类记录一下git的常用命令。<br><img src="/media/article/15403035072735.png" alt="Git版本控制系统VCS基本操作流程图"></p><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><h3 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h3><p><code>git init</code> 将当前目录变为本地仓库（.git）<br><code>git clone</code> 克隆一个远程仓库到本地<br><code>git clone -b branch url</code> 克隆远程仓库指定branch分支到本地<br><code>git config user.name</code> 查看用户名<br><code>git config user.email</code> 查看邮箱</p><h3 id="设置与配置"><a href="#设置与配置" class="headerlink" title="设置与配置"></a>设置与配置</h3><p><code>git config -global user.name/email &quot;参数&quot;</code> git是分布式版本控制，所以添加用户名和邮箱作为一个标识<br><code>ssh -keygen -t rsa -C &quot;email&quot;</code> 生成本地ssh key</p><h3 id="本地版本库"><a href="#本地版本库" class="headerlink" title="本地版本库"></a>本地版本库</h3><p><code>git add &quot;filename.*&quot;</code> 添加到暂存区<br><code>git commit -m &quot;filename.*&quot;</code> 提交到本地仓库<br><code>git commit --amend</code> 尝试重新提交，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add file1 // 将file1 添加至缓存区</span><br><span class="line">git commmit -m &quot;update files&quot; //提交file1到本地仓库,提交完发现忘记file2没有提交，则你可以使用如下命令，提交file2并覆盖之前的提交信息。</span><br><span class="line">git add file2 // 添加file2</span><br><span class="line">git commit -amend // 尝试重新提交commit信息，并覆盖掉之前的提交信息</span><br></pre></td></tr></table></figure><p><code>git status</code> 查看本地仓库状态<br><code>git diff filename.*</code> 查看尚未暂存的文件修改的部分<br><code>git diff --cached</code>或<code>git diff --staged</code>查看已暂存的文件修改的部分<br><code>git log</code> commit的日志<br><code>git log --pretty=oneline</code> 日志显示为缩略版<br>注：<code>git reset</code> 不加<code>--hard</code>参数对当前工作区文件不会有任何修改，只是对缓存区进行操作。一旦加了参数，操作一定要慎重，否则你当前工作区中的修改将会全部被清除。<br><code>git reset HEAD file</code> 将file退回到当前版本（仅仅是对缓存区进行操作）<br><code>git reset --hard HEAD^</code> 退回到上一版本<br><code>git reset --hard HEAD^^</code> 退回到前二的版本<br><code>git reset --hard HEAD~100</code> 退回到前100版本<br><code>git reset --hard 版本号</code> 退回到一个特定的版本<br><code>git reflog</code> 查看所有操作日志，包括分支和删除的commit<br><code>git reset --mixed</code> 将当前文件撤出缓存区，保留文件修改<br><code>git rm --cached file</code> 删除缓存区file<br><code>git checkout -- file</code> 恢复工作区file（取消工作区文件的修改）</p><h3 id="远程版本库"><a href="#远程版本库" class="headerlink" title="远程版本库"></a>远程版本库</h3><p><code>git remote add origin 远程git地址</code> 连接<br><code>git push -u origin master</code> 把本地库分支master内容推送到远程库（-u 命令在第一次关联本地库和远程库时使用）<br><code>git clone url</code> 克隆远程(url)库</p><h3 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h3><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p><code>git branch</code> 查看分支<br><code>git checkout</code> 切换分支<br><code>git checkout -b</code>  创建并切换分支<br><code>git merge</code> 合并到当前分支<br><code>git branch -d</code>删除某分支<br><code>git merge --no-ff -m &quot;注释&quot;</code>分支合并分支禁用fast forward<br><code>git stash</code> 将当前分支的工作现场保留下来<br><code>git stash list</code> 查看工作现场<br><code>git stash apply</code> 恢复内容但是你需要git stash drop删除stash<br><code>git stash pop</code> 恢复的同时把stash内容也删除<br><code>git remote</code> 查看远程库的信息<br><code>git remote -v</code> 查看远程库的详细信息<br><code>git push origin master</code> master为本地的分支名推送分支<br><code>git checkout -b dev origin/dev</code> dev为分支名，做完开发后<br><code>git push origin dev</code> 推送到远程库<br><code>git pull</code> 抓取最新的提交,并尝试自动合并到本地当前所在的分支<br><code>git fetch</code> 抓取最新的提交，不会自动合并，必须手动。<br><code>git rebase</code> 变基,将提交到某一分支上的所有修改都移至另一分支上<br><code>git rebase --continue</code> <strong><em>继续变基操作，一般用于第一次变基失败后，解决冲突文件，将冲突文件添加到缓存区，不要提交，然后再执行此命令。如果提交了，执行<code>git rebase --skip</code>命令取消rebase状态。</em></strong><br><code>git branch --set-upstream dev origin/dev</code> 指定本地dev分支（已经创建的）与远程origin/dev分支的连接<br><code>git branch -u origin/dev</code> 指定当前所在连接远程origin/dev分支的连接<br><code>git checkout --track origin/dev</code> 创建新的dev分支，制定远程连接origin/dev</p><blockquote><p>如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p></blockquote><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ol><li>每开发一个新特性可以新建一个本地特性分支，开发完成后合并到本地主线。</li><li>如果不使用特性分支开发可以使用<code>git stash</code>保存当前的工作空间。</li><li>远程代码和本地代码合并有两种方式，<code>git pull</code>和<code>git fetch</code>，<code>git pull</code>命令会自动合并远程代码，冲突后需要解决冲突后提交。<code>git fetch</code>不自动和本地代码合并，需要手动merge。</li><li>在合并时，根据项目情况使用<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">变基</a>，<code>git pull --rebase</code>可以保持自动合并的情况下进行变基。一般情况下，远程库不保留本地操作历史，所以本地与远程代码合并时最好使用变基。</li><li><strong><em>使用变基原则</em></strong>：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Utils </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高性能MySQL -- 摘自《高性能MySQL第三版》</title>
      <link href="/zhongyp.github.io/mysql/2018-04-02-mysql/"/>
      <url>/zhongyp.github.io/mysql/2018-04-02-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="引擎篇"><a href="#引擎篇" class="headerlink" title="引擎篇"></a>引擎篇</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li><p>Myisam是Mysql的默认存储引擎，当create创建新表时，未指定新表的存储引擎时，默认使用Myisam。</p></li><li><p>每个MyISAM在磁盘上存储成三个文件。文件名都和表名相同，扩展名分别是.frm（存储表定义）、.MYD (MYData，存储数据)、.MYI (MYIndex，存储索引)。数据文件和索引文件可以放置在不同的目录，平均分布io，获得更快的速度。</p></li><li><p>它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一 .</p></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li><p>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比Myisam的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</p></li><li><p>用于事务处理应用程序，具有众多特性，包括ACID 事务支持。</p></li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>将所有数据保存在RAM 中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。</p><table><tr></tr><tr></tr><tr><td>特点</td><td>Myisam</td><td> BDB</td><td> Memory</td><td>InnoDB</td><td> Archive</td></tr><tr><td>存储限制</td><td>没有</td><td>没有</td><td>有</td><td>64TB</td><td>没有</td></tr><tr><td>事务安全</td><td></td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>锁机制</td><td>表锁</td><td>页锁</td><td>表锁</td><td>行锁</td><td>行锁</td></tr><tr><td>B 树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr><td>数据缓存</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>空间使用</td><td>低</td><td>低</td><td>N/A</td><td> 高</td><td>非常低</td></tr><tr><td>内存使用</td><td>低</td><td>低</td><td>中等</td><td>高</td><td>低</td></tr><tr><td>批量插入的速度</td><td>高</td><td>高</td><td>高</td><td>低</td><td>非常高</td></tr><tr><td>支持外键</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr></tr></table><h2 id="Schema与数据类型优化"><a href="#Schema与数据类型优化" class="headerlink" title="Schema与数据类型优化"></a>Schema与数据类型优化</h2><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li><p>一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p></li><li><p>简单的数据类型通常需要更少的CPU周期。</p></li><li><p>尽量避免使用NULL，原因是由于NULL可能需要单独的位（bit）去存储或者NULL使得索引、索引统计、值比较都更为复杂。</p></li></ul><h3 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h3><ul><li><p>范式化的更新操作会比反范式化的快。</p></li><li><p>当数据较好范式化的时候，只有很少或者没有重复数据，所以只需要修改更少的数据。</p></li><li><p>范式化的表通常更小。</p></li><li><p>很少有冗余数据意味着检索列表数据更少需要distinct或者group by语句。</p></li></ul><h3 id="反范式的优点和缺点"><a href="#反范式的优点和缺点" class="headerlink" title="反范式的优点和缺点"></a>反范式的优点和缺点</h3><ul><li>反范式的schema所有数据都在一张表中，可以很好的避免关联，还可以避免随机IO(和存储引擎有关)。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>尽可能避免过度设计，例如会导致复杂查询的schema设计，或者有很多列的表的设计。</p></li><li><p>使用小而简单的合适数据类型，除非真实数据模型中确切的需要，否则应尽可能的避免NULL值。</p></li><li><p>尽量使用相同的数据类型存储相似或者相关的值，尤其是在关联条件中要使用的列。</p></li><li><p>避免使用MySQL已经遗弃的特性，例如浮点数的精度，或者整数的显示宽度。</p></li><li><p>小心使用ENUM和SET。避免使用BIT。</p></li></ul><h2 id="高性能索引创建"><a href="#高性能索引创建" class="headerlink" title="高性能索引创建"></a>高性能索引创建</h2><p>系统从磁盘读取数据到内存是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页（page）的概念，页是其磁盘管理的最小单位。</p><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><h4 id="B-Tree索引（平衡多路查找树）"><a href="#B-Tree索引（平衡多路查找树）" class="headerlink" title="B-Tree索引（平衡多路查找树）"></a>B-Tree索引（平衡多路查找树）</h4><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree.png?raw=true" alt="b-tree"></p><p>B-Tree 通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。B-Tree索引能够加快访问数据的速度，存储引擎不需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放指向子节点的指针，存储引擎根据这些指针向下层查找。指针中定义了子节点页中值的<br>上限和下限。最终找到该值或者不存在。</p><p>叶子节点比较特殊，他们指向的是被索引的数据，而不是其他的节点页。</p><p>树的深度和表的大小直接相关。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree1.png?raw=true" alt="b-tree"></p><p>可以使用B-Tree索引的查询类型：</p><p>全值匹配：全值匹配指的是和索引的所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen 1960-01-01。</p><p>匹配最左前缀：可用于查找索引的第一列。</p><p>匹配列前缀：也可以匹配某一列的值的开头部分。</p><p>匹配范围值：遵循最左前缀的前提下，范围查找。</p><p>精确匹配某一列并范围匹配另外一列：可用于查找所有姓为Allen,并且名字是字母K开头的人。</p><p>只访问索引的查询：B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。</p><p>B-Tree使用限制：</p><p>必须遵循最左原则。</p><p>如果查询中某个列的范围查询，则其右边所有列都无法使用索引优化查找。</p><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>在B-tree的基础上，为叶子节点增加链表指针，而且所有的关键字都在叶子节点中出现，且数据只存储在叶子节点中。非叶子节点的关键字仅作为叶子节点的索引。</p><h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h4><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><p>在MySQL中，只有Memory引擎显式支持哈希索引且支持非唯一哈希索引的。</p><p>哈希索引每个槽点编号是有序的。</p><p>哈希索引使用限制：</p><p>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</p><p>哈希索引并不是按照索引值顺序存储的，所以无法用于排序。</p><p>哈希索引也不支持部分索引列的匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</p><p>哈希索引支持等值比较查询，包括=、in()、&lt;=&gt;也不支持任何范围查询，例如WHERE price &gt; 100。</p><p>访问哈希索引的数据非常快，除非有很多哈希冲突。</p><p>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。</p><p>除了Memory引擎外，NDB集群引擎也支持唯一哈希索引，且在NDB集群引擎中作用非常特殊。</p><p>InnoDB引擎有一个特殊的功能叫“自适应哈希索引”。当InnoDB引擎注意到某些索引值被使用的非常频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型索引，它查找的是文本中的关键词，而不是直接比较索引中的值。适用于MATCH AGINST操作，而不是普通的WHERE条件操作。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li><p>索引大大减少了服务器需要扫描的数据量。</p></li><li><p>索引可以帮助服务器避免排序和临时表。</p></li><li><p>索引可以将随机IO变为顺序IO。</p></li></ul><h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。我们应该简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。</p><p>例如：<code>select actor_id from sakila.actor where actor_id + 1 = 4</code></p><h4 id="前缀索引和索引的选择性"><a href="#前缀索引和索引的选择性" class="headerlink" title="前缀索引和索引的选择性"></a>前缀索引和索引的选择性</h4><p>问题： 有时候需要索引很长的字符串，这会让索引变的大且慢。</p><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但会降低索引的选择性。</p><p>一般情况下对于Blob、text或者很长的varchar()类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p><p>前缀的基数应该接近于完整列的基数。</p><h4 id="多索引列"><a href="#多索引列" class="headerlink" title="多索引列"></a>多索引列</h4><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。</p><h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>多列索引的列顺序经典法则：当不需要考虑排序和分组时，将选择性最高的列放到索引最前列。大都情况下是适用的，也需要根据业务去考虑一些特殊情况。</p><p>需要考虑哪些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单纯的索引类型，而是一种数据存储方式。具体细节依赖其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p><p>当表有聚簇索引时，它的数据行实际存放在索引的叶子页中。术语“聚簇”标识数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>由于是存储引擎自己实现聚簇索引，因此不是每个引擎都支持聚簇索引。</p><p>叶子页包含了行的全部数据，但是节点页只包含了索引列。InnoDB将通过主键聚集数据，这也就是说图中的“被索引列”就是主键列。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/clusterindex.png?raw=true" alt="cluster-index"></p><p>注： 如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。</p><p>聚簇索引的优点：</p><ul><li><p>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘IO。</p></li><li><p>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引查找的要快。</p></li><li><p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p></li></ul><p>聚簇索引缺点：</p><ul><li><p>聚簇索引最大限度的提高了IO密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有什么优势了。</p></li><li><p>插入速度严重依赖插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用optimize table命令重新组织一下表。</p></li><li><p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被动更新的行移动到新的位置。</p></li><li><p>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</p></li><li><p>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</p></li><li><p>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</p></li><li><p>二级索引访问需要两次索引查找，而不是一次。二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找对应的行。对于InnoDB，自适应性哈希索引能够减少这样重复的工作。</p></li></ul><h4 id="InnoDB和MyISAM的数据分布对比"><a href="#InnoDB和MyISAM的数据分布对比" class="headerlink" title="InnoDB和MyISAM的数据分布对比"></a>InnoDB和MyISAM的数据分布对比</h4><p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table    layout_test&#123;</span><br><span class="line">col1 int not null,</span><br><span class="line">col2 int not null,</span><br><span class="line">primary key(col1),</span><br><span class="line">key(col2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设该表主键取值1-10000，按照随机顺序插入并使用OPTIMIZE TABLE命令做了优化。换句话说，数据在磁盘上的存储已经做到最优，但行的顺序是随机的。</p><p>列col2的值是从1-100的随机值，所以有很多重复的值。</p><p>MyISAM数据（非聚簇）分布：</p><p>MyISAM按照数据插入顺序存储在磁盘上。</p><p>在行的旁边显示行号，从0开始递增。因为行是定长的，所以MyISAM可以从表的开头跳过所需的字节找到需要的行。</p><p>这种分布方式容易创建索引。</p><p>数据分布：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/myisam.png?raw=true" alt="数据分布"></p><p>主键分布：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/myisamcol.png?raw=true" alt="表的主键"></p><p>col2列索引分布：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/myisamkey.png?raw=true" alt="col2列索引分布"></p><p>InnoDB数据（聚簇）分布：</p><p>InnoDB支持聚簇索引，所以使用非常不同的方式存储同样的数据。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/innodbkey.png?raw=true" alt="主键分布"></p><p>该图显示了整个表，而不是只有索引。在InnoDB中，聚簇索引就是表，所以不像MyISAM那样需要独立的存储。</p><p>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。</p><p>InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。利：减少了当出现行移动或者数据页分裂时二级索引的维护工作。弊：使用主键值当做指针会让二级索引占用更多的空间。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/innodb.png?raw=true" alt="索引分布"></p><p>上图显示了示例表col2的索引，每一个叶子节点都包含了索引列（col2）,紧接着是主键值（col1）。</p><p>该图展示了B-Tree的叶子节点结构，InnoDB的非叶子节点包含了索引列和一个指向下级节点的指针（下一级节点可以是非叶子节点，也可以是叶子节点）。这对聚簇索引和二级索引都适用。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/innodba.png?raw=true" alt="聚簇索引和非聚簇索引"></p><h4 id="InnoDB表中按主键顺序插入行"><a href="#InnoDB表中按主键顺序插入行" class="headerlink" title="InnoDB表中按主键顺序插入行"></a>InnoDB表中按主键顺序插入行</h4><p>如果正在使用InnoDB表并且并没有什么数据需要聚集，可以定义一个代理键作为主键，最简单的方法是使用AUTO_INCREMENT自增列。这样可以保证数据按顺序写入，对于根据主键做关联操作的性能也会更好。</p><p>最好避免随机（不连续且值分布范围非常大）聚簇索引，特别对IO密集型应用。从性能考虑，使用UUID作为聚簇索引，使得聚簇索引的插入变的完全随机，使得数据没有任何聚集特性。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/clustersort.png?raw=true" alt="聚簇索引插入顺序的索引值"></p><p>如上图所示，因为主键的值是顺序的，所以InnoDB把每一条纪律都存储在上一条纪律后面。当达到页的最大填充因子时，下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。</p><p>聚簇索引顺序插入缺点：</p><ul><li><p>对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用（主键引起间隙锁竞争）。</p></li><li><p>另一个热点是AUTO_INCREMENT锁机制，如果遇到这个问题，可以重新设计表或者应用，或者修改innodb_autoinc_lock_mode配置。</p></li></ul><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/clusternosort.png?raw=true" alt="非聚簇索引插入顺序的索引值"></p><p>非聚簇索引因为新行的主键值不一定比之前插入的大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找需要的位置—通常是已有数据的中间位置—并且分配空间。还会增加很多额外的工作，并导致数据分布不够优化。</p><p>非聚簇索引插入缺点：</p><ul><li><p>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这样会导致大量的随机IO。</p></li><li><p>因为写入是乱序的，InnoDB不得不频繁的做页分裂操作，以便新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</p></li><li><p>由于频繁的页分裂，页会变的稀疏并被不规则的填充，所以最终会有数据碎片。</p></li></ul><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>通常大家会根据查询的where条件来创建索引，不过这只是优化索引的一个方面。如果一个索引包含所有需要查询字段的值我们就称之为“覆盖索引”。</p><p>覆盖索引的优点：</p><ul><li><p>索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大的减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对IO密集型应用也有帮助，因为索引比数据更小，更容易全部放入内存中（MyISAM压缩索引以变得更小）。</p></li><li><p>因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多。（MyISAM和Percona XtraDB，甚至可以通过OPTIMIZE命令使得索引完全顺序排列，这样简单的范围查询能使用完全顺序的索引访问）</p></li><li><p>一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。</p></li><li><p>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</p></li></ul><p>不是所有的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree做索引覆盖。</p><p>当发起一个索引覆盖查询时，在Explain的Extra列可以看到“Using index”的信息（Extra列的Using index和type列的inxex搞混淆，其实两者我完全不同，type列标识查询访问数据方式，也称之为join type）。</p><p>索引覆盖查询可能还有很多陷阱可能导致无法实现优化。MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了WHERE条件中的字段，但不是整个查询涉及的字段。如果条件为假，MySQL5.5和更早版本也总是会回表获取数据行，尽管并不需要这一行且最终也会被过滤掉。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain select * from products where actor=&apos;scan carrey&apos; and title like &apos;%APOLLO%&apos; --这条语句使用的是Extra:using where</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有列，而没有任何索引覆盖了所有的列。MySQL存在另一个途径：WHERE条件中的列是有索引可以覆盖的，因此MySQL可以使用该索引找到对应的actor并检查title是否匹配，过滤之后再读取需要的数据行。</p></li><li><p>MySQL不能再索引中执行LIKE操作。这是底层存储引擎API的限制，MySQL5.5和更早版本中只允许在索引中做简单比较操作。MySQL能在索引中做最左前缀匹配的LIKE查询，存储引擎就无法比较匹配。MySQL服务器只能提取数据行的值而不是索引值来做比较。</p></li></ul><p>解决方案：</p><p>先将索引扩展至3个（artist，title，prod_id）,然后按照如下方式重写查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain select * from products join(select prob_id from products where actor=&apos;sean carrey&apos; and title like &apos;%APOLLO%&apos;) as t1 on(t1.prod_id=products.prod_id)</span><br></pre></td></tr></table></figure><p>Extra: using where;using index</p><p>我们把这种方式叫做延迟关联，因为延迟了对列的访问。在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id,然后根据这些prop_id值在外层查询匹配获取需要的所有列值。虽然无法使用索引覆盖整个查询，但总算比完全无法利用索引覆盖的好。</p><p>这样的优化效果取决于WHERE条件匹配返回的行数。举个例子：</p><p>假设products有100w行数据，我们使用上面两个SQL在不同的三个场景中测试。</p><ol><li><p>sean carrey 出演了3w部作品，2w部标题中包含Apollo。</p></li><li><p>sean carrey 出演了3w部作品，40部标题中包含Apollo。</p></li><li><p>sean carrey 出演了50部作品，10部标题中包含Apollo。</p></li></ol><p>测试结果：</p><table><br><br><tr><td>序号</td><td>原查询</td><td>优化后</td></tr><br><tr><td>1</td><td>5</td><td>5</td></tr><br><tr><td>2</td><td>7</td><td>35</td></tr><br><tr><td>3</td><td>2400</td><td>2000</td></tr><br><br></table><p>结果分析：</p><p>实例1中，查询返回了一个很大的结果集，因此看不到优化结果。大部分时间都花在读取和发送数据上了。</p><p>实例2中，经过索引过滤，尤其第二个条件过滤后只返回很少的结果集，优化效果很明显，优化查询的效率主要得益于只需要读取40行完整的数据行。</p><p>实例3中，显示了子查询效率反而下降的情况。因为索引过滤符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。</p><h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>MySQL有两种方式生成有序的结果：通过排序操作。按索引顺序扫描。</p><p>如果explain出来的type列的值为index，则说明MySQL使用索引扫描来做排序。</p><p>扫描索引本身是很快的，因为只需要从一条索引纪律移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不没扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机IO，因此按索引顺序读取数据的速度通常要比顺序的全表扫描慢，尤其是在IO密集型的工作负载时。</p><p>MySQL可以使用同一个索引既满足排序，又满足查找行。</p><p>只有当索引的列顺序和 order by子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一个表时，才能使用索引做排序。order by子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则MySQL都需执行排序操作，而无法利用索引排序。</p><p>有一种情况下 order by子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以弥补索引的不足。</p><p>例如：表rental在列(rental_date,inventory_id,customer_id)上有名为rental_date的索引。</p><p>建表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table rental(</span><br><span class="line">    primary key(rental_id),</span><br><span class="line">    unique key rental_date(rental_date,inventory_id,customer_id),</span><br><span class="line">    key idx_fk_inventory_id(inventory_id),</span><br><span class="line">    key idx_fk_customer(customer_id),</span><br><span class="line">    key idx_fk_staff_id(staff_id),</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查询排序：</p><p><code>explain select rental_id,staff_id from sakila.rental where rental_date=&#39;2005-05-25&#39; order by inventory_id, customer_id</code></p><p>即时order by 子句不满足索引的最左前缀的要求，也可以用于查询排序，这是因为索引的第一列被指定为一个常数。</p><p>下面这个查询可以利用索引排序，是因为查询为索引的第一列提供了常量条件，而使用第二列进行排序，将两列组合在一起，就形成了索引的最左前缀,总的来说只要查询满足最左前缀即可排序：</p><p><code>where rental_date=&#39;2005-05-05&#39; order by inventory_id desc</code></p><p>下面是一些不能使用索引做排序的查询：</p><ul><li><p>这个查询使用了两种不同的排序方向，但索引列都是正序排序的：</p><p><code>where rental_date =&#39;2005-05-25&#39; order by inventory_id desc,customer_id asc</code></p></li></ul><ul><li><p>这个查询的order by 子句中引用了一个不在索引中的列：</p><p><code>where rental_date =&#39;2005-05-25&#39; order by inventory_id,staff_id</code></p></li><li><p>这个查询的where和order by中的列无法组合成索引的最左前缀：</p><p><code>where rental_date =&#39;2005-05-25&#39; order by customer_id</code></p></li><li><p>这个查询在索引列的第一列上是范围条件，所以MySQL无法使用索引的其余列：</p></li></ul><p><code>where rental_date &gt; &#39;2005-05-25 order by ...</code> </p><ul><li>这个查询在inventory_id上有多个等于条件，对于排序来说，这也是一种范围查询：</li></ul><p><code>where rental_date=&#39;2015-05-25&#39; and inventory_id in(1,2) order by customer_id</code></p><p>下面这个例子理论上是可以使用索引进行关联排序的，但由于优化器在优化时将film_actor表当做关联的第二张表，所以实际上无法使用索引：</p><p><code>explain select actor_id,title from sakila.film_actor inner join sakila.film using(film_id) order by actor_id</code></p><p>使用索引排序做排序的一个重要的用法是当查询同时有order by和limit子句的时候。</p><h4 id="压缩索引"><a href="#压缩索引" class="headerlink" title="压缩索引"></a>压缩索引</h4><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入到内存中，这在某些情况下能极大的提高性能。默认只压缩字符串，但通过参数设置也可以对整数进行压缩。</p><p>MyISAM的压缩方法是：先完全保存索引块的第一个值，然后将其他值和第一个值进行比较得到相同的前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。</p><p>压缩块使用更少的时间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以无法使用二分查找而只能从头开始。正序快，倒序慢。</p><p>使用pack_keys来控制索引压缩的方式。</p><h4 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h4><p>MySQL允许在相同列上创建多个索引，并且需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个的进行考虑，影响性能。</p><p>重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。</p><p>错误示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table test(</span><br><span class="line"> id int not null primary key,</span><br><span class="line"> a int not null,</span><br><span class="line"> b int not null,</span><br><span class="line"> unique(id),</span><br><span class="line"> index(id)</span><br><span class="line">)engine=InnoDB;</span><br></pre></td></tr></table></figure><p>上面其实给id创建了3条索引，MySQL的唯一限制和主键限制都是通过索引实现的。</p><p>通常没有理由在同一列上创建多条索引，除非在同一列上创建不同类型的索引来满足查询需求。例如key（id）和fulltext key（id）就是两种类型的索引。</p><p>冗余和重复有些不同，如果创建了索引（A,B），再创建（A），则（A）就是冗余的。这种冗余只是对B-Tree来说的。另外，其他不同类型的索引（哈希索引或者全文索引）也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是什么。</p><p>冗余索引通常发生在为表添加新索引的时候。</p><p>大多数情况下都不需要冗余索引，应该尽量扩展已经有的索引而不是创建新索引。有时候出于性能问题也考虑冗余索引，因为扩展已有的索引会导致其变的太大，从而影响其他使用该索引的查询性能。</p><h4 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h4><p>除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。建议删除。</p><p>最简单有效的办法是在Percona Server或者MariaDB中先打开userstates服务器变量，然后让服务器正常运行一段时间，再通过查询Information_schema.index_statistics就能查到每个索引的使用频率。</p><p>还可以使用Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行explain操作，然后打印出关于索引和查询的报告。</p><h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p>索引可以让查询锁定更少的行。</p><p>优点：</p><ul><li><p>InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外的开销。</p></li><li><p>锁定超过需要的行会增加锁争用并减少并发性。</p></li></ul><p>InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问行数，从而减少锁的数量。只有当InnoDB在存储引擎层能够过滤所有不需要的行时才有效。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set autocommmit = 0;</span><br><span class="line">begin;</span><br><span class="line">select actor_id from sakila.actor where actor_id &lt; 5 and actor_id &lt;&gt; 1 for update;</span><br></pre></td></tr></table></figure><table><tr><td>actor_id</td></tr><tr><td>2</td></tr><tr><td>3</td></tr><tr><td>4</td></tr></table><p>这条查询仅仅会返回2-4行数据，但是实际上获取了1-4行之间的行的排它锁。锁住第一行是因为MySQL为该查询选择的执行计划是索引范围扫描：</p><table><br>    <tr><td>id</td><td>select_type</td><td>table</td><td>type</td><td>key</td><td>Extra</td></tr><br>    <tr><td>1</td><td>SIMPLE</td><td>actor</td><td>range</td><td>PRIMARY</td><td>Using where;Using index</td></tr><br><br></table><p>问题：如果不能使用索引查找和锁定行的话问题可能会更糟糕，MySQL会做全表扫描并锁住所有的行。</p><p>InnoDB在二级索引上使用共享锁，但访问主键索引需要排他锁。这消除了使用覆盖索引的可能性，并且使得<code>select for update</code> 比<code>lock in share mode</code>或非锁定查询要慢的多。</p><h3 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h3><h3 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h3><p>维护表有3个目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。</p><h4 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h4><p>表损坏（corruption）是件很糟糕的事情。对于MyISAM，表损坏通常是系统崩溃导致的。</p><p>损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时甚至还会导致数据库的崩溃。</p><p>修复：</p><ul><li><p>check table，能找出大多数表和索引错误。有些存储引擎不支持该命令。</p></li><li><p>repair table，和check类似。</p></li><li><p>alter table innodb_tbl engine=innodb，修改表的存储引擎为当前引擎重建表。</p></li><li><p>离线工具myisamchk</p></li><li><p>将数据导出在重新导入。</p></li><li><p>如果损坏的是行数据或者系统区域，以上办法无效。</p></li><li><p>如果损坏系统区域或者行数据，可以从备份中恢复表，或者尝试从损坏的数据文件中尽可能的恢复数据。</p></li></ul><p>如果InnoDB引擎的表出现损坏，那么一定是发生了严重的错误，需要立刻调查原因。具体细节可以查看MySQL手册。</p><h4 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h4><h4 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三个原则：</p><ul><li><p>单行访问时很慢的。最好读取块中能包含尽可能多的所需要的行。使用索引可以创建位置引用以提升效率。</p></li><li><p>按顺序访问范围数据是很快的，这有两个原因。第一、顺序IO不需要多次磁盘寻道，所以比随机IO快很多。第二、如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且group by查询也无需再做排序和将行按组进行聚合计算了。</p></li><li><p>索引覆盖查询是很快的。</p></li></ul><p>一般来说，我们建议按响应时间来对查询进行分析。</p><p>如果一个查询无法从所有可能的索引中获益，则应该看看是否可以创建一个更合适的索引来提升性能。</p><h2 id="剖析MySQL查询"><a href="#剖析MySQL查询" class="headerlink" title="剖析MySQL查询"></a>剖析MySQL查询</h2><p>对查询进行性能剖析有两种方式，每种方式都有各自的问题。</p><h3 id="剖析服务器负载"><a href="#剖析服务器负载" class="headerlink" title="剖析服务器负载"></a>剖析服务器负载</h3><p>服务器端可以有效的审计效率低下的查询。</p><h4 id="捕获MySQL的查询到日志文件中"><a href="#捕获MySQL的查询到日志文件中" class="headerlink" title="捕获MySQL的查询到日志文件中"></a>捕获MySQL的查询到日志文件中</h4><p>慢查询日志是一种轻量而且功能全面的性能剖析工具，是优化服务器查询的利器。可以通过修改针对每个链接的long_query_time的阈值来捕获所以的查询。</p><p>通用日志在查询请求到服务器时进行记录，所以不包含响应时间和执行计划等重要信息。日志信息记录到数据库表中。</p><h4 id="分析查询日志"><a href="#分析查询日志" class="headerlink" title="分析查询日志"></a>分析查询日志</h4><p>工具：pt-query-digest</p><p>剖析报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest1.png?raw=true" alt="查询日志"></p><p>详细报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest2.png?raw=true" alt="详细查询日志"></p><h3 id="剖析单条查询"><a href="#剖析单条查询" class="headerlink" title="剖析单条查询"></a>剖析单条查询</h3><h4 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h4><p>show profile命令是在5.1版本之后引入的，默认是禁用的，可以通过<code>set profiling=1</code>动态的修改。这个功能有一定的作用，将来能会被Performance Schema所取代。</p><p>下面是对一个视图的剖析结果：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling1.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling2.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling3.png?raw=true" alt="详细查询日志"></p><p>剖析报告给出查询执行每个步骤花费的时间，看结果无法快速确定哪个步骤花费时间最多，因为输出是按照执行顺序排序，而不是花费的时间排序的。如果不使用show profile命令。还可以直接查询information_schema中对应的表，按照格式化输出。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/information_schema.png?raw=true" alt="详细查询日志"></p><p>效果比看show profile输出的结果好很多，可以很直观的看到哪些步骤花费时长较长。</p><h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="查询慢的原因"><a href="#查询慢的原因" class="headerlink" title="查询慢的原因"></a>查询慢的原因</h3><p>查询最重要的是响应时间，如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行更快。</p><p>MySQL执行查询的时候，查询需要在不同的地方花费时间，如网络、cpu、生成统计信息和执行计划、锁等待等。在每一个消耗大量时间的查询案例中，我们都能看到一些不必要的额外操作、某些操作被额外的执行了很多次、某些操作执行的太慢等。</p><p>优化查询的目的就是减少和消除这些操作所花费的时间。</p><h3 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h3><p>查询性能低下最基本的原因是访问的数据太多。某些查询不可避免的需要筛选大量数据，大部分查询都可以通过减少访问的数据量的方式进行优化。对于低效查询可以分为两个步骤分析：</p><ul><li><p>1.确认应用程序是否检索大量超过需要的数据。如访问过多的行或者列。</p></li><li><p>2.确定MySQL服务器层是否在分析大量超过需要的数据行。</p></li></ul><h4 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h4><ul><li><p>查询不需要的记录</p></li><li><p>多表关联返回全部的列</p></li><li><p>总是取出全部的列</p></li><li><p>重复查询相同的数据</p></li></ul><h4 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h4><p>在确定查询只返回需要的数据以后，最简单的衡量查询开销的三个指标如下：</p><ul><li><p>响应时间</p></li><li><p>扫描的行数</p></li><li><p>返回的行数</p></li></ul><p>响应时间：响应时间只是一个表面上的值。响应时间是服务时间和排队时间。服务时间指数据库处理这个时间花费的时间。排队时间指服务器因为等待某些资源而没有真正执行查询的时间。</p><p>快速上限估计：了解查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以在具体硬件条件下一次IO的消耗时间。</p><p>扫描的行数和返回的行数： 分析查询时，查看扫描的行数一定程度上可以反映出该查询找到需要的数据的效率高不高。</p><p>扫描的行数和访问类型：在explain语句中的type列反映了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。从慢到快，扫描的行数从小到大。</p><p>如果查询没有找到合适的访问类型，那么解决的最好办法通常是增加一个合适的索引。</p><p>例如：</p><p><code>select * from sakila.film_actor where film_id = 1;</code></p><p>这个查询返回10行数据，从explain的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/ref.png?raw=true" alt="详细查询日志"></p><p>explain的结果也显示MySQL预估需要访问10行数据。查询优化器认为这种访问类型可以高效的完成查询。如果我们删除索引再来运行：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/where.png?raw=true" alt="详细查询日志"></p><p>正如我们预料的，查询变成全表扫描，MySQL预估会扫描5073条记录来完成查询。</p><p>一般MySQL使用如下三种方式应用WHERE条件，从好到坏依次是：</p><ul><li><p>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</p></li><li><p>使用索引覆盖扫描（Extra:using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录。</p></li><li><p>从数据表中返回数据（Extra:using where），然后过滤不满足条件的记录。这是在服务器层完成的，MySQL需要从数据表中读出来然后再进行过滤。</p></li></ul><p>虽然例子说明了好的索引多么重要，但是也不是说增加了索引就能让扫描的行数等于返回的行数。例如使用聚合函数的查询：</p><p><code>select actor_id,count(*) from sakila.film_actor group by actor_id</code></p><p>这个例子没有什么索引能够让这样的查询减少需要扫描的行数。</p><p>通常如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试使用下面的技巧去优化：</p><ul><li><p>使用覆盖索引扫描，把所有需要的列放到索引中，这样存储引擎无需回表获取对应行就可以返回结果了。</p></li><li><p>改变库表结构。例如使用单独的汇总表。</p></li><li><p>重写复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</p></li></ul><h3 id="重构查询的方式非锁"><a href="#重构查询的方式非锁" class="headerlink" title="重构查询的方式非锁"></a>重构查询的方式非锁</h3><h4 id="一个复杂的查询还是多个简单的查询"><a href="#一个复杂的查询还是多个简单的查询" class="headerlink" title="一个复杂的查询还是多个简单的查询"></a>一个复杂的查询还是多个简单的查询</h4><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><p>将大查询分为小查询，每个查询功能完全一样，只完成一小部分，每次返回一小部分查询结果。删除旧数据就是一个很好的例子</p><h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><p>对每一个表进行一次单表查询，然后将结果在应用程序中关联。</p><p>分解关联查询的优点：</p><ul><li><p>让缓存效率跟高。</p></li><li><p>执行单个查询可以减少锁的竞争。</p></li><li><p>做应用层关联，可以更好的对数据库拆分，更容易做到，高性能可扩展。</p></li><li><p>查询效率本身效率也可能会有所提升。</p></li><li><p>可以减少冗余记录的查询。</p></li><li><p>这样做相当于在应用中实现了哈希关联而不是MySQL的嵌套循环关联。</p></li></ul><h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><p>查询执行路径：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/process.png?raw=true" alt="查询执行路径"></p><h3 id="MySQL查询优化器的局限性"><a href="#MySQL查询优化器的局限性" class="headerlink" title="MySQL查询优化器的局限性"></a>MySQL查询优化器的局限性</h3><h3 id="查询优化器的提示"><a href="#查询优化器的提示" class="headerlink" title="查询优化器的提示"></a>查询优化器的提示</h3><h3 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h3><h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><h2 id="MySQL的高级特性"><a href="#MySQL的高级特性" class="headerlink" title="MySQL的高级特性"></a>MySQL的高级特性</h2><ul><li><p>分区表</p></li><li><p>视图</p></li><li><p>外键约束</p></li><li><p>MySQL内部存储代码</p></li><li><p>游标</p></li><li><p>绑定变量</p></li><li><p>用户自定义函数</p></li><li><p>插件</p></li><li><p>字符集和校对</p></li><li><p>全文索引</p></li><li><p>分布式（XA）事务</p></li><li><p>查询缓存</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL优化</title>
      <link href="/zhongyp.github.io/mysql/2018-04-02-sql/"/>
      <url>/zhongyp.github.io/mysql/2018-04-02-sql/</url>
      
        <content type="html"><![CDATA[<h2 id="常用SQL技巧"><a href="#常用SQL技巧" class="headerlink" title="常用SQL技巧"></a>常用SQL技巧</h2><h3 id="1-1-检索包含最大和最小值的行"><a href="#1-1-检索包含最大和最小值的行" class="headerlink" title="1.1 检索包含最大和最小值的行"></a>1.1 检索包含最大和最小值的行</h3><p><code>select max(test_score),min(test_score) from student</code></p><h3 id="1-2-巧用rand-rand-n-提取随机行"><a href="#1-2-巧用rand-rand-n-提取随机行" class="headerlink" title="1.2 巧用rand()/rand(n)提取随机行"></a>1.2 巧用rand()/rand(n)提取随机行</h3><p><code>select * from table order by rand()</code></p><h3 id="1-3-group-by的with-rollup子句做统计"><a href="#1-3-group-by的with-rollup子句做统计" class="headerlink" title="1.3 group by的with rollup子句做统计"></a>1.3 group by的with rollup子句做统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table sales(</span><br><span class="line"></span><br><span class="line">year int not null,</span><br><span class="line">country varchar(20) not null,</span><br><span class="line">product varchar(32) not null,</span><br><span class="line">profit int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2001);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2002);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2003);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2004);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2005);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2006);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2007);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2008);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2009);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2010);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2011);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2012);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year;</span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year with rollup;</span><br></pre></td></tr></table></figure><p>当你使用ROLLUP时, 你不能同时使用ORDER BY子句进行结果排序。换言之， ROLLUP和ORDER BY 是互相排斥的LIMIT 用在ROLLUP 后面。</p><h3 id="1-4-bit-group-functions做统计"><a href="#1-4-bit-group-functions做统计" class="headerlink" title="1.4 bit group functions做统计"></a>1.4 bit group functions做统计</h3><p>bit_count:用来计算二进制数中包含1的个数</p><p>bit_or:就是对两个二进制数进行或运算</p><p>bit_and:就是对两个二进制数进行并运算</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="通过show-status和应用特点了解各种SQL的执行频率。"><a href="#通过show-status和应用特点了解各种SQL的执行频率。" class="headerlink" title="通过show status和应用特点了解各种SQL的执行频率。"></a>通过show status和应用特点了解各种SQL的执行频率。</h3><p>首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)</p><p>show status</p><p>常用的:</p><p>show status like ‘uptime’ ; </p><p>show stauts like ‘com_select’  show status like ‘com_insert’ …类推 update  delete</p><p>show session或global status like …. 如果你不写session或global,默认是session 会话，指取出当前窗口的执行，如果你想看所有session,从mysql 启动到现在，则应该 global。</p><p>show status like ‘connections’; </p><p>//显示慢查询次数</p><p>show status like ‘slow_queries’;</p><p>以下几个参数对Myisam 和Innodb 存储引擎都计数：</p><ol><li><p>Com_select 执行select 操作的次数，一次查询只累加1；</p></li><li><p>Com_insert 执行insert 操作的次数，对于批量插入的insert 操作，只累加一次；</p></li><li><p>Com_update 执行update 操作的次数；</p></li><li><p>Com_delete 执行delete 操作的次数；</p></li></ol><p>以下几个参数是针对Innodb 存储引擎计数的，累加的算法也略有不同：</p><ol><li><p>Innodb_rows_read select 查询返回的行数；</p></li><li><p>Innodb_rows_inserted 执行Insert 操作插入的行数；</p></li><li><p>Innodb_rows_updated 执行update 操作更新的行数；</p></li><li><p>Innodb_rows_deleted 执行delete 操作删除的行数；</p></li></ol><p>对于事务型的应用，通过Com_commit 和Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。</p><p>此外，以下几个参数便于我们了解数据库的基本情况：</p><ol><li><p>Connections 试图连接Mysql 服务器的次数</p></li><li><p>Uptime 服务器工作时间</p></li><li><p>Slow_queries 慢查询的次数</p></li></ol><h3 id="定位执行效率较低的SQL"><a href="#定位执行效率较低的SQL" class="headerlink" title="定位执行效率较低的SQL"></a>定位执行效率较低的SQL</h3><p>可以通过以下两种方式定位执行效率较低的SQL 语句：</p><ol><li><p>可以通过慢查询日志定位那些执行效率较低的sql 语句，用–log-slowqueries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过long_query_time 秒的SQL语句的日志文件。可以链接到管理维护中的相关章节。</p></li><li><p>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist 命令查看当前MySQL 在进行的线程，包括线程的状态，是否锁表等等，可以实时的查看SQL 执行情况，同时对一些锁表操作进行优化。</p></li></ol><h3 id="通过explain分析低效SQL的执行计划"><a href="#通过explain分析低效SQL的执行计划" class="headerlink" title="通过explain分析低效SQL的执行计划"></a>通过explain分析低效SQL的执行计划</h3><h4 id="select-type：-select-类型"><a href="#select-type：-select-类型" class="headerlink" title="select_type： select 类型"></a>select_type： select 类型</h4><p>A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个</p><p>B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</p><p>C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union</p><p>D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响</p><p>E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</p><p>F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</p><p>G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</p><p>H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</p><h4 id="table：-输出结果集的表"><a href="#table：-输出结果集的表" class="headerlink" title="table： 输出结果集的表"></a>table： 输出结果集的表</h4><p>显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的<derived n="">就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的<union m,n="">，与<derived n="">类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</derived></union></derived></p><h4 id="type：-表示表的连接类型"><a href="#type：-表示表的连接类型" class="headerlink" title="type： 表示表的连接类型"></a>type： 表示表的连接类型</h4><p>当表中仅有一行是type的值为system是最佳的连接类型；</p><p>当select操作中使用索引进行表连接时type的值为ref；</p><p>当select的表连接没有使用索引时，经常会看到type的值为ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。</p><p>依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</p><p>A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p><p>B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</p><p>C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</p><p>D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</p><p>E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p><p>F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</p><p>G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</p><p>H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p><p>I：range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</p><p>J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</p><p>K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p><p>L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p><h4 id="possible-keys：-表示查询时-可以使用的索引列"><a href="#possible-keys：-表示查询时-可以使用的索引列" class="headerlink" title="possible_keys： 表示查询时,可以使用的索引列."></a>possible_keys： 表示查询时,可以使用的索引列.</h4><h4 id="key：-表示使用的索引"><a href="#key：-表示使用的索引" class="headerlink" title="key： 表示使用的索引"></a>key： 表示使用的索引</h4><h4 id="key-len：-索引长度"><a href="#key-len：-索引长度" class="headerlink" title="key_len： 索引长度"></a>key_len： 索引长度</h4><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p><h4 id="rows：-扫描范围"><a href="#rows：-扫描范围" class="headerlink" title="rows： 扫描范围"></a>rows： 扫描范围</h4><h4 id="Extra：-执行情况的说明和描述"><a href="#Extra：-执行情况的说明和描述" class="headerlink" title="Extra： 执行情况的说明和描述"></a>Extra： 执行情况的说明和描述</h4><p>A：distinct：在select部分使用了distinc关键字</p><p>B：no tables used：不带from字句的查询或者From dual查询</p><p>C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</p><p>D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</p><p>E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p><p>F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。</p><p>G：using sort_union，using_union，using intersect，using sort_intersection：</p><p>using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集</p><p>using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集</p><p>using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。</p><p>H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</p><p>I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition</p><p>J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个</p><p>K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p><p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息</p><h3 id="确定问题并采取响应的优化措施"><a href="#确定问题并采取响应的优化措施" class="headerlink" title="确定问题并采取响应的优化措施"></a>确定问题并采取响应的优化措施</h3><h3 id="索引的存储分类"><a href="#索引的存储分类" class="headerlink" title="索引的存储分类"></a>索引的存储分类</h3><p>myisam 表的数据文件和索引文件是自动分开的；innodb 的数据和索引是存储在<br>同一个表空间里面，但可以有多个文件组成。<br>创建索引语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</span><br><span class="line">[USING index_type]</span><br><span class="line">ON tbl_name (index_col_name,...)</span><br><span class="line">index_col_name:</span><br><span class="line">col_name [(length)] [ASC | DESC]</span><br></pre></td></tr></table></figure><p>索引的存储类型目前只有两种（btree 和hash），具体和表的模式相关：</p><p>myisam btree</p><p>innodb btree</p><p>memory/heap hash，btree</p><p>mysql 目前不支持函数索引，只能对列的前一部分（length）进行索引，例：</p><p><code>create index ind_test on table1(name(5))</code></p><p>对于char 和varchar 列，使用前缀索引将大大节省空间。</p><h3 id="MySQL如何使用索引"><a href="#MySQL如何使用索引" class="headerlink" title="MySQL如何使用索引"></a>MySQL如何使用索引</h3><p>索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高SELECT 操作性能的最佳途径。</p><p>查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。</p><p>下列情况下，Mysql 不会使用已有的索引：</p><p>1.如果mysql 估计使用索引比全表扫描更慢，则不使用索引。例如：如果key_part1均匀分布在1 和100 之间，下列查询中使用索引就不是很好：</p><p><code>SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90</code></p><p>2.如果使用heap 表并且where 条件中不用＝索引列，其他&gt; 、&lt;、&gt;=、&lt;=均不使用索引；</p><p>3.如果不是索引列的第一部分；</p><p>4.如果like 是以％开始；</p><p>5.对where 后边条件为字符串的一定要加引号，字符串如果为数字mysql 会自动转为字符串，但是不使用索引。</p><h3 id="查看索引的使用情况"><a href="#查看索引的使用情况" class="headerlink" title="查看索引的使用情况"></a>查看索引的使用情况</h3><p>如果索引正在工作，Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。</p><p>Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明表索引不正确或写入的查询没有利用索引。</p><p><code>show status like &#39;Handler_read%&#39;;</code></p><h3 id="定期分析表"><a href="#定期分析表" class="headerlink" title="定期分析表"></a>定期分析表</h3><h4 id="ANALYZE-TABLE"><a href="#ANALYZE-TABLE" class="headerlink" title="ANALYZE TABLE"></a>ANALYZE TABLE</h4><p>语法：</p><p><code>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM, BDB 和InnoDB 表有作用。对于MyISAM 表，本语句与使用myisamchk -a 相当。</p><h4 id="CHECK-TABLE"><a href="#CHECK-TABLE" class="headerlink" title="CHECK TABLE"></a>CHECK TABLE</h4><p>语法：</p><p><code>CHECK TABLE tbl_name [, tbl_name] ... [option] ...</code></p><p><code>option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}</code></p><p>检查一个或多个表是否有错误。CHECK TABLE 对MyISAM 和InnoDB 表有作用。对于MyISAM 表，关键字统计数据被更新。</p><p>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。</p><h4 id="CHECKSUM-TABLE"><a href="#CHECKSUM-TABLE" class="headerlink" title="CHECKSUM TABLE"></a>CHECKSUM TABLE</h4><p>语法：</p><p><code>CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]</code></p><p>报告一个表校验和。</p><h3 id="使用optimize-table"><a href="#使用optimize-table" class="headerlink" title="使用optimize table"></a>使用optimize table</h3><h4 id="OPTIMIZE-TABLE"><a href="#OPTIMIZE-TABLE" class="headerlink" title="OPTIMIZE TABLE"></a>OPTIMIZE TABLE</h4><p>语法：</p><p><code>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>如果已经删除了表的一大部分，或者如果您已经对含有可变长度行的表（含有VARCHAR, BLOB 或TEXT 列的表）进行了很多更改，则应使用OPTIMIZE TABLE。被删除的记录被保持在链接清单中，后续的INSERT 操作会重新使用旧的记录位置。您可以使用OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。</p><p>OPTIMIZE TABLE 只对MyISAM, BDB 和InnoDB 表起作用。</p><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><h4 id="对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。"><a href="#对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。" class="headerlink" title="对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。"></a>对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tblname DISABLE KEYS;</span><br><span class="line">loading the data</span><br><span class="line">ALTER TABLE tblname ENABLE KEYS;</span><br></pre></td></tr></table></figure><p>这两个命令用来打开或者关闭Myisam 表非唯一索引的更新。在导入大量的数据到一个非空的Myisam 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的Myisam 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。</p><h4 id="而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率："><a href="#而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率：" class="headerlink" title="而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率："></a>而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率：</h4><p>a. 因为Innodb 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果Innodb 表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。</p><p>b. 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SETUNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p><p>c. 如果应用使用自动提交的方式，建议在导入前执行SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p><h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><p>如果你同时从同一客户插入很多行，使用多个值表的INSERT 语句。这比使用分开INSERT 语句快(在一些情况中几倍)。</p><p><code>Insert into test values(1,2),(1,3),(1,4)…</code></p><p>如果你从不同客户插入很多行，能通过使用INSERT DELAYED 语句得到更高的速度。Delayed 的含义是让insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘；这比每条语句分别插入要快的多；LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完后才进行插入。</p><p><code>Insert delayed into test values(1,2),(1,3),(1,4)…</code></p><p><code>Insert low_priority into test values(1,2),(1,3),(1,4)…</code></p><p>将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）。</p><p>如果进行批量插入，可以增加bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对myisam 表使用。</p><p>在my.cnf中添加如下语句，将insert语句的长度设为最大。</p><p><code>Max_allowed_packet=1M</code></p><p><code>Net_buffer_length=2k</code></p><p>当从一个文本文件装载一个表时，使用LOAD DATA INFILE。这通常比使用很多INSERT 语句快20 倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//数据</span><br><span class="line"></span><br><span class="line">1669,Jim,Smith</span><br><span class="line">337,Mary,Jones</span><br><span class="line">2005,Linda,Black</span><br><span class="line"></span><br><span class="line">示例语句：</span><br><span class="line"></span><br><span class="line">load data infile &quot;/data/mysql/e.sql&quot; into table tablename fields terminated by &apos;,&apos;;</span><br></pre></td></tr></table></figure><p>根据应用情况使用replace 语句代替insert。<code>replace low_priority into ta values(1,2);</code><br>replace具备替换拥有唯一索引或者主键索引重复数据的能力，也就是如果使用replaceinto插入的数据的唯一索引或者主键索引与之前的数据有重复的情况，将会删除原先的数据，然后再进行添加。</p><p>根据应用情况使用ignore 关键字忽略重复记录。<br><code>insert ignore into</code><br>当插入数据时，如出现错误时，如重复数据，将不返回错误，只以警告形式返回。所以使用ignore请确保语句本身没有问题，否则也会被忽略掉。例如：<code>INSERT IGNORE INTO books (name) VALUES (&#39;MySQL Manual&#39;)</code></p><h3 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h3><p>默认情况下，MySQL 排序所有GROUP BY col1，col2，….。查询的方法如同在查询中指定ORDER BY col1，col2，…。如果显式包括一个包含相同的列的ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。</p><p>如果查询包括GROUP BY 但你想要避免排序结果的消耗，你可以指定ORDER BY NULL禁止排序。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO foo</span><br><span class="line">SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;</span><br></pre></td></tr></table></figure><h3 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h3><p>在某些情况中，MySQL 可以使用一个索引来满足ORDER BY 子句，而不需要额外的排序。where 条件和order by 使用相同的索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或者都是降序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如：下列sql 可以使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1,key_part2,... ;</span><br><span class="line">SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2</span><br><span class="line">DESC;</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</span><br><span class="line">但是以下情况不使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;</span><br><span class="line">--order by 的字段混合ASC 和DESC</span><br><span class="line">SELECT * FROM t1 WHERE key2=constant ORDER BY key1;</span><br><span class="line">--用于查询行的关键字与ORDER BY 中所使用的不相同</span><br><span class="line">SELECT * FROM t1 ORDER BY key1, key2;</span><br><span class="line">--对不同的关键字使用ORDER BY。</span><br></pre></td></tr></table></figure><h3 id="优化join语句"><a href="#优化join语句" class="headerlink" title="优化join语句"></a>优化join语句</h3><p>Mysql4.1 开始支持SQL 的子查询。这个技术可以使用SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。</p><p>假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><p><code>SELECT * FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerIDFROM salesinfo)</code></p><p>如果使用连接(JOIN).. 来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID 建有索引的话，性能将会更好，查询如下：</p><p><code>SELECT * FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL</code></p><p>连接(JOIN).. 之所以更有效率一些，是因为MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h3 id="mysql如何优化or条件"><a href="#mysql如何优化or条件" class="headerlink" title="mysql如何优化or条件"></a>mysql如何优化or条件</h3><p>对于or 子句，如果要利用索引，则or 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。</p><h3 id="查询优先还是更新优先"><a href="#查询优先还是更新优先" class="headerlink" title="查询优先还是更新优先"></a>查询优先还是更新优先</h3><p>MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。</p><p>我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。</p><p>下面我们提到的改变调度策略的方法主要是针对Myisam 存储引擎的，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。</p><p>MySQL 的默认的调度策略可用总结如下：</p><ol><li><p>写入操作优先于读取操作。</p></li><li><p>对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。</p></li><li><p>对某张数据表的多个读取操作可以同时地进行。</p></li></ol><p>MySQL 提供了几个语句调节符，允许你修改它的调度策略：</p><ol><li><p>LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE。</p></li><li><p>HIGH_PRIORITY关键字应用于SELECT和INSERT语句。</p></li><li><p>DELAYED关键字应用于INSERT和REPLACE语句。</p></li></ol><p>如果写入操作是一个LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在LOW_PRIORITY 写入操作永远被阻塞的情况。</p><p>SELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的SELECT 在正常的SELECT 语句之前执行，因为这些语句会被写入操作阻塞。</p><p>如果你希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么请使用–low-priority-updates 选项来启动服务器。通过使用INSERT HIGH_PRIORITY 来把INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT 语句的影响。</p><h3 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h3><p><code>SELECT SQL_BUFFER_RESULTS ...</code></p><p>将强制MySQL 生成一个临时结果集。只要所有临时结果集生成后，所有表上的锁定均被释放。这能在遇到表锁定问题时或要花很长时间将结果传给客户端时有所帮助。</p><p>当处理一个会让客户端耗费点时间才能处理的大结果集时， 可以考虑使用SQL_BUFFER_RESULT 提示字。这样可以告诉MySQL 将结果集保存在一个临时表中，这样可以尽早的释放各种锁。</p><h4 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h4><p>在你查询语句中表名的后面，添加USE INDEX 来提供你希望MySQ 去参考的索引列表，就可以让MySQL 不再考虑其他可用的索引。</p><p><code>Eg:SELECT * FROM mytable USE INDEX (mod_time, name) ...</code></p><h4 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h4><p>如果你只是单纯的想让MySQL 忽略一个或者多个索引，可以使用IGNORE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytale IGNORE INDEX (priority) ...</code></p><h4 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h4><p>为强制MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytable FORCE INDEX (mod_time) ...</code></p><h3 id="其他优化措施"><a href="#其他优化措施" class="headerlink" title="其他优化措施"></a>其他优化措施</h3><ol><li><p>使用持久的连接数据库以避免连接开销。</p></li><li><p>经常检查所有查询确实使用了必要的索引。</p></li><li><p>避免在频繁更新的表上执行复杂的SELECT 查询，以避免与锁定表有关的由于读、写冲突发生的问题。</p></li><li><p>对于没有删除的行操作的MyISAM 表，插入操作和查询操作可以并行进行，因为没有删除操作的表查询期间不会阻塞插入操作．对于确实需要执行删除操作的表，尽量在空闲时间进行批量删除操作，避免阻塞其他操作。</p></li><li><p>充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少MySQL 需要做的语法分析从而提高插入速度。</p></li><li><p>对经常访问的可以重构的数据使用内存表，可以显著提高访问的效率。</p></li><li><p>通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份期间对应用的影响，可以在复制服务器上执行备份操作。</p></li><li><p>表的字段尽量不使用自增长变量，在高并发情况下该字段的自增可能对效率有比较大的影响，推荐通过应用来实现字段的自增长。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM</title>
      <link href="/zhongyp.github.io/jvm/2018-03-27-jvm/"/>
      <url>/zhongyp.github.io/jvm/2018-03-27-jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JVM的自动内存管理机制"><a href="#1-JVM的自动内存管理机制" class="headerlink" title="1. JVM的自动内存管理机制"></a>1. JVM的自动内存管理机制</h2><h3 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h3><p><img src="/media/article/jvm-1.7-later.png" alt="jvm 1.7"></p><h4 id="1-1-1-程序计数器（PC-Register）"><a href="#1-1-1-程序计数器（PC-Register）" class="headerlink" title="1.1.1 程序计数器（PC Register）"></a>1.1.1 程序计数器（PC Register）</h4><ul><li>当前线程所执行字节码的行号指示器，字节码解释器的作用是通过改变计数器的值来选取下一条需要执行的字节码指令。</li><li>如果当前执行的是Native方法，则这个计数器为空。</li><li>Java虚拟机中<strong><em>唯一</em></strong>没有OOM的区域。</li></ul><h4 id="1-1-2-Java虚拟机栈-（JVM-Stack）"><a href="#1-1-2-Java虚拟机栈-（JVM-Stack）" class="headerlink" title="1.1.2 Java虚拟机栈 （JVM Stack）"></a>1.1.2 Java虚拟机栈 （JVM Stack）</h4><ul><li>虚拟机栈描述的是Java方法执行的内存模型，生命周期与线程相同。</li><li><strong><em>每个方法运行都会创建一个栈帧</em></strong>，存储局部变量表(Local Variable Table)，操作栈(Operation Stack)，方法出口等信息。</li><li><strong><em>在编译期分配</em></strong>局部变量表存放各种基本数据类型、对象引用类型和returnAddress(指向一条字节码指令的地址)。</li><li>如果请求的栈深度大于最大可用栈深度时，系统就会抛出StackOverflowError错误。</li><li>如果虚拟机动态扩展无法申请到足够的的内存时会抛出OOM异常。大部分虚拟机都可以动态扩展，当然也允许固定长度虚拟机栈。</li></ul><h4 id="1-1-3-本地方法栈（Native-Method-Stack）"><a href="#1-1-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="1.1.3 本地方法栈（Native Method Stack）"></a>1.1.3 本地方法栈（Native Method Stack）</h4><ul><li>虚拟机栈为执行Java方法服务，本地方法栈为Native方法服务。</li><li>会出现OOM或者StackOverflowError，原因和虚拟机栈类似。</li></ul><h4 id="1-1-4-Java堆（Heap）"><a href="#1-1-4-Java堆（Heap）" class="headerlink" title="1.1.4 Java堆（Heap）"></a>1.1.4 Java堆（Heap）</h4><ul><li>虚拟机启动时创建被所有线程共享的内存区域，为了存储所有对象实例和数组。垃圾回收的主要区域。</li></ul><h4 id="1-1-5-方法区（Method-Area）"><a href="#1-1-5-方法区（Method-Area）" class="headerlink" title="1.1.5 方法区（Method Area）"></a>1.1.5 方法区（Method Area）</h4><ul><li>别名：“永久代“、”非堆，各个线程共享的内存区域，<strong><em>存储虚拟机已加载的类信息，静态变量、常量、即时编译器编译后的代码数据</em></strong>。默认最小为16MB，最大为64MB，可以通过-XX:PermSize和-XX:MaxPermSize 参数限制方法区大小。</li><li>Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做元空间。</li></ul><h4 id="1-1-6-运行时常量池（Runtime-Constant-Pool）"><a href="#1-1-6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="1.1.6 运行时常量池（Runtime Constant Pool）"></a>1.1.6 运行时常量池（Runtime Constant Pool）</h4><ul><li>运行时常量池：jdk1.6及之前是方法区的一部分，其中的主要内容来自于JVM对Class的加载。Java7中已经将运行时常量池从方法区（永久代）移除，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。</li><li><strong><em>类加载后</em></strong>存储编译器生成的常量（各种字面量和符号引用）。基本数据类型不叫常量，可被修改，String和final修饰的才是。字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名、字段名称和描述符、方法名称和描述符。</li><li>由于运行时常量池从方法区移动到堆，所以jdk1.6和jdk1.7对于常量池的使用还是有些区别的，<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern</a></li></ul><h4 id="1-1-7-直接内存-Direct-Memory"><a href="#1-1-7-直接内存-Direct-Memory" class="headerlink" title="1.1.7 直接内存(Direct Memory)"></a>1.1.7 直接内存(Direct Memory)</h4><ul><li>堆外内存，JVM虚拟机各个区域内存总和大于机器物理内存可能会导致OOM。</li></ul><h3 id="1-2-对象状态算法"><a href="#1-2-对象状态算法" class="headerlink" title="1.2 对象状态算法"></a>1.2 对象状态算法</h3><ul><li><p>引用计数算法： 很难解决对象之间相互引用的问题，内存泄露。</p></li><li><p>跟搜索算法：通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索的路径成为引用链，当一个对象到GC Root没有一个引用时，则证明此对象是不可用的。</p></li></ul><p>注：1. GC对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI。2. 跟搜索算法中，没有引用的对象并非非死不可，还有经历两次标记，第一次发现没有引用，则进行标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或finalize()已经被调用过，虚拟机将这两种情况都视为没有必要执行。</p><h4 id="1-2-1-回收方法区"><a href="#1-2-1-回收方法区" class="headerlink" title="1.2.1 回收方法区"></a>1.2.1 回收方法区</h4><p>方法区主要回收废弃变量和无用的类。无用的类：该类所有实例都已被回收，加载该类的ClassLoader被回收，该类对应的java.lang.Class对象没有在任何地方被引用。只有同时满足无用的类的三个条件，才<strong><em>可以</em></strong>被回收。反射、动态代理、CGLib等bytecode框架场景以及频繁定义ClassLoader的场景都需要具备卸载功能，以保证永久代不会溢出。</p><h3 id="1-3-垃圾收集算法"><a href="#1-3-垃圾收集算法" class="headerlink" title="1.3 垃圾收集算法"></a>1.3 垃圾收集算法</h3><ul><li><p>标记清除算法： 标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。效率问题，空间问题（内存碎片）。</p></li><li><p>复制算法： 新生代使用复制算法回收，由于新生代98%的对象都是朝生夕死的，所以不需要1:1的比例划分内存空间（Hotspot默认8:1），而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一个Survivor。当回收时，将Eden和Survivor中还存活的对象一次性的拷贝到另一块的Survivor上。最后清理掉Eden和刚才使用过的Survivor。当Survivor空间不够用时，需要依赖其他的老年代进行分配担保（Handle Promotion）。分配担保：如果Survivor空间没有足够的空间存放上次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p></li><li><p>标记-整理算法：让所有存活的对象向一端移动，然后清理掉端边界以外的内存。老年代常用的算法。</p></li><li><p>分代收集算法： 根据对象的存活周期不同，将内存划分为几块，根据各个年代的特点进行垃圾回收。</p></li></ul><h3 id="1-4-垃圾收集器"><a href="#1-4-垃圾收集器" class="headerlink" title="1.4 垃圾收集器"></a>1.4 垃圾收集器</h3><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/gc.jpg?raw=true" alt="垃圾回收器"><br><a href="#垃圾收集器">图片来自《深入理解Java虚拟机》</a><br>如果两个收集器之间存在连线，就说明他们可以搭配使用。</p><ol><li><p>Serial</p><p> 复制算法，新生代的单线程收集器，简单高效，stop the world。</p></li><li><p>ParNew</p><p> 复制算法，Serial的多线程版本，stop the world。首选的新生代收集器。</p></li><li><p>Parallel Scavenge</p><p> 新生代收集器，使用复制算法，多线程并行, stop the world。目标达到可控制的吞吐量。运行用户代码时间/CPU消耗总时常=吞吐量。该收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMills参数及直接设置吞吐量大小的-XX:GCTimeRatio参数。MaxGCPauseMills参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。GCTimeRatio参数的值应该是一个大于0的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。除了这两个参数，还有一个-XX:+UseAdaptiveSizePolicy值得关注。打开这个参数后，不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大吞吐量这种方式称为GC自适应的调节策略（GC Ergonomics）</p></li><li><p>Serial Old</p><p> Serial收集器的老年代版本，单线程收集器，使用标记-整理算法，stop the world。主要有两个用途：1. 在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候用。</p></li><li><p>Parallel Old</p><p> Parallel Scavenge的老年代版本，标记-整理算法，stop the world。</p></li><li><p>CMS（Concurrent Mark Sweep）收集器</p></li></ol><p>最短回收停顿时间为目标的收集器，重视服务响应速度，标记-清除算法实现。第一款并发收集器，可与用户线程并发执行。执行过程分为4个步骤：初始标记(CMS initial mark)、并发标记(CMS concurrent mark)、重新标记(CMS remark)、并发清除(CMS concurrent sweep)。初始和重新stop the world。初始标记只是标记GCRoots能直接关联的对象，速度很快，并发标记进行GCROOTs Tracing的过程。重新标记为了修复并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。<br>优点：并发收集、低停顿。<br>缺点：1. 对CPU资源非常敏感，解决方案，减少GC线程的独占时间。2. 无法处理浮动垃圾。CMS运行期间，用户线程产生的垃圾为浮动垃圾，CMS无法在本次收集中个清理这些浮动垃圾。如果CMS运行期间，内存无法满足用户线程要求，就会出现Concurrent Mode Failure失败，可能导致另一个FullGC产生，启动预备方案 Serial Old。3. 产生大量的空间碎片。</p><ol start="7"><li><p>G1收集器</p><p> 标记整理算法实现，精确的控制停顿，指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。G1将整个Java堆（老年代，新生代）划分多个大小固定的独立区域（Region），并且追踪这些区域里面的垃圾堆积程度。在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ol><h3 id="1-5-内存分配与回收"><a href="#1-5-内存分配与回收" class="headerlink" title="1.5 内存分配与回收"></a>1.5 内存分配与回收</h3><p>对象在Eden中分配内存，没有足够的空间进行垃圾回收。MinorGC。</p><pre><code>MinorGC: 新生代垃圾回收的动作，频繁且速度快。MajorGC（FullGC）: 指发生在老年代的GC，慢，清理新生代和老年代，CMS</code></pre><p>大对象指需要大量连续空间的Java对象。典型就是很长的字符串和数组。直接进入老年代分配，避免在Eden及Survivor中大量复制拷贝。</p><p>长期生活的对象进入老年代。对象年龄计数器，每一次MinorGC增长1岁。默认15岁进入老年代。</p><p>动态对象年龄判断，如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄段的对象直接进入老年代。</p><p>空间担保分配，每次MinorGC,检测升级到老年代的大小是否大于老年代的空间，如果大于，则进行FullGC。</p><h2 id="2-JDK命令行工具-性能监控和故障处理"><a href="#2-JDK命令行工具-性能监控和故障处理" class="headerlink" title="2. JDK命令行工具 性能监控和故障处理"></a>2. JDK命令行工具 性能监控和故障处理</h2><h3 id="2-1-jps"><a href="#2-1-jps" class="headerlink" title="2.1 jps"></a>2.1 jps</h3><p>虚拟机进程状况工具。 显示当前所有java进程pid的命令。</p><p>-l 输出主类的全名，如果进程执行的是Jar包，输出Jar路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -l</span><br><span class="line">5696 com.intellij.rt.execution.application.AppMain</span><br><span class="line">944 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">4488</span><br><span class="line">1900 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">7244 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure><p>-v 输出虚拟机进程启动时JVM参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -v</span><br><span class="line">5696 AppMain -Didea.launcher.port=7534 -Didea.launcher.bin.path=F:\Program Files\intellij IDEA\bin -Dfile.encoding=UTF-8</span><br><span class="line">944 RemoteMavenServer -Djava.awt.headless=true -Didea.version==2016.2.5 -Xmx768m -Didea.maven.embedder.version=3.0.5 -Dfile.encoding=GBK</span><br><span class="line">1656 Jps -Denv.class.path=.;C:\Program Files\Java\jdk1.8.0_161\lib\dt.jar;C:\Program Files\Java\jdk1.8.0_161\lib\tools.jar; -Dapplication.home=C:\Program Files\Java\jdk1.8.0_161 -Xms8m</span><br><span class="line">4488  -Xms128m -Xmx750m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djb.vmOptionsFile=F:\Program Files\intellij IDEA\bin\idea64.exe.v</span><br><span class="line">moptions -Xbootclasspath/a:F:\Program Files\intellij IDEA\lib\boot.jar -Didea.paths.selector=IntelliJIdea2016.2 -Didea.jre.check=true -XX:ErrorFile=C:\Users\zhongyp\java_error_in_idea_%p.log -XX:HeapDumpPath=C:\Users\zhongyp\java_error_in_idea.hprof</span><br><span class="line">1900 Launcher -Xmx700m -Djava.awt.headless=true -Djava.endorsed.dirs=&quot;&quot; -Djdt.compiler.useSingleThread=true -Dpreload.project.path=E:/demo -Dpreload.config.path=C:/Users/zhongyp/.IntelliJIdea2016.2/config/options -Dcompile.parallel=false -Drebuild.on.dependency.change=true -Djava.net.preferIPv4Stack=true</span><br><span class="line"> -Dio.netty.initialSeedUniquifier=-1505227146882843300 -Dfile.encoding=GBK -Djps.file.types.component.name=FileTypeManager -Duser.language=zh -Duser.country=CN -Didea.paths.selector=IntelliJIdea2016.2 -Didea.home.path=F:\Program Files\intellij IDEA -Didea.config.path=C:\Users\zhongyp\.IntelliJIdea2016.2\</span><br><span class="line">config -Didea.plugins.path=C:\Users\zhongyp\.IntelliJIdea2016.2\config\plugins -Djps.log.dir=C:/Users/zhongyp/.IntelliJIdea2016.2/system/log/build-log -Djps.fallback.jdk.home=C:/Program Files/Java/jdk1.8.0_161/jre -Djps.fallback.jdk.version=1.8.0_161 -Djava.io.tmpdir=C:/Users/zhongyp/.IntelliJIdea2016.2/</span><br><span class="line">system/compile-server/_temp_ -Dkotlin.incremental.compilation.experimental=true -Dkotlin.daemon.enabled -Dkotlin.daemon.cli</span><br></pre></td></tr></table></figure><p>-q 只输出LVMID，省略主类的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -q</span><br><span class="line">5696</span><br><span class="line">8912</span><br><span class="line">944</span><br><span class="line">4488</span><br><span class="line">1900</span><br></pre></td></tr></table></figure><p>-m 输出虚拟机进程启动时传递给主类main()函数的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">5696 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">10484 Jps -m</span><br><span class="line">4488</span><br><span class="line">1900 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/intel</span><br><span class="line">lij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/id</span><br><span class="line">ea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.ja</span><br><span class="line">r;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br></pre></td></tr></table></figure><h3 id="2-2-jstat"><a href="#2-2-jstat" class="headerlink" title="2.2 jstat"></a>2.2 jstat</h3><p> 虚拟机统计信息监视工具，用于监视虚拟机各种运行状态信息的命令。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾回收、JIT编译等运行数据。运行期定位虚拟机性能问题的首选工具。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-class：监视类装载、卸载数量、总空间以及类装载所耗时间。</span><br><span class="line"></span><br><span class="line">-gc：监视JAVA堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间，GC已用时间合计等信息；</span><br><span class="line"></span><br><span class="line">-gccapacity：监视内容与-gc基本相同，但输出主要关注 java堆各个区域使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcutil：监视内容与-gc基本相同，便输出主要关注已使用空间占总空间的百分比；</span><br><span class="line"></span><br><span class="line">-gccause：与-gcutil功能一样，但是会额外输出导致 一次GC产生的原因；</span><br><span class="line"></span><br><span class="line">-gcnew：监视新生代GC状态；</span><br><span class="line"></span><br><span class="line">-gcnewcapacity：监视内容与-gcnew基本相同，输出最要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcold：监视老年代GC状况；</span><br><span class="line"></span><br><span class="line">-gcoldcapacity：监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcpermcapacity：监视永久代使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-compiler：输入JIT编译器编译过的方法，耗时等信息；</span><br><span class="line"></span><br><span class="line">-printcompilation：输出已经被JIT编译的方法；</span><br></pre></td></tr></table></figure><h3 id="2-3-jinfo"><a href="#2-3-jinfo" class="headerlink" title="2.3 jinfo"></a>2.3 jinfo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-flag &lt;name&gt; ：可查看虚拟机启动时显式指定的参数列表。</span><br><span class="line">-flag [+|-]&lt;name&gt;：设置或取消VM参数</span><br><span class="line">-flag &lt;name&gt;=&lt;value&gt;：给VM参数设置新值</span><br><span class="line">-flags：可查看所有VM参数；</span><br><span class="line">-sysprops：查看java系统参数;</span><br><span class="line">&lt;no option&gt;：表示在不给定任何选项时，打印出以上所有的VM参数</span><br></pre></td></tr></table></figure><p> 实时的查看和调整虚拟机的各项参数。</p><h3 id="2-4-jmap"><a href="#2-4-jmap" class="headerlink" title="2.4 jmap"></a>2.4 jmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-dump：生成java堆转储快照，格式为：-dump[live, ] format=b, file=&lt;filename&gt;,其中live子参数说明是否只dump出存活对象；</span><br><span class="line"></span><br><span class="line">-finalizerinfo：显示在F-QueuiK 等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-heap：显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-histo：显示堆中对象统计信息，包括类、实例数量、合计容量；</span><br><span class="line"></span><br><span class="line">-permstat：以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台有效；</span><br><span class="line"></span><br><span class="line">-F：当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，只在Linux/Solaris平台有效</span><br></pre></td></tr></table></figure><p> Java内存映像工具。用于生成堆转储快照，还可以查询finalize()执行队列，Java堆和永久代的详细信息，如空间使用率、当前使用的哪种收集器等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jmap -dump:format=b,file=D:\test.bin 2768</span><br><span class="line">Dumping heap to D:\test.bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h3 id="2-5-jhat"><a href="#2-5-jhat" class="headerlink" title="2.5 jhat"></a>2.5 jhat</h3><p><code>jhat D:\test.bin</code></p><p> 分析jmap生成的堆转储快照，在浏览器查看。</p><h3 id="2-6-jstack"><a href="#2-6-jstack" class="headerlink" title="2.6 jstack"></a>2.6 jstack</h3><p> 用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合，生成快照的目的是定位线程出现长时间停顿的原因。</p><p>-F    当正常输出的请求不被响应时，强制输出线程堆栈</p><p>-l    除堆栈外，显示关于锁的附加信息</p><p>-m    如果调用到本地方法的话，可以显示c/c++的堆栈</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">//        Thread t1 = new Worker(1);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        t1.start();</span><br><span class="line">        final A a = new A();</span><br><span class="line">        final B b = new B();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                a.getBLock(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                b.getALock(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getBLock(B b)&#123;</span><br><span class="line"></span><br><span class="line">        b.getALock(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getALock(A a)&#123;</span><br><span class="line">        a.getBLock(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">1904 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">11540 Jps -m</span><br><span class="line">13204 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/inte</span><br><span class="line">llij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/i</span><br><span class="line">dea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.j</span><br><span class="line">ar;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br><span class="line">4488</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jstack -F 1904</span><br><span class="line">Attaching to process ID 1904, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.161-b12</span><br><span class="line">Deadlock Detection:</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193ce108 (Object@0x00000000d6129700, a com/zhongyp/B),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193cb878 (Object@0x00000000d6127d20, a com/zhongyp/A),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line"></span><br><span class="line">Found a total of 1 deadlock.</span><br><span class="line"></span><br><span class="line">Thread 1: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 18: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=0, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=2, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$2.run() @bci=18, line=38 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 17: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=0, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=2, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$1.run() @bci=18, line=26 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 16: (state = IN_NATIVE)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.accept0(int, java.net.InetSocketAddress[]) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.socketAccept(java.net.SocketImpl) @bci=37, line=131 (Interpreted frame)</span><br><span class="line"> - java.net.AbstractPlainSocketImpl.accept(java.net.SocketImpl) @bci=7, line=409 (Interpreted frame)</span><br><span class="line"> - java.net.PlainSocketImpl.accept(java.net.SocketImpl) @bci=42, line=199 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.implAccept(java.net.Socket) @bci=60, line=545 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.accept() @bci=48, line=513 (Interpreted frame)</span><br><span class="line"> - com.intellij.rt.execution.application.AppMain$1.run() @bci=13, line=79 (Interpreted frame)</span><br><span class="line"> - java.lang.Thread.run() @bci=11, line=748 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 10: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 9: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 8: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 7: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.Object.wait() @bci=2, line=502 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference.tryHandlePending(boolean) @bci=54, line=191 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference$ReferenceHandler.run() @bci=1, line=153 (Interpreted frame)</span><br></pre></td></tr></table></figure><h2 id="3-JDK可视化工具"><a href="#3-JDK可视化工具" class="headerlink" title="3. JDK可视化工具"></a>3. JDK可视化工具</h2><p>JConsole: Java监视与管理控制台。基于JMX的可视化监视和管理工具。监视Java堆和永久代的的变化趋势。</p><p>VisualVM: 多合一故障处理工具。</p><h2 id="4-JVM调优案例"><a href="#4-JVM调优案例" class="headerlink" title="4. JVM调优案例"></a>4. JVM调优案例</h2><h3 id="4-1-高性能硬件上的程序部署策略"><a href="#4-1-高性能硬件上的程序部署策略" class="headerlink" title="4.1 高性能硬件上的程序部署策略"></a>4.1 高性能硬件上的程序部署策略</h3><p>使用64位JDK大内存。</p><p>问题：1.内存回收导致长时间停顿。2.64位JDK的性能测试结果普遍低于32位JDK。3.需要保证程序足够稳定，这种应用如果产生堆溢出几乎就无法产生堆转储快照。4. 相同程序64位JDK中消耗内存一般比32位大，这是由于指针膨胀和数据类型对其补白导致的。</p><p>使用若干个32位虚拟机建立逻辑集群来利用集群资源。</p><p>问题：1.尽量避免节点竞争全局资源，如并发写操作导致IO异常。2.很难高效率的利用某些资源池，比如连接池，导致一些节点满了，其他的还为零。3.各个节点仍然不可避免的受到32位的限制（2GB）。4.大量使用本地缓存的应用，改为集中式的缓存。</p><h3 id="4-2-集群间同步导致内存溢出"><a href="#4-2-集群间同步导致内存溢出" class="headerlink" title="4.2 集群间同步导致内存溢出"></a>4.2 集群间同步导致内存溢出</h3><h3 id="4-3-堆外内存导致的溢出错误"><a href="#4-3-堆外内存导致的溢出错误" class="headerlink" title="4.3 堆外内存导致的溢出错误"></a>4.3 堆外内存导致的溢出错误</h3><h3 id="4-4-外部命令导致系统缓慢"><a href="#4-4-外部命令导致系统缓慢" class="headerlink" title="4.4 外部命令导致系统缓慢"></a>4.4 外部命令导致系统缓慢</h3><h2 id="5-java内存模型和线程"><a href="#5-java内存模型和线程" class="headerlink" title="5. java内存模型和线程"></a>5. java内存模型和线程</h2><h3 id="5-1-java内存模型"><a href="#5-1-java内存模型" class="headerlink" title="5.1 java内存模型"></a>5.1 java内存模型</h3><h4 id="5-1-1-主内存和工作内存"><a href="#5-1-1-主内存和工作内存" class="headerlink" title="5.1.1 主内存和工作内存"></a>5.1.1 主内存和工作内存</h4><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p><p>注： 这里说的变量包括了实例变量、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有，不会被共享，自然就不存在竞争问题。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程简介</title>
      <link href="/zhongyp.github.io/concurrency/2017-03-16-thread-brief/"/>
      <url>/zhongyp.github.io/concurrency/2017-03-16-thread-brief/</url>
      
        <content type="html"><![CDATA[<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h3><p>现代操作系统在运行程序时，会为其创建一个进程。比如你现在用的浏览器，系统就会为其创建一个甚至多个进程。<strong><em>引入进程的目的是为了更好的使操作系统并发执行程序。来提高资源利用率和系统吞吐量，增加并发程度。</em></strong><br>线程是现代操作系统调度的基本单元，是运行在进程上下文中的逻辑流，是程序执行流的最小单元，也叫轻量级进程（Light Weight Process），也可以称之为CPU的执行单元。一个程序作为一个进程来运行，程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行一个处理器核心上。<strong><em>引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。线程不拥有系统资源（代码，数据、堆、共享库、文件），只拥有运行中必不可少的资源（线程ID, 栈，栈指针，程序计数器、通用目的寄存器和条件码）。</em></strong><br>线程是调度的抽象。<strong><em>Java中将线程的执行和执行对象抽象开来，JDK包中执行的有Thread类，Executor框架，可执行目标有Runaable，Callable。</em></strong></p><h4 id="1-1-线程的优点"><a href="#1-1-线程的优点" class="headerlink" title="1.1 线程的优点"></a>1.1 线程的优点</h4><ol><li>多处理器使用： 提高资源利用率和系统吞吐量。</li></ol><h4 id="1-2-线程的风险"><a href="#1-2-线程的风险" class="headerlink" title="1.2 线程的风险"></a>1.2 线程的风险</h4><ol><li>安全风险：对于共享变量的访问、操作容易造成安全风险。</li><li>活跃度风险：死锁引发活动度失败。</li><li>性能风险：线程之间频繁调度导致上下文切换导致巨大的系统开销。</li></ol><h3 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2. 线程的状态"></a>2. 线程的状态</h3><p><img src="/media/article/ThreadStatus.png" alt="ThreadStatus"><br><a href="#线程简介">图片来自：Java并发编程的艺术-</a></p><ul><li>新建(NEW)：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（READY）。</li></ul><p><strong><em>注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</em></strong></p><ul><li><p>运行状态(RUNNABLE)：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行中”。</p></li><li><p>就绪(READY)：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。</p></li><li><p>运行(RUNNING)：处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>等待状态(WAITING)：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程作出一些特定动作（通知或中断）。</p></li><li><p>超时等待状态(TIME_WAITING)：该状态不同于WAITING，它是可以在指定的时间自行返回的。</p></li><li><p>阻塞(BLOCKED)：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a>关于BLOCKED的描述：Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.翻译：阻塞线程是等待获取同步监视器锁的线程。线程等待获取同步监视器锁进入同步代码块/方法,或者调用Object.wait方法后,被唤醒后等待获取同步监视器锁,<strong><em>重入</em></strong>同步代码块/方法。</p></li><li><p>死亡(DEAD)：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ul><h3 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3. 线程优先级"></a>3. 线程优先级</h3><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。</p><p><strong><em>注：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</em></strong></p><h3 id="4-Daemon线程"><a href="#4-Daemon线程" class="headerlink" title="4. Daemon线程"></a>4. Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用做程序中后台调度及支持性工作。<br><strong><em> 注意：构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</em></strong></p><p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</span><br><span class="line">• Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">    * 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line">    * 该方法必须在启动线程前调用。</span><br><span class="line">    * 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。</span><br><span class="line">    * 这可能抛出 SecurityException（在当前线程中）。   </span><br><span class="line">    *   参数：</span><br><span class="line">    *      on - 如果为 true，则将该线程标记为守护线程。    </span><br><span class="line">    *   抛出：    </span><br><span class="line">    *     IllegalThreadStateException - 如果该线程处于活动状态。    </span><br><span class="line">    *     SecurityException - 如果当前线程无法修改该线程。</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">public final void setDaemon(boolean on)</span><br></pre></td></tr></table></figure><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p><a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">Java多线程详解</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程（1）-读Thread类源码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>经典面试题整理</title>
      <link href="/zhongyp.github.io/interfaceview/2018-03-02-classic-interview-questions/"/>
      <url>/zhongyp.github.io/interfaceview/2018-03-02-classic-interview-questions/</url>
      
        <content type="html"><![CDATA[<h2 id="corejava"><a href="#corejava" class="headerlink" title="corejava"></a>corejava</h2><ol><li><p>hashcode 相等两个类一定相等么？equals呢？相反呢？</p></li><li><p>介绍一下集合框架</p></li><li><p>hashmap hashtable 底层实现什么区别？hashtale和concurrenthashmap呢？</p></li><li><p>hashmap和treemap 什么区别？底层数据结构呢？</p></li><li><p>线程池用过么？都有什么参数？底层如何实现的？</p></li><li><p>sychnized和Lock什么区别？sychnize什么情况是对象锁，什么时候是全局锁？为什么？</p></li><li><p>ThreadLocal 是什么？底层如何实现？写一个例子？</p></li><li><p>volitile的工作原理？</p></li><li><p>cas知道么？如何实现的？</p></li><li><p>请用至少四种写法？写一个单例模式？</p></li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol><li><p>请介绍一下JVM内存模型？用过什么垃圾回收器，都说说？</p></li><li><p>线上发送频繁full gc如何处理？CPU使用率过高怎么办？如何定位问题？如何解决？说一下解决思路和处理方法。</p></li><li><p>知道字节码么？字节码都有那些？Integer * 5,int y=5, 比较x==y 都经过那些步骤？</p></li><li><p>讲讲类加载机制？都有哪些类加载器，这些类加载器都加载哪些文件？手写一下类加载Demo</p></li><li><p>知道osgi么？他是如何实现的？</p></li><li><p>请问你做过哪些JVM优化？使用什么方法？达到什么效果？</p></li><li><p>class.forName(“java.lang.String”)和String.class.getClassLoader.loadClass(“java.lang.String”)什么区别？</p></li></ol><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol><li><p>spring都有哪些机制？AOP底层如何实现的？IOC？</p></li><li><p>cglib知道么？它和JDK动态代理有什么区别？手写一个jdk动态代理？</p></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li><p>使用mysql索引都有哪些原则？索引什么数据结构？B+tree和B tree什么区别？</p></li><li><p>mysql有哪些存储引擎啊？都有啥区别？要详细？</p></li><li><p>设计高并发系统数据库层面该怎么设计？数据库锁有哪些类型？如何实现？</p></li><li><p>数据库事务有哪些？</p></li></ol><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ol><li><p>如何设计可以动态扩容缩容的分库分表方案？</p></li><li><p>用过哪些分库分表的中间件，有啥优点和缺点，讲一下你了解的分库分表中间件的底层实现原理。</p></li><li><p>我现在有一个未分库分表的系统，以后系统需要分库分表，如何设计，让未分库分表的系统动态切换到分库分表系统上？</p></li><li><p>分布式事务知道么？ 你们怎么解决的？ TCC?那若出现网络原因，网络连不通怎么办啊？</p></li><li><p>为什么分库分表？</p></li><li><p>分布式寻址方式都有哪些算法？知道一致hash么？手写一下Java实现代码？你若userId取模分片，那我要查一段连续时间里的数据怎么办？</p></li><li><p>如何解决分库分表主键问题？有什么实现方案？</p></li></ol><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><ol><li><p>redis和memched 什么区别？为什么单线程的redis比多线程的memched效率要高？</p></li><li><p>redis有什么数据类型？都在哪些场景下使用？</p></li><li><p>redis的主从复制是怎么实现的？redis的集群模式是如何实现的呢？redis的key是如何寻址的？</p></li><li><p>使用redis如何设计分布式锁？使用zk可以么？如何实现？这两种哪个效率更高？</p></li><li><p>知道redis的持久化么？有什么优点和缺点？具体底层实现呢？</p></li><li><p>redis过期策略都有哪些？LRU？写一下Java版本代码？</p></li></ol><h2 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h2><ol><li><p>说一下dubbo的实现过程，注册中心挂了可以继续通信么？</p></li><li><p>zk原理知道么？zk都可以干什么？paxos算法知道么？说一下原理和实现？</p></li><li><p>dubbo支持哪些序列化协议？hessian？说一下hessian的数据结构？PB知道么？为啥PB效率是最高的？</p></li><li><p>知道netty么？netty可以干嘛？NIO,BIO,AIO都是什么啊？有什么区别？</p></li><li><p>dubbo复制均衡策略和高可用策略都有哪些？动态代理策略呢？</p></li><li><p>为什么要进行系统拆分啊？拆分不用dubbo可以么？dubbo和thrift什么区别啊？</p></li></ol><h2 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h2><ol><li><p>为什么使用消息队列？消息队列有什么优点和缺点？</p></li><li><p>如何保证消息队列的高可用？如何保证消息不被重复消费？</p></li><li><p>kafka，activemq，rabbitmq，rocketmq都有什么优点和缺点？</p></li><li><p>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路？</p></li></ol><h2 id="分布式搜索引擎"><a href="#分布式搜索引擎" class="headerlink" title="分布式搜索引擎"></a>分布式搜索引擎</h2><ol><li><p>es的工作过程实现是如何的？如何实现分布式的啊？</p></li><li><p>es在数据量很大的情况下，如何提高查询效率？</p></li><li><p>es的查询是一个怎么的工作过程？底层的lucence介绍一下？倒排索引知道么？es和mongodb什么区别？都在什么场景下使用？</p></li></ol><h2 id="高并发高可用架构设计"><a href="#高并发高可用架构设计" class="headerlink" title="高并发高可用架构设计"></a>高并发高可用架构设计</h2><ol><li><p>如何设计一个高并发高可用系统？</p></li><li><p>如何限流？工程中怎么做的，说一下具体实现？</p></li><li><p>缓存如何使用的？缓存使用不会造成什么后果？</p></li><li><p>如何熔断？熔断框架都有哪些？具体实现原理知道么？</p></li><li><p>如何降级？ 如何进行系统拆分？如何数据库拆分？</p></li></ol><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><ol><li><p>说一下TCP/IP 四层？</p></li><li><p>http的工作流程？ http1.0 http1.1 http2.0具体哪些区别？</p></li><li><p>TCP三次握手，四层分手的工作流程？画一下流程图？为什么不是四次五次或者两次？</p></li><li><p>画一下https的工作流程？具体如何实现？如何防止被抓包？</p></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>45亿阿拉伯数字，如何进行去重？如何找出最大的那个数？</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>二叉树和红黑树<br><a href="https://www.jianshu.com/p/a07d1d4004b0" target="_blank" rel="noopener">博文推荐</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法（Algorithm）</title>
      <link href="/zhongyp.github.io/algorithm/2018-01-10-Algorithm/"/>
      <url>/zhongyp.github.io/algorithm/2018-01-10-Algorithm/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/zhongyp/Demo/tree/master/src/main/java/com/zhongyp/algorithm" target="_blank" rel="noopener">本文的所有算法代码均在github上保存，点击此链接即可访问</a></p><p>算法的分类以及经典算法题的代码实现，修炼内功</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 先序、中序遍历二叉树</span><br><span class="line"> * 先序：根左右</span><br><span class="line"> * 中序：左根右</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// 标记先序索引位置</span><br><span class="line">int count = 0;</span><br><span class="line">public  Tree buildTreeByPreMid(int[] a, int s1, int e1,int[] b, int s2, int e2)&#123;</span><br><span class="line"></span><br><span class="line">    if(s1&gt;e1||s2&gt;e2)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree tree = new Tree();</span><br><span class="line">     tree.value = a[count];</span><br><span class="line">    // index为a[s1]在b中的索引</span><br><span class="line">    int index = getIndex(b, a[count]);</span><br><span class="line">    count++;</span><br><span class="line">    // count标识左子树先序的起点，s1+index为左子树先序的终点，s2,index-1分别为左子树中序的起点和终点</span><br><span class="line">    tree.left = buildTreeByPreMid(a, count, s1+index, b, s2, index-1);</span><br><span class="line">    tree.right = buildTreeByPreMid(a, count, s1+e2-index, b, index+1, e2);</span><br><span class="line"></span><br><span class="line">    return tree;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 中序、后序 构建二叉树</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">int count1 = 7;</span><br><span class="line">public Tree buildTreeByMidLast(int[] a, int s1, int e1,int[] b, int s2, int e2)&#123;</span><br><span class="line">    if(s1&gt;e1||s2&gt;e2)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree tree = new Tree();</span><br><span class="line">    tree.value = a[e1];</span><br><span class="line">    int index = getIndex(b, a[e1]);</span><br><span class="line">    count1--;</span><br><span class="line">    tree.right = buildTreeByMidLast(a, count1+index-e2+1, count1, b, index+1, e2);</span><br><span class="line">    tree.left = buildTreeByMidLast(a, s1, count1, b, s2, index-1);</span><br><span class="line">    return tree;</span><br><span class="line">&#125;</span><br><span class="line">private int getIndex(int[] b,int value)&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for(int tmp:b)&#123;</span><br><span class="line">        if(tmp==value)&#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 先序</span><br><span class="line">public void printPre(Tree tree)&#123;</span><br><span class="line">    if(tree != null)&#123;</span><br><span class="line">        System.out.print(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        printPre(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        printPre(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 中序</span><br><span class="line">public void printMid(Tree tree)&#123;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        printMid(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (tree != null)&#123;</span><br><span class="line">        System.out.print(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        printMid(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 后序</span><br><span class="line">public void printLast(Tree tree)&#123;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        printLast(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        printLast(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">    if (tree != null)&#123;</span><br><span class="line">        System.out.print(tree.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 1.将节点放入队列</span><br><span class="line"> * 2.取出队列第一个节点</span><br><span class="line"> * 3.将取出的节点的左右节点一次放入队列</span><br><span class="line"> * 递归</span><br><span class="line"> */</span><br><span class="line">public void printLevel(Tree tree)&#123;</span><br><span class="line">    if(tree == null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree current;</span><br><span class="line">    LinkedList list = new LinkedList();</span><br><span class="line">    list.offer(tree);</span><br><span class="line">    while(!list.isEmpty())&#123;</span><br><span class="line">        current = (Tree)list.poll();</span><br><span class="line">        System.out.print(current.value);</span><br><span class="line">        if(current.left != null)&#123;</span><br><span class="line">            list.offer(current.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(current.right != null)&#123;</span><br><span class="line">            list.offer(current.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 二叉树叶子节点个数</span><br><span class="line">int count2 = 0;</span><br><span class="line">public void sumLeaf(Tree tree)&#123;</span><br><span class="line">    if(tree.left == null&amp;&amp;tree.right == null)&#123;</span><br><span class="line">        count2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.left != null)&#123;</span><br><span class="line">        sumLeaf(tree.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.right != null)&#123;</span><br><span class="line">        sumLeaf(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 二叉树的高度</span><br><span class="line">public int hightTree(Tree tree)&#123;</span><br><span class="line">    if(tree == null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree.left == null &amp;&amp; tree.right == null)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int l_hight = hightTree(tree.left);</span><br><span class="line">    int r_hight = hightTree(tree.right);</span><br><span class="line">    return l_hight&gt;r_hight?l_hight+1:r_hight+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求两个节点的最近公共祖先</span><br><span class="line">public void commonParent(int value1, int value2)&#123;</span><br><span class="line">    if(root == null || p == root || q == root) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tree l = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    Tree r = lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">    if(l!= null &amp;&amp; r!= null) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return l != null?l:r;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 路径值</span><br><span class="line">Stack&lt;Integer&gt; stack = new Stack();</span><br><span class="line">public void FindPath(Tree tree, int sum, int current)&#123;</span><br><span class="line">    if(tree==null)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current+=tree.value;</span><br><span class="line">    stack.push(tree.value);</span><br><span class="line">    if(current==sum)&#123;</span><br><span class="line">        System.out.println(&quot;PATH:&quot;);</span><br><span class="line">        for(int val : stack)&#123;</span><br><span class="line">            System.out.print(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current&lt;sum)&#123;</span><br><span class="line">        if(tree.left != null)&#123;</span><br><span class="line">            FindPath(tree.left,sum,current);</span><br><span class="line">        &#125;</span><br><span class="line">        if(tree.right != null)&#123;</span><br><span class="line">            FindPath(tree.right,sum,current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current -= tree.value;</span><br><span class="line">    stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>链表逆序（不可使用其他空间）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 非递归</span><br><span class="line"> */</span><br><span class="line">public Node reverse(Node node)&#123;</span><br><span class="line">    Node init = null;</span><br><span class="line">    while(node != null)&#123;</span><br><span class="line">        Node node1 = init;</span><br><span class="line">        Node node2 = node;</span><br><span class="line">        node = node.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        init = node2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归方式</span><br><span class="line"> * @param node1</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Node reverse1(Node node1)&#123;</span><br><span class="line"></span><br><span class="line">    Node init = node1.next;</span><br><span class="line">    if(init != null)&#123;</span><br><span class="line">        Node node2= reverse1(init);</span><br><span class="line">        Node tmp = getLastNode(node2);</span><br><span class="line">        node1.next = null;</span><br><span class="line">        tmp.next = node1;</span><br><span class="line">        return node2;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h2><ul><li>插入排序： 直接插入，希尔排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 直接插入排序算法的空间复杂度为O(1)。</span><br><span class="line">     * 最好的情况，要比较的无序序列原本就是顺序有序的，那么要比较的次数是n-1，移动了0次，时间复杂度O(n)。</span><br><span class="line">     * 最坏的情况，要比较的无序序列原本就是逆序有序的，那么要比较的次数是(n+2)(n-1)/2，移动的次数(n+4)(n-1)/2，时间复杂度O(n²)。</span><br><span class="line">     * 直接插入排序的平均复杂度为O(n²)。</span><br><span class="line">     * 直接插入排序是稳定的。</span><br><span class="line">     * @param num</span><br><span class="line">     */</span><br><span class="line">public void directInsert(int[] num)&#123;</span><br><span class="line">    for(int i=1; i&lt;num.length; i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">            if(num[i]&lt;num[j])&#123;</span><br><span class="line">                int a = num[j];</span><br><span class="line">                num[j] = num[i];</span><br><span class="line">                num[i] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int val:num)&#123;</span><br><span class="line">        System.out.print(val + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">     * 希尔排序在最坏的情况下的运行时间是O(n²)，平均时间复杂度为O(n^1.3)。</span><br><span class="line">     * 希尔排序对于多达几千个数据项的，中等大小规模的数组排序表现良好。</span><br><span class="line">     * 希尔排序不像快速排序和其它时间复杂度为O(nlog2n)的排序算法那么快，因此对非常大的文件排序，它不是最优选择。</span><br><span class="line">     * 但是，希尔排序比选择排序和插入排序这种时间复杂度为O(n²)的排序算法还是要快得多，并且它非常容易实现。</span><br><span class="line">     * 它在最坏情况下的执行效率和在平均情况下的执行效率相比没有差很多。</span><br><span class="line">     * 此外希尔排序是不稳定的(指在多次插入排序中，相同元素可能在插入排序中移动，导致稳定性被破坏)。</span><br><span class="line">     * @param num</span><br><span class="line">     */</span><br><span class="line">public void hillSort(int[] num)&#123;</span><br><span class="line">    int gap = 5;</span><br><span class="line">    while(gap&gt;0)&#123;</span><br><span class="line">        for(int i=0; i&lt;num.length-gap; i++)&#123;</span><br><span class="line">            if(num[i]&gt;num[i+gap])&#123;</span><br><span class="line">                int a = num[i];</span><br><span class="line">                num[i] = num[i+gap];</span><br><span class="line">                num[i+gap] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = gap/2;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int val:num)&#123;</span><br><span class="line">        System.out.print(val + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>选择排序： 简单选择排序，堆排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 选择排序</span><br><span class="line">     * @param num</span><br><span class="line">     */</span><br><span class="line">    public void simpleSort(int[] num)&#123;</span><br><span class="line">        for(int i=0;i&lt;num.length;i++)&#123;</span><br><span class="line">            int index = i;</span><br><span class="line">            for(int j=i;j&lt;num.length-1;j++)&#123;</span><br><span class="line">                if(num[index]&gt;num[j+1])&#123;</span><br><span class="line">                    index = j+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int a = num[i];</span><br><span class="line">            num[i] = num[index];</span><br><span class="line">            num[index] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int val:num)&#123;</span><br><span class="line">            System.out.print(val + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 堆排序</span><br><span class="line">     *</span><br><span class="line">     * 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</span><br><span class="line">     *</span><br><span class="line">     * @param num</span><br><span class="line">     * @param index</span><br><span class="line">     */</span><br><span class="line">    public void heapSort(int[] num, int index)&#123;</span><br><span class="line"></span><br><span class="line">        for(int i=index/2;i&gt;-1;i--)&#123;</span><br><span class="line">            if((2*i)&lt;index&amp;&amp;num[i]&lt;num[2*i])&#123;</span><br><span class="line">                int a = num[i];</span><br><span class="line">                num[i] = num[2*i];</span><br><span class="line">                num[2*i] = a;</span><br><span class="line">            &#125;</span><br><span class="line">            if((2*i+1)&lt;index&amp;&amp;num[i]&lt;num[2*i+1])&#123;</span><br><span class="line">                int a = num[i];</span><br><span class="line">                num[i] = num[2*i+1];</span><br><span class="line">                num[2*i+1] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int a = num[index];</span><br><span class="line">        num[index] = num[0];</span><br><span class="line">        num[0] = a;</span><br><span class="line">        index = index-1;</span><br><span class="line">        if(index&gt;0)&#123;</span><br><span class="line">            heapSort(num,index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>交换排序： 冒泡排序，快速排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    // 冒泡排序</span><br><span class="line">    public static void bubbleSort()&#123;</span><br><span class="line">//        int[] arr = &#123;3,5,7,1,4&#125;;</span><br><span class="line">        int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">        int i,j,temp,len=arr.length;</span><br><span class="line">        //是否已经完成排序的标志</span><br><span class="line">        boolean flag;</span><br><span class="line">        //排序</span><br><span class="line">        for(i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            for(j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">                if(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    flag = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                System.out.println(&quot;第&quot; + (i+1) + &quot;趟结束了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出数组</span><br><span class="line">        for(int o:arr)&#123;</span><br><span class="line">            System.out.print(&quot; &quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 快速排序</span><br><span class="line">    public static void quickSort(int[] num,int start, int end)&#123;</span><br><span class="line">            int sys = num[start];</span><br><span class="line">            int left = start;</span><br><span class="line">            int right = end;</span><br><span class="line"></span><br><span class="line">            while(start&lt;end)&#123;</span><br><span class="line">                if(num[end]&lt;sys)&#123;</span><br><span class="line">                    num[start] = num[end];</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    end--;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(sys&lt;num[start])&#123;</span><br><span class="line">                    num[end] = num[start];</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num[start] = sys;</span><br><span class="line">            if(left&lt;start-1)&#123;</span><br><span class="line">                quickSort(num,left,start-1);</span><br><span class="line">            &#125;</span><br><span class="line">            if(right&gt;end+1)&#123;</span><br><span class="line">                quickSort(num,end+1,right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>归并排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">static int[] sort(int[] a, int start, int end)&#123;</span><br><span class="line"></span><br><span class="line">    int mid ;</span><br><span class="line">    if(start&lt;end)&#123;</span><br><span class="line">        mid = (start + end)/2;</span><br><span class="line">        a = sort(a, start, mid);</span><br><span class="line">        a = sort(a, mid+1, end);</span><br><span class="line">        a = merge(a, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int[] merge(int[] a, int start, int mid, int end)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    int[] c = new int[a.length];</span><br><span class="line">    while((start+i)&lt;=mid&amp;&amp;(mid+1+j)&lt;=end)&#123;</span><br><span class="line">        if(a[start+i]&gt;a[mid+1+j])&#123;</span><br><span class="line">            c[i+j] = a[mid+1+j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            c[i+j] = a[start+i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    while((start+i)&lt;=mid)&#123;</span><br><span class="line">        c[i+j] = a[start+i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while((mid+1+j)&lt;=end)&#123;</span><br><span class="line">        c[i+j] = a[mid+1+j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int k=0;k&lt;=(i+j-1);k++)&#123;</span><br><span class="line">        a[start+k] = c[k];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基数排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int[] radixSort(int[] A, int n) &#123;</span><br><span class="line">    int length = n;</span><br><span class="line">    int divisor = 1;// 定义每一轮的除数，1,10,100...</span><br><span class="line">    int[][] bucket = new int[10][length];// 定义了10个桶，以防每一位都一样全部放入一个桶中</span><br><span class="line">    int[] count = new int[10];// 统计每个桶中实际存放的元素个数</span><br><span class="line">    int digit;// 获取元素中对应位上的数字，即装入那个桶</span><br><span class="line">    for (int i = 1; i &lt;= 3; i++) &#123;// 经过4次装通操作，排序完成</span><br><span class="line">        for (int temp : A) &#123;// 计算入桶</span><br><span class="line">            digit = (temp / divisor) % 10;</span><br><span class="line">            bucket[digit][count[digit]++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = 0;// 被排序数组的下标</span><br><span class="line">        for (int b = 0; b &lt; 10; b++) &#123;// 从0到9号桶按照顺序取出</span><br><span class="line">            if (count[b] == 0)// 如果这个桶中没有元素放入，那么跳过</span><br><span class="line">            continue;</span><br><span class="line">            for (int w = 0; w &lt; count[b]; w++) &#123;</span><br><span class="line">                A[k++] = bucket[b][w];</span><br><span class="line">            &#125;</span><br><span class="line">            count[b] = 0;// 桶中的元素已经全部取出，计数器归零</span><br><span class="line">        &#125;</span><br><span class="line">        divisor *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指offfer-所有算法"><a href="#剑指offfer-所有算法" class="headerlink" title="剑指offfer 所有算法"></a>剑指offfer 所有算法</h2><p>第01-10题</p><p>【剑指Offer学习】【面试题02：实现Singleton 模式——七种实现方式】</p><p>【剑指Offer学习】【面试题03：二维数组中的查找】</p><p>【剑指Offer学习】【面试题04：替换空格】</p><p>【剑指Offer学习】【面试题05：从尾到头打印链表】</p><p>【剑指Offer学习】【面试题06：重建二叉树】</p><p>【剑指Offer学习】【面试题07：用两个栈实现队列】</p><p>【剑指Offer学习】【面试题08：旋转数组的最小数字】</p><p>【剑指Offer学习】【面试题09：斐波那契数列】</p><p>【剑指Offer学习】【面试题10：二进制中1 的个数】</p><p>第11-20题</p><p>【剑指Offer学习】【面试题11：数值的整数次方】</p><p>【剑指Offer学习】【面试题12：打印1 到最大的n 位数】</p><p>【剑指Offer学习】【面试题13：在O（1）时间删除链表结点】</p><p>【剑指Offer学习】【面试题14：调整数组顺序使奇数位于偶数前面】</p><p>【剑指Offer学习】【面试题15：链表中倒数第k个结点】</p><p>【剑指Offer学习】【面试题16：反转链表】</p><p>【剑指Offer学习】【面试题17：合并两个排序的链表】</p><p>【剑指Offer学习】【面试题18：树的子结构】</p><p>【剑指Offer学习】【面试题19：二叉树的镜像】</p><p>【剑指Offer学习】【面试题20：顺时针打印矩阵】</p><p>第21-30题</p><p>【剑指Offer学习】【面试题21：包含min函数的钱】</p><p>【剑指Offer学习】【面试题22：栈的压入、弹出序列】</p><p>【剑指Offer学习】【面试题23：从上往下打印二叉树】</p><p>【剑指Offer学习】【面试题24：二叉搜索树的后序遍历序列】</p><p>【剑指Offer学习】【面试题25：二叉树中和为某一值的路径】</p><p>【剑指Offer学习】【面试题26：复杂链表的复制】</p><p>【剑指Offer学习】【面试题27：二叉搜索树与双向链表】</p><p>【剑指Offer学习】【面试题28：字符串的排列】</p><p>【剑指Offer学习】【面试题29：数组中出现次数超过一半的数字】</p><p>【剑指Offer学习】【面试题30：最小的k个数】</p><p>第31-40题</p><p>【剑指Offer学习】【面试题31：连续子数组的最大和】</p><p>【剑指Offer学习】【面试题32：求从1到n的整数中1出现的次数】</p><p>【剑指Offer学习】【面试题33：把数组排成最小的数】</p><p>【剑指Offer学习】【面试题34：丑数】</p><p>【剑指Offer学习】【面试题35：第一个只出现一次的字符】</p><p>【剑指Offer学习】【面试题36：数组中的逆序对】</p><p>【剑指Offer学习】【面试题37：两个链表的第一个公共结点】</p><p>【剑指Offer学习】【面试题38：数字在排序数组中出现的次数】</p><p>【剑指Offer学习】【面试题39：二叉树的深度】</p><p>【剑指Offer学习】【面试题40：数组中只出现一次的数字】</p><p>第41-50题</p><p>【剑指Offer学习】【面试题41：和为s 的两个数字vs 和为s 的连续正数序列】</p><p>【剑指Offer学习】【面试题42：翻转单词顺序vs左旋转字符串】</p><p>【剑指Offer学习】【面试题43 : n 个锻子的点数】</p><p>【剑指Offer学习】【面试题44：扑克牌的顺子】</p><p>【剑指Offer学习】【面试题45：圆圈中最后剩下的数字(约瑟夫环问题)】</p><p>【剑指Offer学习】【面试题47：不用加减乘除做加法】</p><p>【剑指Offer学习】【面试题49：把字符串转换成整数】</p><p>【剑指Offer学习】【面试题50：树中两个结点的最低公共祖先】</p><p>第51-60题</p><p>【剑指Offer学习】【面试题51：数组中重复的数字】</p><p>【剑指Offer学习】【面试题52：构建乘积数组】</p><p>【剑指Offer学习】【面试题53：正则表达式匹配】</p><p>【剑指Offer学习】【面试题54：表示数值的字符串】</p><p>【剑指Offer学习】【面试题55：字符流中第一个不重复的字符】</p><p>【剑指Offer学习】【面试题56：链表中环的入口结点】</p><p>【剑指Offer学习】【面试题57：删除链表中重复的结点】</p><p>【剑指Offer学习】【面试题58：二叉树的下一个结点】</p><p>【剑指Offer学习】【面试题59：对称的二叉树】</p><p>【剑指Offer学习】【面试题60：把二叉树打印出多行】</p><p>第61-67题</p><p>【剑指Offer学习】【面试题61：按之字形顺序打印二叉树】</p><p>【剑指Offer学习】【面试题62：序列化二叉树】</p><p>【剑指Offer学习】【面试题63：二叉搜索树的第k个结点】</p><p>【剑指Offer学习】【面试题64：数据流中的中位数】</p><p>【剑指Offer学习】【面试题65：滑动窗口的最大值】</p><p>【剑指Offer学习】【面试题66：矩阵中的路径】</p><p>【剑指Offer学习】【面试题67：机器人的运动范围】</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>并查集</p></li><li><p>KMP</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存模型</title>
      <link href="/zhongyp.github.io/concurrency/2018-03-04-java-memory-model/"/>
      <url>/zhongyp.github.io/concurrency/2018-03-04-java-memory-model/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型（Java Memory Model，简称：JMM），下文中如果没有特殊说明，JMM即代表“Java内存模型”。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-缓存一致性"><a href="#1-1-缓存一致性" class="headerlink" title="1.1 缓存一致性"></a>1.1 缓存一致性</h3><p>在并发编程模型中，需要处理两个关键的问题：<strong>线程之间以何种机制交换信息（通信）及如何控制不同线程之间操作发生相对顺序的机制（同步）</strong>。<br>线程之间的通信机制有两种：共享内存和消息传递，每种通信机制对应不同的内存模型。<br>共享内存模型：线程之间通过读-写内存中的公共状态进行隐式通信。<br>消息传递模型：线程之间没有公共状态，线程之间必须通过发送消息来显示的进行通信。<br><strong><em>Java并发采用的是共享内存模型</em></strong>。<br>在共享的内存模型，多处理器体系架构中，每个<a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2" target="_blank" rel="noopener">处理器</a>都有自己的缓存，并且周期性的与主内存协调一致。处理器架构提供了不同级别的缓存一致性（cache coherence），有些仅提供最小的保证，几乎在任何时间内，都允许不同的处理器在相同位置上看到不同的值。<br>举个简单的例子：在java中，执行下面这个语句：</p><p><code>i  = 10++;</code></p><p>1) 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p><p>2) 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p><p>3) 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</p><p>4) 最终结果i的值是11，而不是12。这就是缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p><p><strong>注：</strong><br>同步：<strong>指程序中用于控制不同线程间操作发生相对顺序的机制</strong>，意味着某种形式的原子性或者互斥。<br>共享内存的并发模型中，同步是显式，程序员必须显示的指定某个方法或某段代码需要在线程之间互斥执行。消息传递的并发模型中，消息的发送必须在消息的接收之前，因此同步是隐式的。</p><p>想要保证每个处理器能在任意时间内获知其他处理器正在处理的工作，代价很高而且很多时候这些信息都是不必要的，所以就牺牲掉存储的一致性来保证性能。为了共享数据时能得到存储协调的保证，Java提供了自己的JMM解决与底层平台存储模型的差异化。</p><h3 id="1-2-重排序"><a href="#1-2-重排序" class="headerlink" title="1.2 重排序"></a>1.2 重排序</h3><p>除了上述的缓存一致性问题外，在执行程序时，为了提高程序的性能，使得处理器内部的运算单元被充分利用，编译器和处理器常常会对指令做重排序。<br>从Java源代码到最终执行的指令序列，会分别经历下面的三种重排序：<br><img src="/media/java-resort.png" alt="resort"><br>图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><ol><li>编译器重排序。编译器不改变单线程语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级重排序。现代处理器采用指令级并行技术将多条指令重叠执行。<strong><em>如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</em></strong></li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>编译器和处理器重排序时会遵守数据依赖性，编译器、运行时和处理器都必须遵守as-if-serial语义。<br><strong>注：</strong><br>数据依赖性：编译器和处理器不会改变存在数据以来关系的两个操作的执行顺序。<strong>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</strong><br>as-if-serial：内部线程类似顺序化语义。不管如何的重排序，单线程程序的执行结果不能被改变。</p><h4 id="1-2-1-重排序的影响"><a href="#1-2-1-重排序的影响" class="headerlink" title="1.2.1 重排序的影响"></a>1.2.1 重排序的影响</h4><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public void writer()&#123;</span><br><span class="line">        a = 1; // 1</span><br><span class="line">        flag = true; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    public void reader()&#123;</span><br><span class="line">        if (flag)&#123; // 3</span><br><span class="line">            int i = a * a; // 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设线程A先执行writrer方法，随后线程B执行reader方法，线程执行操作4时，不一定能看到1处的赋值。原因如下图：<br><img src="/media/resort.png" alt="resort"><br>图片来自<a href="#2-4-happens-before">Java并发编程艺术</a><br>由于操作1和2没有依赖关系，所以编译器和处理器可以对这两个操作重排序，线程A首先标记了flag，随后线程B读取flag。由于flag=true，线程B可以读取a，但是此时的a并为被线程A赋值。所以这里的多线程程序的语义被破坏了。JMM提供同步机制来抑制编译器、运行时和硬件对存储操作的各种方式的重排序，保证内存的可见性。                                              </p><h2 id="2-JMM设计"><a href="#2-JMM设计" class="headerlink" title="2. JMM设计"></a>2. JMM设计</h2><p><img src="/media/jmm-abs.png" alt="JMM的抽象结构"><br>JMM在内存中的抽象结构，图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><p>JMM属于语言级别的内存模型，确保在不同的编译和不同处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，决定一个线程对共享变量的写入何时对另一个线程可见，提供内存可见性保证。<br>从JDK5开始，Java使用JSR-133内存模型。JSR-133使用<strong>happens-before概念保证内存的可见性</strong>。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ol><li><p><strong><em>程序次序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</em></strong></p></li><li><p><strong><em>监视器锁规则：一个unLock操作先行发生于后面对同一个锁的lock操作。</em></strong></p></li><li><p><strong><em>volatile变量规则：对一个volatile变量的写操作，happens-before于后续对这个volatile变量的读操作。</em></strong></p></li><li><p><strong><em>传递性：如果操作A happens-before操作B，而操作B happens-before操作C，则可以得出操作A happens-before操作C。</em></strong></p></li><li><p>start()规则：Thread对象的start()方法happens-before此线程的每个一个动作</p></li><li><p>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p></li></ol><p><img src="/media/happens-before-design.png" alt="happens-before-design"><br>JMM设计图，图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><h2 id="3-JMM的可见性保证"><a href="#3-JMM的可见性保证" class="headerlink" title="3. JMM的可见性保证"></a>3. JMM的可见性保证</h2><ul><li>单线程程序。<strong><em>单线程程序不会出现内存可见性问题。</em></strong>编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li>正确<strong><em>同步</em></strong>的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。JMM通过根据happens-before原则限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li><li>未同步/未正确同步的多线程程序。JMM为他们提供最小的安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么时默认值（0、null、false）。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://www.importnew.com/24082.html" target="_blank" rel="noopener">你真的了解volatile关键字吗？</a></p><p><a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">Java中Volatile关键字详解</a></p><p><a href="">Java并发编程艺术</a></p><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a></p><p><a href="">Java并发编程实践</a></p><p><a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2" target="_blank" rel="noopener">每个程序员都应该了解的 CPU 高速缓存</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>旅行</title>
      <link href="/zhongyp.github.io/life/2017-7-5-journey/"/>
      <url>/zhongyp.github.io/life/2017-7-5-journey/</url>
      
        <content type="html"><![CDATA[<h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>旅行让我能望得辽远，想得细密，理解人生的遗憾，与这世界的好处。</p><h2 id="生活的城市"><a href="#生活的城市" class="headerlink" title="生活的城市"></a>生活的城市</h2><ul><li><p><a href="#滕州2013-9">滕州（~2013-9）</a></p></li><li><p><a href="#烟台2013-92016-7">烟台（2013-9~2016-7）</a></p></li><li><p><a href="#北京2016-7">北京（2016-7~）</a></p></li></ul><h2 id="那些值得纪念的地方"><a href="#那些值得纪念的地方" class="headerlink" title="那些值得纪念的地方"></a>那些值得纪念的地方</h2><ul><li><p><a href="#日照2010-8">日照（2010-8）</a></p></li><li><p><a href="#廊坊2012-7">廊坊（2012-7）</a></p></li><li><p><a href="#蓬莱2013-10">蓬莱（2013-10）</a></p></li><li><p><a href="#威海2015-10">威海（2015-10）</a></p></li><li><p><a href="#长岛2017-5">长岛（2017-5）</a></p></li><li><p><a href="#乌兰布统2017-7">乌兰布统（2017-7）</a></p></li></ul><h2 id="生活的城市-1"><a href="#生活的城市-1" class="headerlink" title="生活的城市"></a>生活的城市</h2><h3 id="滕州（-2013-9）"><a href="#滕州（-2013-9）" class="headerlink" title="滕州（~2013-9）"></a>滕州（~2013-9）</h3><h3 id="烟台（2013-9-2016-7）"><a href="#烟台（2013-9-2016-7）" class="headerlink" title="烟台（2013-9~2016-7）"></a>烟台（2013-9~2016-7）</h3><p>大学四年（其实只呆过三年）生活的地方。四年也没去过多少地方，大都时间都在瞎忙，等过了最闲暇的时光，才知道自己错过太多。</p><h3 id="北京（2016-7-）"><a href="#北京（2016-7-）" class="headerlink" title="北京（2016-7~）"></a>北京（2016-7~）</h3><!--![1](/media/photo/DSC_2616.jpg)![1](/media/photo/DSC_2617.jpg)![1](/media/photo/DSC_2618.jpg)![1](/media/photo/DSC_2709.jpg)![1](/media/photo/DSC_2739.jpg)![1](/media/photo/DSC_2741.jpg)![1](/media/photo/DSC_2745.jpg)![1](/media/photo/DSC_2746.jpg)![1](/media/photo/DSC_2747.jpg)![1](/media/photo/DSC_2748.jpg)![1](/media/photo/DSC_2751.jpg)![1](/media/photo/DSC_2767.jpg)![1](/media/photo/DSC_2769.jpg)![1](/media/photo/DSC_2776.jpg)![1](/media/photo/DSC_2779.jpg)--><h2 id="那些值得纪念的地方-1"><a href="#那些值得纪念的地方-1" class="headerlink" title="那些值得纪念的地方"></a>那些值得纪念的地方</h2><h3 id="日照（2010-8）"><a href="#日照（2010-8）" class="headerlink" title="日照（2010-8）"></a>日照（2010-8）</h3><h3 id="廊坊（2012-7）"><a href="#廊坊（2012-7）" class="headerlink" title="廊坊（2012-7）"></a>廊坊（2012-7）</h3><h3 id="蓬莱（2013-10）"><a href="#蓬莱（2013-10）" class="headerlink" title="蓬莱（2013-10）"></a>蓬莱（2013-10）</h3><h3 id="威海（2015-10）"><a href="#威海（2015-10）" class="headerlink" title="威海（2015-10）"></a>威海（2015-10）</h3><h3 id="长岛（2017-5）"><a href="#长岛（2017-5）" class="headerlink" title="长岛（2017-5）"></a>长岛（2017-5）</h3><h3 id="乌兰布统（2017-7）"><a href="#乌兰布统（2017-7）" class="headerlink" title="乌兰布统（2017-7）"></a>乌兰布统（2017-7）</h3><h3 id="济南（2018-5）"><a href="#济南（2018-5）" class="headerlink" title="济南（2018-5）"></a>济南（2018-5）</h3><h3 id="西安（2018-10）"><a href="#西安（2018-10）" class="headerlink" title="西安（2018-10）"></a>西安（2018-10）</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>书单</title>
      <link href="/zhongyp.github.io/life/2017-1-1-books/"/>
      <url>/zhongyp.github.io/life/2017-1-1-books/</url>
      
        <content type="html"><![CDATA[<blockquote><p>夫君子之行，静以修身，俭以养德。非澹泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！</p></blockquote><p>– 2017、2018、2019年书单</p><h2 id="书架👈🏻👈🏻👈🏻"><a href="#书架👈🏻👈🏻👈🏻" class="headerlink" title="书架👈🏻👈🏻👈🏻"></a><a href="https://github.com/zhongyp/mybook" target="_blank" rel="noopener">书架👈🏻👈🏻👈🏻</a></h2><ul><li><p>architecture</p><ul><li>SOA服务管控和治理四.pdf</li><li>Zabbi 监控系统深度实践 带书签目录 完整版.pdf</li><li>ZooKeeper在携程的使用和场景.pdf</li><li>zookeeper双数据中心容灾研究.pdf</li><li>中国区块链技术和应用发展白皮书.pdf</li><li>亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统.pdf</li><li>从PAXOS到ZOOKEEPER分布式一致性原理与实践.pdf</li><li>全面认识微服务&amp;SpringCloud_Jack_张振华.pdf</li><li>分布式Java应用：基础与实践.pdf</li><li>分布式服务框架原理与实践_李林锋著.pdf</li><li>分布式混合云DevOps实践.pdf</li><li>基于区块链的分布式超级计算项目（分布式渲染） supercomputing.pdf</li><li>大型分布式网站架构设计与实践.带目录书签.完整版.pdf</li><li>大型网站系统与Java中间件实践(jb51.net).pdf</li><li>大数据 互联网大规模数据挖掘与分布式处理 第2版 2015.7.pdf</li><li>尽在双⒒_阿里巴巴技术演进与超越.pdf</li><li>微信 朋友圈技术之道wechat_moments_architecture_201512.pdf</li><li>微服务架构如何落地实践.pdf</li><li>服务治理中间件dubbo原理解析.pdf</li><li>程序员必读之软件架构.pdf</li><li>阿里分布式消息系统ONS原理与实践.pdf</li></ul></li><li><p>chm</p><ul><li>JAVA设计模式.chm    </li><li>Spring2.5-.chm</li></ul></li><li><p>coder</p><ul><li>Effective Java第二版</li><li>Go语言实战</li><li>Netty权威指南</li><li>利用python进行数据分析</li><li>Netty实战.epub</li><li>Netty实战.mobi</li><li>UNIX环境高级编程（中文第2版）.pdf</li><li>UNIX网络编程卷1：套接字联网API（第3版）.pdf</li><li>UNIX网络编程卷2：进程间通信（第2版）.pdf</li></ul></li><li><p>java</p><ul><li>Java_TCPIP_Socket网络编程</li><li>Java并发艺术</li><li>Effective Java第二版</li><li>Effective Unit Testing</li><li>Java8实战</li><li>Java NIO（中文版）</li><li>Java多线程设计模式</li><li>Java并发编程实践</li><li>Java问题定位技术</li><li>TCP-IP详解卷一</li><li>实战Java高并发程序设计</li></ul></li><li><p>smart</p><ul><li>周志华-机器学习</li><li>周志华-数据挖掘与机器学习</li><li>Spark机器学习</li><li>Machine Learning in Action</li><li>机器学习十大算法</li><li>机器学习实战</li><li>Machine Learning in Action SourceCode</li></ul></li><li><p>framework</p><ul><li>Hibernate开发指南</li><li>SpringGuide</li><li>Spring源码深度解析</li><li>dubbo源码解析2.0</li><li>ZooKeeper</li><li>Dubbo设计原则和实现原理</li><li>Dubbo监控中心的介绍与简易监控中心的安装</li><li>Dubbo-基础篇-持续集成篇-Hudson持续集成服务器的安装配置与使用</li><li>Jenkins权威指南</li><li>Spring boot实战（丁雪丰）</li><li>Spring boot张卫滨</li><li>分布式系统原理与范型</li><li>框架设计原则（梁飞）</li><li>Dubbo项目结构解析</li><li>Kafka深度解析</li></ul></li></ul><ul><li><p>database</p><ul><li>高性能MySQL 第3版</li><li>MySQL技术内幕</li><li>Redis实战</li><li>MongoDB权威指南</li><li>MyCat_In_Action_中文版</li><li>Oracle 11g 从入门到精通</li><li>redis设计与实现</li><li>网易分布式数据库DDB</li></ul></li><li><p>utils</p><ul><li>Git和特性开发</li><li>HTTPS权威指南</li><li>idea使用教程</li><li>intellij idea 快捷键整理</li><li>Linux命令行与shell脚本编程大全</li><li>Nginx开发</li><li>Shell高级编程（中文版）</li><li>深入理解JVM虚拟机</li></ul></li></ul><ul><li>other<ul><li>产品经理手册</li><li>经济学原理</li><li>你要如何衡量你的人生</li><li>牛津通识精选</li><li>三体2 黑暗森林</li><li>手把手教你读财报</li><li>More Effective C++</li><li>[英]-奥斯丁-傲慢与偏见.mobi</li><li>东野圭吾《信》.mobi</li><li>人类简史.mobi</li><li>你的第一本哲学书.mobi</li><li>关键对话.mobi</li><li>叶嘉莹先生作品10册套装.mobi</li><li>在路上</li><li>在路上.mobi</li><li>如何听如何说-莫提默·J.艾德勒.mobi</li><li>如何阅读一本书.mobi</li><li>学会提问-尼尔•布朗.mobi    </li><li>当年明月-明朝那些事儿（1-9）.mobi</li><li>批判性思维工具-理查德•保罗.mobi</li><li>把时间当作朋友（第3版）.mobi</li><li>指数基金投资指南-银行螺丝钉.mobi</li><li>最好的告别.mobi</li><li>杀死一只知更鸟史上最受喜爱的小说之一畅销全球的良知启蒙善良与爱不可辜负.mobi</li><li>百年孤独-加西亚·马尔克斯.mobi</li><li>远山淡影+-+[Ӣ]+石黑一雄.mobi</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冒泡排序</title>
      <link href="/zhongyp.github.io/algorithm/2015-08-04-BubbleSort/"/>
      <url>/zhongyp.github.io/algorithm/2015-08-04-BubbleSort/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>冒泡排序是依次比较数列相邻的两个数字的大小，按照从大到小或者从小到大的规则进行交换，重复遍历数列直至没有可交换的数列，排序完成。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>数列：[3,5,1,7,4]</p><p>规则：从小到大</p><p>排序：</p><ul><li>比较3-5，5大于3，不交换，数列不变[3,5,1,7,4]</li><li>比较5-1,5大于1，交换，数列变化[3,1,5,7,4]</li><li>比较5-7,7大于5，不交换，数列不变[3,1,5,7,4]</li><li>比较7-4,7大约4，交换，数列变化[3,1,5,4,7]</li><li>然后重复遍历数列,直至最后没有可以交换的数列。</li></ul><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    public static void bubbleSort()&#123;</span><br><span class="line">//        int[] arr = &#123;3,5,7,1,4&#125;;</span><br><span class="line">        int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">        int i,j,temp,len=arr.length;</span><br><span class="line">        //是否已经完成排序的标志</span><br><span class="line">        boolean flag;</span><br><span class="line">        //排序</span><br><span class="line">        for(i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            for(j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">                if(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    flag = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                System.out.println(&quot;第&quot; + (i+1) + &quot;趟结束了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出数组</span><br><span class="line">        for(int o:arr)&#123;</span><br><span class="line">            System.out.print(&quot; &quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>最坏情况下：第1趟排序需要比较(n-1)次，… 第(n-1)趟比较1次，O(n)=((n-1)+1)<em>(n-1)/2=n</em>(n-1)/2=n^2。</p><p>最好情况下：比较(n-1)次。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
