<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>阻塞与非阻塞队列</title>
      <link href="/concurrency/2020-01-07/"/>
      <url>/concurrency/2020-01-07/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lambda表达式的使用</title>
      <link href="/concurrency/2019-12-26-java-lambda/"/>
      <url>/concurrency/2019-12-26-java-lambda/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>匿名类有一个问题是，如果你的匿名类的实现非常简单，比如一个接口仅仅包含一个方法，那么匿名类的语法可能是笨重和模糊的。比如当一个人点击一个按钮应该执行什么动作，在这种情况下，你通常以一个方法作为参数传到另一个方法。lambda表达式允许你将方法作为另一个方法的参数，或者代码作为数据。</p><h3 id="2-Lambda表达式的理想用例"><a href="#2-Lambda表达式的理想用例" class="headerlink" title="2. Lambda表达式的理想用例"></a>2. Lambda表达式的理想用例</h3><h4 id="第1步-创建搜索符合一个特征的成员的方法"><a href="#第1步-创建搜索符合一个特征的成员的方法" class="headerlink" title="第1步. 创建搜索符合一个特征的成员的方法"></a>第1步. 创建搜索符合一个特征的成员的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersonsOlderThan(List&lt;Person&gt; roster, int age) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (p.getAge() &gt;= age) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第2步-创建更通用搜索方法"><a href="#第2步-创建更通用搜索方法" class="headerlink" title="第2步. 创建更通用搜索方法"></a>第2步. 创建更通用搜索方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersonsWithinAgeRange(</span><br><span class="line">    List&lt;Person&gt; roster, int low, int high) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第3步-在本地类中指定搜索条件代码"><a href="#第3步-在本地类中指定搜索条件代码" class="headerlink" title="第3步. 在本地类中指定搜索条件代码"></a>第3步. 在本地类中指定搜索条件代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersons(List&lt;Person&gt; roster, CheckPerson tester) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface CheckPerson &#123;</span><br><span class="line">    boolean test(Person p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CheckPersonEligibleForSelectiveService implements CheckPerson &#123;</span><br><span class="line">    public boolean test(Person p) &#123;</span><br><span class="line">        return p.gender == Person.Sex.MALE &amp;&amp;</span><br><span class="line">            p.getAge() &gt;= 18 &amp;&amp;</span><br><span class="line">            p.getAge() &lt;= 25;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printPersons(roster, new CheckPersonEligibleForSelectiveService());</span><br></pre></td></tr></table></figure><h4 id="第4步-在匿名类中指定搜索条件代码"><a href="#第4步-在匿名类中指定搜索条件代码" class="headerlink" title="第4步. 在匿名类中指定搜索条件代码"></a>第4步. 在匿名类中指定搜索条件代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    new CheckPerson() &#123;</span><br><span class="line">        public boolean test(Person p) &#123;</span><br><span class="line">            return p.getGender() == Person.Sex.MALE</span><br><span class="line">                &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">                &amp;&amp; p.getAge() &lt;= 25;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第5步-使用Lambda表达式指定搜索条件代码"><a href="#第5步-使用Lambda表达式指定搜索条件代码" class="headerlink" title="第5步. 使用Lambda表达式指定搜索条件代码"></a>第5步. 使用Lambda表达式指定搜索条件代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    (Person p) -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第6步-将标准功能接口与Lambda表达式一起使用"><a href="#第6步-将标准功能接口与Lambda表达式一起使用" class="headerlink" title="第6步. 将标准功能接口与Lambda表达式一起使用"></a>第6步. 将标准功能接口与Lambda表达式一起使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface CheckPerson &#123;</span><br><span class="line">    boolean test(Person p);</span><br><span class="line">&#125;</span><br><span class="line">interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br><span class="line">interface Predicate&lt;Person&gt; &#123;</span><br><span class="line">    boolean test(Person t);</span><br><span class="line">&#125;</span><br><span class="line">public static void printPersonsWithPredicate(</span><br><span class="line">    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPersonsWithPredicate(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第7步-在整个应用程序中使用Lambda表达式"><a href="#第7步-在整个应用程序中使用Lambda表达式" class="headerlink" title="第7步. 在整个应用程序中使用Lambda表达式"></a>第7步. 在整个应用程序中使用Lambda表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">printPersonsWithPredicate(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line">);</span><br><span class="line">public static void processPersons(</span><br><span class="line">    List&lt;Person&gt; roster,</span><br><span class="line">    Predicate&lt;Person&gt; tester,</span><br><span class="line">    Consumer&lt;Person&gt; block) &#123;</span><br><span class="line">        for (Person p : roster) &#123;</span><br><span class="line">            if (tester.test(p)) &#123;</span><br><span class="line">                block.accept(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">processPersons(</span><br><span class="line">     roster,</span><br><span class="line">     p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">         &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">         &amp;&amp; p.getAge() &lt;= 25,</span><br><span class="line">     p -&gt; p.printPerson()</span><br><span class="line">);</span><br><span class="line">public static void processPersonsWithFunction(</span><br><span class="line">    List&lt;Person&gt; roster,</span><br><span class="line">    Predicate&lt;Person&gt; tester,</span><br><span class="line">    Function&lt;Person, String&gt; mapper,</span><br><span class="line">    Consumer&lt;String&gt; block) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            String data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">processPersonsWithFunction(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第8步-更广泛的使用泛型"><a href="#第8步-更广泛的使用泛型" class="headerlink" title="第8步. 更广泛的使用泛型"></a>第8步. 更广泛的使用泛型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;X, Y&gt; void processElements(</span><br><span class="line">    Iterable&lt;X&gt; source,</span><br><span class="line">    Predicate&lt;X&gt; tester,</span><br><span class="line">    Function &lt;X, Y&gt; mapper,</span><br><span class="line">    Consumer&lt;Y&gt; block) &#123;</span><br><span class="line">    for (X p : source) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            Y data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">processElements(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="第9步-使用接受Lambda表达式作为参数的聚集操作"><a href="#第9步-使用接受Lambda表达式作为参数的聚集操作" class="headerlink" title="第9步. 使用接受Lambda表达式作为参数的聚集操作"></a>第9步. 使用接受Lambda表达式作为参数的聚集操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(</span><br><span class="line">        p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">            &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">            &amp;&amp; p.getAge() &lt;= 25)</span><br><span class="line">    .map(p -&gt; p.getEmailAddress())</span><br><span class="line">    .forEach(email -&gt; System.out.println(email));</span><br></pre></td></tr></table></figure><h3 id="3-Lambda表达式的语法"><a href="#3-Lambda表达式的语法" class="headerlink" title="3. Lambda表达式的语法"></a>3. Lambda表达式的语法</h3><ul><li>用括号括起来的形式参数的逗号分隔列表。 CheckPerson.test方法包含一个参数p，它表示Person类的一个实例。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; p.getGender() == Person.Sex.MALE </span><br><span class="line">    &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">    &amp;&amp; p.getAge() &lt;= 25</span><br></pre></td></tr></table></figure><ul><li><p>箭头标记： -&gt;</p></li><li><p>一个主体，包含一个单个表达式或者一个声明块。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">p.getGender() == Person.Sex.MALE </span><br><span class="line">    &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">    &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line"></span><br><span class="line">p -&gt; &#123;</span><br><span class="line">    return p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">email -&gt; System.out.println(email)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Calculator &#123;</span><br><span class="line">  </span><br><span class="line">    interface IntegerMath &#123;</span><br><span class="line">        int operation(int a, int b);   </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public int operateBinary(int a, int b, IntegerMath op)&#123;</span><br><span class="line">        return op.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">    </span><br><span class="line">        Calculator myApp = new Calculator();</span><br><span class="line">        IntegerMath addition = (a, b) -&gt; a + b;</span><br><span class="line">        IntegerMath subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        System.out.println(&quot;40 + 2 = &quot; +</span><br><span class="line">            myApp.operateBinary(40, 2, addition));</span><br><span class="line">        System.out.println(&quot;20 - 10 = &quot; +</span><br><span class="line">            myApp.operateBinary(20, 10, subtraction));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-访问封闭范围的局部变量"><a href="#4-访问封闭范围的局部变量" class="headerlink" title="4. 访问封闭范围的局部变量"></a>4. 访问封闭范围的局部变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class LambdaScopeTest &#123;</span><br><span class="line"></span><br><span class="line">    public int x = 0;</span><br><span class="line"></span><br><span class="line">    class FirstLevel &#123;</span><br><span class="line"></span><br><span class="line">        public int x = 1;</span><br><span class="line"></span><br><span class="line">        void methodInFirstLevel(int x) &#123;</span><br><span class="line">            </span><br><span class="line">            // The following statement causes the compiler to generate</span><br><span class="line">            // the error &quot;local variables referenced from a lambda expression</span><br><span class="line">            // must be final or effectively final&quot; in statement A:</span><br><span class="line">            //</span><br><span class="line">            // x = 99;</span><br><span class="line">            </span><br><span class="line">            Consumer&lt;Integer&gt; myConsumer = (y) -&gt; </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;x = &quot; + x); // Statement A</span><br><span class="line">                System.out.println(&quot;y = &quot; + y);</span><br><span class="line">                System.out.println(&quot;this.x = &quot; + this.x);</span><br><span class="line">                System.out.println(&quot;LambdaScopeTest.this.x = &quot; +</span><br><span class="line">                    LambdaScopeTest.this.x);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            myConsumer.accept(x);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        LambdaScopeTest st = new LambdaScopeTest();</span><br><span class="line">        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(23);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 23</span><br><span class="line">y = 23</span><br><span class="line">this.x = 1</span><br><span class="line">LambdaScopeTest.this.x = 0</span><br></pre></td></tr></table></figure><p>局部类有权访问其所在类的成员。此外，局部类可以访问局部变量。但是，局部类只能访问声明为final的局部变量（对于非final的数据也能访问，但是不能赋值）。当局部类访问封闭块的局部变量或参数时，它将捕获该变量或参数。</p><p>Lambda表达式和匿名类、局部类类似，它可以捕获变量，但是Lambda表达式不会出现匿名类和局部类的变量遮蔽问题，如下 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ShadowTest &#123;</span><br><span class="line"></span><br><span class="line">    public int x = 0;</span><br><span class="line"></span><br><span class="line">    class FirstLevel &#123;</span><br><span class="line"></span><br><span class="line">        public int x = 1;</span><br><span class="line"></span><br><span class="line">        void methodInFirstLevel(int x) &#123;</span><br><span class="line">            System.out.println(&quot;x = &quot; + x);</span><br><span class="line">            System.out.println(&quot;this.x = &quot; + this.x);</span><br><span class="line">            System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.this.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        ShadowTest st = new ShadowTest();</span><br><span class="line">        ShadowTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(23);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 23</span><br><span class="line">this.x = 1</span><br><span class="line">ShadowTest.this.x = 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaScopeTest &#123;</span><br><span class="line"></span><br><span class="line">    public int x = 0;</span><br><span class="line"></span><br><span class="line">    class FirstLevel &#123;</span><br><span class="line"></span><br><span class="line">        public int x = 1;</span><br><span class="line"></span><br><span class="line">        void methodInFirstLevel(int x) &#123;</span><br><span class="line">            </span><br><span class="line">            // The following statement causes the compiler to generate</span><br><span class="line">            // the error &quot;local variables referenced from a lambda expression</span><br><span class="line">            // must be final or effectively final&quot; in statement A:</span><br><span class="line">            //</span><br><span class="line">            // x = 99;</span><br><span class="line">            </span><br><span class="line">            Consumer&lt;Integer&gt; myConsumer = (y) -&gt; </span><br><span class="line">            &#123;</span><br><span class="line">                // 直接访问methodInFirstLevel方法参数</span><br><span class="line">                System.out.println(&quot;x = &quot; + x); // Statement A</span><br><span class="line">                // Lamda表达式参数</span><br><span class="line">                System.out.println(&quot;y = &quot; + y);</span><br><span class="line">                // FirstLevel参数</span><br><span class="line">                System.out.println(&quot;this.x = &quot; + this.x);</span><br><span class="line">                // LambdaScopeTest参数 </span><br><span class="line">                System.out.println(&quot;LambdaScopeTest.this.x = &quot; +</span><br><span class="line">                    LambdaScopeTest.this.x);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            myConsumer.accept(x);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        LambdaScopeTest st = new LambdaScopeTest();</span><br><span class="line">        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(23);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 23</span><br><span class="line">y = 23</span><br><span class="line">this.x = 1</span><br><span class="line">LambdaScopeTest.this.x = 0</span><br></pre></td></tr></table></figure></p><p>但是，从Java SE 8开始，局部类可以访问final变量或具有final效果的局部变量和封闭块的参数。如果你在一个方法内定义局部类，它可以访问方法的参数。Lambda表达式同样如此。</p><h3 id="5-目标类型和方法参数"><a href="#5-目标类型和方法参数" class="headerlink" title="5. 目标类型和方法参数"></a>5. 目标类型和方法参数</h3><p>对于方法参数，Java编译器使用其他两种语言特性确定目标类型：重载解析和类型参数推断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void invoke(Runnable r) &#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T invoke(Callable&lt;T&gt; c) &#123;</span><br><span class="line">    return c.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-序列化"><a href="#6-序列化" class="headerlink" title="6. 序列化"></a>6. 序列化</h3><p>如果lambda表达式的目标类型和捕获的参数可序列化，则可以对其进行序列化。但是，像内部类一样，强烈建议不要对lambda表达式进行序列化。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda Expressions</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 8 Stream</title>
      <link href="/java/2019-12-25-java8-stream/"/>
      <url>/java/2019-12-25-java8-stream/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Java8-Stream"><a href="#什么是Java8-Stream" class="headerlink" title="什么是Java8 Stream"></a>什么是Java8 Stream</h2><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚集操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。</p><p>A pipeline is a sequence of aggregate operations. The following example prints the male members contained in the collection roster with a pipeline that consists of the aggregate operations filter and forEach:</p><p>管道是一个聚集操作的序列。下面的例子使用包含聚集操作filter和forEach的管道打印包含在roster集合中男性成员的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(e -&gt; e.getGender() == Person.Sex.MALE)</span><br><span class="line">    .forEach(e -&gt; System.out.println(e.getName()));</span><br></pre></td></tr></table></figure><p>管道包含如下的组件：</p><ul><li>一个源：可以是一个集合、数组、一个生成方法，或者I/O channel。</li><li>零个或者多个中间操作。一个中间操作，例如filter，生成一个流。</li><li>一个终止操作，一个终止操作例如forEach，产生一个非流结果。例如原始值（如double值），集合，或者在forEach的情况下根本没有任何值。 </li></ul><blockquote><p>流是一个元素的序列。不像一个集合，它不是一个数据结构存储元素。相反，一个流通过管道从一个源中提取值。filter操作返回一个包含匹配它断言的要素集的新流。</p></blockquote><h2 id="聚集操作相比于Iterator的不同"><a href="#聚集操作相比于Iterator的不同" class="headerlink" title="聚集操作相比于Iterator的不同"></a>聚集操作相比于Iterator的不同</h2><ul><li>使用内部遍历： 聚集操作不包含类似于指示处理集合内的下一个元素的next方法。使用内部委派，你的应用程序确定要迭代的集合，而JDK确定如何迭代该集合。使用外部迭代，你的应用决定它迭代什么集合和它怎样迭代。但是，外部迭代仅仅可以有序的迭代集合的元素。内部迭代没有这个限制，它可以更好的发挥并行计算的优势，它可以将问题分发为子问题，同时解决这些问题，然后将解决子问题方案的结果组合。</li><li>从流中处理元素：聚集操作从流中处理元素，不是直接从集合中。因此，它们也称作流操作。</li><li>他们支持行为作为参数：对于大多数聚集操作你可以指定lambda表达式作为参数，这允许你自定义一个特定的聚集操作的行为动作。</li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><code>boolean    allMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether all elements of this stream match the provided predicate.</li><li><code>boolean    anyMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether any elements of this stream match the provided predicate.</li><li><code>static &lt;T&gt; Stream.Builder&lt;T&gt; builder()</code><br>Returns a builder for a Stream.</li><li><code>&lt;R,A&gt; R    collect(Collector&lt;? super T,A,R&gt; collector)</code><br>Performs a mutable reduction operation on the elements of this stream using a Collector.</li><li><code>&lt;R&gt; R    collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code><br>Performs a mutable reduction operation on the elements of this stream.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code><br>Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.</li><li><code>long    count()</code><br>Returns the count of elements in this stream.</li><li><code>Stream&lt;T&gt;    distinct()</code><br>Returns a stream consisting of the distinct elements (according to Object.equals(Object)) of this stream.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    empty()</code><br>Returns an empty sequential Stream.</li><li><code>Stream&lt;T&gt;    filter(Predicate&lt;? super T&gt; predicate)</code><br>Returns a stream consisting of the elements of this stream that match the given predicate.</li><li><code>Optional&lt;T&gt;    findAny()</code><br>Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.</li><li><code>Optional&lt;T&gt;    findFirst()</code><br>Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty.</li><li><code>&lt;R&gt; Stream&lt;R&gt;    flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code><br>Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>DoubleStream    flatMapToDouble(Function&lt;? super T,? extends DoubleStream&gt; mapper)</code><br>Returns an DoubleStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>IntStream    flatMapToInt(Function&lt;? super T,? extends IntStream&gt; mapper)</code><br>Returns an IntStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>LongStream    flatMapToLong(Function&lt;? super T,? extends LongStream&gt; mapper)</code><br>Returns an LongStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>void    forEach(Consumer&lt;? super T&gt; action)</code><br>Performs an action for each element of this stream.</li><li><code>void    forEachOrdered(Consumer&lt;? super T&gt; action)</code><br>Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    generate(Supplier&lt;T&gt; s)</code><br>Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    iterate(T seed, UnaryOperator&lt;T&gt; f)</code><br>Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.</li><li><code>Stream&lt;T&gt;    limit(long maxSize)</code><br>Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.</li><li><code>&lt;R&gt; Stream&lt;R&gt;    map(Function&lt;? super T,? extends R&gt; mapper)</code><br>Returns a stream consisting of the results of applying the given function to the elements of this stream.</li><li><code>DoubleStream    mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code><br>Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>IntStream    mapToInt(ToIntFunction&lt;? super T&gt; mapper)</code><br>Returns an IntStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>LongStream    mapToLong(ToLongFunction&lt;? super T&gt; mapper)</code><br>Returns a LongStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>Optional&lt;T&gt;    max(Comparator&lt;? super T&gt; comparator)</code><br>Returns the maximum element of this stream according to the provided Comparator.</li><li><code>Optional&lt;T&gt;    min(Comparator&lt;? super T&gt; comparator)</code><br>Returns the minimum element of this stream according to the provided Comparator.</li><li><code>boolean    noneMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether no elements of this stream match the provided predicate.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    of(T... values)</code><br>Returns a sequential ordered stream whose elements are the specified values.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    of(T t)</code><br>Returns a sequential Stream containing a single element.</li><li><code>Stream&lt;T&gt;    peek(Consumer&lt;? super T&gt; action)</code><br>Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.</li><li><code>Optional&lt;T&gt;    reduce(BinaryOperator&lt;T&gt; accumulator)</code><br>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.</li><li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code><br>Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.</li><li><code>&lt;U&gt; U    reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</code><br>Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions.</li><li><code>Stream&lt;T&gt;    skip(long n)</code><br>Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream.</li><li><code>Stream&lt;T&gt;    sorted()</code><br>Returns a stream consisting of the elements of this stream, sorted according to natural order.</li><li><code>Stream&lt;T&gt;    sorted(Comparator&lt;? super T&gt; comparator)</code><br>Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.</li><li><code>Object[]    toArray()</code><br>Returns an array containing the elements of this stream.</li><li><code>&lt;A&gt; A[]    toArray(IntFunction&lt;A[]&gt; generator)</code><br>Returns an array containing the elements of this stream, using the provided generator function to allocate the returned array, as well as any additional arrays that might be required for a partitioned execution or for resizing.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">Java 8 中的 Streams API 详解-陈争云, 占宇剑, 和司磊</a></p><p><a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html#pipelines" target="_blank" rel="noopener">Pipelines and Streams</a></p><p><a href="https://docs.oracle.com/javase/10/index.html" target="_blank" rel="noopener">Java™ Platform Standard Ed. 8</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初探 Spring Boot</title>
      <link href="/spring/2019-12-13-spring-boot-init/"/>
      <url>/spring/2019-12-13-spring-boot-init/</url>
      
        <content type="html"><![CDATA[<h2 id="1-起步"><a href="#1-起步" class="headerlink" title="1. 起步"></a>1. 起步</h2><h3 id="1-1-Spring-Boot启动"><a href="#1-1-Spring-Boot启动" class="headerlink" title="1.1 Spring Boot启动"></a>1.1 Spring Boot启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//开启组件扫描和自动配置@SpringBootApplication</span><br><span class="line">public class ReadingListApplication &#123;</span><br><span class="line"> public static void main(String[] args) &#123; </span><br><span class="line">    SpringApplication.run(ReadingListApplication.class, args);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@SpringBootApplication开启了Spring的组件扫描和Spring Boot的自动配置功能。实际上，@SpringBootApplication将三个有用的注解组合在了一起。</p><ul><li>Spring的@Configuration:标明该类使用Spring基于Java的配置。虽然本书不会写太多配置，但我们会更倾向于使用基于Java而不是XML的配置。</li><li>Spring的@ComponentScan:启用组件扫描，这样你写的Web控制器类和其他组件才能被 自动发现并注册为Spring应用程序上下文里的Bean。本章稍后会写一个简单的Spring MVC控制器，使用@Controller进行注解，这样组件扫描才能找到它。</li><li>Spring Boot的@EnableAutoConfiguration:这个不起眼的小注解也可以称为 @Abracadabra1，就是这一行配置开启了Spring Boot自动配置的魔力，让你不用再写成篇的配置了</li></ul><h3 id="1-2-Spring-Boot测试"><a href="#1-2-Spring-Boot测试" class="headerlink" title="1.2 Spring Boot测试"></a>1.2 Spring Boot测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(classes = ReadingListApplication.class) @WebAppConfiguration</span><br><span class="line">public class ReadingListApplicationTests &#123;</span><br><span class="line">  @Test</span><br><span class="line">  public void contextLoads() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadingListApplication.class不止是个用于测试的占位符，它还是一个例 子，告诉你如何为Spring Boot应用程序编写测试。</p><h3 id="1-3-Spring-Boot构建过程"><a href="#1-3-Spring-Boot构建过程" class="headerlink" title="1.3 Spring Boot构建过程"></a>1.3 Spring Boot构建过程</h3><p>构建插件的主要功能是把项目打包成一个可执行的超级JAR(uber-JAR)，包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行 应用程序。</p><p>除了构建插件，Maven构建说明中还将spring-boot-starter-parent作为上一级，这样就能利用Maven的依赖管理功能。继承很多常用库的依赖版本，注意这个pom.xml里的<denpendency>都没有指定版本。</denpendency></p><h3 id="1-4-起步依赖"><a href="#1-4-起步依赖" class="headerlink" title="1.4 起步依赖"></a>1.4 起步依赖</h3><p>Spring Boot通过提供众多起步依赖降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型(Project Object Model，POM)，定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。</p><p>起步依赖和你项目里的其他依赖没什么区别。也就是说，你可以通过构建工具中的功能，选择性地覆盖它们引入的传递依赖的版本号，排除传递依赖，当然还可以为那些Spring Boot起步依赖没有涵盖的库指定依赖。<br>以Spring Boot的Web起步依赖为例，它传递依赖了Jackson JSON库。如果你正在构建一个生产或消费JSON资源表述的REST服务，那它会很有用。但是，要构建传统的面向人类用户的Web应用程序，你可能用不上Jackson。虽然把它加进来也不会有什么坏处，但排除掉它的传递依赖，可以为你的项目瘦身。</p><p>Maven总是会用最近的依赖，也就是说，你在项目的构建说明文件里增加的这个依赖，会覆 盖传递依赖引入的另一个依赖。</p><h3 id="1-5-使用自动配置"><a href="#1-5-使用自动配置" class="headerlink" title="1.5 使用自动配置"></a>1.5 使用自动配置</h3><p>Spring Boot的自动配置是一个运行时的过程，考虑了众多因素才决定Spring配置用哪个。</p><p>例如：</p><ul><li>Spring的JdbcTemplate是不是在Classpath里?如果是，并且有DataSource的Bean，则自动配置一个JdbcTemplate的Bean。</li><li>Thymeleaf是不是在Classpath里?如果是，则配置Thymeleaf的模板解析器、视图解析器以<br>及模板引擎。</li><li>Spring Security是不是在Classpath里?如果是，则进行一个非常基本的Web安全设置。</li></ul><h3 id="1-6-定义领域模型"><a href="#1-6-定义领域模型" class="headerlink" title="1.6 定义领域模型"></a>1.6 定义领域模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Book &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy=GenerationType.AUTO) 7 private Long id;</span><br><span class="line">    private String reader;</span><br><span class="line">    private String isbn;</span><br><span class="line">    private String title;</span><br><span class="line">    private String author;</span><br><span class="line">    private String description;</span><br><span class="line">    </span><br><span class="line">    set...();</span><br><span class="line">    ...</span><br><span class="line">    get...();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-定义仓库接口"><a href="#1-7-定义仓库接口" class="headerlink" title="1.7 定义仓库接口"></a>1.7 定义仓库接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line">public interface ReadingListRepository extends JpaRepository&lt;Book, Long&gt; &#123; </span><br><span class="line">    List&lt;Book&gt; findByReader(String reader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过扩展JpaRepository，ReadingListRepository直接继承了18个执行常用持久化操作的方法。JpaRepository是个泛型接口，有两个参数:仓库操作的领域对象类型，及其ID属性的类型。此外，我还增加了一个findByReader()方法，可以根据读者的用户名来查找阅读列表。</p><h3 id="1-8-创建Web"><a href="#1-8-创建Web" class="headerlink" title="1.8 创建Web"></a>1.8 创建Web</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/&quot;)</span><br><span class="line">public class ReadingListController &#123;</span><br><span class="line">      private ReadingListRepository readingListRepository;</span><br><span class="line">      @Autowired</span><br><span class="line">      public ReadingListController(ReadingListRepository readingListRepository) </span><br><span class="line">      &#123; </span><br><span class="line">        this.readingListRepository = readingListRepository;</span><br><span class="line">      &#125;</span><br><span class="line">      @RequestMapping(value=&quot;/&#123;reader&#125;&quot;, method=RequestMethod.GET) </span><br><span class="line">      public String readersBooks(@PathVariable(&quot;reader&quot;) String reader,Model model) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; readingList = readingListRepository.findByReader(reader);</span><br><span class="line">        if (readingList != null) &#123; </span><br><span class="line">            model.addAttribute(&quot;books&quot;, readingList);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;readingList&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      @RequestMapping(value=&quot;/&#123;reader&#125;&quot;, method=RequestMethod.POST) </span><br><span class="line">      public String addToReadingList(@PathVariable(&quot;reader&quot;) String reader, Book book) &#123; </span><br><span class="line">        book.setReader(reader);</span><br><span class="line">        readingListRepository.save(book);</span><br><span class="line">        return &quot;redirect:/&#123;reader&#125;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-自定义配置"><a href="#2-自定义配置" class="headerlink" title="2. 自定义配置"></a>2. 自定义配置</h2><h3 id="2-1-覆盖自动配置"><a href="#2-1-覆盖自动配置" class="headerlink" title="2.1 覆盖自动配置"></a>2.1 覆盖自动配置</h3><p>有些时候Spring Boot的自动配置并不能覆盖你的需求，需要自定义一些配置覆盖自动配置。</p><p>想要覆盖Spring Boot的自动配置，仅仅需要编写一个显式的配置。</p><p>自动配置自带了很多配置类，他们都使用了Spring 4.0的条件化配置，可以在运行时判断是该被运用还是该被忽略。</p><h3 id="2-2-通过属性文件外置配置"><a href="#2-2-通过属性文件外置配置" class="headerlink" title="2.2 通过属性文件外置配置"></a>2.2 通过属性文件外置配置</h3><p>Spring Boot提供了300多个用于微调的属性。<br>Spring Boot能从多种属性源获得属性：</p><ul><li>命令行参数</li><li>java:comp/env里的JNDI属性</li><li>JVM系统属性</li><li>操作系统环境变量</li><li>随机生成的带Random.*前缀的属性。例如：${random.long}</li><li>应用程序以外的application.properties或者application.yml</li><li>打包在应用程序以内的application.properties或者application.yml</li><li>通过@PropertySource标注的属性源</li><li>默认属性</li></ul><h3 id="2-3-Bean的配置外置"><a href="#2-3-Bean的配置外置" class="headerlink" title="2.3 Bean的配置外置"></a>2.3 Bean的配置外置</h3><p><code>@ConfigurationProperties(&quot;amzon&quot;)</code> 注入带amazon前缀的属性。<br><code>@Profile(&quot;production&quot;)</code>production环境运行时激活。</p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><h3 id="3-1-集成测试自动配置"><a href="#3-1-集成测试自动配置" class="headerlink" title="3.1 集成测试自动配置"></a>3.1 集成测试自动配置</h3><p>Spring Framework的核心工作是将所有组件编织在一起，构成一个应用程序。整个过程就是读取配置说明(可以是XML、基于Java的配置、基于Groovy的配置或其他类型的配置)，在应用程序上下文里初始化Bean，将Bean注入依赖它们的其他Bean中。<br>对Spring应用程序进行集成测试时，让Spring遵照生产环境来组装测试目标Bean是非常重要的一点。自Spring 2.5开始，集成测试支持的形式就变成了SpringJUnit4ClassRunner。这是一个JUnit类运行器，会为JUnit测试加载Spring应用程序上下文，并为测试类自动织入所需的Bean。<br>SpringApplication不仅加载应用程序上下文，还会开启日志、加载外部属性(application.properties或application.yml)，以及其他Spring Boot特性。用@Context- Configuration则得不到这些特性。<br>@SpringApplicationConfiguration的用法和@ContextConfiguration大致相同，但<br>也有不同的地方，@SpringApplicationConfiguration加载Spring应用程序上下文的方式同 SpringApplication相同，处理方式和生产应用程序中的情况相同。这包括加载外部属性和 Spring Boot日志。<br>我们有充分的理由说，在大多数情况下，为Spring Boot应用程序编写测试时应该用@Spring-ApplicationConfiguration代替@ContextConfiguration。在本章中，我们当然也会用 @SpringApplicationConfiguration来为Spring Boot应用程序(包括那些面向前端的应用程 序)编写测试。</p><h3 id="3-2-模拟Spring-MVC"><a href="#3-2-模拟Spring-MVC" class="headerlink" title="3.2 模拟Spring MVC"></a>3.2 模拟Spring MVC</h3><p>早在Spring 3.2，Spring Framework就有了一套非常实用的Web应用程序测试工具，能模拟 Spring MVC，不需要真实的Servlet容器也能对控制器发送HTTP请求。Spring的Mock MVC框架模拟了Spring MVC的很多功能。它几乎和运行在Servlet容器里的应用程序一样，尽管实际情况并非如此。<br>要在测试里设置Mock MVC，可以使用MockMvcBuilders，该类提供了两个静态方法。</p><ul><li>standaloneSetup():构建一个Mock MVC，提供一个或多个手工创建并配置的控制器。 </li><li>webAppContextSetup():使用Spring应用程序上下文来构建Mock MVC，该上下文里</li></ul><p>可以包含一个或多个配置好的控制器。 两者的主要区别在于，standaloneSetup()希望你手工初始化并注入你要测试的控制器，而webAppContextSetup()则基于一个WebApplicationContext的实例，通常Spring加载。前者同单元测试更加接近，你可能只想让它专注于单一控制器的测试，而后者让Spring加载控制 器及其依赖，以便进行完整的集成测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import static org.hamcrest.Matchers.*;</span><br><span class="line">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line">@SpringApplicationConfiguration(classes = ReadingListApplication.class)</span><br><span class="line">@WebAppConfiguration</span><br><span class="line">public class MockMvcWebTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private WebApplicationContext webContext;</span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line">    @Before</span><br><span class="line">    public void setupMockMvc() &#123;</span><br><span class="line">        mockMvc = MockMvcBuilders .webAppContextSetup(webContext) .build();</span><br><span class="line">    &#125; </span><br><span class="line">    @Test</span><br><span class="line">    public void homePage() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/readingList&quot;)) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.view().name(&quot;readingList&quot;)) .andExpect(MockMvcResultMatchers.model().attributeExists(&quot;books&quot;)) .andExpect(MockMvcResultMatchers.model().attribute(&quot;books&quot;,Matchers.is(Matchers.empty())));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void homePage() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(get(&quot;/readingList&quot;)) .andExpect(status().isOk()) .andExpect(view().name(&quot;readingList&quot;)) .andExpect(model().attributeExists(&quot;books&quot;)) .andExpect(model().attribute(&quot;books&quot;, is(empty())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">Spring Boot实战-丁雪丰</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库系统概念</title>
      <link href="/mysql/2019-12-05-database/"/>
      <url>/mysql/2019-12-05-database/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1. 什么是数据库？"></a>1. 什么是数据库？</h3><p>数据库管理系统（DataBase-Management System， DBMS）由一个互相关联的数据的集合和一组用以访问这些数据的程序组成。这个数据集通常称为数据库。</p><p>数据库结构的基础是数据模型（data model）。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。</p><p>数据模型可被划分为四类：</p><ul><li>关系模型（relational）：关系模型用表的集合来表示数据和数据间的联系。</li><li>实体-联系模型（entity-relationship model）：实体-联系（E-R）数据模型给予对现实世界的这样一种认识：现实世界由一组称作实体的基本对象以及这些对象间的联系构成。</li><li>基于对象的数据模型（object-based data model）：面向对象的数据模型可以看成是E-R模型增加封装、方法和对象标识等概念后的扩展。</li><li>半结构化数据模型（semistructured data model）：半结构化数据结构模型允许那些相同类型的数据项含有不同的属性集的数据定义。可扩展标记语言（eXtensible Markup Language， XML）被广泛的用来表示半结构化数据。</li></ul><h3 id="2-数据库语言"><a href="#2-数据库语言" class="headerlink" title="2. 数据库语言"></a>2. 数据库语言</h3><p>数据库操纵语言（Data-manipulationn Language）来表达数据的查询和更新。数据库定义语言（data-definition language）来定义数据库模型。</p><h3 id="3-关系数据库"><a href="#3-关系数据库" class="headerlink" title="3. 关系数据库"></a>3. 关系数据库</h3><p>关系数据库基于关系模型，使用一系列来表达数据以及这些数据之间的联系。</p><h4 id="3-1-关系数据库的结构"><a href="#3-1-关系数据库的结构" class="headerlink" title="3.1 关系数据库的结构"></a>3.1 关系数据库的结构</h4><p>关系数据库由表的集合构成，每个表有唯一的名字。</p><p>一般来说，表中一行代表了一组值之间的一种联系。由于一个表就是这种联系的一个集合，表这个概念和数学上的关系这个概念是密切相关的，这也正是关系数据模型名称的由来。</p><h3 id="4-数据库存储和查询"><a href="#4-数据库存储和查询" class="headerlink" title="4. 数据库存储和查询"></a>4. 数据库存储和查询</h3><p>存储管理器是数据库系统中负责在数据库中存储的低层数据与应用程序以及向系统提交的查询之间提供接口的部件。存储管理器负责与文件管理器交互。原始数据通过操作系统提供的文件系统存储在磁盘上。存储管理器将各种DML语句翻译为底层文件系统命令。</p><p>存储管理部件：</p><ul><li>权限及完整性管理器（authorization and integrity manager）,它检测是否满足完整性约束，并检查试图访问数据的用户的权限。</li><li>事务管理器（transaction manager），它保证即使发生了故障，数据库也保持在一致的状态，并保证并发事务的执行不发生冲突。</li><li>文件管理器（file manager），它管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构。</li><li>缓冲区管理器（buffer manager），它负责将数据从磁盘取到内存中来，并决定你哪些数据应被缓冲存储在内存中。缓冲区管理器 是数据库系统中的一个关键部分，因为它使用数据库可以处理比内存更大的数据。</li></ul><p>存储管理器实现了集中数据结构：</p><ul><li>数据文件（data files），存储数据库自身。</li><li>数据字典（data dictionary），存储关于数据库结构的元数据，尤其是数据库模式。</li><li>索引（index），提供对数据项的快速访问。</li></ul><p>查询处理器：</p><ul><li>DDL解释器（DDL interpreter），它解释DDL语句并将这些定义记录在数据字典中。</li><li>DML编译器（DML compiler），将查询语言中的 DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。</li></ul><p>一个查询通常可被翻译为多种等价的具有相同结果的执行方案的一种。DML编译器还进行查询优化（query optimization），也就是从几种选择中选出代价最小的一种。</p><ul><li>查询执行引擎（query evaluation engine），执行由DML编译器产生的低级指令。</li></ul><h3 id="5-事务管理"><a href="#5-事务管理" class="headerlink" title="5. 事务管理"></a>5. 事务管理</h3><p>事务（transaction）是数据库应用中完成单一逻辑功能的操作集合。每一个事务是一个既具有原子性又具有一致性的单元。</p><p>事务管理器（transaction manager）包括并发控制管理器和恢复管理器。</p><p>并发管理器（concurrency-control manager）控制并发事务间的相互影响，保证数据库一致性。</p><p>恢复管理器（recovery manager）负责保证原子性和持久性。</p><h3 id="6-数据库体系结构"><a href="#6-数据库体系结构" class="headerlink" title="6. 数据库体系结构"></a>6. 数据库体系结构</h3><p>数据库应用通常可分为两或三个部分。</p><p><img src="/media/article/database-structure.png" alt="database-structure"></p><h3 id="7-数据挖掘和信息检索"><a href="#7-数据挖掘和信息检索" class="headerlink" title="7. 数据挖掘和信息检索"></a>7. 数据挖掘和信息检索</h3><p>数据挖掘（data mining）这个术语指半自动地分析大型数据库并从中找出有用的模式的过程。</p><h2 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h2><h3 id="1-SQL查询语言预览"><a href="#1-SQL查询语言预览" class="headerlink" title="1. SQL查询语言预览"></a>1. SQL查询语言预览</h3><ul><li>数据定义语言 （Data-Definition Language， DDL）：SQL DDL提供定义关系模式、删除关系以及修改关系模式的命令。</li><li>数据操作语言（Data-Manipulation Language， DML）：SQL DML提供从数据库中查询信息，以及 在数据库中插入元组、删除元组、修改元组的能力。</li><li>完整性（integrity）：SQL DDL包括定义完整性约束的命令，保存在数据库中的数据必须满足所定义的完整性约束。破坏完整性约束的更新是不允许的。</li><li>视图定义 （view definition）：SQL DDL包括定义视图的命令。</li><li>事务控制（transaction control）：SQL 包括定义事务的开始和结束的命令。</li><li>嵌入式SQL和动态SQL（embedded SQL and dynamic SQL）：嵌入式和动态SQL定义SQL语句如何嵌入到通用编程语言，如C、C++和Java中。</li><li>授权（authorization）：SQL DDL包括定义对关系和视图的访问权限的命令。</li></ul><h4 id="1-1-SQL数据定义"><a href="#1-1-SQL数据定义" class="headerlink" title="1.1 SQL数据定义"></a>1.1 SQL数据定义</h4><p>基本类型：</p><ul><li>char(n)：固定长度的字符串，用户指定长度n。也可以使用全称character。</li><li>varchar(n)：可变长度的字符串，用户指定最大长度n，等价于全称character varying。</li><li>int：整数类型，等价于integer。</li><li>smallint：小整数类型。</li><li>numeric(p,d)：定点数，精度由用户指定。</li><li>real，double precision：浮点数与双精度浮点数，精度与机器相关。</li><li>float(n)：精度至少为n位的浮点数。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>两种基本的索引类型：</p><ul><li>顺序索引。基于值的顺序排序。</li><li>散列索引。介于将值平均分不到若干散列桶中。一个值所属的散列桶是由一个函数决定的，该函数称为散列函数。</li></ul><p>对于索引的考虑因素：</p><ul><li>访问类型（access type）：能有效支持的访问类型。访问类型可以包括找到具有特定属性值的记录，以及找到属性值落在某个特定范围内的记录。</li><li>访问时间（access time）：在查询中使用该技术找到一个特定数据项货数据项集所需的时间。</li><li>插入时间（insertion time）：插入一个新数据项所需的时间。该值包括找到待删除项所需的时间，以及更新索引结构所需的时间。</li><li>空间开销（space overhead）：索引结构所占用的额外存储空间。</li></ul><h3 id="1-顺序索引"><a href="#1-顺序索引" class="headerlink" title="1. 顺序索引"></a>1. 顺序索引</h3><p>顺序索引按照顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。<br>被索引的文件中的记录自身也可以按照某种排序顺序存储，正如图书馆中的书按某些属性顺序存放一样。一个文件可以有多个索引，分别基于不同的搜索码。<br><strong><em>如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为聚集索引（clustering index）</em></strong>。聚集索引也称为 主索引（primary index）；搜索码指定的顺序与文件中记录的物理顺序不同的索引称为非聚集索引（nonclustering index）或辅助索引（secondary index）。</p><h4 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h4><p>索引项（index entry）或索引记录（index record）由一个搜索码值和指向具有该搜索码值的一条或者多条记录的指针构成。指向记录的指针包括磁盘块的标识和标识磁盘块内记录的块内偏移量。<br>可以使用的顺序索引有两类：</p><ul><li>稠密索引（dense index）：在稠密索引中，文件中的每个搜索码值都有一个索引项。在稠密索引中，索引项包括搜索码值以及指向具有该搜索码的第一条数据记录的指针。具有相同搜索码值的其余记录顺序的存储在第一条数据记录之后，由于该索引是聚集索引，因此记录根据相同的索引码值排序。在稠密非聚集索引中，索引必须存储指向所有具有相同搜索码值的记录的指针列表。</li><li>稀疏索引（sparse index）：在稀疏索引中，只为搜索码的某些值建立索引项。只有当关系按搜索码排列顺序存储时才能使用稀疏索引，换句话说，只有索引是聚集索引时才能使用稀疏索引。和稠密索引一样，每个索引项也包括一个搜索码和指向具有该搜索码值的第一条记录的指针。为了定位一条记录，我们找到其最大搜索码值小于或等于所查找记录的搜索码值的索引项。然后从该索引项指向的记录开始，沿着文件的指针查找，直到找到记录为止。</li></ul><p><img src="/media/article/dense-sparse-index.png" alt="dennse-sparse"></p><h4 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h4><p>具有两级或者两级以上的索引称为多集（multilevel）索引。多级索引搜索记录于用二分法搜索记录相比需要的I/O操作要少得多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis和消息中间件</title>
      <link href="/redis/2019-11-16-redis-queue/"/>
      <url>/redis/2019-11-16-redis-queue/</url>
      
        <content type="html"><![CDATA[<p>Redis自带的PUB/SUB机制，即发布-订阅模式。这种模式生产者(producer)和消费者(consumer)是1-M的关系，即一条消息会被多个消费者消费。如果消息丢失、Redis宕机部分数据没有持久化甚至突然的网络抖动都可能带来数据的丢失，应该是无法忍受的。其次，扩展不灵活，没法通过多加consumer来加快消费的进度，如果前端写入数据太多，同步会比较慢，数据不同步的状态越久，风险越大，可以通过channel拆分的方式来解决，虽然不灵活，但可以规避。这种方案更适合于对数据可靠性要求不高，比如一些统计日志打点。</p><p>Redis的PUSH/POP机制，利用的Redis的列表(lists)数据结构。比较好的使用模式是，生产者lpush消息，消费者brpop消息，并设定超时时间，可以减少redis的压力。这种方案相对于第一种方案是数据可靠性提高了，只有在Redis宕机且数据没有持久化的情况下丢失数据，可以根据业务通过AOF和缩短持久化间隔来保证很高的可靠性，而且也可以通过多个client来提高消费速度。但相对于专业的消息队列来说，该方案消息的状态过于简单(没有状态)，且没有ack机制，消息取出后消费失败依赖于client记录日志或者重新push到队列里面。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">从Redis谈起（三）—— Redis和消息中间件<br>–中间件架构</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/redis/2019-11-18-redis-strike/"/>
      <url>/redis/2019-11-18-redis-strike/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/linxiyue/p/11295463.html" target="_blank" rel="noopener">浅谈布隆过滤器Bloom Filter</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis空间优化</title>
      <link href="/redis/2019-11-13-redis-space-optimization/"/>
      <url>/redis/2019-11-13-redis-space-optimization/</url>
      
        <content type="html"><![CDATA[<p>我们项目使用Redis越来越多，可是Redis毕竟是基于内存的数据库，所以对于Redis的空间使用如果不加注意，很容易导致内存溢出。</p><h3 id="1-Redis数据结构"><a href="#1-Redis数据结构" class="headerlink" title="1. Redis数据结构"></a>1. Redis数据结构</h3><p>Redis使用了五种数据对象：字符串对象，列表对象，哈希对象，集合对象，有序集合对象。</p><p>Redis基于这五种对象也给出了优化：</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串中有int、embstr和raw（Simple Dynamic String）两种存储字符串的结构。如果只读且大小小于32字节，则使用embstr，否则使用raw，embstr只能转化为raw，raw不能转化为embstr。关于两者的区别详细了解<a href="/redis/2019-06-21-redis/#1-8-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1">Redis设计与实现</a></p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的底层数据结构在3.2版本之前可以是链表（linkedlist），也可以是压缩列表（ziplist），对于链表保存不需要连续的内存空间（是优点也是缺点，容易造成内存碎片），相比于压缩列表多了保存pre、next指针的空间，ziplist保存在连续内存空间上，不需要维护pre、next指针。当保存的字符串长度小于64字节且列表对象个数小于512时使用压缩列表。</p><p>在3.2版本之后唯一的数据结构是快表（quicklist），它是一个双向链表，而且是一个ziplist的双向链表。这是什么意思呢？我们知道，双向链表是由多个节点（Node）组成的。这个描述的意思是：quicklist的每个节点都是一个ziplist。</p><p>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</p><p>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象底层数据结构可以是ziplist和字典hashtable。ziplist存储字符串不超过32字节和总个数不超过512的数据。</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象底层数据结构是intset或者hashtable。</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合对象底层数据结构是ziplist或者是skiplist。当存储的字符串长度大于64时转为skiplist。<br>skiplist存储时使用skiplist和hashtabl两种结构进行存储，如果我们只是用字典hashtable来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p><p>需要注意的是<strong><em>字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p>使用上述对象时，需要考虑底层数据结构特性，是否会因为频繁删除增加修改，造成Redis的内存碎片化，频繁修改的数据不建议放入到Redis。不仅如此，考虑到Redis空间的复用性，对于不常用的key设置过期时间。</p><h3 id="2-Redis存储优化"><a href="#2-Redis存储优化" class="headerlink" title="2. Redis存储优化"></a>2. Redis存储优化</h3><p>本章节摘自《<a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a>》</p><ol><li><p>利用Redis内存分配器做第一层优化。例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p></li><li><p>尽量使用整型/长整型。如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。</p></li><li><p>利用共享对象，共享对象包括10000个整数，可以通过REDIS_SHARED_INTEGERS参数提高共享对象的个数。</p></li><li><p>关注内存碎片率，如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。</p></li><li><p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p></li><li><p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a></p><p><a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a></p><p><a href="/redis/2019-06-21-redis/#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8%E5%AD%98%E5%82%A8%E6%95%88%E7%8E%87">quicklist存储效率</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程池</title>
      <link href="/concurrency/2019-11-07-threadpool/"/>
      <url>/concurrency/2019-11-07-threadpool/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在生产环境中，应避免直接创建线程，线程数量必须得到控制。</p></blockquote><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>为了控制线程，JDK类库提供了一套Executor框架。</p><p><img src="/media/article/executor.png" alt="executor"></p><p>线程池是JDK用来管理线程的的静态工厂。上图中ThreadPoolExecutor表示一个线程池。<br>Executor是一个接口，接口中只有<code>void execute(Runnable command)</code>方法。<br>ExecutorService也是一个接口，继承ExecutorService，增加了许多使用线程池的公用方法定义。<br>AbstactExecutorService为ExecutorService接口提供了默认实现。<br>ThreadPoolExecutor继承AbstactExecutorService抽象类。<br>Executors类是JDK1.5版本时封装的线程池工厂和工具类，这个类提供了几种默认的<a href="/concurrency/2019-11-07-threadpool/#1-2-Executor%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90">线程池类型</a>和默认线程池工厂。<br>ForkJoinPool是Java7加入的一种用于并行执行任务的框架</p><h3 id="1-1-创建线程池"><a href="#1-1-创建线程池" class="headerlink" title="1.1 创建线程池"></a>1.1 创建线程池</h3><p>创建线程池的实现其实是实例化ThreadPoolExecutor的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>corePoolSize：指定线程池中的线程数量。<br>maximumPoolSize：线程池中的最大线程数量。<br>keepAliveTime：当线程池超过corePoolSize时，多余的空闲线程的空闲时间。<br>unit：keepAliveTime的时间单位。<br>workQueue：任务队列，被提交但未被执行的任务。<br>threadFactory工厂：创建线程的工厂，一般默认就可以。<br>handler：拒绝策略，当线程池满负荷运行，如何拒绝新的任务的策略。</p><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>keepAliveTime，unit，threadFactory几个参数可根据线程池的任务场景去做简单的变化，在此不再赘述，一般自定义线程池我们的关注点大都在corePoolSize，maximumPoolSize，workQueue，handler四个参数上。</p><p>corePoolSize，根据业务的通用场景确定即可。《Java并发编程实践》书中给出了一个估算线程池corePoolSize大小的经验公式：<br>Ncpu=cpu数量<br>Ucpu=希望cpu的使用率，0&lt;Ucpu&lt;1<br>W/C=等待时间与计算时间的比率， <a href="https://www.cnblogs.com/gatsby123/p/11127158.html" target="_blank" rel="noopener">CPU计算时间计算方式</a></p><p><code>Nthreads=Ncpu*Ucpu*(1+W/C)</code></p><p>如果你处理的是阻塞比较多的任务，你可以根据上述公式大致算出需要的线程数量（一般会远远超出当前实例所在服务器的cpu数量）；如果是阻塞比较少的任务即cpu计算比重较大的任务，线程的数量可能就会相应的减少一些，避免服务器的超负荷运行。总之线程数不是精确的一个数，只要符合你业务的场景的大概数量就可以。</p><p>workQueue任务队列分为有限、无限、同步移交三种阻塞队列，常用的有如下几个：</p><ul><li>ArrayBlockingQueue: 一个基于数组结构的有界阻塞队列，此队列按照FIFO原则排序。</li><li>LinkedBlockingQueue: 一个基于链表的阻塞队列，此队列按照FIFO原则排序，吞吐量高于ArrayBlockingQueue。</li><li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须阻塞到另一个线程的移除操作。</li><li>PriorityBlockingQueue: 具有优先级的无限阻塞队列。</li></ul><p>线程池的执行过程：</p><p><img alt="threadpool-processor" src="/media/article/threadpool-processor.png" width="75%"></p><p>–图摘自《Java并发编程艺术》9.1小节-线程池的实现原理。</p><p>队列的大小和maxmumPoolSize息息相关，如果使用无界队列，则maxmumPoolSize也就失效了，如果使用的是有界队列，则当有界队列满了，则新启动线程执行任务。直到最大线程也满了之后执行拒绝策略。</p><p>最后就是拒绝策略:</p><ul><li>AbortPolicy: 直接抛出异常。</li><li>CallerRunPolicy: 使用调用者的线程执行任务。</li><li>DiscardOldestPolicy: 丢弃队列里最老的任务，并执行当前任务。</li><li>DiscardPolicy: 不处理，不丢弃。</li></ul><p>除此之外还可以实现RejectExecutionHandler接口，自定义拒绝策略。</p><h3 id="1-2-Executor提供的几种类型的线程池解析"><a href="#1-2-Executor提供的几种类型的线程池解析" class="headerlink" title="1.2 Executor提供的几种类型的线程池解析"></a>1.2 Executor提供的几种类型的线程池解析</h3><ol><li>Executors.newFixedThreadPool(1);</li></ol><p>Executors.newFixedThreadPool创建的线程池可以指定核心线程数，但是使用的是无界队列，如果是IO密集型任务，可能导致内存溢出。</p><ol start="2"><li>Executors.newSingleThreadExecutor();</li></ol><p>Executors.newSingleThreadExecutor()创建一个线程的线程池，同样使用无界队列，和newFixedThreadPool的差别仅限于核心线程数。</p><ol start="3"><li>Executors.newCachedThreadPool();</li></ol><p>Executors.newCachedThreadPool()创建的线程池是一个没有队列的存储任务的线程池，线程池最大数量为Integer.MAX_VALUE。所以这个线程池会一直创建新的线程执行任务，可能导致内存溢出。适用于中小数量级的任务，且任务非CPU密集型。</p><ol start="4"><li>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory());</li></ol><p>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory())创建可以定时或延时执行任务的线程池，与Timer相比，具有更多的弹性。<a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-add1.html" target="_blank" rel="noopener">详解Java定时任务—极客学院</a></p><ol start="5"><li>Executors.newWorkStealingPool();</li></ol><p>封装的ForkJoinPool线程池，线程数量为当前运行环境的cpu数量，不处理异常，异步模式。下一小节详细介绍。</p><h3 id="1-3-ForkJoinPool线程池初探"><a href="#1-3-ForkJoinPool线程池初探" class="headerlink" title="1.3 ForkJoinPool线程池初探"></a>1.3 ForkJoinPool线程池初探</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成小任务，最终汇总小任务结果后得到大任务结果的框架。</p><p><img src="/media/article/forkjoin.png" alt="forkjoin"></p><p>–图片摘自《Java并发编程的艺术》6.4.1 什么是Fork/Join框架 小节。</p><p>缺点：在某些情况下，该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。</p><h4 id="使用ForkJoinPool"><a href="#使用ForkJoinPool" class="headerlink" title="使用ForkJoinPool"></a>使用ForkJoinPool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private static final int THRESHOLD = 2;  // 阈值 private int start;</span><br><span class="line">private int end;</span><br><span class="line">public CountTask(int start, int end) &#123;</span><br><span class="line">    this.start = start; this.end = end;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected Integer compute() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    // 如果任务足够小就计算任务</span><br><span class="line">    boolean canCompute = (end - start) &lt;= THRESHOLD; </span><br><span class="line">    if (canCompute) &#123;</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">         sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">        int middle = (start + end) / 2;</span><br><span class="line">        CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end); // 执行子任务</span><br><span class="line">        leftTask.fork();</span><br><span class="line">        rightTask.fork();</span><br><span class="line">        // 等待子任务执行完，并得到其结果</span><br><span class="line">        int leftResult=leftTask.join();</span><br><span class="line">        int rightResult=rightTask.join();</span><br><span class="line">        // 合并子任务</span><br><span class="line">        sum = leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">    // 生成一个计算任务，负责计算1+2+3+4</span><br><span class="line">    CountTask task = new CountTask(1, 4);</span><br><span class="line">    // 执行一个任务</span><br><span class="line">    Future&lt;Integer&gt; result = forkJoinPool.submit(task); </span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–示例摘自《Java并发编程的艺术》6.4.4 使用Fork/Join框架 小节。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>ForkJoinTask提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被 取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(task.isCompletedAbnormally()) &#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>ForkJoinPool继承AbstractExecutorService。</p><p>ForkJoinPool参数：</p><ul><li>parallelism线程数量；</li><li>ForkJoinWorkerThreadFactory是ForkJoin线程工厂，创建ForkJoinWorkerThread的线程类实例；</li><li>mode是使用FIFO模式（true）还是LIFO模式（false）；</li><li>UncaughtExceptionHandler是异常处理；</li><li>workerNamePrefix工作线程的名称前缀；</li></ul><p>通常来说，我们使用ForkJoinPool时如果不指定线程数量时默认取2047和当前服务器cpu数量中的最小值。简单来说就是创建了一个fork/join线程的线程池。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">Effective Java 第二版 中文版 </a><br><a href="">实战Java高并发程序设计 葛一鸣，郭超编著</a><br><a href="">Java并发编程艺术 方腾飞，魏鹏，程晓明 著</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AspectJ</title>
      <link href="/java/2019-10-04-aspectj/"/>
      <url>/java/2019-10-04-aspectj/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文引用自<a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p></blockquote><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><blockquote><p>AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言。当然，AspectJ需要使用额外的编译器。</p></blockquote><blockquote><p>AspectJ可以通过多种方式实现，包括源码织入或字节码织入，并且可以直接在虚拟机（VM）中实现。在所有情况下，AspectJ程序都将成为在Java VM中运行的有效Java程序。受切面影响的类与不受影响的类具有二进制兼容性（以保持与不受影响的原始文件编译的类兼容）。支持多种实现方式使该语言可以随着技术的变化而发展，并且与Java兼容可确保平台可用性。<br>AspectJ采用编译期织入和类加载期织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<br>使用AspectJ LTW有两个主要步骤，第一，通过JVM的-javaagent参数设置LTW的织入器类包，以代理JVM默认的类加载器；第二，LTW织入器需要一个aop.xml文件，在该文件中指定切面类和需要进行切面织入的目标类。</p></blockquote><blockquote><p>设置-javaagent JVM参数的方法:<br>(1)在Eclipse下的设置:<br>运行类-&gt;右键单击-&gt;Run As-&gt;Run…，可以在弹出的Run设置窗口设置该类的各项运行属性，切换到Arguments Tab页，在VM arguments中通过-javaagent指定AspectJ 织入器类包。<br>-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar<br>(2)在Tomcat下的设置<br>打开&lt;Tomcat_Home&gt;\bin\catalina.bat，在该批处理文件头部添加以下的设置：<br>set JAVA_OPTS=-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CGLIB浅析</title>
      <link href="/java/2019-10-04-cglib/"/>
      <url>/java/2019-10-04-cglib/</url>
      
        <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><p>本文打算从这几个方面来理解CGLIB怎样生成动态代理类的：</p><ol><li><a href="#1-使用Cglib动态代理">怎样使用CGLIB？</a></li><li><a href="#2-CGLIB原理解析">CGLIB怎样生成/缓存动态代理类实例的？</a></li><li><a href="#3-CGLIB代理类调用方法原理解析">CGLIB生成的动态代理类怎样调用的，过程是怎样的，这样有什么好处？</a></li><li>常见问题<a href="#FAQ">FAQ</a></li></ol><h2 id="1-使用Cglib动态代理"><a href="#1-使用Cglib动态代理" class="headerlink" title="1. 使用Cglib动态代理"></a>1. 使用Cglib动态代理</h2><p>CGLIB的使用和JDK Proxy类似，不同的是CGLIB既可以指定接口，也可以直接代理未实现接口的普通类。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">LogInterceptor logInterceptor = new LogInterceptor();</span><br><span class="line">// 设置超类，cglib是通过继承来实现的</span><br><span class="line">enhancer.setSuperclass(UserDao.class);</span><br><span class="line">enhancer.setCallback(logInterceptor);</span><br><span class="line">/**</span><br><span class="line"> * 如果是实现指定接口，可以使用setInterfaces方法设置接口</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// enhancer.setInterfaces(new Class[]&#123;Dao.class&#125;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果使用createClass方法返回值为代理类的Class对象，需要设置CallbackType参数；当使用create方法时，CallbackType和callback都不为空时，两者类型必须相等。</span><br><span class="line"> * create方法返回的是代理类实例</span><br><span class="line"> * enhancer.setCallbackType(LogInterceptor.class);</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 创建代理类</span><br><span class="line">Dao dao = (Dao)enhancer.create();</span><br><span class="line">dao.select();</span><br></pre></td></tr></table></figure></p><p>// 方法拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">//        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">//        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>// 实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao implements Dao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-CGLIB生成动态代理类的原理解析"><a href="#2-CGLIB生成动态代理类的原理解析" class="headerlink" title="2. CGLIB生成动态代理类的原理解析"></a>2. CGLIB生成动态代理类的原理解析</h2><p>CGLIB，JDK proxy生成过程上大同小异，都是使用弱引用缓存已生成的Class对象，如果缓存中没有，则使用字节码技术生成动态代理类字节码和Class对象，只不过使用的字节码技术不太一样罢了。<br>下图是CGLIB动态代理生成代理类Class对象的流程：<a href="/media/article/cglib-processor.png">点击看大图</a></p><p><img src="/media/article/cglib-processor.png"></p><p>CGLIB动态代理基于ASM技术，使用<a href="/java/2019-10-06-asm/">ASM</a>技术的部分就是图中标红的模块。</p><p>CGLIB动态代理如果没有特殊设置也会缓存已生成的动态代理类的Class对象。</p><p><img src="/media/article/cglib-cache.png" alt="cglib-cache"></p><p>上图是CGLIB缓存动态代理类的Class对象的结构。</p><p>CGLIB第一次生成动态代理类Class对象的方法调用流程：</p><p><img src="/media/article/cglib-method.png" alt="cglib-method"></p><h2 id="3-CGLIB代理类调用方法原理解析"><a href="#3-CGLIB代理类调用方法原理解析" class="headerlink" title="3. CGLIB代理类调用方法原理解析"></a>3. CGLIB代理类调用方法原理解析</h2><blockquote><p>使用<code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;./&quot;)</code>可以输出生成的代理类的class文件。这里由于篇幅问题，只展示文章需要的内容，想看完整的代理类的字节码文件可以自己输出查看。</p></blockquote><p>CGLIB针对一个目标类一般会生成3个动态代理类，1个<code>UserDao$$EnhancerByCGLIB$$c00e2e9b extends UserDao implements Factory</code>，还有2个和调用有关的FastClass代理类<code>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc extends FastClass</code>，<code>UserDao$$FastClassByCGLIB$$890e5f18 extends FastClass</code></p><p>UserDao$$EnhancerByCGLIB$$c00e2e9b类的静态初始化块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 当前线程的缓存</span><br><span class="line">CGLIB$THREAD_CALLBACKS = new ThreadLocal();</span><br><span class="line">// 空参数对象</span><br><span class="line">CGLIB$emptyArgs = new Object[0];</span><br><span class="line">// 动态代理类的Class对象</span><br><span class="line">Class var0 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao$$EnhancerByCGLIB$$c00e2e9b&quot;);</span><br><span class="line">Class var1;</span><br><span class="line">// 只获取update和select的方法对象</span><br><span class="line">Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;update&quot;, &quot;()V&quot;, &quot;select&quot;, &quot;()V&quot;&#125;, (var1 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao&quot;)).getDeclaredMethods());</span><br><span class="line">CGLIB$update$0$Method = var10000[0];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$update$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;update&quot;, &quot;CGLIB$update$0&quot;);</span><br><span class="line">CGLIB$select$1$Method = var10000[1];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$select$1$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;select&quot;, &quot;CGLIB$select$1&quot;);</span><br></pre></td></tr></table></figure><p>当动态代理类调用update()方法（update是DAO接口内的方法）时，首先调用下面这个动态生成的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * cglib使用Class对象创建对象实例(Enhancer.nextNewInstance())的时候，会反射调用CGLIB$SET_THREAD_CALLBACKS方法，将MethodInterceptor实例缓存在CGLIB$THREAD_CALLBACKS这个代理类的的ThreadLocal中，然后初始化动态代理类实例时，调用CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">public final void update() &#123;</span><br><span class="line">   // 初始化动态代理类实例时，已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">   MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">       CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">       var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (var10000 != null) &#123;</span><br><span class="line">       var10000.intercept(this, CGLIB$update$0$Method, CGLIB$emptyArgs, CGLIB$update$0$Proxy);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       super.update();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">   UserDao$$EnhancerByCGLIB$$c00e2e9b var1 = (UserDao$$EnhancerByCGLIB$$c00e2e9b)var0;</span><br><span class="line">   if (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">       var1.CGLIB$BOUND = true;</span><br><span class="line">       Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">       if (var10000 == null) &#123;</span><br><span class="line">           var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">           if (CGLIB$STATIC_CALLBACKS == null) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 也就是说，初始化动态代理类实例时，最后如果var1.CGLIB$BOUND = true，则说明已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">       var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在调用到了MethodInterceptor的intercept方法了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">   // methodProxy.invokeSuper</span><br><span class="line">   Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>methodProxy，还记得动态代理类的static代码块么，在那时就已经初始化好了methodProxy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) &#123;</span><br><span class="line">   MethodProxy proxy = new MethodProxy();</span><br><span class="line">   // 使用Signature对象封装方法名和返回值</span><br><span class="line">   proxy.sig1 = new Signature(name1, desc);</span><br><span class="line">   proxy.sig2 = new Signature(name2, desc);</span><br><span class="line">   // 将UserDAO和UserDAO的动态代理类的Class文件放入CreateInfo对象</span><br><span class="line">   proxy.createInfo = new MethodProxy.CreateInfo(c1, c2);</span><br><span class="line">   return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了知道methodProxy怎么来的，继续往下走，invokeSuper():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       this.init();</span><br><span class="line">       MethodProxy.FastClassInfo fci = this.fastClassInfo;</span><br><span class="line">       // 这里调用的实际是FastClass代理类中的invoke方法</span><br><span class="line">       return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">   &#125; catch (InvocationTargetException var4) &#123;</span><br><span class="line">       throw var4.getTargetException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void init() &#123;</span><br><span class="line">   if (this.fastClassInfo == null) &#123;</span><br><span class="line">       Object var1 = this.initLock;</span><br><span class="line">       synchronized(this.initLock) &#123;</span><br><span class="line">           if (this.fastClassInfo == null) &#123;</span><br><span class="line">               MethodProxy.CreateInfo ci = this.createInfo;</span><br><span class="line">               MethodProxy.FastClassInfo fci = new MethodProxy.FastClassInfo();</span><br><span class="line">               // UserDAO和UserDAO的代理类分别有自己的FastClassInfo，分别使用个字的ClassInfo生成FastClass代理类</span><br><span class="line">               // 生成UserDAO的FastClass代理类</span><br><span class="line">               fci.f1 = helper(ci, ci.c1);</span><br><span class="line">               // 生成UserDAO代理类的FastClass代理类</span><br><span class="line">               fci.f2 = helper(ci, ci.c2);</span><br><span class="line">               // 生成方法索引</span><br><span class="line">               fci.i1 = fci.f1.getIndex(this.sig1);</span><br><span class="line">               fci.i2 = fci.f2.getIndex(this.sig2);</span><br><span class="line">               this.fastClassInfo = fci;</span><br><span class="line">               this.createInfo = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据索引调用方法，fci.i2的值为12，调用索引12的方法。<br>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc动态代理类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123;</span><br><span class="line">   c00e2e9b var10000 = (c00e2e9b)var2;</span><br><span class="line">   int var10001 = var1;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">       switch(var10001) &#123;</span><br><span class="line">       case 0:</span><br><span class="line">           return new Boolean(var10000.equals(var3[0]));</span><br><span class="line">       case 1:</span><br><span class="line">           return var10000.toString();</span><br><span class="line">       case 2:</span><br><span class="line">           return new Integer(var10000.hashCode());</span><br><span class="line">       case 3:</span><br><span class="line">           return var10000.clone();</span><br><span class="line">       case 4:</span><br><span class="line">           var10000.update();</span><br><span class="line">           return null;</span><br><span class="line">       case 5:</span><br><span class="line">           return var10000.newInstance((Class[])var3[0], (Object[])var3[1], (Callback[])var3[2]);</span><br><span class="line">       case 6:</span><br><span class="line">           return var10000.newInstance((Callback)var3[0]);</span><br><span class="line">       case 7:</span><br><span class="line">           return var10000.newInstance((Callback[])var3[0]);</span><br><span class="line">       case 8:</span><br><span class="line">           var10000.select();</span><br><span class="line">           return null;</span><br><span class="line">       case 9:</span><br><span class="line">           var10000.setCallback(((Number)var3[0]).intValue(), (Callback)var3[1]);</span><br><span class="line">           return null;</span><br><span class="line">       case 10:</span><br><span class="line">           return c00e2e9b.CGLIB$findMethodProxy((Signature)var3[0]);</span><br><span class="line">       case 11:</span><br><span class="line">           c00e2e9b.CGLIB$STATICHOOK1();</span><br><span class="line">           return null;</span><br><span class="line">       case 12:</span><br><span class="line">           var10000.CGLIB$update$0();</span><br><span class="line">           return null;</span><br><span class="line">       case 13:</span><br><span class="line">           var10000.CGLIB$select$1();</span><br><span class="line">           return null;</span><br><span class="line">       case 14:</span><br><span class="line">           return new Boolean(var10000.CGLIB$equals$2(var3[0]));</span><br><span class="line">       case 15:</span><br><span class="line">           return var10000.CGLIB$toString$3();</span><br><span class="line">       case 16:</span><br><span class="line">           return new Integer(var10000.CGLIB$hashCode$4());</span><br><span class="line">       case 17:</span><br><span class="line">           return var10000.CGLIB$clone$5();</span><br><span class="line">       case 18:</span><br><span class="line">           var10000.setCallbacks((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 19:</span><br><span class="line">           c00e2e9b.CGLIB$SET_STATIC_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 20:</span><br><span class="line">           c00e2e9b.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 21:</span><br><span class="line">           return var10000.getCallback(((Number)var3[0]).intValue());</span><br><span class="line">       case 22:</span><br><span class="line">           return var10000.getCallbacks();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; catch (Throwable var4) &#123;</span><br><span class="line">       throw new InvocationTargetException(var4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问流程图：</p><p><img src="/media/article/cglib-invoke.png" alt="cglib-invoke"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是CGLIB还是JDK proxy都是为了控制对象的访问，但是怎样控制访问是CGLIB和JDK proxy思想上的最大区别，JDK proxy通过接口得到method对象后使用反射直接调用目标方法，CGLIB则是更复杂的多，CGLIB先是继承目标类，然后通过字节码技术生成代理方法（CGLIB$update$0）和update（上述例子中的方法，这里用来举例），然后通过方法代理（MethodProxy）和FastClass访问机制（通过方法名和返回值生成索引，调用时直接索引至目标方法）回调目标方法。</p><blockquote><p>TIPS:其实这里还有很多想说的，但是总也感觉表达的总是不是那么的到位，所以暂且先这样了，等着后续再继续完善。</p></blockquote><p>优点：</p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似CGLIB动态代理就没有这种限制。</li><li>只操作我们关心的类，不必为其他相关类增加工作量。</li><li>高性能，高性能体现方法的调用上，CGLIB的方法调用为FastClass机制，JDK Proxy为反射调用。</li></ul><h2 id="4-一些源码"><a href="#4-一些源码" class="headerlink" title="4. 一些源码"></a>4. 一些源码</h2><p>下面是一些比较核心的一些代码解析：</p><p>入口，AbstractGenerator中的create(key)方法，参数key=KeyFactory.newInstance()。KeyFactory也是CGLIB动态生成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 参数key是Enhancer.KeyFactory(superclassname)的实例，这个KeyFactory类也是cglib动态生成的，当你new Enhancer()时，Enhancer会动态的生成该实例对象，superclassname就是上面的UserDAO。</span><br><span class="line">protected Object create(Object key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ClassLoader loader = this.getClassLoader();</span><br><span class="line">        // CACHE时WeakHashMap 第一层缓存的容器</span><br><span class="line">        Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        // 第一层缓存 key是classLoader</span><br><span class="line">        AbstractClassGenerator.ClassLoaderData data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">        if (data == null) &#123;</span><br><span class="line">            Class var5 = AbstractClassGenerator.class;</span><br><span class="line">            // 加锁意义在于CACHE时静态变量，属于该类，不是该实例对象，所以线程安全需要加锁。</span><br><span class="line">            synchronized(AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">                if (data == null) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; newCache = new WeakHashMap(cache);</span><br><span class="line">                    // 创建第二层缓存容器</span><br><span class="line">                    data = new AbstractClassGenerator.ClassLoaderData(loader);</span><br><span class="line">                    // 将第二层缓存容器放入第一层容器内，key为classloader</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.key = key;</span><br><span class="line">        // 使用ClassLoaderData data获取Enhancer.EnhancerFactoryData对象，Enhancer.EnhancerFactoryData对象中是代理类的Class对象，也可以直接获取KeyFactory的Class对象</span><br><span class="line">        Object obj = data.get(this, this.getUseCache());</span><br><span class="line">        // firstInstance主要是针对KeyFactory生成的Class对象，例如接口方法生成的MethodWraper的代理类Class对象，nextInstance针对Enhancer实例生成的Enhancer.EnhancerFactoryData实例，实例中存储着真正的代理类的Class对象，如果生成的代理类中有接口方法，生成代理类时，会生成接口方法的MethodWrapper的代理类实例。</span><br><span class="line">        return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);</span><br><span class="line">    &#125; catch (Error | RuntimeException var9) &#123;</span><br><span class="line">        throw var9;</span><br><span class="line">    &#125; catch (Exception var10) &#123;</span><br><span class="line">        throw new CodeGenerationException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一级缓存中的value，ClassLoaderData的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoaderData(ClassLoader classLoader) &#123;</span><br><span class="line">  if (classLoader == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;classLoader == null is not yet supported&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // 首先用弱引用封装classLoader，垃圾回收时可以直接回收</span><br><span class="line">      this.classLoader = new WeakReference(classLoader);</span><br><span class="line">      Function&lt;AbstractClassGenerator, Object&gt; load = new Function&lt;AbstractClassGenerator, Object&gt;() &#123;</span><br><span class="line">          public Object apply(AbstractClassGenerator gen) &#123;</span><br><span class="line">              Class klass = gen.generate(ClassLoaderData.this);</span><br><span class="line">              // 这里需要注意gen是Enhancer实例，还是KeyFactory$Genertor实例，两者的wrapCachedClass完全不一样，使用的数据结构也不一样。Enhancer使用的数据结构是EnhancerFactoryData，KeyFactory$Genertor使用LoadingCache</span><br><span class="line">              return gen.wrapCachedClass(klass);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      // this.generatedClasses的key是KeyFactory根据superclassName生成的key实例，将load放入LoadingCache，等下如果LoadingCache的map获取代理类为null，需要回调这个load重新生成代理类</span><br><span class="line">      this.generatedClasses = new LoadingCache(GET_KEY, load);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二级缓存的对象LoadingCache中的核心方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// key是Enhancer实例，或者是KeyFactory$Generator实例</span><br><span class="line">public V get(K key) &#123;</span><br><span class="line">   KK cacheKey = this.keyMapper.apply(key);</span><br><span class="line">   Object v = this.map.get(cacheKey);</span><br><span class="line">   return v != null &amp;&amp; !(v instanceof FutureTask) ? v : this.createEntry(key, cacheKey, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected V createEntry(final K key, KK cacheKey, Object v) &#123;</span><br><span class="line">   boolean creator = false;</span><br><span class="line">   FutureTask task;</span><br><span class="line">   Object result;</span><br><span class="line">   if (v != null) &#123;</span><br><span class="line">       task = (FutureTask)v;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       task = new FutureTask(new Callable&lt;V&gt;() &#123;</span><br><span class="line">           public V call() throws Exception &#123;</span><br><span class="line">               // 回调AbstractGenerator.ClassLoaderData构造器中的load</span><br><span class="line">               return LoadingCache.this.loader.apply(key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 获取map中的value，如果是Enhancer.EnhancerFactoryData就直接返回，如果不是，继续往下获取Class对象</span><br><span class="line">       result = this.map.putIfAbsent(cacheKey, task);</span><br><span class="line">       // 如果等于null，需要重新生成</span><br><span class="line">       if (result == null) &#123;</span><br><span class="line">           creator = true;</span><br><span class="line">           task.run();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (!(result instanceof FutureTask)) &#123;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           task = (FutureTask)result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">       result = task.get();</span><br><span class="line">   &#125; catch (InterruptedException var9) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Interrupted while loading cache item&quot;, var9);</span><br><span class="line">   &#125; catch (ExecutionException var10) &#123;</span><br><span class="line">       Throwable cause = var10.getCause();</span><br><span class="line">       if (cause instanceof RuntimeException) &#123;</span><br><span class="line">           throw (RuntimeException)cause;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       throw new IllegalStateException(&quot;Unable to load cache item&quot;, cause);</span><br><span class="line">   &#125;</span><br><span class="line">   // 新建的Class对象或者Enhancer.EnhancerFactoryData需要存起来</span><br><span class="line">   if (creator) &#123;</span><br><span class="line">       this.map.put(cacheKey, result);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Enhancer中生成动态代理类的逻辑，使用了ASM技术：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public void generateClass(ClassVisitor v) throws Exception &#123;</span><br><span class="line">   Class sc = this.superclass == null ? Object.class : this.superclass;</span><br><span class="line">   if (TypeUtils.isFinal(sc.getModifiers())) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Cannot subclass final class &quot; + sc.getName());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">       this.filterConstructors(sc, constructors);</span><br><span class="line">       List actualMethods = new ArrayList();</span><br><span class="line">       List interfaceMethods = new ArrayList();</span><br><span class="line">       final Set forcePublic = new HashSet();</span><br><span class="line">       // 将接口中的方法获取放入到forcePublic中，获取的其实是KeyFactory生成的MethodWrapper实例 select,&#125;, void</span><br><span class="line">       // actualMethods是一个包含所有方法的数组，值类似public void com.zhongyp.advanced.proxy.cglib.UserDao.update()</span><br><span class="line">       getMethods(sc, this.interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line">       // 获取到所有的方法及访问标识</span><br><span class="line">       List methods = CollectionUtils.transform(actualMethods, new Transformer() &#123;</span><br><span class="line">           public Object transform(Object value) &#123;</span><br><span class="line">               Method method = (Method)value;</span><br><span class="line">               int modifiers = 16 | method.getModifiers() &amp; -1025 &amp; -257 &amp; -33;</span><br><span class="line">               if (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                   // 如果接口中有相同的方法，</span><br><span class="line">                   modifiers = modifiers &amp; -5 | 1;</span><br><span class="line">               &#125;</span><br><span class="line">               return ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 下面就是ASM的操作逻辑了</span><br><span class="line">       // 参数v是ClassVisitor</span><br><span class="line">       ClassEmitter e = new ClassEmitter(v);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), Type.getType(sc), this.useFactory ? TypeUtils.add(TypeUtils.getTypes(this.interfaces), FACTORY) : TypeUtils.getTypes(this.interfaces), &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), (Type)null, new Type[]&#123;FACTORY&#125;, &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       // 构造器信息</span><br><span class="line">       List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line">       e.declare_field(2, &quot;CGLIB$BOUND&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       e.declare_field(9, &quot;CGLIB$FACTORY_DATA&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (!this.interceptDuringConstruction) &#123;</span><br><span class="line">           e.declare_field(2, &quot;CGLIB$CONSTRUCTED&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(26, &quot;CGLIB$THREAD_CALLBACKS&quot;, THREAD_LOCAL, (Object)null);</span><br><span class="line">       e.declare_field(26, &quot;CGLIB$STATIC_CALLBACKS&quot;, CALLBACK_ARRAY, (Object)null);</span><br><span class="line">       if (this.serialVersionUID != null) &#123;</span><br><span class="line">           e.declare_field(26, &quot;serialVersionUID&quot;, Type.LONG_TYPE, this.serialVersionUID);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for(int i = 0; i &lt; this.callbackTypes.length; ++i) &#123;</span><br><span class="line">           e.declare_field(2, getCallbackField(i), this.callbackTypes[i], (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(10, &quot;CGLIB$CALLBACK_FILTER&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           this.emitMethods(e, methods, actualMethods);</span><br><span class="line">           this.emitConstructors(e, constructorInfo);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.emitDefaultConstructor(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       this.emitSetThreadCallbacks(e);</span><br><span class="line">       this.emitSetStaticCallbacks(e);</span><br><span class="line">       this.emitBindCallbacks(e);</span><br><span class="line">       if (this.useFactory || this.currentData != null) &#123;</span><br><span class="line">           int[] keys = this.getCallbackKeys();</span><br><span class="line">           this.emitNewInstanceCallbacks(e);</span><br><span class="line">           this.emitNewInstanceCallback(e);</span><br><span class="line">           this.emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">           this.emitGetCallback(e, keys);</span><br><span class="line">           this.emitSetCallback(e, keys);</span><br><span class="line">           this.emitGetCallbacks(e);</span><br><span class="line">           this.emitSetCallbacks(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.end_class();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>CGLIB针对final方法怎么处理的呢？</li></ol><p>不处理，因为继承了目标类，所以动态代理类实例可以直接调用目标类的final方法。</p><ol start="2"><li>CGLIB动态代理是通过字节码底层继承要代理类来实现，如果被代理类被final关键字所修饰，那么代理会失败么？</li></ol><p>代理不会失败，只会直接调用目标类的final方法。如update方法是final的，代理类不会做其他的处理，会直接调用UserDAO的update方法。   </p><ol start="3"><li>CGLIB到底比JDk Proxy快在哪里？</li></ol><p>测试环境JDK1.8，平台macOS Catalina。</p><p>一般意义上认为CGLIB在创建动态代理类比JDK Proxy慢，但是在方法调用上CGLIB比JDK Proxy快。<br>但是通过个人的测试，CGLIB在创建动态代理类确实比JDK Proxy慢一点，基本上CGLIB创建一个动态代理类实例需要30ms，JDK Proxy基本上也就10ms。<br>方法调用上100w次JDK proxy用时33233ms，CGLIB用时34259ms。两者差距并不是很明显。</p><ol start="4"><li>为什么CGLIB要使用fastclass机制？</li></ol><p>JDK之前的版本对于反射调用优化不是特别好，反射方法调用很慢，所以为了避免反射带来的性能消耗，采用fastclass机制，fastclass其实就是把需要需要调用的目标方法进行封装，获取到每个方法的索引值，调用时，通过调用方法获取索引值，直接调用到封装的目标方法。这种调用和直接调用性能差别不大。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDK动态代理浅析</title>
      <link href="/java/2019-10-04-jdk-proxy/"/>
      <url>/java/2019-10-04-jdk-proxy/</url>
      
        <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><h2 id="1-使用JDK动态代理"><a href="#1-使用JDK动态代理" class="headerlink" title="1. 使用JDK动态代理"></a>1. 使用JDK动态代理</h2><p>JDK动态代理使用起来很简单，如下：</p><p>TestService是一个业务接口，接口中有个test方法， TestServiceImpl是TestService的实现类。<br>InvocationHandler是JDK动态代理的调用代理方法处理接口，我们JDK使用动态代理时需要实现这个接口，在这个接口的处理方法中编写处理逻辑，你想怎样控制目标方法的访问都可以在这个方法中实现。然后调用Proxy类的静态方法newProxyInstance方法即可获得到代理类实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        TestServiceImpl testService = new TestServiceImpl();</span><br><span class="line">        // 声明自己的处理类</span><br><span class="line">        MyInvokeHandler myInvokeHandler = new MyInvokeHandler(testService);</span><br><span class="line">        // 第一次生成代理类</span><br><span class="line">        TestService proxy = (TestService) Proxy.newProxyInstance(TestService.class.getClassLoader(),new Class[]&#123;TestService.class&#125;,myInvokeHandler);</span><br><span class="line">        // 代理类调用接口方法</span><br><span class="line">        proxy.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestServiceImpl implements TestService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;我要开始测试啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyInvokeHandler implements InvocationHandler&#123;</span><br><span class="line">    Object obj;</span><br><span class="line">    public MyInvokeHandler(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        //在反射调用之前，可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        method.invoke(obj,args);</span><br><span class="line">        //在反射调用之后，也可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface TestService&#123;</span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java通过<code>Proxy</code>类和<code>InvocationHandler</code>接口生成动态代理类<code>$Proxy0</code>。<code>Proxy</code>类是JDK生成动态代理的核心类，包含了JDK动态代理生成代理类的大部分逻辑。</p><!--![java-proxy](/media/article/java-proxy.001.png)--><h2 id="2-Java动态代理源码解析"><a href="#2-Java动态代理源码解析" class="headerlink" title="2. Java动态代理源码解析"></a>2. Java动态代理源码解析</h2><blockquote><p>Class对象每个类只有一个（同一个类加载器的情况下），该Class对象在类加载阶段生成，存储在内存中，非Java虚拟机堆，是该类对外访问的唯一入口。<a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-12.html#jls-12.4" target="_blank" rel="noopener">Java Language Specification 12.4</a></p></blockquote><p>Java生成动态代理类的核心方法是：ProxyClassFactory的<code>Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>。</p><p>参数：<code>ClassLoader loader</code>接口类加载器，<code>Class&lt;?&gt;[] interfaces</code>接口类的Class。</p><p>下面代码主要作用就是通过遍历接口数组，校验接口数组中的数据是否合法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 遍历接口类的Class数组</span><br><span class="line">  for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">      </span><br><span class="line">      Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          // 反射获得接口类Class对象</span><br><span class="line">          interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      // 校验是否是同一个类加载器，如果是不同的类加载器，生成的接口Class对象是不同的</span><br><span class="line">      if (interfaceClass != intf) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // Java动态代理仅支持接口代理</span><br><span class="line">      if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 使用Set来验证传入的接口数组中是否存在相同的接口</span><br><span class="line">      if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>下面这么多代码是为了给下面生成的代理类找到一个合理的包名和类名，如果接口数组中有非public属性的接口，如果此接口的包名不为null，则使用这个接口的包名，否则使用默认的<code>com.sun.proxy</code>包名，类名则是“上述包名+$Proxy+自增数字”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String proxyPkg = null;     </span><br><span class="line">int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">    int flags = intf.getModifiers();</span><br><span class="line">    if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">        accessFlags = Modifier.FINAL;</span><br><span class="line">        String name = intf.getName();</span><br><span class="line">        int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">        String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            proxyPkg = pkg;</span><br><span class="line">        &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (proxyPkg == null) &#123;</span><br><span class="line">    // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">    proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用自增数字区分不同的类</span><br><span class="line">long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br></pre></td></tr></table></figure><p>下面就是整个动态代理最核心的代码。生成代理类class文件的字节码，根据这个文件的字节码生成代理类的Class对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成字节数组，这个字节数组是生成的Class文件的字节数组，将这个字节流输出到class文件，就是上面的$Proxy0代理类。  </span><br><span class="line">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line"> proxyName, interfaces, accessFlags);</span><br><span class="line">try &#123;</span><br><span class="line"> // 通过刚才生成的代理类文件，生成代理类的Class对象。</span><br><span class="line"> return defineClass0(loader, proxyName,</span><br><span class="line">                     proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">&#125; catch (ClassFormatError e) &#123;</span><br><span class="line"> throw new IllegalArgumentException(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码仅仅是生成动态代理类的逻辑，不是JDK Proxy生成动态代理类实例的流程。</p><p>建议下面跟着源码一点点看如下的流程图。</p><p><img src="/media/article/weakcache.png" alt="weakcache"></p><p>第一个结构图是WeakCache的缓存结构图，WeakCache是Proxy的一个实例，每次去创建代理时，都会先去访问WeakCache，WeakCache中没有才会去创建。WeakCache采用两级缓存机制，第一层使用classloader生成的弱引用key，map实例valueMap的value在ConcurrentHashMap map中，valueMap是ConcurrentHasshMap， valueMap中使用接口数组（创建代理类传入的接口数组参数）生成的subKey，这个subKey不是弱引用，valueMap的value即可能是WeakCache.Factory实例，也可能是实现Supplier接口和继承WeakReference类的CacheValue实例。CacheValue用于封装动态生成的代理类的Class对象，WeakCache.Factory中包含生成动态代理类字节码和Class对象的逻辑，这个逻辑就是上面源码分析中的apply方法。<br>第二个是流程图，使用Proxy.newProxyInnstance生成动态代理类时，读取缓存的流程，结合着结构图和代码，应该可以理解JDK Proxy的整个缓存存储结构及读取流程。</p><p>生成的<code>$Proxy0</code>代理类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zhongyp.advanced.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">// 这个地方有两个接口，是因为我之前做测试的时候多加了一个TestService1接口。</span><br><span class="line">final class $Proxy0 extends Proxy implements TestService, TestService1 &#123;</span><br><span class="line"></span><br><span class="line">    // TestSerivce，TestService1两个接口总共就4个方法，test()，test1()，test3()，test4()，这里有7个方法，其中三个是hashCode，toString，equals。</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    private static Method m6;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m5;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 接口中的所有方法都会在代理类中生成，然后将代理类中的方法对象与方法名匹配放到InvocaotionHandler实现类实例的方法参数中</span><br><span class="line">    public final void test() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test3() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m4, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test4() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m6, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test1() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m5, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 动态代理在初始化是会初始化所有的方法对象</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m3 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test&quot;);</span><br><span class="line">            m4 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test3&quot;);</span><br><span class="line">            m6 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test4&quot;);</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m5 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test1&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于JDK动态代理的调用很简单，上面是我们上面的例子输出的动态代理类反编译的代码，我们看到接口中的每个方法<code>super.h.invoke(this, m5, (Object[])null)</code>，super就是Proxy，h是Proxy中的InvocationnHandler实例，InvocationHandler实例反射调用你的方法。InvocationHandler是在生成动态代理类的class对象后，创建动态代理类实例作为构造参数传进去的，所以虽然当前接口参数相同时，可能返回同一个动态代理类Class对象，但是只要InvocationHandler不同，他们就是不同的实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">    super(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/jdk-proxy-invoke.png" alt="jdk-proxy-invoke"></p><p>优点：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比cglib更加可靠。</li><li>平滑进行JDK版本升级，而字节码类库通常需要进行更新来保证在新版Java上能够使用。</li><li>代码实现简单。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>为什么JDK动态代理仅支持实现接口类的动态代理？</li></ol><p>这个问题我觉得可以从JDK做动态代理的初衷来说，JDK动态代理类是在运行时实现指定的接口列表的类，这个是JDK在设计实现动态代理最初就已经确定了的，所以可以看到在生成代理类的过程中，基本上就把接口类当作一个已知条件在使用，包括在定义缓存使用的subKey，代理类包名的生成规则中，反射获取Method对象等等地方，所以不存在为什么只支持实现接口类，而是JDK动态代理类的设计就是这样子的。</p><ol start="2"><li>为什么WeakCache采用两级缓存接口？</li></ol><p>这个问题我们可以从两个缓存的不同点来看，第一层缓存map是一个弱引用key，非弱引用valueMap，第二层缓存valueMap使用的是非弱引用subKey，弱引用CacheValue。我们都知道弱引用只要有垃圾回收时就会被回收，主要是为了防止缓存太多导致服务频繁的FullGC，所以第一层的作用就是当垃圾回收时，将缓存的valueMap全部清空。还有一个原因是第一层缓存使用的是classloader生成的key，所以map其实缓存的是所有当前同一个classloader生成的代理类的class对象。再说第二层缓存，第二层缓存使用的是创建代理类时传入的接口数组生成的subKey，这个是为了区分实现不同接口的动态代理类Class对象，如果说两个类都实现了同一个接口，那岂不是获取的同样的Class对象，这么说也是对的，区别在于实现的InvocationHandler接口的子类h不同，而这个h才是生成代理类实例的最终区别。第二层缓存为什么CacheValue使用弱引用，原因在于第一层缓存虽然key时弱引用，但是value不是，所以垃圾回收时只会回收key，不会回收value，value只会在下一次调用Proxy.newProxyInstance方法时才会去清空无效key的value。所以为了value能及时清空，所以CacheValue也使用了弱引用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射</title>
      <link href="/java/2019-10-04-reflection/"/>
      <url>/java/2019-10-04-reflection/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这种动态获取信息以及动态创建/调用对象方法的功能称为Java语言的反射机制。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以在运行时动态的确定类型并创建实例，可以调用实例中的任意方法即是方法时private的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>相比于编译时确定类型的方式，运行时确定类型创建实例会带来一定的性能消耗。</li><li>反射需要运行时的权限在安全管理器下运行时可能不存在。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。</li><li>由于反射允许代码执行非反射代码中非法的操作（例如访问私有字段和方法），因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射代码破坏了抽象，因此可能会随着平台的升级而改变行为。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><p>反射调用慢在哪里？</p></blockquote><p>相对于在编译时确定对象类型，反射是在运行时动态创建对象并确定对象类型，所以会比编译时确定对象类型多一些性能消耗即慢。<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  User user = new User();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在4.5ms左右</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  Class&lt;?&gt; clazz =  Class.forName(&quot;com.zhongyp.advanced.refect.User&quot;, true, ReflectDemo.class.getClassLoader());</span><br><span class="line">            User user = (User) clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在20ms左右</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>知识结构图</title>
      <link href="/java/2019-09-29-knowledge-structure/"/>
      <url>/java/2019-09-29-knowledge-structure/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/article/knowledge-structure.png" alt="knowledge-structure"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>闲谈Java引用</title>
      <link href="/java/2019-09-15-reference/"/>
      <url>/java/2019-09-15-reference/</url>
      
        <content type="html"><![CDATA[<p>Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。</p><h2 id="1-强引用-StrongReference"><a href="#1-强引用-StrongReference" class="headerlink" title="1. 强引用(StrongReference)"></a>1. 强引用(StrongReference)</h2><p>Java中最常见的引用方式。当一个对象被一个或者一个以上的引用变量引用时，它处于激活状态，不可能被系统垃圾回收机制回收。</p><h2 id="2-软引用-SoftReference"><a href="#2-软引用-SoftReference" class="headerlink" title="2. 软引用(SoftReference)"></a>2. 软引用(SoftReference)</h2><p>软引用需要通过SoftRefrence类来实现，当一个对象只具有软引用时，可能被垃圾回收机制回收。当系统内存空间足够时，它不会被系统回收，当系统内存空间不够时，系统将会回收。</p><p>和弱引用的区别仅仅在于垃圾回收时， 是否根据空间大小回收的区别。</p><p>何时回收软引用的对象？</p><p>从1.3.1开始软可达对象将在最后被引用之后存活一段时间。默认值是堆中每MB空闲空间一秒的生存时间。这个值可以使用<code>-XX:SoftRefLRUPolicyMSPerMB</code>调整。<br>Java Hotspot服务端虚拟机使用最大可能的堆大小计算剩余可用空间。<br>Java Hotspot客户端虚拟机使用当前堆大小计算空闲空间。<br>这就意味着对于服务端虚拟机总体趋势是增长堆而不是清理软引用，因此在垃圾回收时<code>-Xmx</code>对软引用的回收有重要的影响。<br>相反，客户端虚拟机将很大趋势去清理软引用而不是增长堆。</p><p>上述行为对于1.3.1到Java SE 6版本的Java HotSpot VM都是正确的。但是，此行为不是VM规范的一部分，并且在将来的版本中可能会更改。同样，不保证-XX：SoftRefLRUPolicyMSPerMB标志在任何给定的发行版中均不存在。</p><p>在1.3.1版之前，Java HotSpot VM会在发现软引用时清除它们。</p><p>当我定期打开-verbose：gc时，我得到了很多完整的GC，已经调整了堆并且没有什么区别，这是怎么回事？</p><p>如果您使用的是RMI，则可能会遇到分布式GC。另外，某些应用程序添加了显式GC的思想，即它将使它们的应用程序更快。幸运的是，您可以在1.3及更高版本中使用命令行选项禁用此功能。尝试将-XX：+ DisableExplicitGC与-verbose：gc一起使用，看看是否有帮助。</p><h2 id="3-虚引用-PhantomReference"><a href="#3-虚引用-PhantomReference" class="headerlink" title="3. 虚引用(PhantomReference)"></a>3. 虚引用(PhantomReference)</h2><p>虚引用通过PhantomReference实现，虚引用类似于完全没有引用，虚引用对对象本身没有太大的影响。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列(ReferenceQueue)联合使用。</p><p>举例来说就是，如果垃圾回收时，发现一个实例对象除了虚引用外没有任何其他的引用，将会把这个引用放到<br><code>java.lang.ref.Reference.pending</code>队列里，GC完成时，通知ReferenceHandler这个守护线程做一些后续处理（如释放内存等等操作）。</p><h2 id="4-弱引用-WeakReference"><a href="#4-弱引用-WeakReference" class="headerlink" title="4. 弱引用(WeakReference)"></a>4. 弱引用(WeakReference)</h2><p>弱引用通过WeakReference类实现，对只有弱引用的对象而言，当系统垃圾回收机制运行时，不管内存是否足够，总会回收该对象所占用的内存。</p><h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue referenceQueue = new ReferenceQueue();</span><br><span class="line">WeakReference weakReference = new WeakReference(new TestEntity(), referenceQueue);</span><br><span class="line">((TestEntity) weakReference.get()).test();</span><br></pre></td></tr></table></figure><p>ReferenceQueue的作用是为了查看哪些WeakReference和SoftReferece被回收了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p><p><a href="https://www.jianshu.com/p/e66930caca9c" target="_blank" rel="noopener">Java PhantomReference详解</a></p><p><a href="oracle.com/technetwork/java/hotspotfaq-138619.html#gc_softrefs">Frequently Asked Questions About the Java HotSpot VM</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机知识点架构图</title>
      <link href="/jvm/2019-09-08-jvm-structure/"/>
      <url>/jvm/2019-09-08-jvm-structure/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/article/jvm-structure.png" alt="jvm-structure"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态代理浅析</title>
      <link href="/java/2019-09-09-java-proxy/"/>
      <url>/java/2019-09-09-java-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是动态代理？"><a href="#1-什么是动态代理？" class="headerlink" title="1. 什么是动态代理？"></a>1. 什么是动态代理？</h2><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问，而不是增强目标对象的功能。</p><blockquote><p>访问控制包括同步，身份验证，远程访问（RPC），惰性实例化（休眠，Mybatis），AOP（事务）。</p></blockquote><p><img src="/media/article/proxy-invoke-method.png" alt="代理方法调用"></p><p>实现代理的技术有很多，如 CGLIB(ASM)、AspectJ、Javassist、JDK Proxy等。</p><ul><li>ASM: 针对<strong><em>运行时</em></strong>动态生成和转换类（class）的Java语言工具，旨在处理已编译的Java类（class）。<a href="/java/2019-10-04-cglib/">CGLIB浅析</a></li><li>AspectJ: AspectJ采用<strong><em>编译时</em></strong>织入和<strong><em>类加载时</em></strong>织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<a href="/java/2019-10-04-aspectj/">AspectJ</a></li><li>Javassist: Javassist在Java中是一个用来编辑字节码的扩展包，它允许Java程序在<strong><em>运行时</em></strong>定义一个新类或者在JVM<strong><em>加载class文件时</em></strong>修改class文件。<br><a href="/java/2019-09-04-javassist/">Javassist</a></li><li>JDK Proxy: JDK动态代理类是在<strong><em>运行时</em></strong>实现指定的接口列表的类，该类实例上的其中一个接口进行的方法调用时，将被通过统一的接口进行编码并调用到另一个对象。因此，动态代理类可用于为接口列表创建类型安全的代理对象，而无需诸如在编译时使用编译工具预生成代理类。动态代理类实例的代理方法调用将在该代理类实例中的处理程序中通过java.lang.reflect.Method对象进行调用，该对象标识了所调用的方法和包含参数的Object类型数组，翻译自<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a>。详情<a href="/java/2019-10-04-jdk-proxy/">《JDK 动态代理浅析》</a></li></ul><p>在Java语言中，从构建代理类的时期上来看，有三种：编译时、类加载时和运行时。从方式上来说有两种，一种是静态代理，一种是动态代理。<br>动态代理则是一种方便<strong><em>运行时</em></strong>动态构建代理、动态处理代理方法调用的机制。例如ASM，Javassist，Java Proxy。</p><p><strong><em>编译时</em></strong>和<strong><em>类加载时</em></strong>构建代理类则属于静态代理。例如AspectJ。</p><h2 id="2-常用代理方式"><a href="#2-常用代理方式" class="headerlink" title="2. 常用代理方式"></a>2. 常用代理方式</h2><p>由于篇幅问题，本文进行了拆分，详细了解常用的代理方式的原理，请点击下方链接。</p><p><a href="/java/2019-10-04-jdk-proxy/">JDK proxy</a></p><p><a href="/java/2019-10-04-cglib/">CGLIB浅析</a></p><p><a href="/java/2019-10-04-aspectj/">AspectJ</a></p><p><a href="/java/2019-09-04-javassist/">Javassist</a></p><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h2><p><img src="/media/article/15688575046625.png" alt="jclasslib"><br>图片引用自<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">《美团技术团队》-字节码增强技术探索</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>1.Java生成动态代理的时候，使用WeakCache缓存已经生成的动态代理工厂，疑问点在于，为什么缓存的key使用的是<a href="/java/2019-09-15-reference/">弱引用</a>？</p><p>答: 类中的静态变量，当它持有一个指向一个对象的引用时，它就作为GC Root，第一类被列为GC Root的元素就是静态成员变量。因此若缓存不再需要时，使用强引用会让GC进行标记分析时认为从GC Root可达，不太会去标记这块内存，反之能够有效地标记这些缓存，从而提高内存回收效率。引用自<a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a></p><p>个人分析: 既然缓存代理工厂类，为什么不使用SoftReference，这样只有内存空间不够时才会进行回收。这样可以最大限度的缓存生成的代理工厂？<br>如果使用SoftReference，当服务使用动态代理较多时，可能会导致频繁的FullGC。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html" target="_blank" rel="noopener">Java动态代理机制分析及扩展，第1部分</a><br><a href="https://www.cnblogs.com/whirly/p/10154887.html" target="_blank" rel="noopener">Java 动态代理详解</a><br><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a><br><a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a><br><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a><br><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>了解ASM</title>
      <link href="/java/2019-10-06-asm/"/>
      <url>/java/2019-10-06-asm/</url>
      
        <content type="html"><![CDATA[<h2 id="ASM-是个啥"><a href="#ASM-是个啥" class="headerlink" title="ASM 是个啥"></a>ASM 是个啥</h2><blockquote><p><strong><a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a>技术是个啥？</strong><br>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br>ASM是一个通用的Java字节码操作和分析框架。它可以直接以二进制形式用于修改现有类或动态生成类。 ASM提供了一些常见的字节码转换和分析算法，可以从中构建定制的复杂转换和代码分析工具。 ASM提供与其他Java字节码框架类似的功能，但侧重于性能。因为它的设计和实现是尽可能的小和尽可能快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中使用）。<br>ASM应用广泛：OpenJDK lambda call sites，<a href="http://hg.openjdk.java.net/jdk8/jdk8/nashorn/file/096dc407d310/src/jdk/nashorn/internal/codegen/ClassEmitter.java" target="_blank" rel="noopener">Nashorn compiler</a><br>CGLIB，以动态生成代理类（用于其他项目，例如Mockito和EasyMock），Gradle，在运行时生成一些类。</p></blockquote><h2 id="ASM的原理解析"><a href="#ASM的原理解析" class="headerlink" title="ASM的原理解析"></a>ASM的原理解析</h2><p>ASM中最主要通过<a href="https://github.com/zhongyp/demo/tree/master/src/main/java/com/zhongyp/advanced/pattern/visitor" target="_blank" rel="noopener">访问模式</a>对字节码文件进行修改，读取。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机类加载机制</title>
      <link href="/jvm/2019-08-18-jvm-classloading/"/>
      <url>/jvm/2019-08-18-jvm-classloading/</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p></blockquote><p>Java 虚拟机动态的加载，连接，初始化类或者接口。</p><p>加载是一个通过特殊符号查找类或者接口类型的二进制文件，同时使用二进制文件创建类或者接口的过程。</p><p>连接是一个加载类或者接口并结合它变为Java虚拟机的运行时状态的过程，以便于它可以被Java虚拟机执行。</p><p>一个类或者接口的初始化由执行类或者接口的初始化方法<code>&lt;clinit&gt;</code>组成(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener">§2.9</a>)。</p><p>下图是类或者接口动态加载、连接、初始化的过程：</p><p><img src="/media/article/jvm-classloading.png" alt="jvm-classloading"></p><p>图片摘自<a href="">深入理解Java虚拟机</a></p><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h2><p>加载阶段：</p><ul><li><ol><li>通过一个类的全限定名来获取定义此类二进制字节流。</li></ol></li><li><ol start="2"><li>将这个字节流代表的静态存储结构转换为方法区的运行时数据结构(运行时数据结构详见第四小节<a href="#4-运行时常量池"></a>)。</li></ol></li><li><ol start="3"><li>在<strong><em>内存(Class对象比较特殊，它虽然是对象，但是存储在方法区中)</em></strong>生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol></li></ul><p>对于数组类本身不通过类加载器创建，它由Java虚拟机直接创建。数组类型却由类加载器创建，创建过程遵循以下规则：</p><ul><li>如果数组组件类型是引用类型，则数组被标记为组件类型定义的类加载器定义。否则，数组被标记为引导类加载器定义。</li><li>如果数组的组件类型不是引用类型，Java虚拟机将会把数组标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认是public。</li></ul><p>加载和连接阶段是交叉进行的。</p><h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h2><p>如果需要连接类或接口涉及验证和准备该类或接口，直接超类，直接超接口及其元素类型（如果它是数组类型）。类或接口中符号引用的解析是连接的可选部分。</p><p>只要维护了以下所有属性，此规范允许实现灵活性，以便何时发生连接活动（以及由于递归，加载）。</p><ul><li><p>类或接口在连接之前已完全加载。</p></li><li><p>在初始化之前，类或接口已完全验证并准备好。</p></li></ul><p>在连接期间检测到的错误被抛出到程序中的某个点，程序可能会直接或间接地需要连接到错误中涉及的类或接口。</p><p>例如，Java虚拟机实现可以选择在使用它时分别解析类或接口中的每个符号引用，或者在验证类时立即解析它们。这意味着在一些实现中，在初始化类或接口之后，解析过程可以继续。无论采用哪种策略，在解析期间检测到的任何错误都必须抛出到程序中（直接或间接）使用对类或接口的符号引用的位置。</p><p>因为连接涉及新数据结构的分配，所以它可能会失败OutOfMemoryError。</p><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>验证阶段会完成4个阶段的验证动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置类变量<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。进行内存分配的仅包括<strong><em>类变量[static变量]</em></strong>，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><h3 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic，这些虚拟机指令对运行时常量池进行符号引用，执行任何这些指令都需要解析其符号引用。</p><p>解析是从运行时常量池中的符号引用动态确定具体值的过程。</p><p>对出现在invokedynamic指令的相同的符号引用被解析一次并不意味着被任何其他invokedynamic指令认为已解析。</p><p>对于上述提到的所有指令，如果其中一个指令对符号引用进行了解析，则意味着任何非invokedynamic指令认为这个符号引用已经解析。</p><p>如果在解析符号引用期间发生错误，则必须在程序中(直接或间接)使用符号引用时的某一点抛出IncompatibleClassChangeError(或子类)的实例。</p><p>如果Java虚拟机尝试解析符号引用失败，抛出的错误是LinkageError(或子类)的实例，后续尝试解析引用始终失败，并且和初始解析尝试而引发的错误相同。</p><p>在执行指令之前，不得解析特定invokedynamic指令对调用site说明符的符号引用。</p><p>在<code>invokedynamic</code>指令解析失败的情况下，后续解析尝试不会重新执行引导方法。</p><p>上述某些指令在解析符号引用时需要额外的连接检查。例如，为了使getfield指令成功解析对其运行的字段的符号引用，它不仅必须完成第<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2" target="_blank" rel="noopener">5.4.3.2</a>节中给出的字段解析步骤，还要检查字段是否为静态。如果它是静态字段，则必须抛出链接异常。</p><p>值得注意的是，为了使<code>invokedynamic</code>指令成功解析对调用site说明符的符号引用，其中指定的引导方法必须正常完成并返回合适的调用站点对象。如果引导方法突然完成或返回不合适的调用站点对象，则必须抛出连接异常。</p><p>连接由特定执行特定Java虚拟机指令检查生成的异常在该指令的描述中给出，并且在本解析的一般性讨论中未涉及。请注意，此类异常虽然被描述为Java虚拟机指令执行而非解析的一部分，但仍然被视为解析失败。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h2><p>一个类的加载过程中加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，解析阶段则不一定。解析可以在初始化完成后再开始，这时为了支持Java的运行时绑定。</p><p>Java虚拟机没有进行强制约束什么时候加载，只是严格规范了5中情况必须对类进行”初始化”。</p><ul><li>遇到new、getstatic、putstatic或invokestatic这4条指令时，如果类没有进行初始化，则需要先触发其初始化。4条指令的常见场景是:使用new 关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)、以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7及以上版本的动态语言(详细了解 <a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a>)支持时，如果一个java.lang.incoke.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。</li></ul><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有 <strong><em>类变量的赋值动作</em></strong>和<strong><em>静态语句块(static{}块)中的语句</em></strong>合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语义块之前的变量，定义在它之后的变量，可以赋值，但是不能访问。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test()&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>不需要执行其父接口的<code>&lt;clinit&gt;()</code>方法。<br>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待。</p></blockquote><h2 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4. 运行时常量池"></a>4. 运行时常量池</h2><p>Java虚拟机维护每种类型常量池，这是一种运行时数据结构，它服务于常规编程语言实现的符号表的许多目的。</p><p>类或接口的二进制表示形式中的constant_pool表用于在创建类或接口对象时构造运行时常量池。运行时常量池中的所有引用最初都是符号引用。运行时常量池中的符号引用是从类或接口的二进制表示中的结构派生的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">String str = &quot;str&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">// 基本类型</span><br><span class="line">int i = 1;</span><br><span class="line"></span><br><span class="line">// 基本类型数组</span><br><span class="line">int[] arrayI = new int[3];</span><br><span class="line"></span><br><span class="line">// 引用类型数组</span><br><span class="line">A [] arrayA = new A[3];</span><br><span class="line"></span><br><span class="line">// 引用类型</span><br><span class="line">A a = new A();</span><br><span class="line"></span><br><span class="line">// 引用方法</span><br><span class="line">a.test();</span><br><span class="line"></span><br><span class="line">// 接口声明</span><br><span class="line">C c = new B();</span><br><span class="line"></span><br><span class="line">// 接口方法</span><br><span class="line">c.test();</span><br><span class="line"></span><br><span class="line">// lambda</span><br><span class="line">Runnable x = ()-&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p><code>javap -v</code>编译如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #13.#42        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #25            // str</span><br><span class="line">   #3 = Fieldref           #43.#44        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #45.#46        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #47            // com/zhongyp/test/A</span><br><span class="line">   #6 = Methodref          #5.#42         // com/zhongyp/test/A.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #7 = Methodref          #5.#48         // com/zhongyp/test/A.test:()V</span><br><span class="line">   #8 = Class              #49            // com/zhongyp/test/B</span><br><span class="line">   #9 = Methodref          #8.#42         // com/zhongyp/test/B.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #10 = InterfaceMethodref #50.#48        // com/zhongyp/test/C.test:()V</span><br><span class="line">  #11 = InvokeDynamic      #0:#55         // #0:run:()Ljava/lang/Runnable;</span><br><span class="line">  #12 = Class              #56            // com/zhongyp/test/Test</span><br><span class="line">  #13 = Class              #57            // java/lang/Object</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               LocalVariableTable</span><br><span class="line">  #19 = Utf8               this</span><br><span class="line">  #20 = Utf8               Lcom/zhongyp/test/Test;</span><br><span class="line">  #21 = Utf8               main</span><br><span class="line">  #22 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               args</span><br><span class="line">  #24 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               str</span><br><span class="line">  #26 = Utf8               Ljava/lang/String;</span><br><span class="line">  #27 = Utf8               i</span><br><span class="line">  #28 = Utf8               I</span><br><span class="line">  #29 = Utf8               arrayI</span><br><span class="line">  #30 = Utf8               [I</span><br><span class="line">  #31 = Utf8               arrayA</span><br><span class="line">  #32 = Utf8               [Lcom/zhongyp/test/A;</span><br><span class="line">  #33 = Utf8               a</span><br><span class="line">  #34 = Utf8               Lcom/zhongyp/test/A;</span><br><span class="line">  #35 = Utf8               c</span><br><span class="line">  #36 = Utf8               Lcom/zhongyp/test/C;</span><br><span class="line">  #37 = Utf8               x</span><br><span class="line">  #38 = Utf8               Ljava/lang/Runnable;</span><br><span class="line">  #39 = Utf8               lambda$main$0</span><br><span class="line">  #40 = Utf8               SourceFile</span><br><span class="line">  #41 = Utf8               Test.java</span><br><span class="line">  #42 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #43 = Class              #58            // java/lang/System</span><br><span class="line">  #44 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #45 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #46 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #47 = Utf8               com/zhongyp/test/A</span><br><span class="line">  #48 = NameAndType        #64:#15        // test:()V</span><br><span class="line">  #49 = Utf8               com/zhongyp/test/B</span><br><span class="line">  #50 = Class              #65            // com/zhongyp/test/C</span><br><span class="line">  #51 = Utf8               BootstrapMethods</span><br><span class="line">  #52 = MethodHandle       #6:#66         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #53 = MethodType         #15            //  ()V</span><br><span class="line">  #54 = MethodHandle       #6:#67         // invokestatic com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #55 = NameAndType        #68:#69        // run:()Ljava/lang/Runnable;</span><br><span class="line">  #56 = Utf8               com/zhongyp/test/Test</span><br><span class="line">  #57 = Utf8               java/lang/Object</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #64 = Utf8               test</span><br><span class="line">  #65 = Utf8               com/zhongyp/test/C</span><br><span class="line">  #66 = Methodref          #70.#71        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #67 = Methodref          #12.#72        // com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #68 = Utf8               run</span><br><span class="line">  #69 = Utf8               ()Ljava/lang/Runnable;</span><br><span class="line">  #70 = Class              #73            // java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #71 = NameAndType        #74:#78        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #72 = NameAndType        #39:#15        // lambda$main$0:()V</span><br><span class="line">  #73 = Utf8               java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #74 = Utf8               metafactory</span><br><span class="line">  #75 = Class              #80            // java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #76 = Utf8               Lookup</span><br><span class="line">  #77 = Utf8               InnerClasses</span><br><span class="line">  #78 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #79 = Class              #81            // java/lang/invoke/MethodHandles</span><br><span class="line">  #80 = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #81 = Utf8               java/lang/invoke/MethodHandles</span><br></pre></td></tr></table></figure><h3 id="4-1-CONSTANT-Class-info结构"><a href="#4-1-CONSTANT-Class-info结构" class="headerlink" title="4.1 CONSTANT_Class_info结构"></a>4.1 CONSTANT_Class_info结构</h3><p>对类或接口的符号引用是从类或接口的二进制表示形式中的CONSTANT_Class_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1" target="_blank" rel="noopener">第4.4.1节</a>派生的。这样的引用给出了Class.getName方法返回的表单中的类或接口的名称。</p><p>对于非数组类或接口，名称是类或接口的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>。</p><p>对于n维的数组类，名称以n个出现的ASCII“[”字符开头，后跟元素类型的表示：</p><ul><li><p>如果元素类型是基本类型，则它由相应的字段描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">第4.3.2节</a>表示。</p></li><li><p>否则，如果元素类型是引用类型，则它由ASCII“L”字符后跟元素类型的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>后跟ASCII“;”符号表示。</p></li></ul><h3 id="4-2-CONSTANT-Fieldref-info结构"><a href="#4-2-CONSTANT-Fieldref-info结构" class="headerlink" title="4.2 CONSTANT_Fieldref_info结构"></a>4.2 CONSTANT_Fieldref_info结构</h3><p>对类或接口的字段的符号引用是从类或接口的二进制表示形式中的CONSTANT_Fieldref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了字段的名称和描述符，以及对要在其中找到字段的类或接口的符号引用。</p><h3 id="4-3-CONSTANT-Methodref-info结构"><a href="#4-3-CONSTANT-Methodref-info结构" class="headerlink" title="4.3 CONSTANT_Methodref_info结构"></a>4.3 CONSTANT_Methodref_info结构</h3><p>对类的方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_Methodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了方法的名称和描述符，以及对要在其中找到方法的类的符号引用。</p><h3 id="4-4-CONSTANT-InterfaceMethodref-info"><a href="#4-4-CONSTANT-InterfaceMethodref-info" class="headerlink" title="4.4 CONSTANT_InterfaceMethodref_info"></a>4.4 CONSTANT_InterfaceMethodref_info</h3><p>对接口方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_InterfaceMethodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了接口方法的名称和描述符，以及对要在其中找到方法的接口的符号引用。</p><h3 id="4-5-CONSTANT-MethodHandle-info结构"><a href="#4-5-CONSTANT-MethodHandle-info结构" class="headerlink" title="4.5 CONSTANT_MethodHandle_info结构"></a>4.5 CONSTANT_MethodHandle_info结构</h3><p>方法句柄的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodHandle_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.8" target="_blank" rel="noopener">第4.4.8节</a>派生的。这样的引用根据方法句柄的类型给出了类或接口的字段，类的方法或接口的方法的符号引用。</p><h3 id="4-6-CONSTANT-MethodType-info结构"><a href="#4-6-CONSTANT-MethodType-info结构" class="headerlink" title="4.6 CONSTANT_MethodType_info结构"></a>4.6 CONSTANT_MethodType_info结构</h3><p>方法类型的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodType_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.9" target="_blank" rel="noopener">第4.4.9节</a>派生的。这样的引用给出了方法描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">§4.3.3</a>。</p><h3 id="4-7-CONSTANT-InvokeDynamic-info结构"><a href="#4-7-CONSTANT-InvokeDynamic-info结构" class="headerlink" title="4.7 CONSTANT_InvokeDynamic_info结构"></a>4.7 CONSTANT_InvokeDynamic_info结构</h3><blockquote><h3 id="invokedynamic-instructions"><a href="#invokedynamic-instructions" class="headerlink" title="invokedynamic instructions"></a>invokedynamic instructions</h3><p>A dynamic call site is originally in an unlinked state. In this state, there is no target method for the call site to invoke.<br>动态的调用site起初处在未连接的状态。在这种状态下，调用site没有调用的目标方法。<br>Before the JVM can execute a dynamic call site (an invokedynamic instruction), the call site must first be linked. Linking is accomplished by calling a bootstrap method which is given the static information content of the call site, and which must produce a method handle that gives the behavior of the call site.<br>在JVM可以执行动态调用site（invokedynamic指令）之前，必须首先连接调用site。连接是通过调用一个bootstrap方法来完成的，该方法被赋予了调用站点的静态信息内容，并且必须产生一个方法句柄来给出调用站点的行为。<br>Each invokedynamic instruction statically specifies its own bootstrap method as a constant pool reference. The constant pool reference also specifies the call site’s name and type descriptor, just like invokevirtual and the other invoke instructions.<br>每个invokedynamic指令静态的将它自己的引导方法指定作为一个常量池引用。常量池引用也指定调用site的名称和类型描述，就像invokevirtual和其他的调用描述一样。<br>Linking starts with resolving the constant pool entry for the bootstrap method, and resolving a MethodType object for the type descriptor of the dynamic call site. This resolution process may trigger class loading. It may therefore throw an error if a class fails to load. This error becomes the abnormal termination of the dynamic call site execution. Linkage does not trigger class initialization.<br>连接从解析引导方法的常量池条目开始，并为动态调用site的类型描述符解析MethodType对象。这个解决的进程可能触发类加载。如果一个类加载失败，可能因此抛出一个error。这个error将成为动态调用site执行的异常终止。连接不能触发类的初始化。<br>The bootstrap method is invoked on at least three values:<br>引导方法至少使用3个值调用:</p><ul><li>a MethodHandles.Lookup, a lookup object on the caller class in which dynamic call site occurs</li><li>一个是MethodHandles.Lookup，发生动态调用site的调用类上的一个lookup对象。</li><li>a String, the method name mentioned in the call site</li><li>一个字符创，在调用site中提到的方法名称。</li><li>a MethodType, the resolved type descriptor of the call</li><li>一个MethodType，已解析的调用的类型描述。</li><li>optionally, between 1 and 251 additional static arguments taken from the constant pool。</li><li>可选地，从常量池中获取1到251个额外的静态参数。</li></ul></blockquote><p>对调用站点说明符的符号引用是从类或接口的二进制表示形式中的CONSTANT_InvokeDynamic_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.10" target="_blank" rel="noopener">第4.4.10节</a>派生的。这样的参考给出：</p><ul><li><p>方法句柄的符号引用，它将作为invokedynamic指令的引导方法<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic" target="_blank" rel="noopener">§invokedynamic</a>;</p></li><li><p>一系列符号引用(对类，方法类型和方法句柄)，字符串文字和运行时常量值，它们将作为引导方法的静态参数;</p></li><li><p>方法名称和方法描述符。</p></li></ul><h3 id="4-8-CONSTANT-String-info结构"><a href="#4-8-CONSTANT-String-info结构" class="headerlink" title="4.8 CONSTANT_String_info结构"></a>4.8 CONSTANT_String_info结构</h3><p>此外，某些不是符号引用的运行时值是从constant_pool表中找到的项派生的：</p><p>字符串文字是对类String实例的引用，它是从类或接口的二进制表示形式的CONSTANT_String_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3" target="_blank" rel="noopener">第4.4.3节</a>派生而来的。 CONSTANT_String_info结构给出了构成字符串文字的Unicode代码点序列。</p><p>Java编程语言要求相同的字符串文字[即包含相同代码点序列的文字]必须引用类String的相同实例(JLS§3.10.5)。此外，如果在任何字符串上调用String.intern方法，则结果是对该字符串显示为文字时将返回的同一类实例的引用。因此，以下表达式的值必须为true：</p><p><code>(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</code></p><p>为了派生字符串文字，Java虚拟机检查CONSTANT_String_info结构给出的代码点序列。</p><p>如果先前在类String的实例上调用了String.intern方法，该类包含与CONSTANT_String_info结构给出的Unicode代码点序列相同的Unicode代码点序列，则字符串文字派生的结果是对类String的同一实例的引用。</p><p>否则，将创建一个类String的新实例，其中包含CONSTANT_String_info结构给出的Unicode代码点序列;对该类实例的引用是字符串文字派生的结果。最后，调用新String实例的intern方法。</p><h3 id="4-9-其他结构"><a href="#4-9-其他结构" class="headerlink" title="4.9 其他结构"></a>4.9 其他结构</h3><p>运行时常量值是从类或接口的二进制表示形式中的CONSTANT_Integer_info，CONSTANT_Float_info，CONSTANT_Long_info或CONSTANT_Double_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">第4.4.4节，第4.4.5节</a>派生的。</p><p>请注意，CONSTANT_Float_info结构表示IEEE 754单一格式的值，CONSTANT_Double_info结构表示IEEE 754双格式<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">§4.4.4，§4.4.5</a>中的值。因此，从这些结构导出的运行时常数值必须是可以分别使用IEEE 754单格式和双格式表示的值。</p><p>类或接口的二进制表示的constant_pool表中的其余结构 - CONSTANT_NameAndType_info和CONSTANT_Utf8_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.6" target="_blank" rel="noopener">§4.4.6，§4.4.7</a> - 仅在派生对类，接口，方法，字段的符号引用时间接使用，方法类型和方法句柄，以及派生字符串文字和调用站点说明符时。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a></p><p><a href="">深入理解Java虚拟机</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/package-summary.html#package.description" target="_blank" rel="noopener">Package java.lang.invoke Description</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM官方文档指南</title>
      <link href="/jvm/2019-08-08-offical-document/"/>
      <url>/jvm/2019-08-08-offical-document/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">Java虚拟机规范</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Data Redis的execute和executePipelined的区别</title>
      <link href="/redis/2019-08-06-execute-executePipelined/"/>
      <url>/redis/2019-08-06-execute-executePipelined/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spring-data-redis 2.0.7.RELEASE</p></blockquote><h2 id="executePipelined方法说明"><a href="#executePipelined方法说明" class="headerlink" title="executePipelined方法说明"></a>executePipelined方法说明</h2><p>executePipelined方法基于Redis的pipelining。关于pipelining官方解释如下: </p><p>A Request/Response server can be implemented so that it is able to process new requests even if the client didn’t already read the old responses. This way it is possible to send multiple commands to the server without waiting for the replies at all, and finally read the replies in a single step.<br>—摘自<a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">Redis Piplining</a></p><p>上面的意思大概是Redis服务器可以实现即使没有读取旧响应的情况下也可以发送新的请求，以这种方式可以发送多个命令到服务器而不用等待回复，最后一次获取全部的回复。这就是Redis Pipelining。</p><p>executePipelined的官方注释:</p><p>Executes the given action object on a pipelined connection, returning the results. Note that the callback cannot return a non-null value as it gets overwritten by the pipeline. This method will use the default serializers to deserialize results.</p><p>上面这句话的意思在一个<strong><em>管道连接</em></strong>中执行给定的动作对象，并返回结果。但是需要注意的是callback不能返回一个非null的值，callback的值将被pipeline覆盖。这个方法将使用默认的序列化和反序列化方式处理结果集。</p><p>例举executePipelined(SessionCallback&lt;?&gt; session, @Nullable RedisSerializer&lt;?&gt; resultSerializer) 方法源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt; executePipelined(SessionCallback&lt;?&gt; session, @Nullable RedisSerializer&lt;?&gt; resultSerializer) &#123;</span><br><span class="line">        Assert.isTrue(this.initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);</span><br><span class="line">        Assert.notNull(session, &quot;Callback object must not be null&quot;);</span><br><span class="line">        RedisConnectionFactory factory = this.getRequiredConnectionFactory();</span><br><span class="line">        // 是否开启事务管理，将当前连接注册到事务管理器</span><br><span class="line">        RedisConnectionUtils.bindConnection(factory, this.enableTransactionSupport);</span><br><span class="line"></span><br><span class="line">        List var4;</span><br><span class="line">        try &#123;</span><br><span class="line">            // this.execute其实就是execute，所以本质上来说，两个方法的区别在于executePipeline方法开启了pipeline</span><br><span class="line">            var4 = (List)this.execute((connection) -&gt; &#123;</span><br><span class="line">                // 开启管道</span><br><span class="line">                connection.openPipeline();</span><br><span class="line">                boolean pipelinedClosed = false;</span><br><span class="line"></span><br><span class="line">                List var7;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 在连接中执行SessionCallback中的动作，并获取结果集</span><br><span class="line">                    Object result = this.executeSession(session);</span><br><span class="line">                    // 如果结果集不为空，抛出InvalidDataAccessApiUsageException</span><br><span class="line">                    if (result != null) &#123;</span><br><span class="line">                        throw new InvalidDataAccessApiUsageException(&quot;Callback cannot return a non-null value as it gets overwritten by the pipeline&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    List&lt;Object&gt; closePipeline = connection.closePipeline();</span><br><span class="line">                    pipelinedClosed = true;</span><br><span class="line">                    // 获取管道返回的结果集并序列化</span><br><span class="line">                    var7 = this.deserializeMixedResults(closePipeline, resultSerializer, this.hashKeySerializer, this.hashValueSerializer);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (!pipelinedClosed) &#123;</span><br><span class="line">                        connection.closePipeline();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                // 返回管道的结果集</span><br><span class="line">                return var7;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码中<code>this.execute((connection)...</code>其实就是execute(RedisCallback&lt;?&gt; session)方法。所以executePipelined方法只是在execute内中开启了pipeline而已。</p><h2 id="execute方法说明"><a href="#execute方法说明" class="headerlink" title="execute方法说明"></a>execute方法说明</h2><p>execute相对于<code>executePipelined(SessionCallback&lt;?&gt; session)</code>比较简单，没有过多的处理，而是直接执行SessionCallback中的动作，官方注释如下:</p><p>Executes a Redis session. Allows multiple operations to be executed in the same session enabling ‘transactional’ capabilities through RedisOperations.multi() and RedisOperations.watch(Collection) operations.</p><p>大概意思是执行一个Redis会话。允许在<strong><em>同一会话</em></strong>中执行多个操作，通过RedisOperations.multi()和RedisOperations.watch(Collection)操作启用“事务”功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public &lt;T&gt; T execute(SessionCallback&lt;T&gt; session) &#123;</span><br><span class="line">        Assert.isTrue(this.initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);</span><br><span class="line">        Assert.notNull(session, &quot;Callback object must not be null&quot;);</span><br><span class="line">        RedisConnectionFactory factory = this.getRequiredConnectionFactory();</span><br><span class="line">        RedisConnectionUtils.bindConnection(factory, this.enableTransactionSupport);</span><br><span class="line"></span><br><span class="line">        Object var3;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 执行SessionCallback并获取执行SessionCallback返回的结果集</span><br><span class="line">            var3 = session.execute(this);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接返回结果集</span><br><span class="line">        return var3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="execute和executePipelined区别"><a href="#execute和executePipelined区别" class="headerlink" title="execute和executePipelined区别"></a>execute和executePipelined区别</h2><p>从上面两段源码示例可以看出，execute和executePipelined的最主要区别是executePipelined开启了pipeline。pipline与execute正常的请求/响应的区别主要在于请求/响应模式上，execute是串行化的命令请求，executePipelined请求与响应则是穿插进行。两者区别如图所示:<br>串行:<br><img src="/media/article/redis-execute.png" alt="redis-execute"></p><p>execute方法是串行的，命令请求发出后，必须得到响应数据，才能发送下一条命令请求。所以在一次Redis会话中，一次会话可能包含多次请求，即多次RTT。</p><p>穿插:</p><p><img src="/media/article/redis-executepipeline.png" alt="redis-executepipeline.png"></p><p>executePipelined是穿插的，可以批量发送命令到服务器，也可以批量获取响应数据。即可能使用一次RTT就能完成批量操作。</p><p>除了网络协议上的区别外，execute和executePipelined都支持事务管理器，支持multi，watch，exec，discard等事务操作，不过execute与executePipelined的这些操作还是有些区别的。</p><p>例如 JedisConnection开启multi:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void multi() &#123;</span><br><span class="line">   if (!this.isQueueing()) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           if (this.isPipelined()) &#123;</span><br><span class="line">               // 如果开启了pipeline，则使用Pipeline内部的multi</span><br><span class="line">               // Pipeline绑定的是client</span><br><span class="line">               this.getRequiredPipeline().multi();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // 没有开启pipeline使用jedis的multi</span><br><span class="line">               // jedis的multi绑定的是connection</span><br><span class="line">               this.transaction = this.jedis.multi();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception var2) &#123;</span><br><span class="line">           throw this.convertJedisAccessException(var2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jedis与Pipeline的命令绑定的对象不一样，前者绑定的是connection，后者绑定client。这和上面提到的请求/响应模式有关。<br>watch，exec，discard等操作也是如此。</p><p>除此之外，executePipelined的SessionCallback是不能有返回值的，executePipelined需要返回Pipleline的返回值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wuxian90/article/details/81322536" target="_blank" rel="noopener">Redis客户端与服务端交互详解</a></p><p><a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">pipelining</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> FAQ </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis 设计与实现</title>
      <link href="/redis/2019-06-21-redis/"/>
      <url>/redis/2019-06-21-redis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据结构与对象"><a href="#1-数据结构与对象" class="headerlink" title="1. 数据结构与对象"></a>1. 数据结构与对象</h2><h3 id="1-1-简单动态字符串（SDS）"><a href="#1-1-简单动态字符串（SDS）" class="headerlink" title="1.1 简单动态字符串（SDS）"></a>1.1 简单动态字符串（SDS）</h3><p>Redis没有使用C语言传统的字符串表示，而是构建了一种简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。Redis只会使用C字符串作为字面量。<br>除了用来保存数据库中的字符串值之外，SDS还被用做缓冲区(buffer): AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是SDS实现的。</p><blockquote><p>在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。</p></blockquote><h4 id="1-1-1-SDS的定义"><a href="#1-1-1-SDS的定义" class="headerlink" title="1.1.1 SDS的定义"></a>1.1.1 SDS的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    // 记录buf数组中已使用字节的数量</span><br><span class="line">    // 等于SDS所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    // 记录buf数组中未使用字节的数量</span><br><span class="line">    int free;</span><br><span class="line">    // 字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/15611092689335.jpg" alt="SDS示例"></p><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。</p><h4 id="1-1-2-与C字符串的区别"><a href="#1-1-2-与C字符串的区别" class="headerlink" title="1.1.2 与C字符串的区别"></a>1.1.2 与C字符串的区别</h4><ol><li>获取字符串长度复杂度：C字符串不记录长度信息，所以获取字符串长度复杂度为O(N)，SDS为O(1)。</li><li>杜绝缓冲区溢出：<code>strcat</code>函数可以将src字符串中的内容拼接到dest字符串的末尾:<br><code>char *strcat(char *dest, const char *src)</code><br>因为C字符创不记录自身的长度，所以<code>strcat</code>假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立，就会产生缓冲区溢出。SDS在执行拼接操作之前检查s的长度是否足够，在发现s目前的空间不足以拼接时，sdscat就会扩展s的空间，然后执行拼接操作。</li><li>减少修改字符串时带来的内存重分配次数：b中说道每次拼接字符串时，C字符串都要对C字符串进行一次内存重分配操作（即：在拼接操作，需要扩展空间大小，否则缓冲区溢出；在截断操作，需要释放多余空间，否则内存泄漏），因为重分配是比较耗时的操作，所以为了避免频繁修改字符串对性能造成的影响，SDS通过未使用空间接触了字符串长度和底层数组长度之间的关联：SDS中，buf的长度不一定是字符数量+1，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</li></ol><blockquote><p>空间预分配</p><ul><li>如果对SDS进行修改之后，SDS的长度小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。</li><li>如果对SDS修改之后，SDS的长度大于1MB，那么程序会分配1MB的未使用空间。</li></ul><p>惰性空间释放</p><ul><li>当 SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录下来，并等待将来使用。同时SDS提供了相应的API，在有需要时，释放SDS未使用的空间，这样就可以避免惰性空间释放策略会造成内存浪费。</li></ul></blockquote><h4 id="1-1-3-二进制安全"><a href="#1-1-3-二进制安全" class="headerlink" title="1.1.3 二进制安全"></a>1.1.3 二进制安全</h4><p>C语言字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符串，所以C字符串只能保存文本数据，不能保存二进制数据。<br>SDS的API都是二进制安全(binary-safe)的。</p><h4 id="1-1-4-兼容部分C字符串的函数"><a href="#1-1-4-兼容部分C字符串的函数" class="headerlink" title="1.1.4 兼容部分C字符串的函数"></a>1.1.4 兼容部分C字符串的函数</h4><p>虽然SDS的API都是二进制安全的，但是API总会将SDS保存的数据的末尾设置为空字符串，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数。</p><h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><p>当一个列表键包含数量比较多的元素，又或者包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区(output buffer)。</p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li><li>带链表长度的计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h3 id="1-3-字典"><a href="#1-3-字典" class="headerlink" title="1.3 字典"></a>1.3 字典</h3><h4 id="1-3-1-结构"><a href="#1-3-1-结构" class="headerlink" title="1.3.1 结构"></a>1.3.1 结构</h4><p>字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair)的抽象数据结构。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><p>字典结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">    // 类型特定函数</span><br><span class="line">    dicType *type;</span><br><span class="line">    </span><br><span class="line">    // 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line">    </span><br><span class="line">    // 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    </span><br><span class="line">    // rehash索引</span><br><span class="line">    // 当rehash不在进行时，值为-1</span><br><span class="line">    in threhash; /* rehashing not in progress if rehashidx == -1 */</span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。<br>privdata属性则保存了需要传给那些类型特定函数的可选参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dicType&#123;</span><br><span class="line"></span><br><span class="line">// 计算哈希值的函数</span><br><span class="line">unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">// 复制键的函数</span><br><span class="line">void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">// 对比键的函数</span><br><span class="line">int (*keyCompare)(void *privdata,const void *key1,const void *key);</span><br><span class="line"></span><br><span class="line">// 销毁键</span><br><span class="line">(*keyDestructor)(void *privdata,void *key);</span><br><span class="line"></span><br><span class="line">// 复制值</span><br><span class="line">void(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">// 销毁值</span><br><span class="line">void(*valDestructor)(void *privdata,void *obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ht属性是一个包含两个项的数组，数组的每项都是dictht哈希表，一般情况下只是用ht[0]，ht[1]只会在对ht[0]哈希表进行rehash时使用。<br>除ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有进行rehash，那么它的值为-1。<br><img src="/media/article/dicht.png" alt="dic"></p><h4 id="1-3-2-哈希算法"><a href="#1-3-2-哈希算法" class="headerlink" title="1.3.2 哈希算法"></a>1.3.2 哈希算法</h4><p>Redis使用的是<a href="http://code.google.com/p/smhasher/" target="_blank" rel="noopener">MurmurHash2</a>算法。</p><ol><li>算出hash值：hash=dict-&gt;type-&gt;hashFunction(key);</li><li>根据hash值计算索引值：index = hash &amp; dict-&gt;ht[x].sizemask;//x是0或1</li></ol><h4 id="1-3-4-键冲突"><a href="#1-3-4-键冲突" class="headerlink" title="1.3.4 键冲突"></a>1.3.4 键冲突</h4><p>Redis的哈希表使用链地址法(separate chaining)来解决冲突，每个哈希表节点都有一个next指针，多个哈希表节点就可以用next指针构成一个单项链表。速度考虑，最新节点添加到表头位置，复杂度O(1)。</p><h4 id="1-3-5-rehash"><a href="#1-3-5-rehash" class="headerlink" title="1.3.5 rehash"></a>1.3.5 rehash</h4><blockquote><p><strong>为什么无论是HashMap还是Redis，扩容/收缩时容量大小都是2的幂？</strong></p><ul><li>减少碰撞次数，比如1111&amp;1110=1110，1110&amp;1110=1110；</li><li>容量*2不至于分配空间过大造成浪费；</li></ul></blockquote><p>Redis对字典的rehash步骤如下：</p><ol><li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量：</li></ol><ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n；</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n；</li></ul><ol start="2"><li>将保存在ht[0]中的所有键值对rehash到ht[1]上:rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li></ol><p><strong> 哈希表的扩展与收缩 </strong></p><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p><ul><li>服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子=哈希表已保存节点数量/哈希表大小</span><br><span class="line">load_factor = ht[0].used/ht[0].size</span><br></pre></td></tr></table></figure><p>执行BGSAVE或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，大多数操作系统都采用写时复制(copy-on-write)技术优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子。<br>当哈希表的负载因子小于0.1时，程序自动开始执行收缩操作。</p><h4 id="1-3-6-渐进式rehash"><a href="#1-3-6-渐进式rehash" class="headerlink" title="1.3.6 渐进式rehash"></a>1.3.6 渐进式rehash</h4><p>rehash动作不是一次性、集中式的完成，而是分多次、渐进式的完成。<br>渐进式rehash步骤:</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash值ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作完成。</li></ol><p>在渐进式rehash期间，字典的删除、查找、更新等操作会在两个哈希表上进行。如果新加到字典的键值对一律被保存到ht[1]里面。</p><h3 id="1-4-跳跃表"><a href="#1-4-跳跃表" class="headerlink" title="1.4 跳跃表"></a>1.4 跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p><h4 id="1-4-1-结构"><a href="#1-4-1-结构" class="headerlink" title="1.4.1 结构"></a>1.4.1 结构</h4><p><img src="/media/article/skiplist.png" alt="skiplist"><br>上图展示了一个跳跃表示例，左边是zskiplist结构：</p><ul><li>header: 指向跳跃表的表头节点</li><li>tail: 指向跳跃表的结尾节点</li><li>level: 记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length: 记录跳跃表的长度，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>右侧是zskiplistNode结构：</p><ul><li>level: 节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，以此类推。每层两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，跨度则记录了前进指针所指向节点和当前节点的距离。</li><li>backward: 节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>score: 各个节点中的1.0、2.0、和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排序。</li><li>obj: 各个节点中的o1、o2和o3时节点所保存的成员对象。</li></ul><h3 id="1-5-整数集合"><a href="#1-5-整数集合" class="headerlink" title="1.5 整数集合"></a>1.5 整数集合</h3><p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。<br>整数集合是Redis用于保存整数值的集合抽象数据结构，他可以保存集合类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    // 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    // 集合包含的元素</span><br><span class="line">    uint32_t length;</span><br><span class="line">    // 保存元素的数据</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现:整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小从小打到有序的排列，并且数组中不包含任何重复项。</p><h4 id="1-5-1-整数集合升级"><a href="#1-5-1-整数集合升级" class="headerlink" title="1.5.1 整数集合升级"></a>1.5.1 整数集合升级</h4><p>每当我们将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合先进行升级，然后添加到整数集合里面。</p><p>升级步骤：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，放置元素过程中，需要维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><h3 id="1-6-压缩列表"><a href="#1-6-压缩列表" class="headerlink" title="1.6 压缩列表"></a>1.6 压缩列表</h3><p>当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><p>压缩列表是为了节约内存开发的，是由一系列特殊编码的连续内存块组织的顺序(sequential)数据结构。</p><p><img src="/media/article/ziplist.png" alt="ziplist"><br><img src="/media/article/ziplistintroduce.png" alt="ziplistintroduce"></p><p>节点content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><h4 id="1-6-1-连锁更新"><a href="#1-6-1-连锁更新" class="headerlink" title="1.6.1 连锁更新"></a>1.6.1 连锁更新</h4><p>连锁更新最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最快复杂度为O(N)，所以更新的最快复杂度为O(N^2)。</p><h3 id="1-7-快速列表-quicklist"><a href="#1-7-快速列表-quicklist" class="headerlink" title="1.7 快速列表(quicklist)"></a>1.7 快速列表(quicklist)</h3><p>quicklist是一个ziplist的双向链表（双向链表是由多个节点Node组成的）。也就是说quicklist的每个节点都是一个ziplist。ziplist本身也是一个能维持数据项先后顺序的列表（按插入位置），而且是一个各个数据项在内存上前后相邻的列表。<br>结构如下:</p><p><img src="/media/article/quicklist.png" alt="quicklist"><br>图片来自<a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a></p><p>quicklist基于空间和时间的考虑，结合双向链表和ziplist的优点。</p><blockquote><p>双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。<br>ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。<br>摘自<a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau Redis源码剖析–quicklist</a></p></blockquote><h4 id="快速列表存储效率"><a href="#快速列表存储效率" class="headerlink" title="快速列表存储效率"></a>快速列表存储效率</h4><p>本小节引用自《<a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a>》</p><blockquote><p>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。<br>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。</p></blockquote><p>实际上，Redis提供了一个配置参数<code>list-max-ziplist-size</code>，就是为了让使用者可以来根据自己的情况进行调整。</p><p>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。</p><p>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：</p><ul><li>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）</li><li>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</li><li>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。</li><li>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</li><li>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</li></ul><p>当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数list-compress-depth就是用来完成这个设置的。</p><p><code>list-compress-depth 0</code><br>这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。</p><p>参数list-compress-depth的取值含义如下：</p><ul><li>0: 是个特殊值，表示都不压缩。这是Redis的默认值。</li><li>1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。</li><li>2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。</li><li>3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</li></ul><p>依此类推…<br>由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p><p>Redis对于quicklist内部节点的压缩算法，采用的<a href="http://oldhome.schmorp.de/marc/liblzf.html" target="_blank" rel="noopener">LZF</a>——一种无损压缩算法。</p><h3 id="1-8-对象"><a href="#1-8-对象" class="headerlink" title="1.8 对象"></a>1.8 对象</h3><p>Redis并没有 直接使用SDS、双端链表、字典、压缩列表、整数集合这些数据结构实现键值对数据库，而是基于这些数据结构创建了一个对象系统。对象系统包含：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。<br>Redis的对象系统实现了基于引用计数计数的内存回收机制，当程序 不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外Redis还通过引用计数技术实现了对象共享机制，这种机制在适当情况下，通过让多个数据库键共享同一个对象来节约内存。<br>Redis对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能情况下，空转时长较大的那些键可能会优先被服务器删除。</p><h4 id="1-8-1-对象的类型与编码"><a href="#1-8-1-对象的类型与编码" class="headerlink" title="1.8.1 对象的类型与编码"></a>1.8.1 对象的类型与编码</h4><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，一个对象用作键值对的值。</p><p>Redis中的每个对象都由一个RedisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    </span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    </span><br><span class="line">    // 指向底层实现数据结构的指针</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>type记录了对象的类型：</p><ul><li>REDIS_STRING:字符串对象</li><li>REDIS_LIST:列表对象</li><li>REDIS_HASH:哈希对象</li><li>REDIS_SET:集合对象</li><li>REDIS_ZSET:有序集合对象</li></ul><blockquote><p>字符串键指的是这个数据库键所对应的值得字符串对象<br>列表键指的是数据库键所对应的值为列表对象</p></blockquote><p>ptr指针指向对象的底层实现数据结构，这些数据结构由对象的encoding属性决定。encoding记录对象使用的编码：</p><p><img src="/media/article/encoding-type.png" alt="encoding"><br>除上述列表外，还有一个是REDIS_ENCODING_QUICKLIST编码，快速列表。</p><p>每种类型的对象都至少使用了两种不同编码，下表列出了每种类型的对象可以使用的编码。</p><p><img src="/media/article/type-encoding.png" alt="type-encoding"></p><p>除上述列表外，还有一个是REDIS_LIST对应REDIS_ENCODING_QUICKLIST。</p><h4 id="1-8-2-字符串对象"><a href="#1-8-2-字符串对象" class="headerlink" title="1.8.2 字符串对象"></a>1.8.2 字符串对象</h4><p>字符串对象的编码可以是int、raw或者embstr。<br>如果字符串对象保存的是整数值，将字符串对象的编码设置为int。<br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度大于32字节，字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为raw。<br>raw结构：<br><img src="/media/article/raw.png" alt="raw"><br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度小于32字节，字符串对象将使用embstr编码的方式保存这个字符串值。<br>embstr内存块结构：<br><img src="/media/article/embstr.png" alt="embstr"><br><strong>raw和embstr区别：</strong></p><ul><li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li><li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码字符串对象比起来raw编码的字符串能够更好地利用缓存带来的优势。</li></ul><p>字符串对象保存各类型值得编码方式:</p><p><img src="/media/article/string-type-value.png" alt="string"></p><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。<br>Redis没有为embstr编码的字符串对象编写任何响应的修改程序，所以embstr编码的字符串对象实际上是只读的。</p><p><img src="/media/article/string-order-implement.png" alt="string"></p><h4 id="1-8-3-列表对象"><a href="#1-8-3-列表对象" class="headerlink" title="1.8.3 列表对象"></a>1.8.3 列表对象</h4><p>3.2版本之前列表对象的编码可以使ziplist或者linkedlist。<br>ziplist结构如下：<br><img src="/media/article/ziplist-store.png" alt="ziplist"></p><p>linkedlist结构如下：</p><p><img src="/media/article/linkedlist-store.png" alt="linkedlist"></p><p>StringObject结构：</p><p><img src="/media/article/string-obj-store.png" alt="string-object"></p><p>当列表对象满足如下条件时，使用ziplist编码：<br>列表对象保存的所有字符串元素的长度都小于64字节；<br>列表对象保存的元素数量小于512个；</p><p><strong>列表命令的实现：</strong><br><img src="/media/article/list-order-implement.png" alt="list-order"></p><p>在3.2版本之后唯一的数据结构是快表（quicklist），它是一个双向链表，而且是一个ziplist的双向链表。</p><h4 id="1-8-4-哈希对象"><a href="#1-8-4-哈希对象" class="headerlink" title="1.8.4 哈希对象"></a>1.8.4 哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值得压缩列表节点推入到压缩列表表尾：</p><ul><li>因此保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;HSET profile name &quot;Tom&quot;</span><br><span class="line">&gt;HSET profile age 25</span><br><span class="line">&gt;HSET profile career &quot;Programmer&quot;</span><br></pre></td></tr></table></figure></p><p>哈希对象的压缩列表底层实现：</p><p><img src="/media/article/hash-ziplist-implement.png" alt="hash-ziplist-implement"></p><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><p>如果上述例子不是ziplist而是hashtable，则结构如下：</p><p><img src="/media/article/hashtable-implement.png" alt="hashtable-implement"></p><p>如果哈希对象满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值得字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；</li></ul><p><strong>hash命令：</strong></p><p><img src="/media/article/hash-order.png" alt="hash-order"></p><h4 id="1-8-5-集合对象"><a href="#1-8-5-集合对象" class="headerlink" title="1.8.5 集合对象"></a>1.8.5 集合对象</h4><p>集合对象编码可以是intset或者hashtable。</p><p><strong>集合命令：</strong></p><p><img src="/media/article/set-order.png" alt="set-order"><br><img src="/media/article/set-order1.png" alt="set-order"></p><h4 id="1-8-6-有序集合对象"><a href="#1-8-6-有序集合对象" class="headerlink" title="1.8.6 有序集合对象"></a>1.8.6 有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist。</p><p><strong>ziplist的的存储结构：</strong></p><p><img src="/media/article/sorted-set-ziplist.png" alt="sorted-set-ziplist"><br><img src="/media/article/sorted-set-ziplist1.png" alt="sorted-set-ziplist"></p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset&#123;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点保存了一个集合元素:跳跃表节点的Object属性保存了元素的成员，而跳跃表的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，如<code>ZRANK</code>、<code>ZRANGE</code>等命令就是基于跳跃表API来实现的。</p><p>除此之外，zset结构中的dict字典为有序集合创建了一个从成员的分值的映射，字典中的每个键值对都保存了一个集合元素:字典的键保存了元素的成员，而字典的值保存了元素的分值。通过这个字典，程序可以O(1)复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的。</p><p>虽然zset结构同时使用跳跃表和字典来保存有序集合元素，而这两种数据机构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或分值，也不会浪费额外内存。</p><blockquote><p><strong>为什么有序集合需要同时使用跳跃表和字典来实现？</strong><br>如果我们只是用字典来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p></blockquote><p><strong>skiplist结构：</strong></p><p><img src="/media/article/sorted-set-skiplist.png" alt="sorted-set-skiplist"></p><p><strong><em>注意：字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p><strong>命令实现：</strong></p><p><img src="/media/article/sorted-set-order.png" alt="sorted-set-order"></p><h4 id="1-8-7-类型检查与命令多态"><a href="#1-8-7-类型检查与命令多态" class="headerlink" title="1.8.7 类型检查与命令多态"></a>1.8.7 类型检查与命令多态</h4><p>Redis中用于操作键的命令基本上可以分为两种类型。<br>一种可以对任何类型键执行；另一种只能对特定类型的键执行。</p><p>Redis在执行一个类型特定的命令之前，会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。<br>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的:</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需类型，如果是的话执行。</li><li>否则，拒绝执行，返回类型错误。</li></ul><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。如llen：</p><p><img src="/media/article/llen-order.png" alt="llen-order"></p><h4 id="1-8-8-内存回收"><a href="#1-8-8-内存回收" class="headerlink" title="1.8.8 内存回收"></a>1.8.8 内存回收</h4><p>因为C不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数(reference counting)技术实现的内存回收机制。</p><h4 id="1-8-9-对象共享"><a href="#1-8-9-对象共享" class="headerlink" title="1.8.9 对象共享"></a>1.8.9 对象共享</h4><p>Redis对象的引用计数属性还带有对象共享的作用（多个键共享同一个值对象）。<br>这些共享对象不单单只有字符串键可以使用，那些数据结构中嵌套了字符串对象的对象都可以使用这些共享对象。</p><p>Redis只对包含整数值的字符串对象进行共享。</p><h4 id="1-8-10-对象的空转时长"><a href="#1-8-10-对象的空转时长" class="headerlink" title="1.8.10 对象的空转时长"></a>1.8.10 对象的空转时长</h4><p>除了type、encoding、ptr和refcount四个属性外，redisObject结构包含的最后一个属性为lru属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    unsigned lru:22;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>OBJECT IDLETIME命令可以打印出键的空转时长，计算方式：当前时间-lru。</p><h2 id="2-单机数据库实现"><a href="#2-单机数据库实现" class="headerlink" title="2. 单机数据库实现"></a>2. 单机数据库实现</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p><p><strong>数据库结构示例：</strong><br><img src="/media/article/redis-db.png" alt="db"></p><p>redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典成为键空间：</p><p><strong>数据库键空间示例：</strong><br><img src="/media/article/redis-db-keyspace.png" alt="db"></p><p>键空间的键也就是数据库的键，每个键都是一个字符串对象。<br>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。<br>数据库的键空间是一个字典。</p><p><strong> 读写空间时的维护操作</strong></p><ul><li>读取一个键后，服务器会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>读取一个键后，服务器会更新键的LRU时间，可以使用OBJECT idletime <key> 命令查看键key的闲置时间。</key></li><li>如果服务器在读取一个键时发现该键过期，服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果客户端使用watch命令监视了某个键，那么服务器在对被监视的键进行修改后，会将这个键标记为脏(dirty)。</li><li>服务器每次修改一个键后，都会对(dirty)键计数器的值增1，这个计数器会触发服务器的持久化及复制操作。</li><li>如果服务器开启了数据库通知功能，那么对键进行修改之后，服务器将按配置发送响应的数据库通知。</li></ul><h3 id="2-1-过期时间"><a href="#2-1-过期时间" class="headerlink" title="2.1 过期时间"></a>2.1 过期时间</h3><p>Redis有四种不同的命令可以用于设置键的生存时间或过期时间:</p><ul><li><code>EXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl秒。</li><li><code>PEXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl毫秒。</li><li><code>EXPIREAT&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp秒数时间戳。</li><li><code>PEXPIRE&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp毫秒数时间戳。</li></ul><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典:</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><p>PERSIST命令可以移除一个键的过期时间。</p><p>TTL命令以秒级单位返回键的剩余生存时间，PTTL命令以毫秒为单位返回键的剩余生存时间。</p><h3 id="2-2-过期键删除策略"><a href="#2-2-过期键删除策略" class="headerlink" title="2.2 过期键删除策略"></a>2.2 过期键删除策略</h3><p>定时删除: 在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作。<br>惰性删除: 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。<br>定期删除: 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><h4 id="2-2-1-定时删除"><a href="#2-2-1-定时删除" class="headerlink" title="2.2.1 定时删除"></a>2.2.1 定时删除</h4><p>定时删除对内存友好，对CPU时间不友好，在过期键比较多的情况下，删除过期键这一行为可能会占用相同一部分CPU时间。</p><h4 id="2-2-2-惰性删除"><a href="#2-2-2-惰性删除" class="headerlink" title="2.2.2 惰性删除"></a>2.2.2 惰性删除</h4><p>惰性删除策略对CPU友好，对内存不友好。有内存泄漏的风险。</p><h4 id="2-2-3-定期删除"><a href="#2-2-3-定期删除" class="headerlink" title="2.2.3 定期删除"></a>2.2.3 定期删除</h4><p>定期删除操作的难点在于如果确定删除操作的时长和频率。</p><h4 id="2-2-4-Redis的过期删除策略"><a href="#2-2-4-Redis的过期删除策略" class="headerlink" title="2.2.4 Redis的过期删除策略"></a>2.2.4 Redis的过期删除策略</h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略。</p><h4 id="2-2-5-AOF、RDB和复制功能对过期键的处理"><a href="#2-2-5-AOF、RDB和复制功能对过期键的处理" class="headerlink" title="2.2.5 AOF、RDB和复制功能对过期键的处理"></a>2.2.5 AOF、RDB和复制功能对过期键的处理</h4><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件是，程序会对数据库中的键进行检查，已过期的键不会保存到新建的RDB文件中。</p><p><strong>RDB文件载入：</strong></p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模型运行，那么载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过主从服务器在进行数据同步时，从服务器的数据库会被清空。</li></ul><p>AOF重写的过程中，会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><p>当服务器在复制模式下时，从服务器的过期键删除动作有主服务器控制:</p><ul><li>主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告诉从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，及时碰到过期键也不会将过期键删除，而继续像处理未过期的键一样处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令后，才会删除过期键。</li></ul><h4 id="2-2-6-数据库通知"><a href="#2-2-6-数据库通知" class="headerlink" title="2.2.6 数据库通知"></a>2.2.6 数据库通知</h4><p>数据库通知时Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>监听索引为0的键空间key为message所有操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SUBSCRIBE __keyspace@0__:message</span><br></pre></td></tr></table></figure></p><h3 id="2-3-RDB持久化"><a href="#2-3-RDB持久化" class="headerlink" title="2.3 RDB持久化"></a>2.3 RDB持久化</h3><h4 id="2-3-1-RDB文件的创建与载入"><a href="#2-3-1-RDB文件的创建与载入" class="headerlink" title="2.3.1 RDB文件的创建与载入"></a>2.3.1 RDB文件的创建与载入</h4><p>Redis命令可用于生成RDB文件，一个是SAVE，另一个是BGSAVE。<br>SAVE会阻塞Redis服务进程，知道RDB文件创建完毕，阻塞期间，服务器不能处理任何命令请求。<br>BGSAVE命令会派生除一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求。<br>BGSAVE命令正在执行，客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕后执行。<br>BGREWRITEAOF正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</p><blockquote><p>如果开启了AOF持久化功能，服务器会优先使用AOF文件还原数据库状态。<br>只有AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</p></blockquote><h4 id="2-3-2-自动间隔性保存"><a href="#2-3-2-自动间隔性保存" class="headerlink" title="2.3.2 自动间隔性保存"></a>2.3.2 自动间隔性保存</h4><h4 id="2-3-3-RDB文件结构"><a href="#2-3-3-RDB文件结构" class="headerlink" title="2.3.3 RDB文件结构"></a>2.3.3 RDB文件结构</h4><p><img src="/media/article/rdb-structure.png" alt="rdb"></p><p>REDIS部分用来校验是否为RDB文件。<br>db_version长度为4字节，记录RDB文件的版本号。<br>databases部分包含着两个或者任意多个数据库，以及各个数据库中的键值对数据。<br>EOF标志着RDB文件的正文结束。<br>check_sum保存着一个校验和，由REDIS、db_version、databases、EOF计算得出。校验RDB文件是否出错或者损坏。</p><p>database部分保存任意多个非空数据库，如下图所示，每个非空数据库可以保存SELECTDB、db_number、key_value_pairs:</p><p><img src="/media/article/rdb-structure1.png" alt="rdb"><br><img src="/media/article/rdb-database.png" alt="rdb"></p><p>SELEECT表示数据库号码。<br>db_number保存一个数据库号码。<br>key_value_pairs保存数据库中的所有键值对数据。</p><p><img src="/media/article/rdb-file-structure.png" alt="rdb"></p><p>key_values_pairs保存了一个以上的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。<br>不过期时间的键值对由TYPE、key、value组成。<br>TYPE:</p><ul><li>REDIS_RDB_TYPE_STRING</li><li>REDIS_RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_ZIPLIST</li></ul><p>过期时间的键值对在RDB文件中结构:<br><img src="/media/article/rdb-expire-structure.png" alt="rdb"></p><h3 id="2-4-AOF持久化"><a href="#2-4-AOF持久化" class="headerlink" title="2.4 AOF持久化"></a>2.4 AOF持久化</h3><p>AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤。</p><h4 id="2-4-1-命令追加"><a href="#2-4-1-命令追加" class="headerlink" title="2.4.1 命令追加"></a>2.4.1 命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-2-文件写入与同步"><a href="#2-4-2-文件写入与同步" class="headerlink" title="2.4.2 文件写入与同步"></a>2.4.2 文件写入与同步</h4><p>Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def eventLoop():</span><br><span class="line">    while True:</span><br><span class="line">        # 处理文件事件，接收命令请求以及发送命令回复</span><br><span class="line">        # 处理命令请求时可能会有新内容被追加到aof_buf缓冲区中</span><br><span class="line">        processFileEvents()</span><br><span class="line">        </span><br><span class="line">        # 处理时间事件</span><br><span class="line">        processTimeEvents()</span><br><span class="line">        </span><br><span class="line">        # 考虑是否将aof_buf中的内容写入和保存到AOF文件里面</span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定，各个不同值产生的行为如表:<br><img src="/media/article/appendfsycn.png" alt="appendfsync"></p><h4 id="2-4-3-AOF重写"><a href="#2-4-3-AOF重写" class="headerlink" title="2.4.3 AOF重写"></a>2.4.3 AOF重写</h4><p>因为AOF通过保存执行的写命令来记录数据库状态，所以可能造成AOF文件过大。为了解决这个问题，Redis提供了AOF文件重写功能。通过创建一个新的AOF文件替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF通常比旧AOF小得多。<br>重写功能通过读取服务器当前的数据状态来实现的。因为aof——rewirte函数生成的新的AOF只包含还原当前数据库状态所必需的的命令，所以新AOF文件不会浪费任何硬盘空间。</p><p><strong>注意:</strong><br>在实际中，为了避免执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查所包含的元素数量，如果元素数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值。</p><p>aof_rewrite会长时间阻塞，所以Redis将AOF重写程序放到子进程里执行:</p><ul><li>子进程进行AOF重写期间，服务器进程可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>AOF重写期间，客户端命令可能对现有数据库状态修改，造成当前数据库状态和AOF文件不一致的情况。</p><p>为了解决不一致的情况，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令后，它同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>AOF完成重写后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作:</p><ul><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子的覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ul><p>AOF后台重写过程中，只有信号处理函数执行时会对服务器进程造成阻塞，其他时候，AOF不会阻塞父进程。</p><h3 id="2-5-事件"><a href="#2-5-事件" class="headerlink" title="2.5 事件"></a>2.5 事件</h3><p>Redis服务器是一个事件驱动程序:</p><ul><li>文件事件: Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信产生响应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件: Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h4 id="2-5-1-文件事件"><a href="#2-5-1-文件事件" class="headerlink" title="2.5.1 文件事件"></a>2.5.1 文件事件</h4><p>Redis基于Reactor模式开发了自己的网络事件处理器: 这个处理器被称为文件事件处理器:</p><ul><li>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><h4 id="2-5-2-时间事件"><a href="#2-5-2-时间事件" class="headerlink" title="2.5.2 时间事件"></a>2.5.2 时间事件</h4><p>Redis的时间事件分为以下两类:</p><ul><li>定时事件: 让一段程序在指定的时间之后执行一次。</li><li>周期性时间: 让一段程序每隔指定时间执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成:</p><ul><li>id: 服务器为时间事件创建的全局唯一ID。从小到大递增。</li><li>when: 毫秒级精度的UNIX时间戳，记录了时间事件的到达时间。</li><li>timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件: 该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性事件: 当一个时间事件到达之后，服务器会根据事件处理器返回的值，对事件事件的when属性进行更新，这个事件在一段时间之后再次到达，并以这种方式一致更新并运行下去。</li></ul><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行，这些定期操作由redis.c/serverCron函数负责执行，主要工作包括:</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF和RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><h4 id="2-5-3-事件调度与执行"><a href="#2-5-3-事件调度与执行" class="headerlink" title="2.5.3 事件调度与执行"></a>2.5.3 事件调度与执行</h4><p>事件调度和执行由ae.c/aeProcessEvents函数负责。</p><blockquote><p>processFileEvent这个函数并不存在，在实际中，处理已产生文件事件的代码是直接写在aeProcessEvents函数里面。</p></blockquote><p>事件调度和执行规则:</p><ol><li>aeApiPoll函数的最大阻塞时间由到达时间最近当前时间的时间事件决定，这个方法既可以避免服务器对事件事件进行频繁的轮询，也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何事件事件到达，那么服务器将再次等待处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件。</li><li>对文件事件和时间事件的处理都是同步、有序、原子的执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此不管是文件事件的处理器，还是时间事件的处理器，也不会对事件进行抢占，一次不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可的减少程序阻塞时间，并在有需要时主动让出执行权，从而降低造成时间饥饿的可能性。另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li><li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间晚一些。</li></ol><h2 id="3-多机数据库实现"><a href="#3-多机数据库实现" class="headerlink" title="3. 多机数据库实现"></a>3. 多机数据库实现</h2><h3 id="3-1-复制"><a href="#3-1-复制" class="headerlink" title="3.1 复制"></a>3.1 复制</h3><p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制(replicate)另一个服务器。</p><p>Redis复制功能分为同步和命令传播两个操作：</p><ul><li>同步操作用于将服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致的状态。</li></ul><p>Redis复制实现：</p><ol><li>客户端发送命令(此命令是异步的)：<code>&gt;SLAVEOF master-ip master-port</code>。</li><li>1命令在从服务上完成masterhost和masterport属性的设置之后，从服务器返回OK。</li><li>从服务器根据masterhost和masterport建立socket连接。</li><li>发送PING命令，检查socket连接的读写状态，检查主服务器的命令处理，如果主服务器返回非PONG，则断开并重连主服务器。</li><li>从服务器发送身份验证信息。</li><li>发送从服务器的端口信息。</li><li>同步PSYNC。</li><li>最后命令传播。</li></ol><p>Redis复制流程图：</p><p><img src="/media/article/redis-replicate.png" alt="redis-replicate"></p><p>从Redis 2.8版本开始，Redis使用PSYNC代替SYNC命令执行复制操作。<br>PSYNC命令执行：</p><p><img src="/media/article/psync.png" alt="PSYNC"></p><p>PSYNC与SYNC最显著的区别是PSYNC支持部分重同步。</p><h3 id="3-2-Sentinel"><a href="#3-2-Sentinel" class="headerlink" title="3.2 Sentinel"></a>3.2 Sentinel</h3><p>Sentinel是Redis的高可用解决方案。</p><p>启动Sentinel时，执行<code>redis-server /path/sentinel.conf --sentinel</code>或者<code>redis-sentinel /path/sentinel.conf</code>命令即可。</p><p>Sentinel启动时，需要执行以下步骤：</p><ol><li>初始化服务器</li><li>将普通Redis服务器使用的代码替换成Sentinel专用代码</li><li>初始化Sentinel状态</li><li>根据给定配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连向主服务器的网络连接</li></ol><p>Sentinel状态图：<br><img src="/media/article/redis-sentinel-state.png" alt="redis-sentinel-state"></p><h4 id="3-2-1-获取主从、Sentinel的信息"><a href="#3-2-1-获取主从、Sentinel的信息" class="headerlink" title="3.2.1 获取主从、Sentinel的信息"></a>3.2.1 获取主从、Sentinel的信息</h4><p>初始化Sentinel最后一步是创建连向主服务器的网络连接，Sentinel将成为主服务器的客户端。</p><p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络：</p><ul><li>命令连接，这个连接专门向主服务器发送命令，并接收命令回复。</li><li>订阅连接，这个连接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道。 </li></ul><p>Sentinel默认以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，通过INFO获取主服务器的当前信息。<br>Sentinel通过主服务器发现从服务器时，也会建立上述的两个连接，每10秒发送INFO命令，获取从服务器的当前信息。<br>默认情况下，Sentinel每2秒通过命令连接向所有主从服务器发送如下命令：<br><code>PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_id&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;</code>“</p><p>s开头的是sentinel的信息，m开头的是主服务器的信息，如果发送的是从服务器，则m为从服务器正在复制的主服务器的信息。<br>Sentinel与一个主或从服务器建立订阅连接后，Sentinel就会通过订阅连接，向服务器发送以下命令:<br><code>SUBSCRIBE __sentinel__:hello</code></p><p>Sentinel通过频道信息发现一个新的Sentinel时，不仅会为新的Sentinel创建相应的实例结构，还会创建一个连向新Sentinel的命令连接。</p><h4 id="3-2-1-下线状态"><a href="#3-2-1-下线状态" class="headerlink" title="3.2.1 下线状态"></a>3.2.1 下线状态</h4><p>Sentinel每1秒一次的频率向所有与它建立命令连接的实例发送PING命令，判断是否在线。<br>实例在down-after-milliseconds内返回+PONG、-LOADING、-MASTERDOWN以外的回复，Sentinel将修改该实例的flags属性:SRI_S_DOWN标识，标识进入主观下线状态。<br>超时也会被置为主观下线状态。</p><p>当主服务器被判定为主观下线后，为确认是否真的下线了，Sentinel会询问监视此服务器的其他Sentinel，如果从其他Sentinel得到足够数量的已下线判断后，Sentinel将此服务器置为客观下线。</p><p>Redis下线状态及Sentinel领头选举：<br><img src="/media/article/redis-down.png" alt="redis-down"><br>上图中，1. master代表一个主服务器，2. 监视master的sentinel代表其中一个监视master的sentinel(所有监视master的sentinel都会这样去操作，这个地方只是列出来一个作为示例)，3. 监视master的sentinel代表监视master的sentinel的集合。</p><h4 id="3-2-2-故障转移"><a href="#3-2-2-故障转移" class="headerlink" title="3.2.2 故障转移"></a>3.2.2 故障转移</h4><p>故障转移步骤：</p><ul><li><ol><li>在已下线的主服务器的从服务器中，选一个作为主服务器。</li></ol></li><li><ol start="2"><li>让其他没有作为主服务器的从服务器复制新的主服务器。</li></ol></li><li><ol start="3"><li>将已下线的主服务器置为新主服务器的从服务器，当下线的主服务器再上线时，它就会成为新主服务器的从服务器。</li></ol></li></ul><h3 id="3-3-集群"><a href="#3-3-集群" class="headerlink" title="3.3 集群"></a>3.3 集群</h3><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。</p><h4 id="3-3-1-节点"><a href="#3-3-1-节点" class="headerlink" title="3.3.1 节点"></a>3.3.1 节点</h4><p>当一个节点node发送<code>CLUSTER MEET &lt;IP&gt; &lt;PORT&gt;</code>命令，可以让node节点与ip和port所指定的节点进行握手(handshake)，当握手成功后，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。<br>集群数据结构示例:<br><img src="/media/article/redis-cluster.png" alt="cluster"></p><h4 id="3-3-2-槽"><a href="#3-3-2-槽" class="headerlink" title="3.3.2 槽"></a>3.3.2 槽</h4><p>Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为16384个槽(slot)，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理0个或者最多16384个槽。</p><p>如果16384个槽都有节点在处理时，集群处于上线状态(ok)，相反如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态(fail)。</p><p>槽分配命令<code>CLUSTER ADSLOTS &lt;slot&gt; [slot ...]</code>，例如<code>127.0.0.1:6379&gt;cluster addslots 0 1 2 ... 1000</code>将0到1000的槽分配给本地的6379节点负责。</p><p>槽分配后节点的ClusterState结构:</p><p><img src="/media/article/redis-clusterstate.png" alt="clusterstate"></p><p>集群节点数据库存储结构:</p><p><img src="/media/article/redis-clusterstate1.png" alt="clusterstate"></p><p>集群节点保存key对应槽的跳跃表:</p><p><img src="/media/article/redis-slots-to-key.png" alt="clusterstate"></p><h4 id="3-3-3-分片"><a href="#3-3-3-分片" class="headerlink" title="3.3.3 分片"></a>3.3.3 分片</h4><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的减值对也会从源节点被移动到目标节点。</p><p>Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重分配分片所需要的所有命令。</p><p>Redis重分片迁移过程:</p><p><img src="/media/article/redis-migrate.png" alt="migrate"></p><p>迁移过程中，查询key的命令过程如下:</p><p><img src="/media/article/redis-ask.png" alt="redis-ask"></p><p><img src="/media/article/redis-asking.png" alt="redis-asking"></p><h4 id="3-3-4-故障检测"><a href="#3-3-4-故障检测" class="headerlink" title="3.3.4 故障检测"></a>3.3.4 故障检测</h4><p>集群中的每个节点都会定期的向集群中的其他节点发送PING消息，以此来检测对方是否在线。</p><h4 id="3-3-5-消息"><a href="#3-3-5-消息" class="headerlink" title="3.3.5 消息"></a>3.3.5 消息</h4><p>集群中的各个节点通过发送和接收消息(message)来进行通信。消息主要以下五种:</p><ul><li>MEET消息:当发送者接收客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</li><li>PING消息:集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对五个节点中最长时间没有发送过PING消息的节点发送PING消息。</li><li>PONG消息:当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。</li><li>FAIL消息:当一个主节点A判断另一个主节点B进入FAIL状态时，节点A会向集群广播一条关于B的FAIL消息，所有接收到这条消息的节点都会立即将B标记为已下线。</li><li>PUBLISH消息:当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收者都会执行相同的PUBLISH命令。</li></ul><p>Redis集群中的各个节点通过Gossip协议来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG是三种消息实现。三种消息使用相同的消息正文，通过消息头type区分消息。</p><h2 id="4-独立功能的实现"><a href="#4-独立功能的实现" class="headerlink" title="4. 独立功能的实现"></a>4. 独立功能的实现</h2><h3 id="4-1-事务"><a href="#4-1-事务" class="headerlink" title="4.1 事务"></a>4.1 事务</h3><p>Redis 通过MULTI、EXEC、WATCH等命令来说实现事务。<br>事务在执行期间，服务器不会中断事务处理其他请求。</p><h4 id="4-1-1-事务的实现"><a href="#4-1-1-事务的实现" class="headerlink" title="4.1.1 事务的实现"></a>4.1.1 事务的实现</h4><p>一个事务从开始时到结束通常经历3个阶段:</p><ol><li>事务开始: MULTI</li><li>命令入队: <command></li><li>事务执行: EXEC</li></ol><h4 id="4-1-2-WATCH-命令的实现"><a href="#4-1-2-WATCH-命令的实现" class="headerlink" title="4.1.2 WATCH 命令的实现"></a>4.1.2 WATCH 命令的实现</h4><p>WATCH命令是一个乐观锁(optimistic locking)，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少少有一个已经被修改过了，如果是，则拒绝执行事务，并向客户端返回代表事务执行失败的空回复。<br>每个Redis数据库都保存着一个watched_keys字典，这个字典的键时某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。<br>如果有修改命令对数据库键修改过，那么touchWatchKey函数将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，标识该客户端的事务安全性被破坏。</p><p><img src="/media/article/watch-transaction.png" alt="watch"></p><h4 id="4-1-3-事务的ACID性质"><a href="#4-1-3-事务的ACID性质" class="headerlink" title="4.1.3 事务的ACID性质"></a>4.1.3 事务的ACID性质</h4><p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕。</p><p>Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性，从而确保事务的一致性。以下介绍Redis事务可能出错的地方，并说明Redis是如何妥善处理这些错误。</p><ol><li>入队错误：服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被带有入队错误的事务影响。</li><li>执行错误：</li></ol><ul><li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时触发。</li><li>即使在事务的执行过程中发生错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令不会被出错的命令影响。</li></ul><ol start="3"><li>服务器停机：</li></ol><ul><li>如果Redis服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。</li><li>如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，空白的总是一致的。</li><li>如果服务器运行在AOF模式下，那么事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>BGSAVE 是否会存执行BGSAVE命令后客户端请求的命令？</li><li>假如说每秒执行一次AOF持久化，那么Redis从aof缓冲区写入AOF文件时，服务端处理的命令是否会存入缓冲区，是否会进入AOF文件？</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong><em>文中的列表和图片大都引用自<a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a></em></strong></p><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a><br><a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau-Redis源码解析-quicklist</a><br><a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a><br><a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>How to Write Doc Comments for the Javadoc Tool</title>
      <link href="/java/2019-05-19-javadoc-guide/"/>
      <url>/java/2019-05-19-javadoc-guide/</url>
      
        <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.oracle.com/technetwork/articles/javase/index-137868.html" target="_blank" rel="noopener">How to Write Doc Comments for the Javadoc Tool</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 泛型</title>
      <link href="/java/2019-05-06-java-generics/"/>
      <url>/java/2019-05-06-java-generics/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote><p><strong>其他参数术语：</strong><br>参数化的类型(parameterized type)：<code>List&lt;String&gt;</code><br>实际类型参数(type arguments)：<code>String</code><br>泛型(generic type)：<code>List&lt;E&gt;</code><br>形式类型参数(formal parameter types)：<code>E</code><br>无限制通配符类型(unbounded wildcards)：<code>List&lt;?&gt;</code><br>原生态类型(raw type)：<code>List</code><br>有限制类型参数(bounded type parameter)：<code>&lt;E extends Number&gt;</code><br>递归类型限制(recursive type restriction)：<code>&lt;T extends Comparable&lt;T&gt;&gt;</code><br>有限制通配符类型(bounded wildcards)：<code>List&lt;? extends Number&gt;</code><br>泛型方法(generic method)：<code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code><br>类型令牌(type token)：<code>String.class</code></p><p>– 摘自《Effective Java》</p></blockquote><p>Java集合有个缺点：集合对元素类型没有任何限制，这样就会引发一些问题，例如：创建一个只保存Dog对象的集合，但是程序也能将Cat对象放进去。由于把对象放进集合时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此去除集合元素后通常还需要进行强制类型转换。</p><p>为了解决上述问题，从JDK1.5之后，Java引入了“参数化类型（parameterized type）”的概念，Java的参数化类型被称为泛型（Generic）。</p><p>所谓泛型：就是允许在定义类、接口时指定类型形参（type parameters），这个类型形参将在声明变量、创建对象时确定。泛型的作用就是在编译时保证类型安全。</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>定义泛型接口、类示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义接口时指定一个类型形参</span><br><span class="line">public interface List&lt;E&gt;&#123;</span><br><span class="line">    //在接口里，E可以作为类型使用</span><br><span class="line">    void add(E x);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    E asList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>注意：</em></strong></p><ul><li>包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参(type arguments)，从而可以动态生成无数多个逻辑上的子类，但这种子类在物理上并不存在。</li><li>当创建泛型声明的自定义类，为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明。例如：为<code>Apple&lt;T&gt;</code>类定义构造器，其构造器名依然是<code>Apple</code>，而不是<code>Apple&lt;T&gt;</code>，但调用构造器时可以使用<code>Apple&lt;T&gt;</code>，此时T应该为实参类型。</li></ul><h3 id="2-1-从泛型类派生子类"><a href="#2-1-从泛型类派生子类" class="headerlink" title="2.1 从泛型类派生子类"></a>2.1 从泛型类派生子类</h3><p>当创建子类使用泛型接口或类时，不能再包含类型形参。如下代码时错误的：<br><code>public class A extends Apple&lt;T&gt;{}</code><br>正确方式如下：<br><code>public class A extends Apple&lt;String&gt;{}</code></p><p>类的静态变量和方法在所有的实例间共享，所以在静态方法、静态初始化或者静态变量的声明和初始化中不允许使用类型形参。原因见<a href="#4-3-不能声明静态字段的类型为类型参数">4.3 不能声明静态字段的类型为类型参数</a></p><p>由于系统对于泛型类或接口并不会生成真正的泛型类或接口（即逻辑上的子类，并不是生成真正的子类），所以instanceof运算符后不能使用泛型类。（具体原因见<a href="#4-4-不能使用参数化类型强制类型转换或者instanceof">4.4 不能使用参数化类型强制类型转换或者instanceof</a>）如下的代码时错误的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = new ArrayList&lt;String&gt;();</span><br><span class="line">if(cs instanceof List&lt;String&gt;)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-类型通配符"><a href="#2-2-类型通配符" class="headerlink" title="2.2 类型通配符"></a>2.2 类型通配符</h3><p>类型通配符既可以在方法签名中定义形参的类型，也可以用于定义变量的类型。使用通配符比显式声明通配符声明类型形参更加清晰准确，所以在可能的情况下，使用通配符更好。</p><h4 id="2-2-1-不受约束的通配符"><a href="#2-2-1-不受约束的通配符" class="headerlink" title="2.2.1 不受约束的通配符"></a>2.2.1 不受约束的通配符</h4><p>通配符可用于各种情况：作为参数，字段或局部变量的类型;有时作为返回类型（虽然更好的编程实践更具体）。通配符从不用作泛型方法调用，泛型类实例创建或超类型的类型参数。</p><p>如果满足下面的条件任意一个，就可以使用不受约束通配符：</p><ul><li>如果你正在编写可以<strong>使用Object类中提供的方法实现</strong>的方法。</li><li>当代码使用在泛型类中不依赖类型参数方法时。例如：List.size 或者 List.clear。 事实上，Class&lt;?&gt;经常被使用，因为Class<t>中的大多数方法不依赖T。</t></li></ul><p>使用通配符时，不能将元素放入未知类型的集合中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aaa&quot;);//这行代码引起编译时错误。因为不知道list的类型，所以不能往里面放任何元素，除了null。</span><br></pre></td></tr></table></figure><h4 id="2-2-2-上限通配符"><a href="#2-2-2-上限通配符" class="headerlink" title="2.2.2 上限通配符"></a>2.2.2 上限通配符</h4><p>使用<code>? extend type</code>表示所有type泛型类的子类（包含type本身）。</p><h4 id="2-2-3-下限通配符"><a href="#2-2-3-下限通配符" class="headerlink" title="2.2.3 下限通配符"></a>2.2.3 下限通配符</h4><p>使用<code>? super type</code>表示所有type泛型类的父类（包含type本身）。<del>只能用于泛型方法（有待验证）。</del></p><h4 id="2-2-4-通配符捕获和Helper方法"><a href="#2-2-4-通配符捕获和Helper方法" class="headerlink" title="2.2.4 通配符捕获和Helper方法"></a>2.2.4 通配符捕获和Helper方法</h4><p>在一些情况下，编译器会推断一个通配符的类型。例如，一个列表可以被定义为<code>List&lt;?&gt;</code>，当评估一个表达式时，编译器会从代码中推断一个特定类型。此方案称为通配符捕获。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardError &#123;</span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.set(0, i.get(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>i.set</code>方法编译异常，类型参数<code>List&lt;?&gt;</code>为不确定类型参数，所以<code>i.get(0)</code>获取的类型参数不确定，因此<code>i.set</code>方法不能将未知类型放入<code>i</code>中。（其中i.set默认是i.set(Integer,Object)，因为不确定i.get(0)的类型，所以产生编译问题）解决方案如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardFixed &#123;</span><br><span class="line"></span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // Helper method created so that the wildcard can be captured</span><br><span class="line">    // through type inference.</span><br><span class="line">    private &lt;T&gt; void fooHelper(List&lt;T&gt; l) &#123;</span><br><span class="line">        l.set(0, l.get(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-通配符和子类型"><a href="#2-2-5-通配符和子类型" class="headerlink" title="2.2.5 通配符和子类型"></a>2.2.5 通配符和子类型</h4><p>如泛型，继承和子类型中所述，泛型类或接口仅仅因为它们的类型不同而无关。但是，您可以使用通配符在泛型类或接口之间创建关系。下图是Number和Integer之间的继承关系：<br><img src="/media/article/15579245029350.jpg" alt=""></p><h3 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c)&#123;</span><br><span class="line">    for(T o:a)&#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面示例中，定义了一个泛型方法，该泛型方法中定义了一个T类型形参，这个T类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型形参不同的是，方法声明中定义的形参只能在该方法里使用，而接口、类声明中的定义的类型形参则可以在整个接口、类中使用。<br>与类、接口中使用泛型参数不同的是，方法中的泛型参数无需显式传入实际类型参数，根据实参推断类型形参的值。如果编译器不能推断你希望它拥有的类型，可以通过一个显示的类型参数（explicit type parameter）来告诉它要使用哪种类型。<br>泛型方法的用法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,S&gt; 返回值类型 方法名（形参列表）&#123;</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><em>提示：</em></strong><br>如果某个方法中一个形参（a）的类型或返回值类型依赖于另一个形参（b）的类型，则形参（b）的类型声明不应该使用通配符，因为形参（a）、或返回值与该形参（b）的类型，如果形参（b）的类型无法确定，程序无法定义形参（a）的类型。在这种情况下，<strong><em>只能考虑使用在方法签名中声明类型形参</em></strong>。</p></blockquote><p>类型通配符与显式声明类型形参区别：</p><ul><li>类型通配符即可在方法签名中定义形参的类型，也可以用于定义变量的类型。但泛型方法中类型形参必须在对应方法中显式声明。</li><li><strong><em>泛型方法允许类型形参用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系。如果没有这样的依赖关系，不应该使用泛型方法。</em></strong></li></ul><h3 id="2-4-泛型使用准则"><a href="#2-4-泛型使用准则" class="headerlink" title="2.4 泛型使用准则"></a>2.4 泛型使用准则</h3><blockquote><p>“in”变量：in变量向代码提供数据。想象复制方法有两个参数：<code>copy(src, dest)</code>。<code>src</code>参数提供复制数据，因此时”in”参数。<br>“out”变量：out变量保存数据以供其他地方使用。在复制的例子中，<code>copy(src, dest)</code>，<code>dest</code>参数接受数据，因此时”out”参数。</p></blockquote><ul><li>使用<code>extends</code>关键字定义带有上限通配符的“in”变量。</li><li>使用<code>super</code>关键字定义带有下限通配符的“out”变量。</li><li>在可以使用Object类中定义的方法访问“in”变量的情况下，使用无界通配符。</li><li>在代码需要作为“in”和“out”变量访问的情况下，不要使用通配符。</li></ul><h2 id="3-泛型的擦除与转换"><a href="#3-泛型的擦除与转换" class="headerlink" title="3. 泛型的擦除与转换"></a>3. 泛型的擦除与转换</h2><p>泛型被引入Java语言，以便在编译时提供更严格的类型检查并支持通用编程（向上兼容）。为了实现泛型，Java编译器将类型擦除应用于：</p><ul><li>使用边界替换所有在泛型中的类型参数或者如果类型参数是无界的则使用<code>Object</code>替换。因此生成的字节码只包含通用的类，接口和方法。</li><li>如果必要，插入类型强制转换来保证类型安全。</li><li>生成桥接方法以保留扩展泛型类型中的多态性。</li></ul><p>对于以上3点，1和3可能在<a href="#3-1-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E6%93%A6%E9%99%A4">3.1</a>和<a href="#3-2-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E6%A1%A5%E6%96%B9%E6%B3%95">3.2</a>中会详细说明，但是第二点可能不是那么清楚，如果有必要，类型擦除时，会进行强制类型转换。一般这种情况包括：</p><ul><li>方法的返回类型是类型参数；</li><li>在访问数据域时，域的类型是一个类型参数。</li></ul><p>例如：<br>项目中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println(list1.get(0));</span><br></pre></td></tr></table></figure></p><p>编译后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list1 = new ArrayList();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println((String)list1.get(0));</span><br></pre></td></tr></table></figure></p><p>字节码，字节码命令请参阅<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Chapter 6. The Java Virtual Machine Instruction Set</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">       0: new           #3                  // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #4                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #5                  // String Hell</span><br><span class="line">      11: invokeinterface #6,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      16: pop</span><br><span class="line">      17: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: iconst_0</span><br><span class="line">      22: invokeinterface #8,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">      27: checkcast     #9                  // class java/lang/String 强制类型转换校验是否为String类型</span><br><span class="line">      30: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      33: return</span><br></pre></td></tr></table></figure></p><p>上面的例子说明，编译器在擦除泛型代码时，确实保留了List<string>的相关信息，但是你无法找到列表对象本身的T=String，参阅自<a href="https://stackoverflow.com/questions/339699/java-generics-type-erasure-when-and-what-happens/339708#339708" target="_blank" rel="noopener">Java generics type erasure: when and what happens?</a>Jon Skeet的answer。</string></p><p>详细了解请参阅<a href="https://stackoverflow.com/questions/55084504/insert-type-casts-if-necessary-to-preserve-type-safety" target="_blank" rel="noopener">Insert type casts if necessary to preserve type safety</a></p><h3 id="3-1-泛型方法的擦除"><a href="#3-1-泛型方法的擦除" class="headerlink" title="3.1 泛型方法的擦除"></a>3.1 泛型方法的擦除</h3><p>Java编译器也会擦除泛型方法中的类型参数。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static &lt;T&gt; int count(T[] anArray, T elem)&#123;</span><br><span class="line"></span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(T e : anArray)&#123;</span><br><span class="line">        if(e.equals(elem))&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为T是无限制的，所以Java编译器会使用Object代替它，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int count(Object[] anArray, Object elem) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (Object e : anArray)</span><br><span class="line">        if (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-类型擦除的影响和桥方法"><a href="#3-2-类型擦除的影响和桥方法" class="headerlink" title="3.2 类型擦除的影响和桥方法"></a>3.2 类型擦除的影响和桥方法</h3><p>在编译扩展参数化类或实现参数化接口的类或接口时，编译器可能需要创建一个称为桥接方法的合成方法，作为类型擦除过程的一部分。您通常不需要担心桥接方法，但如果出现在堆栈跟踪中，您可能会感到困惑。</p><p>生成桥接方法以保留扩展泛型类型中的多态性。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T data;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = mn;            // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);     </span><br><span class="line">Integer x = mn.data;    // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>类型擦除后, 代码变成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);</span><br><span class="line">Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>代码执行逻辑如下：</p><p><code>n.setData(&quot;Hello&quot;)</code>使得MyNode类对象中的<code>setData(Object)</code>被执行。<br>在<code>setData(Object)</code>方法体内，对象的数据字段引用被分配为String。<br>通过mn引用的相同对象数据字段，可以访问、且期望是Interger类型。<br>尝试分配String到Integer造成ClassCastException。</p><p>类型擦除后代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    public Object data;</span><br><span class="line"></span><br><span class="line">    public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类型擦除之后，方法签名不匹配。 Node方法变为setData（Object），MyNode方法变为setData（Integer）。因此，MyNode setData方法不会覆盖Node setData方法。 为了解决这个问题并在类型擦除后保留泛型类型的多态性，Java编译器会生成一个桥接方法，以确保子类型按预期工作。对于MyNode类，编译器为setData生成以下桥接方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    // Bridge method generated by the compiler</span><br><span class="line">    //</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>桥接方法与类型擦除后的Node类的setData方法具有相同的方法签名，委托给原始的setData方法(桥接方法在字节码中可见，<code>javap -c class</code>)。</p><h3 id="3-3-不可具体化类型"><a href="#3-3-不可具体化类型" class="headerlink" title="3.3 不可具体化类型"></a>3.3 不可具体化类型</h3><p>可具体化类型是在运行时类型信息完全可用的一种类型。包括基本类型，非泛型类型，原始类型，无界的通配符调用。唯一可具体化参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<br>不可具体化类型是类型信息在编译时通过类型擦除被删除————调用未定义为无界通配符的泛型类型。不可具体化的类型在运行时不是所有信息都可用。不可具体化类型的示例是<code>List &lt;String&gt;</code>和<code>List &lt;Number&gt;</code>; JVM无法在运行时区分这些类型。如<a href="#4-泛型的限制">4 泛型的限制</a>中所示，在某些情况下，不能使用不可具体化的类型：例如，在<code>instanceof</code>表达式的实例中，或作为数组中的元素。</p><h3 id="3-4-堆污染"><a href="#3-4-堆污染" class="headerlink" title="3.4 堆污染"></a>3.4 堆污染</h3><p>堆污染发生在当参数化类型的变量引用不是该参数化类型的对象时。如果程序执行某些操作，在编译时产生未经检查的警告，则会出现这种情况。如果在编译时（在编译时类型检查规则的限制内）或在运行时，一个包含参数化类型操作的正确性不能被验证，则会生成未经检查的警告。例如，在混合原始类型和参数化类型时，或者在执行未经检查的强制转换时，会发生堆污染。</p><p>在通常情况下，当所有代码在相同时间被编译，编译器为潜在的堆污染产生一个未经检查警告来引起你的注意。如果你分开编译代码的各个部分，很难检查出堆污染的潜在风险。如果你确保你的代码编译没有警告，则不会有堆污染可以发生。</p><h3 id="3-5-使用不可具体化形参的可变参数方法的潜在漏洞"><a href="#3-5-使用不可具体化形参的可变参数方法的潜在漏洞" class="headerlink" title="3.5 使用不可具体化形参的可变参数方法的潜在漏洞"></a>3.5 使用不可具体化形参的可变参数方法的潜在漏洞</h3><p>包含可变输入参数泛型方法可以造成堆污染。<br>考虑如下class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBuilder &#123;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) &#123;</span><br><span class="line">    for (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void faultyMethod(List&lt;String&gt;... l) &#123;</span><br><span class="line">    Object[] objectArray = l;     // Valid</span><br><span class="line">    objectArray[0] = Arrays.asList(42);</span><br><span class="line">    String s = l[0].get(0);       // ClassCastException thrown here</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下例子，<code>HeapPollutionExample</code>使用<code>ArrayBuilder</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HeapPollutionExample &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stringListA = new ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; stringListB = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.addToList(stringListA, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;);</span><br><span class="line">    ArrayBuilder.addToList(stringListB, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listOfStringLists =</span><br><span class="line">      new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    ArrayBuilder.addToList(listOfStringLists,</span><br><span class="line">      stringListA, stringListB);</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译时，如下<code>ArrayBuilder.addToList</code>方法的定义将产生warning：<br><code>warning: [varargs] Possible heap pollution from parameterized vararg type T</code><br>当编译器遇到一个可变参数方法，它转换可变形参为数组。然而，Java编程语言不允许参数化类型数组的创建。在<code>ArrrayBuilder.addToList</code>方法中，编译器转换可变形参<code>T...</code>要素为<code>T[]</code>要素。因为类型擦除，编译器转换可变形参为<code>Object[]</code>要素。所以，有堆污染的可能性。<br>如下声明分配可变形参给对象数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray = l;</span><br></pre></td></tr></table></figure></p><p>这种声明可能引起堆污染。可以将与可变形参<code>l</code>的参数化类型匹配的值分配给变量objectArray，因此可以分配给<code>l</code>。然而，在此声明中，编译器不能生成一个未经检查警告。编译器早已在转换可变形参<code>List&lt;String&gt;...l</code> 到形参<code>List[] l</code>时生成警告。这个声明是有效的；<code>l</code>变量的类型是<code>List[]</code>，是<code>Object[]</code>的子类型。</p><p>因此，如果将任何类型的List对象分配给objectArray数组的任何数组组件，编译器不会发出警告或错误，如下所示：<br><code>ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</code><br>在运行时，JVM在以下语句中抛出<code>ClassCastException</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ClassCastException thrown here</span><br><span class="line">String s = l[0].get(0);</span><br></pre></td></tr></table></figure></p><p>存储在变量<code>l</code>的第一个数组组件中的对象具有<code>List&lt;Integer&gt;</code>类型，但此语句需要一个<code>List &lt;String&gt;</code>类型的对象。</p><h3 id="3-6-使用不可具体化的形参防止可变参数方法发出警告"><a href="#3-6-使用不可具体化的形参防止可变参数方法发出警告" class="headerlink" title="3.6 使用不可具体化的形参防止可变参数方法发出警告"></a>3.6 使用不可具体化的形参防止可变参数方法发出警告</h3><p>如果声明具有参数化类型参数的可变参数方法，并确保方法体不会因可变参数形参处理不当而抛出<code>ClassCastException</code>或其他类似异常，你可以通过给静态和非构造方法声明添加如下的注解防止编译器给这些可变参数方法生成警告：<br><code>@SafeVarargs</code><br><code>@SafeVarargs</code>注解是方法约定的记录部分;这个注释断言该方法的实现不会不正确地处理可变形参。<br> 尽管不太可取，但通过在方法声明中添加以下内容来消除此类警告也是可以的：<br><code>@SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})</code><br>但是，此方法不会消除从方法的调用点生成的警告。如果您不熟悉<code>@SuppressWarnings</code>语法，请参阅注释。</p><h2 id="4-泛型的限制"><a href="#4-泛型的限制" class="headerlink" title="4 泛型的限制"></a>4 泛型的限制</h2><h3 id="4-1-不能使用基本类型实例化通用类型"><a href="#4-1-不能使用基本类型实例化通用类型" class="headerlink" title="4.1 不能使用基本类型实例化通用类型"></a>4.1 不能使用基本类型实例化通用类型</h3><p>考虑如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public Pair(K key, V value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当创建一个<code>Pair</code>对象，你不能为类型参数<code>K</code>或者<code>V</code>替换成基本类型：<br><code>Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);  // compile-time error</code><br>你仅可以为类型参数<code>K</code>或者<code>V</code>替换非基本类型：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);</code><br>Java编译器自动装箱<code>8</code>为<code>Integer.valueOf(8)</code>和<code>a</code>为<code>Character(&#39;a&#39;)</code>：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character(&#39;a&#39;));</code></p><h3 id="4-2-不能创建类型参数实例"><a href="#4-2-不能创建类型参数实例" class="headerlink" title="4.2 不能创建类型参数实例"></a>4.2 不能创建类型参数实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">    E elem = new E();  // compile-time error</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种解决方案，你可以创建一个类型参数对象通过反射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">    E elem = cls.newInstance();   // OK</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以调用<code>append</code>方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = new ArrayList&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure></p><h3 id="4-3-不能声明静态字段的类型为类型参数"><a href="#4-3-不能声明静态字段的类型为类型参数" class="headerlink" title="4.3 不能声明静态字段的类型为类型参数"></a>4.3 不能声明静态字段的类型为类型参数</h3><p>类的静态字段是类等级变量，被当前类的所有非静态对象共享。因此，类型参数的静态字段是不允许的。考虑如下类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MobileDevice&lt;T&gt; &#123;</span><br><span class="line">    private static T os;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类型参数的静态字段被允许，如下的代码将会混乱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MobileDevice&lt;Smartphone&gt; phone = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;Pager&gt; pager = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;TabletPC&gt; pc = new MobileDevice&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>因为静态字段<code>os</code>被<code>phone</code>,<code>pager</code>和<code>pc</code>共享，什么是<code>os</code>的真实类型？在相同的时间它不可能是<code>Smartphone</code>，<code>Pager</code>，和<code>TablePc</code>。因此你不能创建类型参数静态字段。</p><h3 id="4-4-不能使用参数化类型强制类型转换或者instanceof"><a href="#4-4-不能使用参数化类型强制类型转换或者instanceof" class="headerlink" title="4.4 不能使用参数化类型强制类型转换或者instanceof"></a>4.4 不能使用参数化类型强制类型转换或者<code>instanceof</code></h3><p>因为Java编译器在泛型代码中擦除所有类型参数，您无法验证在运行时使用泛型类型的参数化类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>传递到<code>rtti</code>方法的参数化类型集合是：<br><code>S = { ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, ... }</code><br>运行时不保持对类型参数的跟踪，因此它不能告诉<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>之间的不同。你最多是使用无限通配符来验证列表是否为ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;?&gt;) &#123;  // OK; instanceof requires a reifiable type</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通常，你不能强制转换参数化类型，除非它通过无限制通配符参数化。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  // compile-time error</span><br></pre></td></tr></table></figure></p><p>但是，在一些情况下，编译器知道类型参数总是有效的，允许强制类型转换。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  // OK</span><br></pre></td></tr></table></figure></p><h3 id="4-5-不能创建参数化类型的数组"><a href="#4-5-不能创建参数化类型的数组" class="headerlink" title="4.5 不能创建参数化类型的数组"></a>4.5 不能创建参数化类型的数组</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</span><br></pre></td></tr></table></figure></p><p>如下代码说明在不同类型插入列表是发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] strings = new String[2];</span><br><span class="line">strings[0] = &quot;hi&quot;;   // OK</span><br><span class="line">strings[1] = 100;    // An ArrayStoreException is thrown.</span><br></pre></td></tr></table></figure></p><p>如果你使用泛型列表尝试相同的事情，将会有如下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&apos;s allowed</span><br><span class="line">stringLists[0] = new ArrayList&lt;String&gt;();   // OK</span><br><span class="line">stringLists[1] = new ArrayList&lt;Integer&gt;();  // An ArrayStoreException should be thrown,</span><br><span class="line">                                            // but the runtime can&apos;t detect it.</span><br></pre></td></tr></table></figure></p><p> 如果参数化列表数组是允许的，之前的代码将失败抛出<code>ArrayStoreException</code>。</p><h3 id="4-6-不能创建、捕获或者抛出参数化类型对象"><a href="#4-6-不能创建、捕获或者抛出参数化类型对象" class="headerlink" title="4.6 不能创建、捕获或者抛出参数化类型对象"></a>4.6 不能创建、捕获或者抛出参数化类型对象</h3><p>泛型类也不能直接或间接继承自Throwable。原因是因为在编译期和运行时都必须知道异常的确切类型。例如如下类将不编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Extends Throwable indirectly</span><br><span class="line">class MathException&lt;T&gt; extends Exception &#123; /* ... */ &#125;    // compile-time error</span><br><span class="line"></span><br><span class="line">// Extends Throwable directly</span><br><span class="line">class QueueFullException&lt;T&gt; extends Throwable &#123; /* ... */ // compile-time error</span><br></pre></td></tr></table></figure></p><p>一个方法不能捕获一个类型参数的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (J job : jobs)</span><br><span class="line">            // ...</span><br><span class="line">    &#125; catch (T e) &#123;   // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，你可以在一个<code>throws</code>子句中使用类型参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parser&lt;T extends Exception&gt; &#123;</span><br><span class="line">    public void parse(File file) throws T &#123;     // OK</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出上述泛化的代码。</p><h3 id="4-7-不能重载形式类型参数擦除后相同原始类型的方法"><a href="#4-7-不能重载形式类型参数擦除后相同原始类型的方法" class="headerlink" title="4.7 不能重载形式类型参数擦除后相同原始类型的方法"></a>4.7 不能重载形式类型参数擦除后相同原始类型的方法</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public void print(Set&lt;String&gt; strSet) &#123; &#125;</span><br><span class="line">    public void print(Set&lt;Integer&gt; intSet) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重载将共享相同的类文件表示，并将生成编译时错误。</p><h2 id="5-泛型与数组"><a href="#5-泛型与数组" class="headerlink" title="5. 泛型与数组"></a>5. 泛型与数组</h2><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型<code>Sub[]</code>就是<code>Super[]</code>的子类型。<br>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h2 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h2><p>如果以上都看完了，可以访问<a href="https://docs.oracle.com/javase/tutorial/java/generics/QandE/generics-questions.html" target="_blank" rel="noopener">Questions</a>试试自己是否真的懂了。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a><br><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">Effective Java</a><br><a href="https://docs.oracle.com/javase/tutorial/java/generics/" target="_blank" rel="noopener">Java Document Generic</a><br><a href="http://www.jiangjun.name/thinking-in-java/chapter15" target="_blank" rel="noopener">第十五章 泛型</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective Java</title>
      <link href="/java/2019-05-02-effective-java/"/>
      <url>/java/2019-05-02-effective-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘自《Effective Java》</p></blockquote><h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><h2 id="一、创建和销毁对象"><a href="#一、创建和销毁对象" class="headerlink" title="一、创建和销毁对象"></a>一、创建和销毁对象</h2><h3 id="1-考虑使用静态工厂方法替代构造器"><a href="#1-考虑使用静态工厂方法替代构造器" class="headerlink" title="1.考虑使用静态工厂方法替代构造器"></a>1.考虑使用静态工厂方法替代构造器</h3><ul><li>静态工厂方法与构造器不同的第一大优势在于，它们有名称，不必和类名相同。</li><li>静态工厂方法与构造器不同的第二大优势在于不必在每次调用他们的时候都创建一个新的对象。</li><li>静态工厂方法与构造器不同的第三大优势在于他们可以返回原类型的任何子类型对象。</li><li>静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们是代码变得更加简洁。</li><li>静态工厂方法的主要缺点在于类如果不含公有的活着受保护的构造器，就不能被子类化。</li><li>静态工厂方法第二个缺点在于它们与其他的静态方法实际上没有任何区别。</li></ul><h3 id="2-遇到多个构造器参数时要考虑用构建器"><a href="#2-遇到多个构造器参数时要考虑用构建器" class="headerlink" title="2.遇到多个构造器参数时要考虑用构建器"></a>2.遇到多个构造器参数时要考虑用构建器</h3><h3 id="3-用私有构造器或着枚举类强化Singleton属性"><a href="#3-用私有构造器或着枚举类强化Singleton属性" class="headerlink" title="3.用私有构造器或着枚举类强化Singleton属性"></a>3.用私有构造器或着枚举类强化Singleton属性</h3><h3 id="4-通过私有构造器强化不可实例化的能力"><a href="#4-通过私有构造器强化不可实例化的能力" class="headerlink" title="4.通过私有构造器强化不可实例化的能力"></a>4.通过私有构造器强化不可实例化的能力</h3><h3 id="5-避免创建不必要的对象"><a href="#5-避免创建不必要的对象" class="headerlink" title="5.避免创建不必要的对象"></a>5.避免创建不必要的对象</h3><h3 id="6-消除过期的对象引用"><a href="#6-消除过期的对象引用" class="headerlink" title="6.消除过期的对象引用"></a>6.消除过期的对象引用</h3><ul><li>只要类是自己管理内存，程序员就应该警惕内存泄露问题。</li><li>内存泄漏的另一个常见来源是缓存。</li><li>内存的第三个常见来源是监听器和其他回调。确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用。</li></ul><h3 id="7-避免使用终结方法"><a href="#7-避免使用终结方法" class="headerlink" title="7.避免使用终结方法"></a>7.避免使用终结方法</h3><ul><li>终结方法（finalizer）通常是不可预测的，也是危险的，一般情况下是不必要的。</li><li>使用终结方法有非常严重的（Severe）性能损失。</li></ul><h2 id="二、对于所有对象都通用的方法"><a href="#二、对于所有对象都通用的方法" class="headerlink" title="二、对于所有对象都通用的方法"></a>二、对于所有对象都通用的方法</h2><h3 id="8-覆盖equals时请遵守通用约定"><a href="#8-覆盖equals时请遵守通用约定" class="headerlink" title="8.覆盖equals时请遵守通用约定"></a>8.覆盖equals时请遵守通用约定</h3><ul><li>类的每个实例本质都是唯一的。</li><li>不关心类是否提供了“逻辑相等（logical equality）“的测试功能。</li><li>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。</li><li>类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用。</li><li>在覆盖equals方法时，必须遵守：<strong>自反性（reflexive）、对称性（symmetric）、传递性（transitive）、一致性（consistent）和对于任何非null的引用，equals(null)必须返回false</strong>。</li></ul><blockquote><p>里氏替换原则（Liskov substitution principle）认为，一个类型的任何重要属性也将适用它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行的很好。</p></blockquote><ul><li>覆盖equals时总要覆盖hashCode。</li><li>不要企图让equals方法过于智能。</li><li>不要将equals声明中的Object对象替换为其他的类型。</li></ul><h3 id="9-覆盖equals总要覆盖hashCode"><a href="#9-覆盖equals总要覆盖hashCode" class="headerlink" title="9.覆盖equals总要覆盖hashCode"></a>9.覆盖equals总要覆盖hashCode</h3><ul><li>在应用程序的执行期间，只要对象的equals方法比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li><li>如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。<strong>（违反第二条）</strong></li><li>如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定产生不同的整数结果。但是程序猿应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列（hash table）的性能。</li></ul><h3 id="10-始终要覆盖toString"><a href="#10-始终要覆盖toString" class="headerlink" title="10.始终要覆盖toString()"></a>10.始终要覆盖toString()</h3><h3 id="11-谨慎覆盖clone"><a href="#11-谨慎覆盖clone" class="headerlink" title="11.谨慎覆盖clone()"></a>11.谨慎覆盖clone()</h3><ul><li>如果专门为了继承而设计的类，覆盖了clone方法，覆盖版本的clone方法就应该模拟Object.clone的行为：他应该声明为protected、抛出CloneNotSupportedException异常，并且该类不应该实现Cloneable接口。</li><li>如果用线程安全的类实现Cloneable接口，要记得它的clone方法必须得到同步。</li><li>任何实现Cloneable接口的类都应该用一个公有的方法覆盖clone，首先调用super.clone，再修正任何需要修正的域。</li><li>另一种实现对象拷贝的好方法是提供一个拷贝构造器(copy constructor)或者拷贝工厂(copy factory)。</li></ul><h3 id="12-考虑实现Comparable接口"><a href="#12-考虑实现Comparable接口" class="headerlink" title="12.考虑实现Comparable接口"></a>12.考虑实现Comparable接口</h3><h2 id="三、类和接口"><a href="#三、类和接口" class="headerlink" title="三、类和接口"></a>三、类和接口</h2><h3 id="13-使类和成员的可访问性最小化"><a href="#13-使类和成员的可访问性最小化" class="headerlink" title="13.使类和成员的可访问性最小化"></a>13.使类和成员的可访问性最小化</h3><ul><li>尽可能的使每个类或者成员不被外界访问。</li><li>实例域绝不能使公有的。</li><li>类具有共有的静态final数组域，或者返回这种域的访问方法，这种几乎总是错误的。</li><li>公有类都不应该包含公有域，除了公有静态final域的特殊情形外。</li><li>确保公有静态final域所引用的对象都是不可变的。</li></ul><h3 id="14-在公有类中使用访问方法而非公有域"><a href="#14-在公有类中使用访问方法而非公有域" class="headerlink" title="14.在公有类中使用访问方法而非公有域"></a>14.在公有类中使用访问方法而非公有域</h3><ul><li>如果类可以在它所在的包的外部进行访问，就提供访问方法。</li><li>如果类是包级私有的，或者私有的嵌套类，直接暴露它的数据域并没有本质的错误。</li></ul><h3 id="15-使可变性最小化"><a href="#15-使可变性最小化" class="headerlink" title="15.使可变性最小化"></a>15.使可变性最小化</h3><p>不可变类只是实例不能被修改的类。每个实例中包含的信息都必须在创建该实例的时候提供，并在对象的整个生命周期固定不变。</p><ul><li>不要提供任何会修改对象状态的方法。</li><li>保证类不被扩展。</li><li>使所有的域都是final的。</li><li>使所有的域都成为私有的。</li><li>确保对于任何可变组件的互斥访问。</li></ul><h3 id="16-复合优先于继承"><a href="#16-复合优先于继承" class="headerlink" title="16.复合优先于继承"></a>16.复合优先于继承</h3><ul><li>与方法调用不同的是，继承打破了封装性。</li></ul><h3 id="17-要么为继承而设计，并提供文档说明，要么就禁止继承。"><a href="#17-要么为继承而设计，并提供文档说明，要么就禁止继承。" class="headerlink" title="17.要么为继承而设计，并提供文档说明，要么就禁止继承。"></a>17.要么为继承而设计，并提供文档说明，要么就禁止继承。</h3><ul><li>构造器绝不能调用可被覆盖的方法。</li><li>无论是clone还是readObject，都不可以调用可覆盖的方法，不管是以直接还是间接的方式。</li></ul><h3 id="18-接口优于抽象类"><a href="#18-接口优于抽象类" class="headerlink" title="18.接口优于抽象类"></a>18.接口优于抽象类</h3><ul><li>现有的类可以很容易被更新，以实现新的接口。</li><li>接口是定义mixin(混合类型)的理想选择。</li><li>接口允许构造非层次结构的类型框架。</li><li>接口使得安全的增强类的功能成为可能。</li><li>通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的优点结合起来。</li></ul><h3 id="19-接口只用于定义类型"><a href="#19-接口只用于定义类型" class="headerlink" title="19.接口只用于定义类型"></a>19.接口只用于定义类型</h3><ul><li>常量接口模式是对接口的不良使用。</li></ul><h3 id="20-类层级优于标签类"><a href="#20-类层级优于标签类" class="headerlink" title="20.类层级优于标签类"></a>20.类层级优于标签类</h3><h3 id="21-用函数对象表示策略"><a href="#21-用函数对象表示策略" class="headerlink" title="21.用函数对象表示策略"></a>21.用函数对象表示策略</h3><p>策略模式</p><h3 id="22-优先考虑静态成员类"><a href="#22-优先考虑静态成员类" class="headerlink" title="22.优先考虑静态成员类"></a>22.优先考虑静态成员类</h3><p>静态类成员：Map中的Entry<br>非静态类成员：Iterator<br>匿名类：无法实例化，无法声明实现接口，扩展类，无法调用任何成员除了从它的超类继承的，必须简洁，常用来作为函数对象，即函数表达式；另一种是创建过程对象（Runable）<br>局部类：声明局部变量的地方都可以声明局部类。</p><p>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中。</p><h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h3 id="23-请不要在新代码中使用原生态类型"><a href="#23-请不要在新代码中使用原生态类型" class="headerlink" title="23.请不要在新代码中使用原生态类型"></a>23.请不要在新代码中使用原生态类型</h3><ul><li>如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。</li><li>泛型有子类化的规则，虽然可以将List<string>传递给List的参数，但是不能将它传给类型List<object>的参数。</object></string></li><li>如果使用像List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<object>这样的参数化类型，则不会。</object></li><li>在类文字中必须使用原生态类型。</li><li>在参数化类型而非无限制通配符类型上使用instanceof操作法是非法的。</li></ul><h3 id="24-消除非受检警告"><a href="#24-消除非受检警告" class="headerlink" title="24.消除非受检警告"></a>24.消除非受检警告</h3><ul><li>尽可能消除每一个非受检警告</li><li>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，只有这种情况下可以用@SuppressWarnings(“unchecked”)注解来禁止这条警告。</li><li>应该在尽可能小的范围内使用SuppressWarnings注解。</li><li>每当使用SuppressWarnings注解，都要增加注释，说明为什么这么做是安全的。</li></ul><h3 id="25-列表优于数组"><a href="#25-列表优于数组" class="headerlink" title="25.列表优于数组"></a>25.列表优于数组</h3><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型。<br><strong>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</strong></p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p><strong>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</strong></p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型时无限制通配符类型，如List&lt;?&gt;和Map&lt;?,?&gt;。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h3 id="26-优先考虑泛型"><a href="#26-优先考虑泛型" class="headerlink" title="26.优先考虑泛型"></a>26.优先考虑泛型</h3><ul><li>不能创建不可具体化的（non-reifiable）类型的数组。解决方案是新建Object数组强制转换为不可具体化类型，确保未受检的转换是安全的，就要尽可能小的范围中禁止警告。</li></ul><h3 id="27-优先考虑泛型方法"><a href="#27-优先考虑泛型方法" class="headerlink" title="27.优先考虑泛型方法"></a>27.优先考虑泛型方法</h3><h3 id="28-利用有限制通配符来提升API的灵活性"><a href="#28-利用有限制通配符来提升API的灵活性" class="headerlink" title="28.利用有限制通配符来提升API的灵活性"></a>28.利用有限制通配符来提升API的灵活性</h3><ul><li>为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。</li><li>如果类型参数只在方法声明中出现一次，就可以用通配符取代它，如果是无限制的类型参数，就用无限制的通配符取代它。</li><li>如果类的用户必须考虑通配符类型，类的API或许就会出错。</li><li>不要用通配符类型作为返回类型，除了为用户提供额外的灵活性之外，它还会强制用户在客户端代码中使用通配符类型。</li></ul><h3 id="29-优先考虑类型安全的异构容器"><a href="#29-优先考虑类型安全的异构容器" class="headerlink" title="29.优先考虑类型安全的异构容器"></a>29.优先考虑类型安全的异构容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Favorites&#123;</span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);</span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不像普通的map，它的<strong>所有键都是不同类型</strong>的，因此Favorites称作类型安全的异构容器（typesafe heterogeneous container）。</p><p>集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数，但是可以通过将类型参数放在键上而不是容器上来避开这一限制。</p><h2 id="五、枚举和注解"><a href="#五、枚举和注解" class="headerlink" title="五、枚举和注解"></a>五、枚举和注解</h2><h3 id="30-用enum代替int常量"><a href="#30-用enum代替int常量" class="headerlink" title="30.用enum代替int常量"></a>30.用enum代替int常量</h3><p>只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。</p><p>如果多个枚举常量同时共享相同的行为，则考虑策略枚举（strategy enum）。</p><h3 id="31-用实例代替序数索引"><a href="#31-用实例代替序数索引" class="headerlink" title="31.用实例代替序数索引"></a>31.用实例代替序数索引</h3><p>永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Ensemble&#123;</span><br><span class="line">    SOLO(1),DUET(2);</span><br><span class="line">    private final int numberOfMusicians;</span><br><span class="line">    Ensemble(int size)&#123;this.numberOfMusicians = size;&#125;</span><br><span class="line">    public int numberOfMusicians()&#123;return numberOfMusicians;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="32-用EnumSet代替位域"><a href="#32-用EnumSet代替位域" class="headerlink" title="32.用EnumSet代替位域"></a>32.用EnumSet代替位域</h3><h3 id="33-用EnumMap代替序数索引"><a href="#33-用EnumMap代替序数索引" class="headerlink" title="33.用EnumMap代替序数索引"></a>33.用EnumMap代替序数索引</h3><h3 id="34-用接口模拟可伸缩的枚举"><a href="#34-用接口模拟可伸缩的枚举" class="headerlink" title="34.用接口模拟可伸缩的枚举"></a>34.用接口模拟可伸缩的枚举</h3><h3 id="35-注解优先于命名模式"><a href="#35-注解优先于命名模式" class="headerlink" title="35.注解优先于命名模式"></a>35.注解优先于命名模式</h3><h3 id="36-坚持使用Override注解"><a href="#36-坚持使用Override注解" class="headerlink" title="36.坚持使用Override注解"></a>36.坚持使用Override注解</h3><h3 id="37-用标记接口定义类型"><a href="#37-用标记接口定义类型" class="headerlink" title="37.用标记接口定义类型"></a>37.用标记接口定义类型</h3><h2 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h2><h3 id="38-检查参数的有效性"><a href="#38-检查参数的有效性" class="headerlink" title="38.检查参数的有效性"></a>38.检查参数的有效性</h3><p>每当编写方法或者构造器时，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显示的检查来实施这些限制。<br>非公有的方法通常应该使用断言（assertion）来检查它们的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(long a[], int offset, int length)&#123;</span><br><span class="line">    assert a != null;</span><br><span class="line">    assert offset &gt;= 0 &amp;&amp; offset &lt;= a.length;</span><br><span class="line">    assert length &gt;= 0 &amp;&amp; length &lt;= a.length - offset;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="39-必要时进行保护性拷贝"><a href="#39-必要时进行保护性拷贝" class="headerlink" title="39.必要时进行保护性拷贝"></a>39.必要时进行保护性拷贝</h3><p>对于构造器的每个可变参数进行保护性拷贝（defensive copy）是必要的。<br>保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    this.start = start;</span><br><span class="line">    this.end = end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中虽然增加约束条件，但是Date在此对象外部还是可以被修改的，因为Date是引用传递，所以为避免这种问题，使用备份对象，而不是使用原始对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    this.start = new Date(start.getTime);</span><br><span class="line">    this.end = new Date(end.getTime);</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。<br>如果类中提供了对其可变内部成员的访问能力，则使它返回可变内部域的保护性拷贝即可。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date start = new Date();</span><br><span class="line">Date end = new Date();</span><br><span class="line">Period p = new Period(start, end);</span><br><span class="line">p.end().setYear(78);//end()方法返回Date对象，Period中提供setYear改变Date属性。</span><br></pre></td></tr></table></figure><p>为了保证传入Period中的start或者end不被改变，只需要修改Period中获取start和end的访问方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Date start()&#123;</span><br><span class="line">    return new Date(start.getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Date end()&#123;</span><br><span class="line"></span><br><span class="line">    return new Date(end.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数的保护性拷贝不仅仅针对不可变类。如果客户端提供的对象是可变的且该对象不允许在你的类对象中变化，就必须对该对象进行保护性拷贝。</p><p>如果拷贝成本受到限制，并且信任它的客户端不会不恰当的修改组件，就可以在文档中声明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。</p><h3 id="40-谨慎设计方法签名"><a href="#40-谨慎设计方法签名" class="headerlink" title="40.谨慎设计方法签名"></a>40.谨慎设计方法签名</h3><p>谨慎的选择方法的名称；<br>不要过于追求提供便利的方法。只有当一项操作被经常用到的时候，才考虑为它提供快捷方式（shorthand）。如果不确定还是不提供快捷为好；<br>避免过长的参数列表；</p><h3 id="41-慎用重载"><a href="#41-慎用重载" class="headerlink" title="41.慎用重载"></a>41.慎用重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionClassifier&#123;</span><br><span class="line"></span><br><span class="line">    public static String classify(Set&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;set&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(List&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;list&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(Collection&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;unknow&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">            new HashSet&lt;String&gt;(),</span><br><span class="line">            new ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">            new HashMap&lt;String, String&gt;().value()</span><br><span class="line">        &#125;;</span><br><span class="line">        for(Collection&lt;?&gt; c : collections)</span><br><span class="line">            System.out.println(classify(c)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果是打印“unknow”三次。</p><h3 id="42-慎用可变参数"><a href="#42-慎用可变参数" class="headerlink" title="42.慎用可变参数"></a>42.慎用可变参数</h3><p>定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用，使用不当，将产生混乱的结果。</p><h3 id="43-返回零长度的数组或者集合，而不是null"><a href="#43-返回零长度的数组或者集合，而不是null" class="headerlink" title="43.返回零长度的数组或者集合，而不是null"></a>43.返回零长度的数组或者集合，而不是null</h3><h3 id="44-为所有导出的API元素编写文档注释"><a href="#44-为所有导出的API元素编写文档注释" class="headerlink" title="44.为所有导出的API元素编写文档注释"></a>44.为所有导出的API元素编写文档注释</h3><h2 id="七、通用程序设计"><a href="#七、通用程序设计" class="headerlink" title="七、通用程序设计"></a>七、通用程序设计</h2><h3 id="45-将局部变量的作用域最小化"><a href="#45-将局部变量的作用域最小化" class="headerlink" title="45.将局部变量的作用域最小化"></a>45.将局部变量的作用域最小化</h3><p>要使用局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。<br>几乎每个局部变量的声明都应该包含一个初始化表达式。</p><h3 id="46-for-each循环优先于传统的for循环"><a href="#46-for-each循环优先于传统的for循环" class="headerlink" title="46.for-each循环优先于传统的for循环"></a>46.for-each循环优先于传统的for循环</h3><p>虽然for-each循环在简洁性和预防bug方面比传统的for循环有优势，且没有性能损失。但是有三种常见情况无法使用for-each:</p><ul><li>过滤： 如果需要遍历集合，并且删除选定的元素，就需要使用显式的迭代器。</li><li>转换： 如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引。</li><li>平行迭代： 如果需要并行的遍历多个集合，就需要显式的控制迭代器或者索引变量。</li></ul><h3 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47.了解和使用类库"></a>47.了解和使用类库</h3><p>每个程序员都应该熟悉java.lang、java.util、java.io中的内容。</p><h3 id="48-如果需要精确的答案，请避免使用float和double"><a href="#48-如果需要精确的答案，请避免使用float和double" class="headerlink" title="48.如果需要精确的答案，请避免使用float和double"></a>48.如果需要精确的答案，请避免使用float和double</h3><p>使用BigDecimal、int或者long进行计算。如果数值防伪不超过9位十进制数字，就可以使用int；如果不超过18位就可以使用long；如果数值超过18位就必须使用BigDecimal。</p><p>BigDecimal缺点：不方便，慢。</p><h3 id="49-基本类型优先于装箱基本类型"><a href="#49-基本类型优先于装箱基本类型" class="headerlink" title="49.基本类型优先于装箱基本类型"></a>49.基本类型优先于装箱基本类型</h3><p>基本类型与装箱基本类型之间主要区别：</p><ul><li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。</li><li>基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值之外，还有非功能值：null。</li><li>基本类型通常比装箱基本类型更节省空间和时间。</li></ul><p>第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型（在代码中不用自己去装箱，如果把基本类型放入集合中，集合会自动把基本类型装箱）。不能放在集合中的原因是：基本类型存放在栈上，集合中的引用则存在堆或方法取上。</p><p>在参数化类型中，必须使用装箱基本类型作为参数，Java不允许使用基本类型，因为Java泛型要求使用的是对象类型，基本类型不是对象类型。</p><h3 id="50-如果其他类型更适合，则尽量避免使用字符串"><a href="#50-如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="50.如果其他类型更适合，则尽量避免使用字符串"></a>50.如果其他类型更适合，则尽量避免使用字符串</h3><p>字符串不适合代替其他的值类型。<br>字符串不适合代替枚举类型。<br>字符串不适合代替聚集类型。<br>字符串也不适合代替能力表。</p><h3 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51.当心字符串连接的性能"></a>51.当心字符串连接的性能</h3><h3 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52.通过接口引用对象"></a>52.通过接口引用对象</h3><p>如果有适合的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。</p><p>如果没有合适的接口存在，完全可以用类而不是接口来引用对象：</p><ul><li>如果具体类没有相关联的接口，不管它是否表示一个值，你都没有别的选择，只有通过它的类来引用它的对象。</li><li>对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架（class-based</li><li>framework），就应该用相关的积累（base class）来引用这个对象，而不是用它的实现类。</li></ul><h3 id="53-接口优先于反射机制"><a href="#53-接口优先于反射机制" class="headerlink" title="53.接口优先于反射机制"></a>53.接口优先于反射机制</h3><p>反射机制：</p><ul><li>丧失了编译时类型检查的好处，包括异常检查。如果程序企图用反射方式调用不存在的活不可访问的方法，在运行时它将会失败，除非采用了特别的预防措施。</li><li>执行反射访问所需的代码非常笨拙和冗长。编写这样的代码非常乏味，阅读起来也很困难。</li><li>性能损失。反射方法调用比普通方法调用慢了许多。</li></ul><p>通常普通应用程序在运行时不应该以反射方式访问对象。<br>对于有些程序，它们必须用到在编译时无法获取的类，但是在编译时存在适当的接口或者超类，通过它们可以引用这个类。如果是这种情况，就可以以反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例。如果适当的构造器不带参数，甚至根本不需要使用<code>java.lang.reflect</code>；<code>Class.newInstance</code>方法就已经提供了所需的功能。</p><h3 id="54-谨慎的使用本地方法"><a href="#54-谨慎的使用本地方法" class="headerlink" title="54.谨慎的使用本地方法"></a>54.谨慎的使用本地方法</h3><h3 id="55-谨慎的优化"><a href="#55-谨慎的优化" class="headerlink" title="55.谨慎的优化"></a>55.谨慎的优化</h3><blockquote><p>很多计算上的过失都被归咎于效率（没有必要达到的效率），而不是任何其他的原因—甚至包括盲目的做傻事。<br>不要取计较效率上的一些小小的得失，在97%的情况下，不成熟的优化才是一切问题的根源。<br>在优化方面，我们应该遵守两条规则：<br>规则1: 不要进行优化。<br>规则2: 还是不要进行优化—也就是说，在你还没有绝对清晰的未优化方案之前，请不要优化。</p></blockquote><p>不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。好的程序体现了信息隐藏的原则：只要有可能，它们就会把设计决策几种在单个模块中，因此，可以改变单个决策，而不会影响到系统的其他部分。</p><p>在设计的过程中考虑性能问题。努力避免限制性能的设计决策。</p><h3 id="56-遵守普遍接受的命名惯例"><a href="#56-遵守普遍接受的命名惯例" class="headerlink" title="56.遵守普遍接受的命名惯例"></a>56.遵守普遍接受的命名惯例</h3><h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><h3 id="57-只针对异常的情况才使用异常"><a href="#57-只针对异常的情况才使用异常" class="headerlink" title="57.只针对异常的情况才使用异常"></a>57.只针对异常的情况才使用异常</h3><p>异常机制的设计初衷是用于不正常的情形，所以很少会有JVM实现试图对它们进行优化，使得与显式的测试一样快速。</p><p>把代码放在try-catch块中反而阻止了现代JVM实现本来可能要执行的某些特定的优化。</p><p>对数组进行遍历的标准模式并不会导致冗余的检查。有些现代的JVM实现会将它们优化掉。</p><h3 id="58-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#58-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="58.对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>58.对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><h3 id="59-避免不必要的使用受检异常"><a href="#59-避免不必要的使用受检异常" class="headerlink" title="59.避免不必要的使用受检异常"></a>59.避免不必要的使用受检异常</h3><h3 id="60-优先使用标准异常"><a href="#60-优先使用标准异常" class="headerlink" title="60.优先使用标准异常"></a>60.优先使用标准异常</h3><p><img src="/media/article/15583547431411.jpg" alt=""></p><h3 id="61-抛出域抽象相对应的异常"><a href="#61-抛出域抽象相对应的异常" class="headerlink" title="61.抛出域抽象相对应的异常"></a>61.抛出域抽象相对应的异常</h3><p>更高层次的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。<br>如果不能阻止或者处理来自低层的异常，一般做法是使用异常转译，除非低层方法碰巧可以保证它抛出的所有异常对高层也合适才可以将异常从低层传播到高层。异常链对高层和低层异常都提供了最佳功能：它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析。</p><h3 id="62-每个方法抛出的异常都要有文档"><a href="#62-每个方法抛出的异常都要有文档" class="headerlink" title="62.每个方法抛出的异常都要有文档"></a>62.每个方法抛出的异常都要有文档</h3><p>始终要单独的声明受检异常，并且利用Javadoc的@throws标记，准确的记录下抛出的每个异常的条件。</p><p>使用Javadoc的@throws标签记录下一个方法可能抛出的每个受检异常，但是不要使用throws关键字将未受检异常包含在方法的声明中。</p><p>如果一个类中的许多方法处于同样的原因而抛出同一个异常，则该类的文档注释中对这个异常建立文档，是可以接受的。</p><h3 id="63-在细节消息中包含能捕获失败的信息"><a href="#63-在细节消息中包含能捕获失败的信息" class="headerlink" title="63.在细节消息中包含能捕获失败的信息"></a>63.在细节消息中包含能捕获失败的信息</h3><p>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。</p><h3 id="64-努力使失败保持原子性"><a href="#64-努力使失败保持原子性" class="headerlink" title="64.努力使失败保持原子性"></a>64.努力使失败保持原子性</h3><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p><h3 id="65-不要忽略异常"><a href="#65-不要忽略异常" class="headerlink" title="65.不要忽略异常"></a>65.不要忽略异常</h3><h2 id="九、并发"><a href="#九、并发" class="headerlink" title="九、并发"></a>九、并发</h2><h3 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66.同步访问共享的可变数据"></a>66.同步访问共享的可变数据</h3><p>Java语言规范保证读或写一个变量是原子的，除非这个变量的类型为long或者double[JLS，17.4.7]。对于这句话不要误解，虽然语言规范保证了线程在读取原子数据的时候，不会看到任意的数值，但是它并不保证一个线程写入的值对于另一个线程将是可见的。为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。</p><h3 id="67-避免过度同步"><a href="#67-避免过度同步" class="headerlink" title="67.避免过度同步"></a>67.避免过度同步</h3><p>为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法，要尽量限制同步区域内部的工作量。</p><h3 id="68-executor和task优先于线程"><a href="#68-executor和task优先于线程" class="headerlink" title="68.executor和task优先于线程"></a>68.executor和task优先于线程</h3><h3 id="69-并发工具优先于wait和notify"><a href="#69-并发工具优先于wait和notify" class="headerlink" title="69.并发工具优先于wait和notify"></a>69.并发工具优先于wait和notify</h3><p>java.util.concurrent中更高级的的工具分成三类：Execcutor Framework、并发集合（Concurrent Collection）以及同步器（Synchronizer）。</p><p>同步器是一些使线程能够等待另一个线程的对象，允许它们协调动作。常用的是CountDownLatch和Semaphore。不常用的是CyclicBarrier和Exchanger。</p><p>对于间歇式的定时，始终应该优先使用System.nanoTime，而不是使用System.currentTimeMills。System.nanoTime更加准确也更加精确，它不受系统的实时时钟的调整所影响。</p><p>如果你在维护使用wait和notify的代码，务必确保始终是利用标准的模式从while循环内部调用wait。一般情况下，你应该优先使用notifyAll，而不是使用notify。如果使用notify，请一定小心，以确保程序的活性。</p><h3 id="70-线程安全性的文档化"><a href="#70-线程安全性的文档化" class="headerlink" title="70.线程安全性的文档化"></a>70.线程安全性的文档化</h3><p>一个类为了可被多个线程安全的使用，必须在文档中清楚的说明它所支持的线程安全级别。</p><ul><li>不可变的（immutable）这个类是不可变的。所以不需要外部同步。例如：String、Long、BigInteger。</li><li>无条件的线程安全（unconditionally thread-safe）这个类的实例是可变的，但是这个类有着足够的内部同步，所以，它的实例可以被并发使用，无需任何外部同步。例如：Random、ConcurrentHashMap。</li><li>有条件的线程安全（conditionally thread-safe）除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。例如：Collections.synchronized包装返回的集合，它们的迭代器（iterator）要求外部同步。</li><li>非线程安全（not thread-safe）这个类的实例是可变的。为了并发地使用它们，客户端必须利用自己选择的外部同步包围每个方法调用。例如：ArrayList、HashMap。</li><li>线程对立（thread-hostile）这个类不能安全的被多个线程并发使用，即使所有的方法调用都被外部同步包围。</li></ul><h3 id="71-慎用延迟初始化"><a href="#71-慎用延迟初始化" class="headerlink" title="71.慎用延迟初始化"></a>71.慎用延迟初始化</h3><p>延迟初始化（lazy initialization）是延迟到需要域的值时才将它初始化的这种行为。<br>大多数的域应该正常地进行初始化，而不是延迟初始化。如果为了达到性能目的，或者为了破坏有害的初始化循环，必须延迟初始化一个域则：<br>对于实例域，就使用双重检查模式（double-check idiom）；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            result = field;</span><br><span class="line">            if(result == null)&#123;</span><br><span class="line">                field = result = computeFieldValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于静态域，则使用lazy initialization holder class idiom；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class FieldHolder&#123;</span><br><span class="line">    static final FieldType field = computeFieldValue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static FieldType getField()&#123;return FieldHolder.field;&#125;</span><br></pre></td></tr></table></figure></p><p>对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式（single-check idiom）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line"></span><br><span class="line">private FieldType getField()&#123;</span><br><span class="line"></span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        field = result = computeFieldValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="72-不要依赖于线程调度器"><a href="#72-不要依赖于线程调度器" class="headerlink" title="72.不要依赖于线程调度器"></a>72.不要依赖于线程调度器</h3><h3 id="73-避免使用线程组"><a href="#73-避免使用线程组" class="headerlink" title="73.避免使用线程组"></a>73.避免使用线程组</h3><p>线程组的初衷是作为一种隔离applet的机制，当然是出于安全的考虑。线程组并没有提供太多有用的功能，而且它们提供的许多功能还都是有缺陷的。</p><h2 id="十、序列化"><a href="#十、序列化" class="headerlink" title="十、序列化"></a>十、序列化</h2><h3 id="74-谨慎的实现Serializable接口"><a href="#74-谨慎的实现Serializable接口" class="headerlink" title="74.谨慎的实现Serializable接口"></a>74.谨慎的实现Serializable接口</h3><p>实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。</p><p>如果接受了默认的序列化形式，并且以后要改变这个类的内部表示法，结果可能导致序列化形式的不兼容。</p><p>第二个代价是，它增加了出现Bug和安全漏洞的可能性。</p><p>实现Serializable第三个代价是，随着类发行新的版本，相关的测试负担也增加了。</p><p>为了继承而设计的类应该尽可能少的趋势线Serializable接口，用户的接口也应该尽可能少的继承Serializable接口。如果违反了这条规则，扩展这个类或者实现该接口的程序员就会背上沉重的负担。然而有些情况下，这条规则确实适合的。例如：如果一个类或者接口存在的目的主要是为了参加到某个框架中，该框架要求所有的参与者都必须实现Serializable接口，那么对于类或者接口来说实现扩展Serializable是有意义的。</p><p>如果一个专门为了继承而设计的类不是可序列化的，就不可能编写出可序列化的子类。特别是，如果超类没有提供可访问的无参构造器，子类也不可能做到序列化。对于未继承而设计的不可序列化的类，你应该提供一个无参构造器。</p><h3 id="75-考虑使用自定义的序列化形式"><a href="#75-考虑使用自定义的序列化形式" class="headerlink" title="75.考虑使用自定义的序列化形式"></a>75.考虑使用自定义的序列化形式</h3><p>如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Name implements Serializable&#123;</span><br><span class="line">    private final String lastName;</span><br><span class="line">    </span><br><span class="line">    private final String firstName;</span><br><span class="line">    </span><br><span class="line">    private final String middleName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使你确定了默认的序列化形式是合适的，通常还必须提供一个readObject方法保证约束关系和安全性。</p><p>当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下4个缺点：</p><ul><li>它使这个类的导出API永远地束缚在该类的内部表示法上。</li><li>它会消耗过多的时间。</li><li>它会消耗过多空间。</li><li>它会引起栈溢出。</li></ul><p>如果所有的实例域都是瞬时的（transient），从技术角度而言，不调用DefaultWriteObject和defaultReadObject也是允许的，但是不推荐这样做。<br>在决定将一个域做成非transient的之前，请一定要确信它的值将是该对象逻辑状态的一部分。<br>如果在读取整个对象状态的任何其他方法上强制任何同步，则也必须在对象序列化上强制这种同步。<br>不管你选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显式的序列版本UID（serial version UID）。</p><h3 id="76-保护性的编写readObject方法"><a href="#76-保护性的编写readObject方法" class="headerlink" title="76.保护性的编写readObject方法"></a>76.保护性的编写readObject方法</h3><p><strong><em>记得回来看反序列化代码</em></strong></p><p>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。保护性拷贝在有效性检查之前进行。</p><p>不要使用writeUnshared和readUnshared方法。</p><p>对于非final的可序列化类，readObject方法不可以调用可被覆盖的方法，无论是直接调用还是间接调用都不可以。如果违反了规则，并覆盖了该方法，被覆盖的方法将在子类的状态被序列化之前先运行，程序很可能失败。</p><p>readObject方法指导：</p><ul><li>对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别。</li><li>对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li><li>如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。</li><li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li></ul><h3 id="77-对于实例控制，枚举类型优先于readResolve"><a href="#77-对于实例控制，枚举类型优先于readResolve" class="headerlink" title="77.对于实例控制，枚举类型优先于readResolve"></a>77.对于实例控制，枚举类型优先于readResolve</h3><p>如果这个类的声明加上了“implements Serializable”的字样，它就不再是一个单例类。无论使用默认的序列化形式，还是自定义的序列化形式，都会返回一个新建的实例，这个新建实例不用于该类初始化时创建的实例。</p><p>readResolve特性允许你用readObject创建的实例代替另一个实例。对于一个正在被序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化后，新建对象上的readResolve方法就会被调用，该方法返回的对象引用将被返回，取代新建对象，指向新建对象的引用不需要再被保留，因此立即成为垃圾回收对象。</p><p>如果readResolve方法忽略被反序列化的对象，只返回该类初始化时创建的实例。如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient的。</p><p>readResolve的可访问性很重要。如果把readResolve方法放在一个final类上，它就应该是私有的。如果吧readResolve方法放在一个非final类上，就必须考虑它的可访问性。</p><p>尽可能的使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控（instance-controlled）的类，就必须提供一个readResolve方法，并确保该类的所有实例域都为基本类型，或者是transient的。</p><h3 id="78-考虑用序列化代理代替序列化实例"><a href="#78-考虑用序列化代理代替序列化实例" class="headerlink" title="78.考虑用序列化代理代替序列化实例"></a>78.考虑用序列化代理代替序列化实例</h3><p>每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。要想文件的带有重要约束条件的对象序列化，这种模式可能是最容易的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 枚举类</title>
      <link href="/java/2019-05-01-java-enum/"/>
      <url>/java/2019-05-01-java-enum/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java枚举类笔记，摘自《疯狂Java讲义》</p></blockquote><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在早期代码中，可能会直接使用简单的静态常量表示枚举，例如如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final int SEASON_SPRING = 1;</span><br><span class="line">public static final int SEASON_SUMMER = 2;</span><br><span class="line">public static final int SEASON_FALL = 3;</span><br><span class="line">public static final int SEASON_WINTER = 4;</span><br></pre></td></tr></table></figure><p>但是这种方式定义会存在如下问题：</p><ul><li>类型不安全：可能存在SEASON_SPRING + SEASON_FALL。</li><li>没有命名空间：当需要使用季节时，必须在SPRING钱使用SEASON_前缀，否则程序可能与其他类中的静态常量混淆。</li><li>打印输出的意义不明确：当输出某个季节时，实际的输出值时数字。</li></ul><p>JDK1.5 之后新增了enum关键字，用来定义枚举类。枚举类是一种特殊类，有自己的成员变量、方法，可以实现一个或者多个接口，可以定义自己的构造器。一个Java源文件中最多只能定一个public访问权限的枚举类，且该Java源文件必须和该枚举类的类名相同。和普通类区别如下：</p><ul><li>使用enum定义的默认枚举类默认继承了java.lang.Enum类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。</li><li>使用enum定义、<strong>非抽象</strong>的枚举类默认会使用final修饰，因此不能派生子类。</li><li>枚举类的构造器只能使用private访问控制符。</li><li>枚举类所有的实例必须在枚举类的第一行显示列出，否则这个枚举类永远都不能产生实例。</li></ul><p>Java枚举类型基本思想：通过公有的静态final域为每个枚举常量到处实例的类。因为没有可以访问的构造器，枚举类型是真正的final。</p><h3 id="1-枚举类的成员变量、方法和构造器"><a href="#1-枚举类的成员变量、方法和构造器" class="headerlink" title="1. 枚举类的成员变量、方法和构造器"></a>1. 枚举类的成员变量、方法和构造器</h3><p>枚举类也是一种比较特殊的类。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;),FEMALE(&quot;女&quot;);</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看出，枚举类中列出枚举值时，实际上就是调用构造器创建枚举类对象，只是这里不是使用new关键字，也无需显式调用构造器。</p><p>上面<code>MALE(&quot;男&quot;),FEMALE(&quot;女&quot;)</code>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void final Gender MALE = new Gender(&quot;男&quot;)；</span><br><span class="line">public static void final Gender FEMALE = new Gender(&quot;女&quot;)；</span><br></pre></td></tr></table></figure></p><h3 id="2-实现接口的枚举类"><a href="#2-实现接口的枚举类" class="headerlink" title="2. 实现接口的枚举类"></a>2. 实现接口的枚举类</h3><p>接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface GenderDesc&#123;</span><br><span class="line">    void info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;men&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,FEMALE(&quot;女&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;women&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong>并非所有的枚举类都使用final修饰，非抽象的枚举类才默认使用final修饰。对于一个抽象的枚举类，系统默认使用abstract修饰，而不是final。</p><h3 id="3-包含抽象方法的抽象类"><a href="#3-包含抽象方法的抽象类" class="headerlink" title="3. 包含抽象方法的抽象类"></a>3. 包含抽象方法的抽象类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public enum Operation&#123;</span><br><span class="line"></span><br><span class="line">    PLUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x-y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x*y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x/y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    public abstract double eval(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Serializable</title>
      <link href="/java/2019-04-27-java-serializable/"/>
      <url>/java/2019-04-27-java-serializable/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java序列化笔记，摘自《疯狂Java讲义》</p></blockquote><h2 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h2><h3 id="1-序列化的含义和意义"><a href="#1-序列化的含义和意义" class="headerlink" title="1.序列化的含义和意义"></a>1.序列化的含义和意义</h3><p>对象序列化指将一个Java对象写入IO流中。<br>对象支持序列化则必须让它的类是可序列化的。该类必须实现如下两个接口之一</p><ul><li><code>Serializable</code></li><li><code>Externalizable</code></li></ul><p>建议：JavaBean类都实现Serializable。</p><h3 id="2-使用对象流实现序列化"><a href="#2-使用对象流实现序列化" class="headerlink" title="2.使用对象流实现序列化"></a>2.使用对象流实现序列化</h3><ul><li>反序列化读取的仅仅是Java对象的数据，而不是Java类，因此采用反序列化恢复Java对象时，必须提供该Java对象所属类的class文件，否则将会引发ClassNotFoundException异常。</li><li>反序列化无需通过构造器来初始化Java对象。</li><li>如果使用序列化机制向文件中写入了多个Java对象，使用反序列化机制恢复对象时必须按实际写入顺序读取。</li><li>当一个可序列化类有多个父类时，这些父类要么有无参数构造器，要么也是可序列化的，否则抛出InvalidClassException。</li><li>如果父类时不可序列化的，只带有无参数构造器，则该父类中定义的成员变量值不会序列化到二进制流中。（反序列化时会调用父类的无参构造器，重新实例化父类对象）</li></ul><h3 id="3-对象引用的序列化"><a href="#3-对象引用的序列化" class="headerlink" title="3.对象引用的序列化"></a>3.对象引用的序列化</h3><p>Java序列化机制算法：</p><ul><li>所有保存到磁盘中的对象都有一个序列化编号。</li><li>当程序试图序列化一个对象时，程序将先检查该对象是否已经被序列化过，只有该对象从未被序列化过，系统才会将该对象转换成字节序列并输出。</li><li>如果某个对象已经序列化过，程序将直接输出一个序列化编号，而不是再次重新序列化该对象。</li></ul><p>注：当程序序列化一个可变对象时，只有第一次writeObject()方法输出时才会将该对象转换成字节序列并输出，当再次调用writeObject()方法时，程序只是输出前面的序列化编号，即使后面该对象的实例变量值已被改变，改变的实例变量值也不会被输出。</p><h3 id="4-自定义序列化"><a href="#4-自定义序列化" class="headerlink" title="4.自定义序列化"></a>4.自定义序列化</h3><blockquote><p>当对某个对象进行序列化时，系统会自动把该对象的所有实例变量依次进行序列化，如果某个实例变量引用另一个对象，则被引用的对象也会被序列化；如果被引用的对象实例变量也引用了其他对象，则被引用的对象也会被序列化，这种情况被称为递归序列化。</p></blockquote><h4 id="4-1-transient关键字"><a href="#4-1-transient关键字" class="headerlink" title="4.1 transient关键字"></a>4.1 transient关键字</h4><p>在实例变量前使用transient关键字修饰，可以指定Java序列化时无需理会该实例变量。<br>transient关键字只能用于修饰实例变量，不能用于修饰Java程序中的其他成分。<br>transient关键字修饰实例变量将被完全隔离在序列化机制之外，这样导致在反序列化恢复Java对象时无法取得该实例的变量值。</p><h4 id="4-2-自定义序列化"><a href="#4-2-自定义序列化" class="headerlink" title="4.2 自定义序列化"></a>4.2 自定义序列化</h4><p>在类中提供如下方法，这些方法用以实现自定义序列化。</p><ul><li><code>private void writeObject(java.io.ObjectOutputStream out)throws IOException</code></li><li><code>private void readObject(java.io.ObjectInputStream in)throws IOException,ClassNotFoundException</code></li><li><code>private void readObjectNoData()throws ObjectStreamException</code></li></ul><p>注：writeObject的顺序与readObject的顺序一致，否则不能正常恢复Java对象。</p><p>writeReplace方法由序列化机制调用，只要该方法存在。在序列化某个对象前，先调用该对象writeReplace()方法，如果该方法返回另一个Java对象，则系统转化序列化另一个对象。<br>与writeReplace方法相对的是，readResolve()，这个方法在readObject()后被调用，该方法的返回值将代替原来反序列化的对象，原来的对象被丢弃。<br>readResolve()在序列化单例类和枚举类时尤其有用。所有的单例类和枚举类在实现序列化时都应该提供readResolve方法，这样才能保证反序列化的正常。</p><h3 id="5-自定义序列化机制"><a href="#5-自定义序列化机制" class="headerlink" title="5.自定义序列化机制"></a>5.自定义序列化机制</h3><p>Java除了Serializable，还提供了另一种序列化机制，这种序列化方式完全由程序员决定存储和恢复对象数据。要实现该目标，Java必须实现Externalizable接口，接口中方法如下：</p><ul><li><code>void readExternal(ObjectInput in)</code>：需要实现readExternal方法实现反序列化。</li><li><code>void writeExternal(ObjectOutput out)</code>：需要实现writeExternal方法来保存对象状态。</li></ul><p>两种序列化机制的对比：</p><p>Serializable</p><ul><li>系统自动保存必要信息</li><li>Java内建支持，易于实现，只需实现该接口即可，无需任何代码支持（也可以自定义）</li><li>性能略差</li></ul><p>Externalizable</p><ul><li>程序员决定存储哪些信息</li><li>仅仅提供空方法，必须自定义实现序列化</li><li>性能略高</li></ul><blockquote><p><strong>注意</strong></p><ul><li>对象的类名、属性（基本类型、数组、对其他对象的引用）都会被序列化；方法、static属性、transient属性都不会被序列化。</li><li>实现Serializable接口的类如果需要想让某个属性不被序列化，可在属性前加transient修饰符，而不是加static。</li><li>保证序列化对象的属性的类型也是可序列化的，否则需要使用transient关键字来修饰该属性，要不然，则该类是不可序列化的。</li><li>反序列化对象时必须有序列化对象的class文件。</li></ul></blockquote><h3 id="6-版本"><a href="#6-版本" class="headerlink" title="6.版本"></a>6.版本</h3><p>反序列化Java对象时必须提供该对象的class文件，如果项目升级，Java如何保证两个class文件的兼容性？</p><p>Java序列化机制允许为序列化类提供一个private static final的serialVersionUID属性值，该属性值用于表示该Java类的序列化版本。</p><ul><li>如果修改类时仅仅修改了方法，则反序列化完全不受任何影响，类定义无需修改serialVersionUID的属性值。</li><li>如果修饰类时仅仅修改了静态属性或瞬态属性，则反序化不受任何影响，类定义无需修改serialVersionUID属性值。</li><li>如果修改类时修饰了非静态、非瞬态属性，则可能导致序列化版本不兼容，如果对象流中的对象和新类中包含同名的属性，而属性类型不同，则反序列化失败，类定义应该更新serialVersionUID属性值。如果对象流中对象比新类中包含更多的属性，则多处的属性值被忽略，序列化版本可以兼容，类定义可以不更新serialVersionUID属性值；但反序列化得到的新对象中多处的属性值都是null（引用类型属性）或0（基本类型属性）。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Transaction Management</title>
      <link href="/transaction/2019-03-07-spring-transaction-management/"/>
      <url>/transaction/2019-03-07-spring-transaction-management/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-事务管理"><a href="#Spring-事务管理" class="headerlink" title="Spring 事务管理"></a>Spring 事务管理</h1><p>翻译自<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-motivation" target="_blank" rel="noopener">spring/docs/4.2.x</a></p><p>翻译过程中使用工具：google翻译，欧路词典</p><p>名词解释：<br>JTA：Java Transaction API<br>JPA：Java Persistence API<br>JDO：Java Data Object<br>CMT： Container Managed Transactions<br>JNDI：Java Naming and Directory Interface<br>JMS： Java Message Service<br>JCA： Java EE Connector Architecture</p><h2 id="1-事务管理"><a href="#1-事务管理" class="headerlink" title="1. 事务管理"></a>1. 事务管理</h2><h2 id="1-1-Spring框架事务管理介绍"><a href="#1-1-Spring框架事务管理介绍" class="headerlink" title="1.1 Spring框架事务管理介绍"></a>1.1 Spring框架事务管理介绍</h2><p>全方面的事务支持是使用Spring框架的最引人注目的原因之一。Spring框架为事务管理提供一致性抽象提供了如下好处：</p><ul><li>一致性编程模型横跨不同的事务APIs，例如 JTA，JPA，JDO。</li><li>支持声明式事务管理</li><li>和复杂编程事务APIs（例如JTA）相比，Spring提供更简单的编程事务管理的API。</li><li>与Spring的数据访问抽象有良好的集成。</li></ul><p>下面的部分描述Spring框架的事务value-adds和技术。(这部分也包含对于最好事务管理的实践，应用服务器集成和常见问题解决方案的讨论)</p><ul><li><a href="#1-2-Spring框架事务支持模型的优势">Spring框架事务支持模型的优势</a>描述你为什么会使用Spring框架的事务抽象，而不是选择EJB的容器管理事务或者通过专有的API（例如Hibernate）驱动本地事务。</li><li><a href="#1-3-理解Spring框架事务抽象">理解Spring框架的事务抽象</a>概述核心类和描述怎样配置和怎样从各种类型的数据源中获取数据源。</li><li><a href="#1-4-将资源与事务同步">将资源与事务同步</a>描述应用代码怎样确保资源的创建，复用和正确的清理。</li><li><a href="#1-5-声明式事务管理">声明式事务管理</a>描述支持声明式事务管理。</li><li><a href="#1-6-编程事务管理">编程事务管理</a>包含支持编程事务管理。</li><li><a href="#1-8-事务约束事件">事务约束事件</a>描述你可以怎样在事务中使用应用程序事件。</li></ul><h2 id="1-2-Spring框架事务支持模型的优势"><a href="#1-2-Spring框架事务支持模型的优势" class="headerlink" title="1.2 Spring框架事务支持模型的优势"></a>1.2 Spring框架事务支持模型的优势</h2><p>传统上，Java EE的开发者对于事务管理有两种选择：全局或者本地事务管理，这两种都有很大的局限性。全局和本地事务管理将在下面的两小节中回顾，接着是Spring框架管理支持解决全局和本地事务管理模型局限性的讨论。</p><h3 id="1-2-1-全局事务"><a href="#1-2-1-全局事务" class="headerlink" title="1.2.1 全局事务"></a>1.2.1 全局事务</h3><p>全部事务管理允许你和多个事务资源一块运行，事务资源一般是关系型数据库和消息队列。应用服务器通过JTA管理全局事务，JTA是一个用起来笨重的API（部分是由于它的异常模型决定的）。此外，JTA<code>UserTransaction</code>正常来说需要JNDI引入资源，意味着为了使用JTA你还需要使用JNDI。显然，全局事务的使用将会限制应用代码潜在的复用，同时JTA只能在应用服务器环境中可用。<br>先前，使用全局事务比较好的方式是通过EJB的容器管理事务：CMT是一张声明式事务管理表（对于编程事务管理也同样好用）。EJB CMT删除了关联事务JNDI的查找，尽管EJB自己必须要使用JNDI。它消除了编写Java代码以控制事务的大部分但不是全部的需要。CMT最大的缺陷是捆绑JTA和应用的服务器环境。同时，CMT只有在EJBs里实现业务逻辑才可用，或者至少在一个事务EJB facade之前。通常EJB的负面影响太大以致于这不是一个有吸引力的方案，尤其是面对声明式事务管理的引人注目的备选方案。</p><h3 id="1-2-2-本地事务"><a href="#1-2-2-本地事务" class="headerlink" title="1.2.2 本地事务"></a>1.2.2 本地事务</h3><p>本地事务是特定于资源的，比如一个事务关联一个JDBC连接。本地事务可能使用简单，但是有明显的缺陷：它们不能在多个事务资源上工作。举个例子，使用JDBC连接的管理事务代码不能在全局JTA事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个数据源的正确性。（值得注意的是，大多数应用使用单个事务资源）另一个缺陷是本地事务在编程模型中是侵入式的。</p><h3 id="1-2-3-Spring框架的一致性编程模型"><a href="#1-2-3-Spring框架的一致性编程模型" class="headerlink" title="1.2.3 Spring框架的一致性编程模型"></a>1.2.3 Spring框架的一致性编程模型</h3><p>Spring 解决了全局和本地事务的缺陷。它允许程序员在任何环境中使用一致性编程模型。你写一次代码，它可以在不同环境中的不同事务管理策略中受益。Spring框架提供声明和编程事务管理。大多数用户使用在大多数情况下被推荐使用的声明式事务模型。<br>对于编程式事务管理，开发者将使用Spring 框架的事务抽象，它可以在底层的事务基础设施上运行。对于声明式模型，开发经常写一点或者没有代码去关联事务管理，因此不依赖Spring框架的事务API或者其他的事务API。</p><blockquote><p><b>对于事务管理，你是否需要应用服务器？</b><br>Spring 框架事务管理支持当企业Java应用需要应用服务器时修改传统规则。<br>尤其，你只是需要通过EJBs声明事务而不是需要应用服务器。事实上，<strong>即使你的应用服务器有的JTA能</strong>力，对比EJB CMT，你可能决定使用Spring框架的声明式事务提供更多能力和一个富有成效的编程模型。<br>通常你需要使用应用服务器的JTA能力仅仅因为你的应用需要跨多个资源去处理事务，这种情况对于许多应用是不需要的，许多高端应用使用一个高扩展性的数据库（如：Oracle RAC）代替多个资源。独立事务管理如 Atomikos Transactions 和 JOTM是其他选择。当然，你可能需要其他应用服务器能力，如Java消息服务和JCA。<br>Spring框架给你当需要扩展你的应用去完整加载应用服务器的选择，替代使用EJB CMT或者JTA的唯一方式是使用本地事务（如：JDBC连接）写代码的日子一去不复返了，如果你需要在全局或者CMT中运行该本地事务代码将会面对大量的返工。使用Spring框架，你仅仅需要在配置文件中定义一些bean，而不是需要去修改代码。</p></blockquote><h2 id="1-3-理解Spring框架事务抽象"><a href="#1-3-理解Spring框架事务抽象" class="headerlink" title="1.3 理解Spring框架事务抽象"></a>1.3 理解Spring框架事务抽象</h2><p><strong>spring框架事务抽象的关键是事务策略的概念</strong>，通过<code>org.springframework.transaction.PlatformTransactionManager</code>接口定义事务策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager&#123;</span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition) throws TransactionException;</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个主要是Java的服务提供发现机制，尽管可以从应用代码中以编程方式使用。因为<code>PlatformTransactionManager</code>是一个接口，它可以在被需要是很容易的仿制或者存根。它和类似JNDI的查找策略无关。<br>定义<code>PlatformTransactionManager</code>的接口实现和spring IoC容器中的其他对象（或bean）相同。即使你使用JTA，仅此一项好处也使得Sping框架事务值得被抽象。相比于直接使用JTA，使用Spring事务抽象可以让测试事务代码更简单。<br>可以被任何<code>PlatformTransactionManager</code>接口的实现方法抛出的非检查（继承<code>java.lang.RuntimeException</code>的类）的<code>TransactionException</code>再次符合Spring的理念。事务基础设施的故障几乎总是致命的。应用代码在极少数情况下可以从事务失败中恢复，应用开发者可以选择捕获和处理<code>TransactionException</code>。重点是开发者不必强制去这样做。<br><code>getTransaction(..)</code>方法返回<code>TransactionStatus</code>对象，依赖一个<code>TransactionDefinition</code>参数。返回的<code>Transaction</code>可能代表一个新事务，或者可以代表一个已经存在的事务如果此事务在当前调用栈中存在匹配的事务。后者的意义是在Java EE事务上下文中，一个线程的执行和一个<code>TransactionStatus</code>相关联。<code>TransactionDefinition</code>接口指定：</p><ul><li>Isolation: 当前事务和其他事务在工作中的隔离程度。例如： 此事务是否可以看到来自其他事务的未提交的写入？</li><li>Propagation: 通常，在事务范围内运行的所有代码都将在此事务中运行。但是，你可以选择在事务上下文已经存在且执行事务方法的事件中指定行为。例如：代码可以在已存在的事务中继续运行（常见情况）;或者挂起已存在的事务，新建事务。Spring提供了EJB CMT中熟悉的所有事务传播选择。了解Spring中关于事务传播语义，<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#tx-propagation" target="_blank" rel="noopener">事务传播</a>。</li><li>Timeout: 在超时和底层事务基础设施自动回滚事务之前，事务可以运行多久？</li><li>Read-only status: 当你的代码读取但是不修改数据数据时可以使用只读事务。只读事务在某些情况下是有用的优化，例如当你使用Hibernate时。</li></ul><p>这些事务反映出了标准的事务概念，如果需要，请参阅讨论事务隔离等级和其他核心事务概念的资源。理解这些概念对使用Spring框架或者其他事务管理的解决方案是很必要的。</p><p><code>TransactionStatus</code>接口提供简单的事务代码去控制事务执行和查询事务状态。这些概念应该是熟悉的，它们对所有事务APIs都是通用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager&#123;</span><br><span class="line">    boolean isNewTransaction();</span><br><span class="line">    boolean hasSavepoint();</span><br><span class="line">    void setRollbackOnly();</span><br><span class="line">    boolean isRollbackOnly();</span><br><span class="line">    void flush();</span><br><span class="line">    boolean isCompleted();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论你在Spring中选择声明式事务还是编程式事务管理，定义正确的<code>PlatformTransactionManager</code>实现是绝对必要的。通常通过依赖注入定义这个实现。</p><p><code>PlatformTransactionManager</code>实现通常需要了解他们运行的环境：JDBC，JTA，Hibernate等等。下面的例子展示你怎样定义一个本地的<code>PlatformTransactionManager</code>实现。（这个例子适用普通的JDBC。）<br>定义一个JDBC<code>DataSource</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>相关<code>PlatformTransactionManager</code>的bean定义将有一个<code>DataSource</code>定义的引用。它看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>如果你在Java EE容器中使用JTA，你将使用通过容器从JNDI中获取的<code>DataSource</code>，和Spring的JtaTransactionManager相关联。这就是JTA和JNDI查找版本的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/jee</span><br><span class="line">        http://www.springframework.org/schema/jee/spring-jee.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;jdbc/jpetstore&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><code>JtaTransactionManager</code>不需要知道<code>DataSource</code>或者其他指定的资源，因为它使用容器的全局事务管理基础设施。</p><blockquote><p>以上定义的<code>dataSource</code>bean使用<code>jee</code>命名空间的<code>&lt;jdni-lookup/&gt;</code>标签。对于<code>schema-based</code>的更多配置信息，<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html" target="_blank" rel="noopener">Chapter40, XML Schema-based 配置</a>，对于<code>&lt;jee/&gt;</code>标签的更多信息，请看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html#xsd-config-body-schemas-jee" target="_blank" rel="noopener">Section 40.2.3</a></p></blockquote><p>你也可以使用轻松的使用Hibernate本地事务，正如在下面展示的例子。这种情况，你需要定义一个Hibernate<code>LocalSessionFactoryBean</code>，你的代码将使用它去获取Hibernate<code>Session</code>实例。</p><p><code>DataSource</code>bean定义和之前示例本地JDBC例子相似，所以下面不在展示。</p><blockquote><p>如果<code>DataSource</code>被任何非JTA事务管理使用，将通过JNDI查找，Java EE容器管理，然后它将是非事务性的，因为是使用Spring框架管理事务，而不是Java EE容器。</p></blockquote><p><code>txManager</code>bean 在这种情况下是属于<code>HibernateTransactionManager</code>类型。以相同的方式，正如<code>DataSourceTransactionManager</code>需要引用<code>DataSource</code>，<code>HiberanteTransactionManager</code>需要引用<code>SessionFactory</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;mappingResources&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;hibernateProperties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            hibernate.dialect=$&#123;hibernate.dialect&#125;</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果你使用Hibernate和Java EE容器管理JTA事务，你应该使用与之前JDBC的JTA例子相同的<code>JtaTransactionManager</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果你使用JTA，你的事务管理定义将看起来一样，而不管你用了什么数据访问技术，是JDBC，Hibernate JPA或者其他支持的技术。这个是确定的事实，JTA 事务是全局事务，可以加入任何的事务资源。</p></blockquote><p>对于以上所有情况，应用代码不需要 改变。你可以通过改变配置来改变如何管理事务，即使你从本地事务改为全局事务，反之亦然。</p><h2 id="1-4-将资源与事务同步"><a href="#1-4-将资源与事务同步" class="headerlink" title="1.4 将资源与事务同步"></a>1.4 将资源与事务同步</h2><p>现在你应该很清楚如何创建不同的事务管理，和它们怎样和需要被同步事务相关资源链接（例如：<code>DataSourceTransactionManager</code>链接JDBC<code>DataSource</code>，<code>HibernateTransactionManager</code>链接Hibernate<code>SessionFactory</code>，等等。）这个章节描述应用代码怎样直接或者非直接使用持久API，如JDBC，Hibernate，或者JDO，确保这些资源被创建，复用，和正确的清理。这个章节也讨论事务同步怎样通过相应的<code>PlatformTransactionManager</code>触发。</p><h3 id="1-4-1-高级同步方式"><a href="#1-4-1-高级同步方式" class="headerlink" title="1.4.1 高级同步方式"></a>1.4.1 高级同步方式</h3><p>首选方法是使用Spring基于高级模板的持久性集成APIs或者使用本地ORM APIs与transacton-aware工厂bean或者代理一起使用，来管理本地资源工厂。transaction-aware解决方案在内部处理资源的创建，复用，清理，资源的可选事务同步和异常映射。因此用户数据访问代码不必解决这些任务，但是可以完全关注于非样板持久逻辑。通常，你使用本地ORM API或者使用模版方式通过使用<code>JdbcTemplate</code>进行JDBC访问。这些解决方案在本参考文档的随后章节中有详细说明。</p><h3 id="1-4-2-低级同步方式"><a href="#1-4-2-低级同步方式" class="headerlink" title="1.4.2 低级同步方式"></a>1.4.2 低级同步方式</h3><p>类例如：<code>DataSourceUtils</code>（JDBC），<code>EntityManagerFactoryUtils</code>(JPA)，<code>SessionFactoryUtils</code>（Hibernate），<code>PersistenceManagerFactoryUtils</code>(JDO)，等类存在于较低级别。<br>本地持久化APIs，你使用这些类去确保Spring框架管理的实例被正确获取，事务被同步（可选），在进程中发生的异常正确的被映射到一致的API。<br>例如，在JDBC的情况下，而不是在<code>DataSource</code>调用<code>getConnection()</code>方法的传统的JDBC方式,你替换使用Spring的<code>org.springframework.jdbc.datasource.DataSourceUtils</code>类，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DataSourceUtils.getConnection(dataSource);</span><br></pre></td></tr></table></figure></p><p>如果一个已经存在的事务有一个链接和它同步，这个实例将被返回。否则，这个方法调用出方法新链接的创建，这个链接（可选）被同步到已经任何已存在的事务上，使得在随后的同一事务中重复调用。 如上所述，任何<code>SQLException</code>在Spring框架<code>CannotGetJdbcConnectionException</code>中是被包括的，是Spring框架非校验数据访问异常之一。这个方式提供了比你从<code>SQLException</code>中轻松获的更多的信息，确保跨数据库的可移植性，设置跨不同的持久化技术。</p><p>这种方式运行也没有Spring事务管理（事务同步时可选的），所以无论你是否使用Spring事务管理，你都可以使用它。</p><p>当然，一旦你使用了Spring的JDBC支持，JPA支持或者Hibernate支持，你通常更喜欢不使用<code>DataSourceUtils</code>或者其他的类，因为相比于直接使用相关的APIs，通过Spring抽象你将工作的更快乐。例如：你使用Spring<code>JdbcTemplate</code>或者<code>jdbc.object</code>包去简化你使用的JDBC，在幕后发生的链接恢复，你将不在需要写任何特定代码。</p><h3 id="1-4-3-TransactionAwareDataSourceProxy"><a href="#1-4-3-TransactionAwareDataSourceProxy" class="headerlink" title="1.4.3 TransactionAwareDataSourceProxy"></a>1.4.3 TransactionAwareDataSourceProxy</h3><p><code>TransactionAwareDataSourceProxy</code>类作为一个低级存在。这是一个<code>DataSource</code>的代理，它包装目标DataSource以增加对Spring管理的事务的认识。在这个方面，它类似于通过Java EE服务器提供的事务JNDI<code>DataSource</code>。</p><p>使用这个累根本不需要或者不可取，除非当已存在的代码必须被调用和传递了一个标准JDBC<code>DataSource</code>接口实现。在这种情况下，代码可能有用，但是参与Spring的事务管理。最好是通过使用上面提到的高级抽象去写新代码。</p><h2 id="1-5-声明式事务管理"><a href="#1-5-声明式事务管理" class="headerlink" title="1.5 声明式事务管理"></a>1.5 声明式事务管理</h2><blockquote><p>大多数Spring框架用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。</p></blockquote><p>使用Spring切面编程的Spring 框架的声明式事务管理成为可能。但是，由于事务切面代码随Spring Framework发行版一起提供并且可能以样板方式使用，因此通常没必要理解AOP概念来有效地使用此代码。</p><p>Spring 框架的声明式事务管理和 EJB CMT在给单个方法级别指定（缺少）事务的行为是相似的。在需要的情况下，不使用事务上下文调用<code>setRollbackOnly()</code>是可能的。两种事务管理类型的不同点是：</p><ul><li>和 EJB CMT不一样，绑定JTA，Spring框架的声明式事务管理可以在任何环境中运行。也可以通过调整配置文件使用JTA事务或者使用JDBC，JPA，Hibernate或者JDO本地事务。</li><li>你可以对任意类用Spring框架声明式事务管理，不仅仅是对于像EJBs的特殊类。</li><li>Spring框架提供声明式回滚规则，没有和EJB等效的功能。提供编程式和声明式两种回滚规则支持。</li><li>Spring框架允许通过使用AOP自定义事务行为。例如，你可以在事务回滚的情况下插入自定义行为。你随着事务advice也可以添加任意advice。使用EJB CMT，除了<code>setRollbackOnly</code>你无法影响容器的事务管理。</li><li>Spring框架和高端服务器一样不支持跨远程调用事务上下文传播特性。如果你需要使用这种特性，我们建议你使用EJB。但是，使用这种特性之前考略清楚，因为一般来说，不想支持事务的跨远程调用。</li></ul><blockquote><p><b>TransactionProxyFactoryBean在哪？</b><br>   在Sping的2.0版本及以上版本的声明事务配置和以前的Spring版本有很大的区别。主要的不同是不在需要配置<code>TransactionProxyFactoryBean</code>beans。<br>   Spring2.0版本之前的配置依然是100%有效的配置；将新<code>&lt;tx:tags/&gt;</code>视为代表你简单的定义<code>TransactionProxyFactoryBean</code> beans。   </p></blockquote><p>回滚规则的概念是重要的：它们允许你头指定哪种异常（或者抛出）应该造成自动的回滚。你以声明的方式指定它，在配置中，不在Java代码中。因此，尽管你可以始终在<code>TransactionStatus</code>对象上调用<code>setRollbackOnly</code>方法去回滚当前事务，但是大多数你常常可以指定<code>MyApplicationException</code>必须总是造成回滚的规则。这个选择对的重大优势是业务对象不依赖事务基础设施。例如，它们通常需要导入Spring 事务APIs或者其他Spring APIs。</p><p>尽管EJB容器默认行为在系统异常（通常是运行时异常）中自动回滚事务，EJB CMT在应用异常（除<code>java.rmi.RemoteException</code>外的检查时异常）中不自动回滚事务。虽然Spring声明式事务管理的默认行为遵循EJB约定（仅仅在非检查异常时自动回滚），但是，自定义这个行为是经常有用的。</p><h3 id="1-5-1-理解声明式事务管理实现"><a href="#1-5-1-理解声明式事务管理实现" class="headerlink" title="1.5.1 理解声明式事务管理实现"></a>1.5.1 理解声明式事务管理实现</h3><p>简单的告诉你去使用<code>@Transactional</code>注解去注解你的类，在配置中添加<code>@EnableTransactionMangement</code>，然后期待你理解它全部怎样运行的是不足够的。这个章节解释在发生与事务相关的问题时Spring的声明式事务基础设施内部工作原理。<br>关于Spring框架的说明书事务支持最重要的概念是通过AOP代理启用这个支持，事务advice由元数据（目前基于XML或者注解）驱动。事务元数据和AOP的组合生成一个代理，这个代理使用<code>TransactionInterceptor</code>和适当的<code>PlatfromTransactionManager</code>实现来驱动围绕方法调用的事务。</p><blockquote><p>Spring AOP 包含在<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring.</a></p></blockquote><p>从概念上讲，调用在一个事务代理上的一个方法像这样：</p><p><img src="media/15528176890745.png" alt=""></p><h3 id="1-5-2-声明式事务实现的例子"><a href="#1-5-2-声明式事务实现的例子" class="headerlink" title="1.5.2 声明式事务实现的例子"></a>1.5.2 声明式事务实现的例子</h3><p>考虑下面的接口，和随后的实现。这个例子使用<code>Foo</code>和<code>Bar</code>类作为标志符，以便于你可以不用管不住特殊域模型，只集中关注事务的使用。对于这个例子的目的，在每一个实现方法体内，<code>DefaultFooService</code>类抛出<code>UnsupportedOperationException</code>实例的事实是好的；它允许你查看创建的事务和然后回滚来响应<code>UnsupportedOperationException</code>实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public interface FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName, String barName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<code>FooService</code>接口的前面两个方法，<code>getFoo(String)</code>和<code>getFoo(String, String)</code>，必须在一个带有只读语义事务的上下文中执行，和其他的方法，<code>insertFoo(Foo)</code>和<code>updateFoo(Foo)</code>，必须在带有只读语义事务上下文中执行。如下配置在下面的几段中被详细解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the transactional advice (what &apos;happens&apos;; see the &lt;aop:advisor/&gt; bean below) --&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;!-- the transactional semantics... --&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!-- all methods starting with &apos;get&apos; are read-only --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;!-- other methods use the default transaction settings (see below) --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ensure that the above transactional advice runs for any execution</span><br><span class="line">        of an operation defined by the FooService interface --&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;fooServiceOperation&quot; expression=&quot;execution(* x.y.service.FooService.*(..))&quot;/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;fooServiceOperation&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- don&apos;t forget the DataSource --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;scott&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;tiger&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- similarly, don&apos;t forget the PlatformTransactionManager --&gt;</span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>检查前面的配置。你想创建一个服务对象，<code>fooService</code>bean。要应用的事务语义被封装在<code>&lt;tx:advice/&gt;</code>定义中。<code>&lt;tx:advice/&gt;</code>定义读作“在只读事务上下文中所有要执行的方法以<code>get</code>开头，所有其他要执行的方法带有默认事务语义。“<code>&lt;tx:advice/&gt;</code>标签的<code>transaction-manager</code>属性被设置为将要驱动事务的<code>PlatformTransactionManager</code>bean 的name，在当前的配置文件中，是<code>txManager</code>bean。</p><blockquote><p>如果你想设置<code>PlatformTransactionManager</code>bean的name为<code>transactionManager</code>，你可以忽略事务advice的<code>transaction-manager</code>属性。如果你想使用任何其他的name给<code>PlatformTransactionManager</code>bean，正如在之前的例子中，你之后必须明确的使用<code>transaction-manager</code>属性。</p></blockquote><p><code>&lt;aop:config/&gt;</code>的定义确保在程序中适当的点执行通过<code>txAdvice</code>bean定义的事务advice。首先你定义一个切入点，切入点与在<code>FooService</code>接口（<code>fooServiceOperation</code>）中定义的任何操作执行的相匹配。然后使用advisor关联切入点和txAdvice。结果表明在执行<code>fooServiceOperation</code>时，通过<code>txAdvice</code>定义的advice将会运行。</p><p>在<code>&lt;aop:pointcut/&gt;</code>元素中定义的表达式，是一个AspectJ切入点表达式；查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring</a>了解更多有关Spring中的切入点表达式的详细信息。</p><p>一个常见的需求时创建一个全部服务层的事务。实现这种需求的最好方式是只修改切入点表达式去匹配在你服务层的所有操作。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;fooServiceMethods&quot; expression=&quot;execution(* x.y.service.*.*(..))&quot;/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;fooServiceMethods&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中：它假设你所有服务接口在<code>x.y.service</code>包中定义；查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring </a>了解更多信息。</p></blockquote><p>现在，我们已经分析了配置，你可能会问你自己，“这所有的配置实际上做了什么？”。</p><p>以上配置将被用来去创建一个事务代理围绕从<code>fooService</code>bean 定义创建的对象。这个代理将使用事务advice配置，以便于在代理上调用一个适当的方法时，一个事务开始，挂起，被标记为只读等等，取决于与该方法关联的事务配置。考虑一下测试驱动以上配置的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Boot &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;context.xml&quot;, Boot.class);</span><br><span class="line">        FooService fooService = (FooService) ctx.getBean(&quot;fooService&quot;);</span><br><span class="line">        fooService.insertFoo (new Foo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码的输出将类似下面的。（为清楚起见，Log4J输出和DefaultFooService类的insertFoo（..）方法抛出的UnsupportedOperationException的堆栈跟踪已被截断。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- the Spring container is starting up... --&gt;</span><br><span class="line">[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean &apos;fooService&apos; with 0 common interceptors and 1 specific interceptors</span><br><span class="line"></span><br><span class="line">&lt;!-- the DefaultFooService is actually proxied --&gt;</span><br><span class="line">[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]</span><br><span class="line"></span><br><span class="line">&lt;!-- ... the insertFoo(..) method is now being invoked on the proxy --&gt;</span><br><span class="line">[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo</span><br><span class="line"></span><br><span class="line">&lt;!-- the transactional advice kicks in here... --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]</span><br><span class="line">[DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction</span><br><span class="line"></span><br><span class="line">&lt;!-- the insertFoo(..) method from DefaultFooService throws an exception... --&gt;</span><br><span class="line">[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException</span><br><span class="line">[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]</span><br><span class="line"></span><br><span class="line">&lt;!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp.PoolableConnection@a53de4]</span><br><span class="line">[DataSourceTransactionManager] - Releasing JDBC Connection after transaction</span><br><span class="line">[DataSourceUtils] - Returning JDBC Connection to DataSource</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)</span><br><span class="line">&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;</span><br><span class="line">at $Proxy0.insertFoo(Unknown Source)</span><br><span class="line">at Boot.main(Boot.java:11)</span><br></pre></td></tr></table></figure><h3 id="1-5-3-回滚一个声明式事务"><a href="#1-5-3-回滚一个声明式事务" class="headerlink" title="1.5.3 回滚一个声明式事务"></a>1.5.3 回滚一个声明式事务</h3><p>上面的章节概述了如何在你的应用中给类（通常是服务层类）声明式的指定事务设置。这个章节描述如果以一种简单的声明式方式控制事务回滚。<br>向Spring框架的事务基础设施表明回滚一个事务的推荐的方式是在当前一个事务上下文从执行的代码中抛出<code>Exception</code>。Spring框架事务基础设施代码将捕获所有未处理异常，因为它会调用堆栈，做出判定是否标记回滚事务标识。</p><p>在它的默认配置中，Spring框架的事务基础设施代码仅仅在runtime，unchecked异常时标记回滚事务；也就是说，当抛出的异常是一个实例或者RuntimeException的子类。（Errors在默认配置下也会回滚）。在一个事务方法中抛出的已检查异常在默认配置下不会造成回滚。</p><p>你可以准确的配置哪些类型的异常标记事务回滚，包括已检查的异常。下面的XML片段演示你怎样给已检查和应用指定异常类型配置回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; rollback-for=&quot;NoProductInStockException&quot;/&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>如果当抛出一个异常的时候，你不想事务回滚，你也可以指定‘不回滚规则’。下面的列子告诉你Spring框架的事务基础设施即使面对未处理的InstrumentNotFoundException也要提交<strong>伴随</strong>事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;updateStock&quot; no-rollback-for=&quot;InstrumentNotFoundException&quot;/&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>当Spring框架的事务基础设施缓存一个异常，参考回滚配置规则来决定是否标记回滚事务时，强匹配规则胜利。因此，在下面配置的这种情况，除<code>InstrumentNotFoundException</code>以外的所有异常都会造成伴随事务的回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Throwable&quot; no-rollback-for=&quot;InstrumentNotFoundException&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>你可以表示一个需要编程式回滚。尽管非常简单，这个进程时侵入式的，Spring框架的事务基础设施将紧紧侵入你的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void resolvePosition() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // some business logic...</span><br><span class="line">    &#125; catch (NoProductInStockException ex) &#123;</span><br><span class="line">        // trigger rollback programmatically</span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有可能强烈推荐使用声明式途径回滚事务。编程式事务回滚应该在你绝对需要时使用，但是它的用法在实现基于POJO的清洁框架时很明显。</p><h3 id="1-5-4-给不同的bean配置不同的事务语义"><a href="#1-5-4-给不同的bean配置不同的事务语义" class="headerlink" title="1.5.4 给不同的bean配置不同的事务语义"></a>1.5.4 给不同的bean配置不同的事务语义</h3><p>考虑具有多个服务层对象的情况，并且您希望对每个对象应用完全不同的事务配置。使用不同的切入点和advice-ref属性值定义不同的&lt;aop：advisor /&gt;元素。作为比较，首先假设您的所有服务层类都在根x.y.service包中定义。要使所有作为在该包（或子包中）中定义的类的实例的bean以及以Service结尾的名称具有默认的事务配置，您将编写以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;serviceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service..*Service.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;serviceOperation&quot; advice-ref=&quot;txAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- these two beans will be transactional... --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;barService&quot; class=&quot;x.y.service.extras.SimpleBarService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ... and these two beans won&apos;t --&gt;</span><br><span class="line">    &lt;bean id=&quot;anotherService&quot; class=&quot;org.xyz.SomeService&quot;/&gt; &lt;!-- (not in the right package) --&gt;</span><br><span class="line">    &lt;bean id=&quot;barManager&quot; class=&quot;x.y.service.SimpleBarManager&quot;/&gt; &lt;!-- (doesn&apos;t end in &apos;Service&apos;) --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>下面的例子展示怎样使用两种完全不同的事务设置配置两种不同的bean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;defaultServiceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service.*Service.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;noTxServiceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service.ddl.DefaultDdlManager.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;defaultServiceOperation&quot; advice-ref=&quot;defaultTxAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;noTxServiceOperation&quot; advice-ref=&quot;noTxAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will be transactional (see the &apos;defaultServiceOperation&apos; pointcut) --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;</span><br><span class="line">    &lt;bean id=&quot;anotherFooService&quot; class=&quot;x.y.service.ddl.DefaultDdlManager&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;defaultTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;noTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot; propagation=&quot;NEVER&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-lt-tx-advice-gt-设置"><a href="#1-5-5-lt-tx-advice-gt-设置" class="headerlink" title="1.5.5 &lt;tx:advice/&gt;设置"></a>1.5.5 <code>&lt;tx:advice/&gt;</code>设置</h3><p>这个章节总结可以指定使用<code>&lt;tx:advice/&gt;标签的各种事务配置。默认的</code><a href="tx:advice/" target="_blank" rel="noopener">tx:advice/</a>`设置：</p><ul><li>传播特性是 <code>REQUIRED</code></li><li>隔离等级是 <code>DEFAULT</code></li><li>事务是读/写</li><li>事务超时默认为底层事务系统的默认超时，如果不支持超时则为none</li><li>任意<code>RuntimeException</code>触发回滚，任意的检查时异常不回滚。</li></ul><p>你可以改变这些默认设置；嵌套在<code>&lt;tx:advice/&gt;</code>和<code>&lt;tx:attributes/&gt;</code>标签中的<code>&lt;tx:method/&gt;</code>标签的各种属性总结如下：<br><a href="tx:method/" target="_blank" rel="noopener">tx:method/</a> 设置:<br><img src="media/15531331224039.jpg" alt=""></p><h3 id="1-5-6-使用-Transactional"><a href="#1-5-6-使用-Transactional" class="headerlink" title="1.5.6 使用@Transactional"></a>1.5.6 使用@Transactional</h3><p>除了基于XML的方式声明事务配置，你也可以使用基于注解的方式。直接在Java源代码中声明事务语义使声明更接近被作用的代码。没有太多过度耦合的危险，因为无论如何，以事务方式使用的代码几乎总是以这种方式部署。</p><blockquote><p>标准<code>javax.transaction.Transactional</code>注解支持使用Spring自己的注解直接替换。请参考JTA 1.2 文档了解更多详细资料。</p></blockquote><p>使用@Transactional注释所提供的易用性最好通过一个示例来说明，该示例将在后面的文本中进行说明。考虑以下类定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// the service class that we want to make transactional</span><br><span class="line">@Transactional</span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当上面的POJO被定义为Spring IoC容器中的bean时，可以通过仅添加一行XML配置来使bean实例成为事务性的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- from the file &apos;context.xml&apos; --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;&lt;!-- a PlatformTransactionManager is still required --&gt;</span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;!-- (this dependency is defined somewhere else) --&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果要连接的<code>PlatformTransactionManager</code>的bean的名字是<code>transactionManager</code>，你可以忽略<code>&lt;tx:annotation-driven</code>/&gt;的<code>transaction-manager</code>属性。如果你要依赖注入的<code>PlatformTransactionManager</code>bean有任何其他的名字，你必须和上面的例子一样明确的使用<code>transaction-manager</code>。<br>如果你基于Java配置，<code>@EnableTransactionManagement</code>注解提供有效的支持。只需添加<code>@Configuration</code>注解类。查看全部详细内容请看javadocs。</p></blockquote><blockquote><p><b>方法可见性和@Transaction</b><br>当使用代理时，仅仅对于public可见性的方法应用<code>@Transactional</code>注解。如果你对protected，private或者包内可见的方法使用<code>@Transactional</code>注解，虽然没有错误，但是这个已经注解的方法不展示已配置的事务配置。如果你需要直接非public的方法，可以考虑使用AspectJ（见下文）。</p></blockquote><p>你可以在一个接口定义，接口上的方法，类定义或者类上的public方法前面设置<code>@Transactional</code>。但是，只有<code>@Transactional</code>注解是不足以激活事务行为的。<code>@Transactional</code>注解是一个简单的元数据，它可以被一些运行时的基础设施消费，这个基础设施是<code>@Transactional</code>-aware和可以使用元数据配置具有事务行为的适当的bean。在上面的例子中，<code>&lt;tx:annotation-driven/&gt;</code>元素打开事务行为。</p><blockquote><p>Spring 推荐你只使用<code>@Transactional</code>注解具体类（和具体类的方法），而不是注解接口。你通常可以在一个接口（或者一个接口的方法）上配置<code>@Transactional</code>注解，但是，仅仅在你使用基于接口代理的方式时才能获得你期望的运行。Java注解不从接口继承Java注解的事实意味着如果你使用基于类的代理（<code>proxy-target-class=&quot;true&quot;</code>）或者基于切面织入（<code>mode=&quot;&quot;aspectj</code>），然后代理和织入的基础设施将不识别事务设置，并且这个对象不被包裹在事务代理中，这将是非常糟糕的。</p></blockquote><blockquote><p>在代理模式（默认）中，仅外部的方法通过代理调用进入会被拦截。这意味着自我调用，实际上，在目标对象的方法调用目标对象的其他方法将不会在运行时引起一个实际的事务，即使被调用的方法使用<code>@Transactional</code>标记。这个代理也必须完整的初始化去提供你期望的行为，因此，你不应该在你的初始化代码中依赖这个特性，即<code>@PostConstruct</code>。</p></blockquote><p>如果你希望自我调用也被包裹在事务中，可以考虑切面模式（在下面的表格中查看模式的属性）的使用。在这种情况下，首先不会有一个代理；相反，为了将<code>@Transactional</code>转换为任何类型方法上的运行时行为，目标类将被织入（它的字节码将被修改）。</p><p><table><tr><td>XML Attribute</td><td>Annotation Attribute</td><td>Default</td><td>Description</td></tr><tr><td><code>transaction-manger</code></td><td>N/A(查看<code>TransactionManagementConfigurer</code> javadocs)</td><td>transactionManager</td><td>要使用的事务管理器的名称。仅在如果事务管理器的名称不是<code>transactionManager</code>时需要，如上面的例子所示</td></tr><tr><td><code>mode</code></td><td><code>mode</code></td><td>proxy</td><td>默认模式“代理”进程使用Spring的AOP框架（以下代理语义，正如上面讨论的，仅适用于通过代理进入的方法调用）代理被注解的bean。替代模式“aspectj”代替使用Spring的AspectJ事务切面织入受影响的类，修改目标类字节码以应用任何类型的方法调用。AspectJ 织入需要spring-aspects.jar在classpath中，同时加载时织入（编译时织入）开启。（查看怎样设置加载时织入的详细内容，请访问<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-aj-ltw-spring" target="_blank" rel="noopener">Spring配置</a>）</td></tr><tr><td><code>proxy-target-class</code></td><td><code>proxyTargetClass</code></td><td>false</td><td>仅适用代理模式。控制给带有<code>@Transactional</code>注解的注解类创建什么类型的事务代理。如果<code>proxy-target-class</code>属性设置为<code>true</code>，基于类的代理将被创建。如果<code>proxy-target-class</code>为false或者这个属性被忽略，标准JDK基于接口的代理将被创建。（详细检查不同类型代理请查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-proxying）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;`order`&lt;/td&gt;&lt;td&gt;`order`&lt;/td&gt;&lt;td&gt;Ordered.LOWEST_PRECEDENCE&lt;/td&gt;&lt;td&gt;定义事务advice的order适用于带有`@Transaction`注解的bean。（关于有关AOP advice的规则的更多信息，查看[Advice ordering](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">10.6 代理机制</a>。）不指定ordering意味着AOP子系统决定advice的order</td></tr></table></p><blockquote><p><code>@EnableTransactionManagement</code>和<code>&lt;tx:annotation-driven/&gt;</code>只查找它们定义在相同应用上下文bean上的<code>@Transactional</code>。这意味着，如果你在一个<code>WebApplicationContext</code>中给一个<code>DispatcherServlet</code>添加注解驱动配置，它仅仅检查你controller带有<code>@Transactional</code>的bean，而不是你的service。了解更多信息查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/mvc.html#mvc-servlet" target="_blank" rel="noopener">The DispatcherServlet</a>。</p></blockquote><p>在评估方法的事务设置时，派生最多的位置优先。下面列子的这种情况，<code>DefaultFooService</code>类在类级别中使用只读事务设置注解，但是，在相同的类中，在<code>updateFoo(Foo)</code>方法上的<code>@Transactional</code>注解优先于类级别定义的事务设置。</p><blockquote><p><b>@Transactional 设置</b><br><code>@Transactional</code>注解是一个元数据，这个元数据指定一个接口，类或者方法必须有事务语义；例如，“当方法被调用时，开始一个全新的只读事务，中止任何已存在的事务“。默认的<code>@Transactional</code>设置如下：</p></blockquote><ul><li>传播特性设置是<code>PROPAGATION_REQUIRED</code>。</li><li>隔离等级是<code>ISOLATION_DEFAULT</code>。</li><li>事务是读/写。</li><li>事务超时默认是底层事务系统的默认超时，或者如果不支持超时为none。</li><li>任何<code>RuntimeException</code>触发回滚，任何已校验异常不会。</li></ul><p>这些默认设置可以改变；在下表中总结了<code>@Transactional</code>注解的各种属性：</p><p><table><tr><td>Property</td><td>Type</td><td>Description</td></tr><tr><td>value</td><td>String</td><td>可选限定符，指定要使用的事务管理器</td></tr><tr><td>propagation</td><td>enum:<code>Propagation</code></td><td>可选传播特性设置</td></tr><tr><td><code>isolation</code></td><td>enum:<code>Isolation</code></td><td>可选隔离级别</td></tr><tr><td><code>readOnly</code></td><td>boolean</td><td>读/写 vs 只读</td></tr><tr><td><code>timeout</code></td><td>int(秒粒度)</td><td>事务超时</td></tr><tr><td><code>rollbackFor</code></td><td>类的对象数组，必须从<code>Throwable</code>派生</td><td>可选异常类数组，这些异常必须造成回滚</td></tr><tr><td><code>rollbackForClassName</code></td><td>类的名称数组，类必须从<code>Throwable</code>派生</td><td>可选异常类名称数组，必须造成回滚</td></tr><tr><td><code>noRollbackFor</code></td><td>类的对象数组，必须从<code>Throwable</code>派生</td><td>可选异常类数组，这些异常必须不造成回滚</td></tr><tr><td><code>noRollbackForClassName</code></td><td>类的名称数组，类必须从<code>Throwable</code>派生</td><td>可选异常类名称数组，必须不造成回滚</td></tr></table><br>目前，你无法明确的掌控事务的名称，如果适用，其中<code>name</code>表示将在事务监视器中显示的事务名称，以及日志记录输出。对于声明式事务，事务名总是全量类名+“.”+事务的advised类的方法名。例如，如果<code>BusinessService</code>类的<code>handlePayment(...)</code>方法开始一个事务，事务名称将会是<code>com.foo.BusinessService.handlePayment</code>。</p><h4 id="使用-Transactional的多个事务管理"><a href="#使用-Transactional的多个事务管理" class="headerlink" title="使用@Transactional的多个事务管理"></a>使用@Transactional的多个事务管理</h4><p>大多数Spring应用仅仅需要单个事务管理，但是可能也会有在单个应用中你想多个独立事务管理的情况。<code>@Transactional</code>注解的属性值可以被用来选择性指定要使用的<code>PlatformTransactionManager</code>。这可以是bean的名称或者事务管理bean的值。例如，如下Java代码使用的限定符值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TransactionalService&#123;</span><br><span class="line"></span><br><span class="line">    @Transactional(&quot;order&quot;)</span><br><span class="line">    public void setSomething(String name)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    @Transactional(&quot;account&quot;)</span><br><span class="line">    public void doSomething()&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在应用上下文中和如下的事务管理bean声明组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tx:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;transactionManager1&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value=&quot;order&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;transactionManager2&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value=&quot;account&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>TransactionalService</code>的两个方法将在单独事务管理器下运行，通过“order”和“account”区分。如果没有找到指定限定符的<code>PlatformTransactionManager</code>的bean，将一直使用<code>&lt;tx:annotation-driven&gt;</code>默认的目标bean名称<code>transactionManager</code>。</p><h4 id="自定义快捷方式注解"><a href="#自定义快捷方式注解" class="headerlink" title="自定义快捷方式注解"></a>自定义快捷方式注解</h4><p>如果你发现你在许多不同方法上重复使用<code>@Transactional</code>的相同属性值，[Spring’s meta-annotaion support]允许你在你的指定使用情况下定义自定义快捷方式的注解。例如，如下注解的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;order&quot;)</span><br><span class="line">public @interface OrderTx &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;account&quot;)</span><br><span class="line">public @interface AccountTx &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许我们将上一小节的例子写为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TransactionalService&#123;</span><br><span class="line">    </span><br><span class="line">    @OrderTx</span><br><span class="line">    public void setSomething(String name)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    @AccountTx</span><br><span class="line">    public void doSomething()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了定义事务管理器的限定符语法，但是我们也可以包含传播特性行为，回滚规则，超时等等。</p><h3 id="1-5-7-事务传播特性"><a href="#1-5-7-事务传播特性" class="headerlink" title="1.5.7 事务传播特性"></a>1.5.7 事务传播特性</h3><p>这个章节描述在Spring中的事务传统特性的一些语义。请注意这个章节不是适当的一个事务传播特性介绍；二是详细描述在Spring中关于事务传播特性的一些语义。</p><p>在Spring管理的事务中，注意物理和逻辑事务的区别，和事务传播特性设置如何应用此差异。<br><img src="media/15534834588483.jpg" alt=""></p><p><code>PROPAGATION_REQUIRES_NEW</code>，与<code>PROPAGATION_REQUIRED</code>相比，为每一个事务作用域使用一个独立的事务。在那种情况下，底层的物理事务是不同的，因此可以独立的提交或者回滚，外部事务不受内部事务回滚状态的影响。</p><h4 id="Nested"><a href="#Nested" class="headerlink" title="Nested"></a>Nested</h4><p><code>PROPAGATION_NESTED</code>使用具有多个保存点的单个物理事务，它可以回滚到该事务。一些局部是回滚允许内部事务域在它的作用域触发回滚，使用外部事务可以继续物理事务而不用管一些已经回滚的操作。这个设置常用来映射JDBC的保存点。因此仅仅和JDBC资源事务一起工作。查看Spring的<code>DataSourceTransactionManager</code>。</p><h3 id="1-5-8-Advising-事务操作"><a href="#1-5-8-Advising-事务操作" class="headerlink" title="1.5.8 Advising 事务操作"></a>1.5.8 Advising 事务操作</h3><p>假如你想同时执行事务和一些基础剖析advice。你怎样在<code>&lt;tx:annotaion-driven/&gt;</code>的上下文中实现这点？</p><p>当你调用<code>updateFoo(Foo)</code>方法，你想看到如下动作：</p><ul><li>配置的剖析切面启动</li><li>事务advice执行</li><li>advised对象上的方法执行</li><li>事务提交</li><li>剖析切面精确报告整个事务方法调用期间</li></ul><blockquote><p>这个章节不关心详细介绍AOP（除非AOP适用于事务）。有关以下AOP配置和AOP的详细介绍，请参见<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10,Aspect Oriented Programming with Spring</a>。</p></blockquote><p>这是上面讨论简单剖析切面的代码。advice的排序由<code>Ordered</code>接口控制。了解advice 排序的全部详细内容，查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">the section called “Advice ordering”</a>..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package x.y;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.springframework.util.StopWatch;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line"></span><br><span class="line">public class SimpleProfiler implements Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private int order;</span><br><span class="line"></span><br><span class="line">    // allows us to control the ordering of advice</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return this.order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrder(int order) &#123;</span><br><span class="line">        this.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this method is the around advice</span><br><span class="line">    public Object profile(ProceedingJoinPoint call) throws Throwable &#123;</span><br><span class="line">        Object returnValue;</span><br><span class="line">        StopWatch clock = new StopWatch(getClass().getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            clock.start(call.toShortString());</span><br><span class="line">            returnValue = call.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            clock.stop();</span><br><span class="line">            System.out.println(clock.prettyPrint());</span><br><span class="line">        &#125;</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the aspect --&gt;</span><br><span class="line">    &lt;bean id=&quot;profiler&quot; class=&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        &lt;property name=&quot;order&quot; __value=&quot;1&quot;__/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; __order=&quot;200&quot;__/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">            &lt;!-- this advice will execute around the transactional advice --&gt;</span><br><span class="line">            &lt;aop:aspect id=&quot;profilingAspect&quot; ref=&quot;profiler&quot;&gt;</span><br><span class="line">                &lt;aop:pointcut id=&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                        expression=&quot;execution(!void x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">                &lt;aop:around method=&quot;profile&quot; pointcut-ref=&quot;serviceMethodWithReturnValue&quot;/&gt;</span><br><span class="line">            &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;scott&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;tiger&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>上述配置的结果是一个fooService bean，它具有按所需顺序应用于它的分析和事务切面。你可以以类似的方式配置任意数量的其他切面。</p><p>以下示例实现与上述相同的配置，但是使用纯粹的XML声明式途径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the profiling advice --&gt;</span><br><span class="line">    &lt;bean id=&quot;profiler&quot; class=&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        __&lt;property name=&quot;order&quot; value=&quot;1__&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;entryPointMethod&quot; expression=&quot;execution(* x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">        &lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;entryPointMethod&quot; __order=&quot;2__&quot;/&gt;</span><br><span class="line">        &lt;!-- order value is higher than the profiling aspect --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:aspect id=&quot;profilingAspect&quot; ref=&quot;profiler&quot;&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                    expression=&quot;execution(!void x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">            &lt;aop:around method=&quot;profile&quot; pointcut-ref=&quot;serviceMethodWithReturnValue&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions such as a DataSource and a PlatformTransactionManager here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>以上配置的结果是一个<code>fooService</code>bean，它具有适用于它的所需排序的剖析和事务切面。如果你想要在事务advice在进入之后，事务advice出去之前，执行的剖析advice，你只需简单的更换剖析切面bean的order属性值，使得它比事务advice的顺序值更高。</p><p>你使用类似的方式配置其他的切面。</p><h3 id="1-5-9-使用带有切面的-Transactional"><a href="#1-5-9-使用带有切面的-Transactional" class="headerlink" title="1.5.9 使用带有切面的@Transactional"></a>1.5.9 使用带有切面的@Transactional</h3><p>在一个Spring容器之外，通过AspectJ切面，也可能使用Spring框架的<code>@Transactional</code>的支持。如果这样做，你首先使用<code>@Transactional</code>注解你的类（和可选择的你的类方法），然后你使用定义在<code>spring-aspects.jar</code>的<code>org.springframework.transaction.aspectj.AnnotationTransactionAspect</code>连接（织入）你的应用。还必须使用事务管理器配置你的切面。你当然可以使用Spring框架的IoC容器去管理依赖注入切面。配置事务管理器切面的最简单方式是使用<code>&lt;tx:annotation-driven/&gt;</code>元素和给<code>aspectj</code>指定<code>mode</code>属性，正如在<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-annotations" target="_blank" rel="noopener">Section 16.5.6 Using @Transactional</a>。因为我们关注在一个Spring容器之外程序的运行，我们将会向你展示如何以编程的方式实现它。</p><blockquote><p> 在继续之前，你可能想要分别去读<a href="">Section 16.5.6 Using @Transactional</a>和<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring</a>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// construct an appropriate transaction manager</span><br><span class="line">DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());</span><br><span class="line"></span><br><span class="line">// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods</span><br><span class="line">AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);</span><br></pre></td></tr></table></figure><blockquote><p>当使用切面，你必须注解实现类（和/或 类里的方法），不是类实现的接口。<br>AspectJ 遵守Java的规则，不继承接口上的注解。</p></blockquote><p>在类上的<code>@Transactional</code>注解给在类里的任何方法的执行指定默认事务语义。<br>在在类里的方法上的<code>@Transactional</code>注解覆盖类提供注解（如果存在）的默认事务语义。不管是否可见，任何的方法可能被注解。</p><p>使用<code>AnnotationTransactionAspect</code>织入你的应用，你要么使用AspectJ（<a href="https://www.eclipse.org/aspectj/doc/released/devguide/index.html" target="_blank" rel="noopener">AspectJ Development Guide</a>）构建你的应用，要么使用加载时织入。使用AspectJ加载时织入的讨论请看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-aj-ltw" target="_blank" rel="noopener">Load-time weaving with AspectJ in the Spring Framework</a></p><h2 id="1-6-编程事务管理"><a href="#1-6-编程事务管理" class="headerlink" title="1.6 编程事务管理"></a>1.6 编程事务管理</h2><p>Spring框架提供两种编程事务管理工具：</p><ul><li>使用<code>TransactionTemplate</code>。</li><li>直接使用<code>PlatformTransactionManager</code>实现。</li></ul><p>对于编程式事务管理Spring团队通常建议使用<code>TransactionTemplate</code>。第二种相似途径是使用JTA<code>UserTransaction</code>API，虽然异常处理不是那么笨重。</p><h3 id="1-6-1-使用TransactionTemplate"><a href="#1-6-1-使用TransactionTemplate" class="headerlink" title="1.6.1 使用TransactionTemplate"></a>1.6.1 使用TransactionTemplate</h3><p><code>TransactionTemplate</code> 采用与其他Spring模版（例如<code>JdbcTemplate</code>）一样的方式。它使用一个回调的方法，使应用代码不必执行样板获取和释放事务资源，并产生驱动程序的代码，以便于被编写的代码仅关注开发人员想要做的事情。</p><blockquote><p>正如你将在如下的例子中看到的，使用<code>TransactionTemplate</code>绝对将你和Spring的事务基础架构和API结合在一起。</p></blockquote><p>应用代码必须在事务上下文中执行，明确的使用<code>TransactionTemplate</code>，看起来和如下的相似。你作为一个应用开发者，写一个<code>TransactionCallback</code>实现（通常表现为一个匿名内部类），这个实现包含在一个事务上下文中执行的代码。然后将自定义<code>TransactionCallback</code>的实例，传递给<code>TransactionTemplate</code>上公开的<code>execute(...)</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    // single TransactionTemplate shared amongst all methods in this instance</span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    // use constructor-injection to supply the PlatformTransactionManager</span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        Assert.notNull(transactionManager, &quot;The &apos;transactionManager&apos; argument must not be null.&quot;);</span><br><span class="line">        this.transactionTemplate = new TransactionTemplate(transactionManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object someServiceMethod() &#123;</span><br><span class="line">        return transactionTemplate.execute(new TransactionCallback() &#123;</span><br><span class="line">            // the code in this method executes in a transactional context</span><br><span class="line">            public Object doInTransaction(TransactionStatus status) &#123;</span><br><span class="line">                updateOperation1();</span><br><span class="line">                return resultOfUpdateOperation2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有返回值，方便的使用<code>TransactionCallbackWithoutResult</code>类和一个匿名内部类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        updateOperation1();</span><br><span class="line">        updateOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在回调中的代码可以通过提供的<code>TransactionStatus</code>对象上调用<code>setRollbackOnly()</code>方法回滚这个事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line"></span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            updateOperation1();</span><br><span class="line">            updateOperation2();</span><br><span class="line">        &#125; catch (SomeBusinessExeption ex) &#123;</span><br><span class="line">            status.setRollbackOnly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="指定事务设置"><a href="#指定事务设置" class="headerlink" title="指定事务设置"></a>指定事务设置</h4><p>你可以以编程方式或配置方式在TransactionTemplate上指定例如传播特性模式，隔离等级，超时等等的事务设置。默认的<code>TransactionTemplate</code>实例有<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-txadvice-settings" target="_blank" rel="noopener">默认事务设置</a>。如下的例子展示对于一个指定<code>TransactionTemplate</code>事务设置的编程式定制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        Assert.notNull(transactionManager, &quot;The &apos;transactionManager&apos; argument must not be null.&quot;);</span><br><span class="line">        this.transactionTemplate = new TransactionTemplate(transactionManager);</span><br><span class="line"></span><br><span class="line">        // the transaction settings can be set here explicitly if so desired</span><br><span class="line">        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);</span><br><span class="line">        this.transactionTemplate.setTimeout(30); // 30 seconds</span><br><span class="line">        // and so forth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下的例子定义了一个使用一些自定义事务设置的<code>TransactionTemplate</code>，使用Spring XML配置。然后可以将<code>sharedTransactionTemplate</code>注入到尽可能多的需要的服务中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sharedTransactionTemplate&quot;</span><br><span class="line">        class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;isolationLevelName&quot; value=&quot;ISOLATION_READ_UNCOMMITTED&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;timeout&quot; value=&quot;30&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>最后，<code>TransactionTemplate</code>类的实例是线程安全的，因为实力不保持任何会话状态。但是，<code>TransactionTemplate</code>实例会保持配置状态，因此当许多类可能共享一个<code>TransactionTemplate</code>的一个单例时，如果一个类需要使用一个带有不同设置（例如，不同隔离等级）的<code>TransactionTemplate</code>，你就需要去创建一个两个不同的<code>TransactionTemplate</code>实例。</p><h3 id="1-6-2-使用PlatformTransactionManager"><a href="#1-6-2-使用PlatformTransactionManager" class="headerlink" title="1.6.2 使用PlatformTransactionManager"></a>1.6.2 使用PlatformTransactionManager</h3><p>你也可以直接使用<code>org.springframework.transaction.PlatformTransactionManager</code>管理你的事务。简单的通过一个bean引用传递你正在用的<code>PlatformTransactionManager</code>的实现给你的bean。然后，使用<code>TransactionDefinition</code>和<code>TransactionStatus</code>对象你可以发起，回滚和提交事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultTransactionDefinition def = new DefaultTransactionDefinition();</span><br><span class="line">// explicitly setting the transaction name is something that can only be done programmatically</span><br><span class="line">def.setName(&quot;SomeTxName&quot;);</span><br><span class="line">def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">TransactionStatus status = txManager.getTransaction(def);</span><br><span class="line">try &#123;</span><br><span class="line">    // execute your business logic here</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex) &#123;</span><br><span class="line">    txManager.rollback(status);</span><br><span class="line">    throw ex;</span><br><span class="line">&#125;</span><br><span class="line">txManager.commit(status);</span><br></pre></td></tr></table></figure><h2 id="1-7-编程式和声明式事务管理器的选择"><a href="#1-7-编程式和声明式事务管理器的选择" class="headerlink" title="1.7 编程式和声明式事务管理器的选择"></a>1.7 编程式和声明式事务管理器的选择</h2><p>编程式事务管理仅仅在你如果有一个小数量的事务操作情况下才是一个好想法。例如，如果你有一个web应用需要仅仅主要是update操作的事务，你不可能想去使用Spring或者其他任何技术去设置事务代理。在这种情况下，使用<code>transactionTemplate</code>可能是一个好方法。可能明确的设置事务名称可以仅在使用编程式途径进行事务管理的情况下去做。</p><p>从另一方面，如果你的应用有很多事务操作，声明式事务管理通常是合算的。它保持事务管理摆脱业务逻辑，配置不困难。当使用Spring框架，而不是EJB CMT时，声明式事务配置的成本将大大降低。</p><h2 id="1-8-事务约束事件"><a href="#1-8-事务约束事件" class="headerlink" title="1.8 事务约束事件"></a>1.8 事务约束事件</h2><p>作为Spring 4.2，一个事件的监听可以被约束为事务的一个阶段。常用的例子是当事务已经成功的完成时去处理事件：当当前事务的结果对于监听器实际上很重要时，这允许事件被更灵活地使用。<br>注册一个常规的监听事件可以通过<code>@EventListener</code>注解。如果你需要和事务绑定它使用<code>@TransactionEventListener</code>。当你这样做时，监听器将默认约束事务提交阶段。<br>我们举个例子说明这个概念。</p><p>假设一个组件发布了一个订单创建的事件，我们想要定义一个监听器，该监听器只应该在事件成功提交时才处理该事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyComponent &#123;</span><br><span class="line"></span><br><span class="line">    @TransactionalEventListener</span><br><span class="line">    public void handleOrderCreatedEvent(CreationEvent&lt;Order&gt; creationEvent) &#123;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>TransactionalEventListener</code>注解暴露一个<code>phase</code>属性，这个属性允许自定义监听器应该约束事务的哪个phase。这个有效的phases是<code>BEFORE_COMMIT</code>，<code>AFTER_COMMIT</code>(default)，<code>AFTER_ROLLBACK</code>和<code>AFTER_COMPLETION</code>，它们聚合事务的完整性（是一个提交或者一个回滚）。</p><p>如果没有正在运行的事务，由于我们无法遵守所需的语义，监听器根本不会被调用。但是，它可能通过设置注解的<code>fallbackExecution</code>属性为true去覆盖该行为。</p><h2 id="1-9-指定应用服务器的集成"><a href="#1-9-指定应用服务器的集成" class="headerlink" title="1.9 指定应用服务器的集成"></a>1.9 指定应用服务器的集成</h2><p>Spring的事务抽象通常是应用服务器不可知。此外，Spring的<code>JtaTransactionManager</code>类，可以可选执行对于JTA<code>UserTransaction</code>和<code>TransactionManager</code>对象的JNDI查找，对于后者对象，自动检查地址，该地址因应用服务器而变化。访问JTA TransactionManager允许增强的事务语义，特别是支持事务暂停。了解详细请查看<code>JtaTransactionManager</code>javadocs。</p><p>Spring的<code>JtaTransactionManager</code>在Java EE应用服务器上运行的标准选择，并已知可以在所有常用的服务器上运行。高级功能（事务暂停）在很多服务器上运行很好，包括GlassFish，JBoss和Geronimo，不需要任何特殊配置。但是，对于完整的支持事务暂停和进一步的高级集成，Spring ship对于WebLogic服务器和WebSphere特殊适配。这些适配在如下章节讨论。</p><p>对于标准场景，包括Weblogic Server和WebSphere，考虑使用定制<code>&lt;tx:jta-trasaction-manager/&gt;</code>配置元素。当已配置时，这元素自动检查底层服务器和选择适用于该平台的最好的事务管理器。这意味着你将不需要必须显式的配置指定服务器适配类（在如下章节讨论）；相反，它们是自动选择的，标准的<code>JtaTransactionManager</code>是默认的后备。</p><h3 id="1-9-1-IBM-WebSphere"><a href="#1-9-1-IBM-WebSphere" class="headerlink" title="1.9.1 IBM WebSphere"></a>1.9.1 IBM WebSphere</h3><p>在WebSphere6.1.0.9及以上版本，建议Spring JTA事务管理器使用<code>WebSphereUowTransactionManager</code>。这个特殊的适配器利用了IBM’s <code>UOWManager</code> API，在WebSphere应用服务器6.0.2.19和以后版本，6.1.0.9和以后版本是适用的。使用这个适配器，驱动Spring事务暂停（暂停/恢复 由<code>PROPAGATION_REQUIRES_NEW</code>发起）是由IBM官方支持的。</p><h3 id="1-9-2-Oracle-WebLogic-Server"><a href="#1-9-2-Oracle-WebLogic-Server" class="headerlink" title="1.9.2 Oracle WebLogic Server"></a>1.9.2 Oracle WebLogic Server</h3><p>在Weblogic Server及以后版本中，你通常将使用<code>WebLogicJtaTransactionManager</code>而不是存<code>JtaTransactionManager</code>类。普通<code>JtaTransactionManager</code>的这个特殊的Weblogic特定的子类在Weblogic管理的事务环境中支持Spring的事务全部功能，超出标准的JTA语义：特性包括事务名称，每个事务的隔离等级，以及在所有的情况下正确的恢复事务。</p><h2 id="1-10-常见问题解决"><a href="#1-10-常见问题解决" class="headerlink" title="1.10 常见问题解决"></a>1.10 常见问题解决</h2><h3 id="1-10-1-对于特定数据源错误的事务管理器的使用"><a href="#1-10-1-对于特定数据源错误的事务管理器的使用" class="headerlink" title="1.10.1 对于特定数据源错误的事务管理器的使用"></a>1.10.1 对于特定数据源错误的事务管理器的使用</h3><p>正确的使用<code>PlatformTransactionManager</code>实现基于你事务技术和需求的选择。正确的使用，Spring框架仅提供一个简单直接和轻便的抽象。如果你正在使用全局事务，你必须使用<code>org.springframework.transaction.jta.JtaTransactionManager</code>类（或者一个指定的应用服务器子类）进行你所有的事务操作。否则事务基础设施在资源（例如容器的<code>DataSource</code>实例）上尝试使用本地事务。这样的本地事务没有意义，一个好的应用服务器把它们当作错误。</p><h2 id="1-11-集成资源"><a href="#1-11-集成资源" class="headerlink" title="1.11 集成资源"></a>1.11 集成资源</h2><p>了解更多关于Spring框架的事务支持信息：</p><ul><li><a href="http://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html" target="_blank" rel="noopener">Distributed transaction in Spring，with and without XA</a>是一个JavaWorld演示文稿，其中Spring的David Syer引导您在Spring应用程序中通过分布式事务的七种模式，其中三种模式使用XA，另外四种没有。</li><li><a href="http://www.infoq.com/minibooks/JTDS" target="_blank" rel="noopener">Java 事务设计策略</a>是一本从<a href="http://www.infoq.com/" target="_blank" rel="noopener">InfoQ</a>得到的书，InfoQ提供一个Java事务快速介绍。它还包括如何使用Spring Framework和EJB3配置和使用事务的并排示例。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中的锁</title>
      <link href="/concurrency/2018-12-17-java-lock/"/>
      <url>/concurrency/2018-12-17-java-lock/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁可以防止多个线程同时访问共享资源。在JDK1.5之前，Java靠synchronized关键字实现锁功能。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">Java并发编程的艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多线程通信</title>
      <link href="/concurrency/2018-12-06-thread-communication/"/>
      <url>/concurrency/2018-12-06-thread-communication/</url>
      
        <content type="html"><![CDATA[<h2 id="1-共享变量的可见性"><a href="#1-共享变量的可见性" class="headerlink" title="1. 共享变量的可见性"></a>1. 共享变量的可见性</h2><p>线程通信主要是通过对共享变量的读写来进行的，一般共享变量，我们会采用使共享变量不可变或者在任何访问状态变量的时候使用同步两种措施进行变量共享。</p><h2 id="2-使用锁同步共享变量状态"><a href="#2-使用锁同步共享变量状态" class="headerlink" title="2. 使用锁同步共享变量状态"></a>2. 使用锁同步共享变量状态</h2><h3 id="2-1-synchronized（内置锁）"><a href="#2-1-synchronized（内置锁）" class="headerlink" title="2.1 synchronized（内置锁）"></a>2.1 synchronized（内置锁）</h3><p>synchronized我们知道常常用来临界区互斥执行，但是除此之外，它还有最重要的功能：锁的内存语义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MonitorExample&#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    public synchronized void writer()&#123;// 1</span><br><span class="line">        a++; // 2</span><br><span class="line">    &#125; // 3</span><br><span class="line">    public synchronized void reader()&#123; // 4</span><br><span class="line">        int i=a; // 5</span><br><span class="line">    &#125; // 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A<strong>先</strong>执行writer()方法，<strong>随后</strong>线程B执行reader()方法。根据JMM的happens-before规则，这段代码包含的happens-before关系可以分为3类。</p><p>1）根据程序次序规则，1 happens-before2, 2 happens-before 3; 4 happens-before 5, 5 happens-before 6。</p><p>2) 根据监视器锁规则，3 happens-before 4。<br>3) 根据happens-before的传递性，2 happens-before 5。</p><p><strong>注：</strong>happens-before规则保证了线程A执行后的结果对B可见，但是线程A的代码不一定在线程B之前执行。上面A与B线程是有先后顺序的，主要是为了方便解释锁的内存语义。 </p><p><img src="/media/article/happens-before-relation.jpg" alt="happens-beofre"><br>图片来自<a href="">Java并发编程艺术图3-24</a></p><p>锁释放和锁获取的内存语义：</p><p><strong>线程A释放一个锁，实质上是线程A向接下来将要获取的这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</strong></p><p><strong>线程B释放一个锁，实质上是线程B接收了之前某个线程发出的（释放这个锁之前对共享变量所做的修改的）消息。</strong></p><p><strong>线程A释放锁，线程B获取锁，这个过程实质上是线程A通过主内存向线程B发送消息。</strong></p><p><img src="/media/article/lock-acquire-state.png" alt="lock-acquire-state"><br>图片来自<a href="">Java并发编程艺术图3-26</a></p><h3 id="2-2-ReentrantLock"><a href="#2-2-ReentrantLock" class="headerlink" title="2.2 ReentrantLock"></a>2.2 ReentrantLock</h3><h2 id="3-使用同步原语"><a href="#3-使用同步原语" class="headerlink" title="3. 使用同步原语"></a>3. 使用同步原语</h2><h3 id="3-1-volatile"><a href="#3-1-volatile" class="headerlink" title="3.1 volatile"></a>3.1 volatile</h3><p>volatile我们熟知的特性是：</p><p>1.可见性</p><p>对一个volatile变量的读，总能看到任意线程对这个volatile变量最后的写入。</p><p>2.有序性</p><p>如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀。lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p><h3 id="3-2-final"><a href="#3-2-final" class="headerlink" title="3.2 final"></a>3.2 final</h3><h2 id="4-其他方式的线程消息通信"><a href="#4-其他方式的线程消息通信" class="headerlink" title="4. 其他方式的线程消息通信"></a>4. 其他方式的线程消息通信</h2><h2 id="4-1-等待通知-wait-notify"><a href="#4-1-等待通知-wait-notify" class="headerlink" title="4.1 等待通知(wait/notify)"></a>4.1 等待通知(wait/notify)</h2><h2 id="4-2-管道通信"><a href="#4-2-管道通信" class="headerlink" title="4.2 管道通信"></a>4.2 管道通信</h2><h2 id="4-3-Thread-join"><a href="#4-3-Thread-join" class="headerlink" title="4.3 Thread.join()"></a>4.3 Thread.join()</h2><h2 id="4-4-ThreadLocal"><a href="#4-4-ThreadLocal" class="headerlink" title="4.4 ThreadLocal"></a>4.4 ThreadLocal</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="">Java并发编程实践</a><br><a href="">Java并发编程艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程安全</title>
      <link href="/concurrency/2018-12-06-thread-security/"/>
      <url>/concurrency/2018-12-06-thread-security/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全-读书笔记"><a href="#线程安全-读书笔记" class="headerlink" title="线程安全-读书笔记"></a>线程安全-读<a href="#引用">书</a>笔记</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>线程安全定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调动作，调用这个对象的行为都可以获得正确的结果，那这个<strong>对象就是线程安全的</strong>。摘至<a href="https://github.com/zhongyp/mybook/blob/master/java/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5.pdf" target="_blank" rel="noopener">《Java并发编程实践》</a><br>编写的线程安全的代码，本质上就是管理对状态（state）的访问，而且通常都是共享的、可变的状态。共享指一个变量可以被多个线程访问；可变变量的值在生命周期内可以改变。<br>无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。<br>保证对象线程安全的三种措施：</p><ul><li>不跨线程共享变量</li><li>使状态变量不可变</li><li>在任何访问状态变量的时候使用同步</li></ul><h2 id="2-Java线程安全"><a href="#2-Java线程安全" class="headerlink" title="2. Java线程安全"></a>2. Java线程安全</h2><h3 id="2-1-线程安全强弱等级"><a href="#2-1-线程安全强弱等级" class="headerlink" title="2.1 线程安全强弱等级"></a>2.1 线程安全强弱等级</h3><p>Java语言中操作各种共享的数据可根据安全程度分为以下5类：</p><h4 id="2-1-1-不可变"><a href="#2-1-1-不可变" class="headerlink" title="2.1.1 不可变"></a>2.1.1 不可变</h4><p>在Java线程里面，不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何的线程安全保障措施。</p><p>Java语言中，如果共享数据是一个基本数据类型，只要在定义时使用final关键字修饰它就可以保证它是不可变的；如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。只要一个不可变的对象被正确构建出来（没有发生<a href="https://www.cnblogs.com/straybirds/p/8640748.html" target="_blank" rel="noopener">this引用逃逸</a>的情况），那么其外部的可见状态也不会改变。保证对象的行为不影响自己状态的途径有很多种，最简单的就是把对象中带有状态的变量都声明为final。</p><h4 id="2-1-2-绝对线程安全"><a href="#2-1-2-绝对线程安全" class="headerlink" title="2.1.2 绝对线程安全"></a>2.1.2 绝对线程安全</h4><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p><h4 id="2-1-3-相对线程安全"><a href="#2-1-3-相对线程安全" class="headerlink" title="2.1.3 相对线程安全"></a>2.1.3 相对线程安全</h4><p>对象单独的操作时线程安全的，我们在调用的时候不需要做额外的保障措施，对于特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。例如：Vector、ConcurrentHashMap等。</p><h4 id="2-1-4-线程兼容"><a href="#2-1-4-线程兼容" class="headerlink" title="2.1.4 线程兼容"></a>2.1.4 线程兼容</h4><p>线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中安全地使用。例如：HashMap等。</p><h4 id="2-1-5-线程对立"><a href="#2-1-5-线程对立" class="headerlink" title="2.1.5 线程对立"></a>2.1.5 线程对立</h4><p>线程对立指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。例如：Thread类中的suspend(),resume()方法。</p><h3 id="2-2-Java线程安全实现"><a href="#2-2-Java线程安全实现" class="headerlink" title="2.2 Java线程安全实现"></a>2.2 Java线程安全实现</h3><h4 id="2-2-1-互斥同步"><a href="#2-2-1-互斥同步" class="headerlink" title="2.2.1 互斥同步"></a>2.2.1 互斥同步</h4><p>互斥同步(Mutual Exclusion &amp; Synchronization)是最常见的一种并发正确性保障手段，同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。是一种悲观的并发策略，无论是否并发都需要加锁。<br>手段：synchronized、ReentrantLock。<br>缺点：线程阻塞和唤醒带来的性能问题，因此互斥同步也称为阻塞同步(Blocking Synchronization)。</p><h4 id="2-2-2-非阻塞同步"><a href="#2-2-2-非阻塞同步" class="headerlink" title="2.2.2 非阻塞同步"></a>2.2.2 非阻塞同步</h4><p>非阻塞同步(Non-Blocking Synchronization)是基于冲突检测的乐观并发策略，通俗的讲就是先进行操作，如果没有其他线程争用共享数据，则操作成功，否则产生冲突，然后进行补偿措施（最常见的就是不断的重试，知道试成功为止）。<br>要求：硬件指令集的发展，需要操作和检测两个步骤具备原子性。<br>常见指令：测试并设置(Test-and-Set)、获取并增加(Fetch-and-Increment)、交换(Swap)、比较并交换(Compare-and-Swap,CAS)、加载链接/条件存储(Load-linked/Store-Conditional,LL/SC)。</p><h4 id="2-2-3-无同步方案"><a href="#2-2-3-无同步方案" class="headerlink" title="2.2.3 无同步方案"></a>2.2.3 无同步方案</h4><p>要保证线程同步，不一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时正确性的手段，如果有些代码不涉及共享数据，自然无需同步保证共享数据争用时的正确性。</p><ul><li>可重入代码（Reentrant Code）：这种代码也叫纯代码（Pure Code），可以在代码执行的任何时刻中断它，转去执行另外一段代码，而控制权回来后继续执行代码，程序不会出现任何错误。</li><li>线程本地存储（Thread Local Storage）：如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，无需同步也能实现线程之间不出现数据争用的问题。</li></ul><h2 id="3-Java锁优化"><a href="#3-Java锁优化" class="headerlink" title="3. Java锁优化"></a>3. Java锁优化</h2><p>为了在线程之间更高效地共享数据，以及解决数据竞争问题，JDK实现了各种锁的优化技术，如适应性自旋(Adaptive Spinning)、锁消除(Lock Elimination)、锁粗化(Lock Coarsening)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)等。</p><h4 id="3-1-自旋锁与自适应性自旋"><a href="#3-1-自旋锁与自适应性自旋" class="headerlink" title="3.1 自旋锁与自适应性自旋"></a>3.1 自旋锁与自适应性自旋</h4><p>互斥同步对性能最大的影响是阻塞的实现，挂起和恢复线程的操作都需要转入内核态完成，这些操作给并发性能带来很大的压力。如果获取共享数据锁时仅需要等待很短的时间，为了很短的时间去挂起和恢复线程并不值得。如果处理器有一个以上的处理器，我们可以线程让请求锁的线程忙循环，不放弃处理器的执行时间，这项技术就是所谓的自旋锁。<br>自适应自旋锁意味着自旋的时间不再固定，根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><h4 id="3-2-锁消除"><a href="#3-2-锁消除" class="headerlink" title="3.2 锁消除"></a>3.2 锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为是线程私有的，同步加锁自然无需执行。</p><h4 id="3-3-锁粗化"><a href="#3-3-锁粗化" class="headerlink" title="3.3 锁粗化"></a>3.3 锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体中。如果虚拟机探测到有这样一串零碎的操作都对一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只加锁一次就可以。</p><h4 id="3-4-轻量级锁"><a href="#3-4-轻量级锁" class="headerlink" title="3.4 轻量级锁"></a>3.4 轻量级锁</h4><p>轻量级锁是JDK1.6 中加入的新型锁机制，轻量级是相对于使用操作系统互斥量来实现传统锁而言，因此传统锁机制被称为重量级锁。轻量级锁本意指在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>HotSpot虚拟机的对象头(Object Header)分为两部分，第一用于存储自身的运行时数据，这部分数据的长度在32位和64位的虚拟机分别是32个和64个bits，官网称它为”Mark Word”。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还有一个额外的部分用于存储数组长度。<br><img src="/media/article/object-header.png" alt="mark word"><br>表摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，根据对象的状态复用自己的存储空间。<br>HotSpot 虚拟机对象头Mark Word不同状态下存储内容表：<br><img src="/media/article/markword.png" alt="mark word"><br>表摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>上表中存储内容列是Mark Word中除标志位外，其他的30bit空间的存储内容，状态列是指不同的锁状态，如：轻量级锁，重量级锁等等。具体内容存储占位如下图所示<br><img src="/media/article/markword-status.png" alt="mark word status"><br>表摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>轻量级锁的执行过程：在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word拷贝，如图：<br><img src="/media/article/markword-cas-before.png" alt="markword-cas-before"><br>图摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新成功了，那么该线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转为“00”，即表示该对象处于轻量级锁定状态。<br><img src="/media/article/markword-cas-after.png" alt="markword-cas-after"><br>图摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>如果更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了该对象的锁，可直接进入同步代码块继续执行，否则说明这个锁对象被其他线程抢占了。如果有两条以上（包括两条）的线程争用同一个锁，轻量级锁不再有效要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁的指针，后面等待的线程也要进入阻塞状态。<br>轻量级锁初始化及膨胀流程图：<br><img src="/media/article/lightweight-expand.png" alt="lightweight"><br>图摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍指向线程的锁记录，就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，同步完成。替换失败，有其他线程尝试获取该锁，此时锁已经膨胀，就要在释放锁的同时，唤醒被挂起的线程。</p><h4 id="3-5-偏向锁"><a href="#3-5-偏向锁" class="headerlink" title="3.5 偏向锁"></a>3.5 偏向锁</h4><p>偏向锁目的是消除数据在无竞争情况下的同步原语。<br>使用场景：锁不仅不存在多线程竞争，而且总是由同一线程多次获得。<br>偏向锁原理：当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”（Mark Word见3.4小节的表中），即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步时，虚拟机都可以不再进行任何同步操作，只需简单测试对象头的Mark Word是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁。如果测试失败，则需要在测试一下Mark Word中偏向锁的标识是否设置成”01”：如果没有设置，则使用CAS竞争锁，如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，继续执行同步块；如果竞争失败，则进行偏向锁撤销。如果设置了则尝试使用CAS将对象头的偏向锁指向当前线程。<br>偏向锁撤销（Revoke Bias）：当有另外一个线程尝试去获取这个锁时，偏向模式结束。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置成无锁状态；如果线程还活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。<br>偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图：<br><img src="/media/article/markword-change.png" alt="markword-change"><br>图摘自<a href="#偏向锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>偏向锁初始化及膨胀流程图：<br><img src="/media/article/bias-expand.png" alt="bias-expand"><br>图摘自<a href="#偏向锁">Java并发编程艺术 2.2小节</a></p><h4 id="3-6-轻量级锁、偏向锁、重量级锁对比"><a href="#3-6-轻量级锁、偏向锁、重量级锁对比" class="headerlink" title="3.6 轻量级锁、偏向锁、重量级锁对比"></a>3.6 轻量级锁、偏向锁、重量级锁对比</h4><p>偏向锁初始化及膨胀流程图：<br><img src="/media/article/lock-advantage-disadvantage.png" alt="lock"><br>图摘自<a href="#轻量级锁、偏向锁、重量级锁对比">Java并发编程艺术 2.2小节</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与实践</a><br><a href="">Java并发编程实践</a><br><a href="">Java并发编程艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程启动与终止</title>
      <link href="/concurrency/2018-12-04-thread-start-end/"/>
      <url>/concurrency/2018-12-04-thread-start-end/</url>
      
        <content type="html"><![CDATA[<h3 id="1-构造线程"><a href="#1-构造线程" class="headerlink" title="1. 构造线程"></a>1. 构造线程</h3><h4 id="1-1-构造线程的方式"><a href="#1-1-构造线程的方式" class="headerlink" title="1.1 构造线程的方式"></a>1.1 构造线程的方式</h4><p>Java构造一个线程有两种方式：</p><p>一种是声明子类继承Thread父类并重写父类的run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeThread extends Thread &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeThread(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeThread p = new PrimeThread(143);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure></p><p>另一种方式是声明子类实现Runnable接口，并实现run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeRun implements Runnable &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeRun(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeRun p = new PrimeRun(143);</span><br><span class="line">new Thread(p).start();</span><br></pre></td></tr></table></figure></p><p>两者其实在本质上是一致的，因为Thread类也继承了Runable接口，所以都实现/重写Runable中的run方法。Java将线程的执行和执行对象抽象开来，JDK中执行的是Thread类，Executor框架，可执行目标有Runable，Callable。对于构造线程的方式第一种方式并不推荐，因为继承Thread类限定了其基本行为，在设计上违反多用组合 少用继承的原则，所以一般构造线程使用第二种方式，实现Runable接口。</p><h4 id="1-2-构造线程的属性"><a href="#1-2-构造线程的属性" class="headerlink" title="1.2 构造线程的属性"></a>1.2 构造线程的属性</h4><p>构造线程时需要提供线程所需要的属性。一个新的（child）线程对象是由parent线程进行空间分配的，而child线程继承了parent是否为Daemon、优先级、和加载资源的contextClassLoader以及可继承的ThreadLocal等属性，同时分配唯一的ID来表示这个child线程。如果创建线程实例后需要修改线程属性，则可以通过Thread提供的一些修改属性的方法进行修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setPriority() // 优先级</span><br><span class="line">getPriority()</span><br><span class="line">setName()。// 线程名</span><br><span class="line">getName()</span><br><span class="line">setDaemon() // 守护线程</span><br><span class="line">isDaemon()</span><br><span class="line">getContextClassLoader()。// 资源加载</span><br><span class="line">setContextClassLoader()</span><br><span class="line">getStackTrace() </span><br><span class="line">getAllStackTraces()</span><br><span class="line">checkAccess()</span><br><span class="line">isCCLOverridden()</span><br><span class="line">auditSubclass() </span><br><span class="line">dumpThreads()</span><br><span class="line">getThreads()</span><br><span class="line">getId()</span><br><span class="line">getState()</span><br><span class="line">setDefaultUncaughtExceptionHandler()</span><br><span class="line">getDefaultUncaughtExceptionHandler()</span><br><span class="line">getUncaughtExceptionHandler()</span><br><span class="line">setUncaughtExceptionHandler()</span><br><span class="line">dispatchUncaughtException()</span><br><span class="line">processQueue()</span><br></pre></td></tr></table></figure></p><p>当然构造线程时有些属性还可以在创建线程实例时就设置，如线程组，栈大小，栈名称，权限控制上下文，可继承的ThreadLocal，下面是JDK初始化一个线程实例时的代码，摘至<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK8</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @param g</span><br><span class="line"> * @param target</span><br><span class="line"> * @param name</span><br><span class="line"> * @param stackSize 线程的栈大小 根据参数传递过程可以看出默认大小为零，即使用默认的线程栈大小</span><br><span class="line"> * @param acc 访问控制权限</span><br><span class="line"> * @param inheritThreadLocals // 可继承的ThreadLocal</span><br><span class="line"> *</span><br><span class="line"> * ThreadGroup 线程组（ThreadGroup）就是由线程组成的管理线程的类，</span><br><span class="line"> *     这个类是java.lang.ThreadGroup类。</span><br><span class="line"> *     定义一个线程组，通过以下代码可以实现。</span><br><span class="line"> *     ThreadGroup group=new ThreadGroup(&quot;group&quot;);</span><br><span class="line"> *     Thread thread=new Thread(group,&quot;the first thread of group&quot;);</span><br><span class="line"> *     ThreadGroup类中的某些方法，可以对线程组中的线程产生作用。例如，setMaxPriority()方法可以设定线程组中的所有线程拥有最大的优先权。</span><br><span class="line"> */</span><br><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                  long stackSize, AccessControlContext acc,</span><br><span class="line">                  boolean inheritThreadLocals) &#123;</span><br><span class="line">    if (name == null) &#123;// 线程名，可相同</span><br><span class="line">        throw new NullPointerException(&quot;name cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();// 获取当前线程，并作为父线程。</span><br><span class="line">    SecurityManager security = System.getSecurityManager();// 获取安全策略</span><br><span class="line">    if (g == null) &#123;</span><br><span class="line">        /* Determine if it&apos;s an applet or not */</span><br><span class="line"></span><br><span class="line">        /* If there is a security manager, ask the security manager</span><br><span class="line">           what to do. */</span><br><span class="line">        if (security != null) &#123;//如果存在安全管理器，则获取它重写的线程组</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If the security doesn&apos;t have a strong opinion of the matter</span><br><span class="line">           use the parent thread group. */</span><br><span class="line">        if (g == null) &#123;</span><br><span class="line">            g = parent.getThreadGroup();//使用父线程组</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* checkAccess regardless of whether or not threadgroup is</span><br><span class="line">       explicitly passed in. */</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Do we have the required permissions?</span><br><span class="line">     */</span><br><span class="line">    if (security != null) &#123;</span><br><span class="line">        if (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    this.group = g;</span><br><span class="line">    this.daemon = parent.isDaemon();//继承父线程的守护属性</span><br><span class="line">    this.priority = parent.getPriority();//继承父线程的优先级</span><br><span class="line">    //继承父线程加载资源的contextClassLoader</span><br><span class="line">    if (security == null || isCCLOverridden(parent.getClass()))</span><br><span class="line">        this.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    else</span><br><span class="line">        this.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    this.inheritedAccessControlContext =</span><br><span class="line">            acc != null ? acc : AccessController.getContext();</span><br><span class="line">    this.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    // 继承父线程可继承的ThreadLocal</span><br><span class="line">    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">        this.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    /* Stash the specified stack size in case the VM cares */</span><br><span class="line">    this.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    /* Set thread ID */</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-启动线程"><a href="#1-3-启动线程" class="headerlink" title="1.3 启动线程"></a>1.3 启动线程</h4><p>线程对象在初始化完成后，调用start方法就可以启动线程。<br><strong><em>注意：启动一个线程，最好为这个线程设置线程名称，这行有助于分析或者排查问题</em></strong></p><h3 id="2-中断线程"><a href="#2-中断线程" class="headerlink" title="2. 中断线程"></a>2. 中断线程</h3><h4 id="2-1-中断的原理"><a href="#2-1-中断的原理" class="headerlink" title="2.1 中断的原理"></a>2.1 中断的原理</h4><p>中断，可以理解为运行中的线程，是否被其他线程进行了中断操作。中断操作包含三个方法。interrupt(),interrupted(),isInterrupted()。下面我们将对这个方法进行详细了解。</p><h5 id="2-1-1-interrupt"><a href="#2-1-1-interrupt" class="headerlink" title="2.1.1 interrupt()"></a>2.1.1 interrupt()</h5><p>中断操作通过调用线程的interrupt()方法进行。例如线程A中断线程B，在线程A的代码中调用ThreadB.interrupt() 即可。</p><p>interrupt()方法不是直接将线程终止，而是针对于不同情况进行不同处理。</p><ol><li>除非终止的是当前线程（始终被允许），否则调用checkAccess方法，可能会导致抛出SecurityException异常。</li><li>如果调用Object类的wait(),wait(long)或者wait(long, int)等方法，或者调用此线程的join(),join(long),join(long, int), sleep(long), sleep(long, int)方法，<strong><em>此线程的中断状态将被清除，同时将抛出InterruptedException异常</em></strong>。</li><li>如果此线程在可中断通道的IO操作上，通道将被关闭，线程被设置中断状态，同时将抛出ClosedByInterruptException异常。</li><li>如果线程在选择器(Selector)阻塞，线程将被设置中断状态，立即从选择操作中返回，可能带有非零值，就像选择器唤醒方法被调用一样。</li><li>如果以上的条件都不满足，此线程将被设置中断状态。</li><li>中断不存活的线程不会有任何影响。</li></ol><p>翻译自<a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Java se7docs</a></p><p>注：Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。<br><strong><em>注意：</em></strong><br>对于会抛出异常的情况，异常一定要处理，一般子线程异常不能抛出非运行时异常，所以子线程我们需要抛出运行时异常，用于给父线程捕获。或者在catch块中使用 Thread.currentThread().interrupt() 重新抛出中断来保证调用栈的高层的代码知道当前线程的中断。</p><h5 id="2-1-2-interrupted"><a href="#2-1-2-interrupted" class="headerlink" title="2.1.2 interrupted()"></a>2.1.2 interrupted()</h5><p>interrupted()主要有以下两个功能：</p><ol><li>测试<strong><em>当前线程</em></strong>是否被中断,清除线程中断状态。换句话说就是，如果当前方法被成功调用两次，则返回false（除非当前线程在第一次调用此方法后第二次调用此方法前被再次中断）。</li><li>线程中断被忽略，在中断时线程处于不活动的状态将被此方法反映返回false。</li></ol><p>interrupted()不同于interrupt(),此方法用于测试当前线程是否被中断，并清除中断状态。代码示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread thread = new InterruptThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    SleepUtils.sleep(1);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">static class InterruptThread extends Thread&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       int count = 0;</span><br><span class="line">       while(true)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           if(Thread.currentThread().interrupted())&#123;//此处仅仅是为了示例</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-1-3-isInterrupted"><a href="#2-1-3-isInterrupted" class="headerlink" title="2.1.3 isInterrupted()"></a>2.1.3 isInterrupted()</h5><ol><li>isInterrupted虽然也是测试线程是否被中断，但是此方法不会更改线程的中断状态。</li><li>线程中断被忽略，在中断时线程处于不活动的状态将被此方法反映返回false。</li></ol><h3 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3. 终止线程"></a>3. 终止线程</h3><h4 id="3-1-过期的suspend-、resume-和stop"><a href="#3-1-过期的suspend-、resume-和stop" class="headerlink" title="3.1 过期的suspend()、resume()和stop()"></a>3.1 过期的suspend()、resume()和stop()</h4><p>在Java API中，suspend()、resume()和stop()三个方法是过期的，不建议使用的。<br>主要原因是：suspend()在调用后，线程不是放已经占有的资源比如说锁，而是占有着资源进入睡眠，这样容易引发死锁状态。stop()方法在终结一个线程时不会保证线程资源的释放，因此导致线程处于不确定的状态下。</p><p><strong><em>sleep和suspend区别：</em></strong><br>相同点：sleep和suspend都会持有占有的资源不释放。<br>不同点：sleep阻塞（TIMED_WAITING）后，经过一段时间自行恢复运行。而suspend必须使用resume()显示的恢复，如果不使用resume()或者resume()失败，很容易引起资源占用导致的死锁。</p><h4 id="3-2-安全的终止线程"><a href="#3-2-安全的终止线程" class="headerlink" title="3.2 安全的终止线程"></a>3.2 安全的终止线程</h4><p>在第2小节提到的中断是线程的一个标示位，中断操作是一种简便的线程间交互方式，这种交互方式适合用来取消和停止任务。除了中断，还可以使用同步变量来控制是否停止并终止该线程。<br><strong><em>线程的终止不是直接强制线程停止，而是引导线程运行结束。</em></strong></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" target="_blank" rel="noopener">Java 安全模型介绍</a><br><a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Class Thread</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程(1)-Thread类源码</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Class文件结构</title>
      <link href="/jvm/2018-11-22-class-structure/"/>
      <url>/jvm/2018-11-22-class-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="class结构"><a href="#class结构" class="headerlink" title="class结构"></a>class结构</h2><blockquote><p>翻译自<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">Chapter 4.The class File Format</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h3><p>用来识别class文件，固定值：0xCAFEBABE。关于0xCAFEBABE还有一个故事<a href="https://leokongwq.github.io/2016/12/31/java-magic-0xCAFEBABE.html" target="_blank" rel="noopener">java魔法之0xCAFEBABE</a></p><h3 id="minor-version-major-version"><a href="#minor-version-major-version" class="headerlink" title="minor_version, major_version"></a>minor_version, major_version</h3><p>minor_version和major_version项的值是此类文件的次要版本号和主要版本号。主要版本号和次要版本号一起确定类文件格式的版本。如果类文件具有主版本号M和次版本号m，则我们将其类文件格式的版本表示为M.m.因此，类文件格式版本可以按字典顺序排序，例如，1.5 &lt;2.0 &lt;2.1。</p><p>当且仅当v位于某个连续范围Mi.0≤v≤Mj.m时，Java虚拟机实现可以支持版本v的类文件格式。 Java SE平台的发行版级负责确定Java虚拟机实现符合的范围。</p><p>JDK 1.0.2版中的Oracle Java虚拟机实现支持包含45.0到45.3类的类文件格式。 JDK发布的1.1.*支持类文件格式版本范围为45.0到45.65535（含）。对于k≥2，JDK版本1.k支持45.0到44 + k.0范围内的类文件格式版本。</p><h3 id="constant-pool-count"><a href="#constant-pool-count" class="headerlink" title="constant_pool_count"></a>constant_pool_count</h3><p>constant_pool_count项的值等于constant_pool表中的条目数加1。如果constant_pool索引大于零且小于constant_pool_count，则认为它是有效的，§4.4.5中注明了long和double类型的常量。</p><h3 id="constant-pool"><a href="#constant-pool" class="headerlink" title="constant_pool[]"></a>constant_pool[]</h3><p>constant_pool是一个存储各种字符串常量、类和接口名称、字段名称以及在Class文件结构和子结构中引用的其他常量的结构表。每个constant_pool表的条目的格式由它的第一个‘tag’字节指出。<br>constant_pool表的索引从1到constant_pool_count-1。</p><h3 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h3><p>access_flags项的值是用来表示访问权限和类或者接口的属性的标志的掩码。设置时，每个标志的解释如表4.1所示。</p><p>Table 4.1. 类访问和属性修饰符</p><p>Flag Name    Value    Interpretation</p><p>ACC_PUBLIC    0x0001    Declared public; 可以被外部包访问。<br>ACC_FINAL    0x0010    Declared final; 不允许有子类。<br>ACC_SUPER    0x0020    在invokespecial指令调用时特别处理超类方法。<br>ACC_INTERFACE    0x0200    标识接口类。<br>ACC_ABSTRACT    0x0400    Declared abstract; 不能被实例化。<br>ACC_SYNTHETIC    0x1000    Declared synthetic; 不再源代码中体现。<br>ACC_ANNOTATION    0x2000    Declared as an annotation type.<br>ACC_ENUM    0x4000    Declared as an enum type.</p><p>可以用ACC_SYNTHETIC标志标记类，以指示它是由编译器生成的，并且不出现在源代码中。</p><p>ACC_ENUM 标志指示这个类或者它的父类是被定义为枚举类型。</p><p>一个接口的特征是被设置ACC_INTERFACE标志。如果没有设置ACC_INTERFACE标志，这个类文件定义的是一个类而不是一个接口。</p><p>如果这个类设置了ACC_INTERFACE标志，它的ACC_ABSTRACT也一定被设置了(JLS §9.1.1.1)。这样的类文件不能设置其ACC_FINAL，ACC_SUPER或ACC_ENUM标志。</p><p>注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，则也必须设置ACC_INTERFACE标志。如果这个类文件没有设置ACC_INTERFACE标志，它可以设置Table 4.1中除ACC_ANNOTATION之外的任何其他标志。但是，这个类不能同时设置ACC_FINAL和ACC_ABSTRACT标志(JLS §8.1.1.2)。</p><p>ACC_SUPER标志指示如果它出现在此类中，则由invokespecial指令（§invokespecial）表示两个备用语义中的哪一个。 Java虚拟机指令集的编译器应设置ACC_SUPER标志。</p><p>ACC_SUPER标志的存在是为了与旧编译器为Java编程语言编译的代码向后兼容。在版本1.0.2之前的Oracle JDK中，编译器生成了ClassFile access_flags，其中现在表示ACC_SUPER的标志没有指定含义，并且Oracle的Java虚拟机实现忽略了该标志（如果已设置）。</p><p>表4.1中未分配的access_flags项的所有位都保留供将来使用。它们应该在生成的类文件中设置为零，并且应该被Java虚拟机的实现忽略。</p><h3 id="this-class"><a href="#this-class" class="headerlink" title="this_class"></a>this_class</h3><p>this_class项的值必须是一个在constant_pool表中的有效索引。constant_pool索引index处的条目必须是一个在此类文件中定义的类或者接口的CONSTANT_Class_info结构。</p><h3 id="super-class"><a href="#super-class" class="headerlink" title="super_class"></a>super_class</h3><p>对于一个类，父类项的值要么是0，要么是一个在常量池表中的有效索引。如果父类项的值非0，则在常量池表索引index位置上的条目一定是CONSTANT_Class_info结构(§4.4.1)，指示class文件中定义的类的直接父类。直接父类或者任何其他父类都不会在它的Class文件结构的access_flags项上设置ACC_FINAL标志。</p><p>如果父类项的值是0，则这个类文件必须是Object类，唯一个没有直接父类的类或者接口。</p><p>对于一个接口，父类项的值必须总是一个在常量池表中的有效索引。在此索引上的常量池条目必须是一个CONSTANT_Class_info结构指示Object类。</p><h3 id="interfaces-count"><a href="#interfaces-count" class="headerlink" title="interfaces_count"></a>interfaces_count</h3><p>interfaces_count项的值是这个类或者接口类型的直接父接口的数量。</p><h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces[]"></a>interfaces[]</h3><p>接口数组中的每个值都必须是一个在常量池表中的有效索引。在常量池表中索引是interfaces[i]（0&lt;=i&lt;interfaces_count）的值上的每个条目必须是表示一个接口的CONSTANT_Class_info 结构 (§4.4.1)，这个接口是这个类或者这个接口类型的父接口，在类型的来源中给出的从左到右的顺序。</p><h3 id="fields-count"><a href="#fields-count" class="headerlink" title="fields_count"></a>fields_count</h3><p>fields_count项的值是字段表中field_info结构的数量。field_info结构指示所有字段，包括在这个类或者接口类型中的类变量和实例变量。</p><h3 id="fields"><a href="#fields" class="headerlink" title="fields[]"></a>fields[]</h3><p>字段表中的每个值都必须是一个给出在这个类或者接口中的字段的完整描述的field_info(§4.5)结构。字段表仅仅包含在这个类或者接口中定义的那些字段。不包含从父类或者父接口中继承的字段。</p><h3 id="methods-count"><a href="#methods-count" class="headerlink" title="methods_count"></a>methods_count</h3><p>methods_count的值给出了方法表中的methods_info结构的数量。</p><h3 id="methods"><a href="#methods" class="headerlink" title="methods[]"></a>methods[]</h3><p>方法表中的每个值都必须是一个给出一个在这个类或者接口中方法的完整描述的method_info结构。如果一个method_info结构的access_flags项未设置ACC_NATIVE和ACC_ABSTRACT标志，Java虚拟机也提供了实现这个方法的指令。</p><p>method_info结构指示了所有在这个类或者接口类型中定义的方法，包括实例方法，类方法，实力初始化方法以及任何类或者接口初始化方法(§2.9)。方法表不包含继承自父类或者父接口的方法。</p><h3 id="attributes-count"><a href="#attributes-count" class="headerlink" title="attributes_count"></a>attributes_count</h3><p>attributes_count项的值给出了在这个类的属性表中的属性数量。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes[]"></a>attributes[]</h3><p>属性表的每个值都必须是一个attribute_info(§4.7)结构。</p><p>本规范定义的属性出现在ClassFile结构的属性表中的是InnerClasses（§4.7.6），EnclosingMethod（§4.7.7），Synthetic（§4.7.8），Signature（§4.7.9）， SourceFile（§4.7.10），SourceDebugExtension（§4.7.11），不推荐使用（§4.7.15），RuntimeVisibleAnnotations（§4.7.16），RuntimeInvisibleAnnotations（§4.7.17）和BootstrapMethods（§4.7.21）属性。</p><p>如果一个Java虚拟机的实现实现识别出class文件的版本在49.0版本以上，它必须识别和正确的读取在49.0或者更高版本class文件的文件结构的属性表中找到的签名(§4.7.9)，RuntimeVisibleAnnotations (§4.7.16)和 RuntimeInvisibleAnnotations (§4.7.17) 属性。</p><p>如果Java虚拟机实现识别出51.0或更高版本的class文件，它必须识别和正确的读取在51.0或更高版本的class文件的文件结构的属性表中找到的BootstrapMethods (§4.7.21) 属性。</p><p>一个Java虚拟机的实现需要静默忽略它无法识别的ClassFile结构的属性表中的任何或所有属性。不允许在本规范中定义的属性影响类文件的语义，但仅允许提供其他描述性信息（第4.7.1节）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发知识架构</title>
      <link href="/concurrency/2018-11-27-concurrency-structure/"/>
      <url>/concurrency/2018-11-27-concurrency-structure/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/article/concurrency.png" alt="Java并发架构图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git常用命令总结</title>
      <link href="/utils/2018-10-23-git/"/>
      <url>/utils/2018-10-23-git/</url>
      
        <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>系统系统性的学习Git，请移步<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Git中文学习文档</a>，这篇文章只是分类记录一下git的常用命令。<br><img src="/media/article/15403035072735.png" alt="Git版本控制系统VCS基本操作流程图"></p><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><h3 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h3><p><code>git init</code> 将当前目录变为本地仓库（.git）<br><code>git clone</code> 克隆一个远程仓库到本地<br><code>git clone -b branch url</code> 克隆远程仓库指定branch分支到本地<br><code>git config user.name</code> 查看用户名<br><code>git config user.email</code> 查看邮箱</p><h3 id="设置与配置"><a href="#设置与配置" class="headerlink" title="设置与配置"></a>设置与配置</h3><p><code>git config -global user.name/email &quot;参数&quot;</code> git是分布式版本控制，所以添加用户名和邮箱作为一个标识<br><code>ssh -keygen -t rsa -C &quot;email&quot;</code> 生成本地ssh key</p><h3 id="本地版本库"><a href="#本地版本库" class="headerlink" title="本地版本库"></a>本地版本库</h3><p><code>git add &quot;filename.*&quot;</code> 添加到暂存区<br><code>git commit -m &quot;filename.*&quot;</code> 提交到本地仓库<br><code>git commit --amend</code> 尝试重新提交，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add file1 // 将file1 添加至缓存区</span><br><span class="line">git commmit -m &quot;update files&quot; //提交file1到本地仓库,提交完发现忘记file2没有提交，则你可以使用如下命令，提交file2并覆盖之前的提交信息。</span><br><span class="line">git add file2 // 添加file2</span><br><span class="line">git commit -amend // 尝试重新提交commit信息，并覆盖掉之前的提交信息</span><br></pre></td></tr></table></figure><p><code>git status</code> 查看本地仓库状态<br><code>git diff filename.*</code> 查看尚未暂存的文件修改的部分<br><code>git diff --cached</code>或<code>git diff --staged</code>查看已暂存的文件修改的部分<br><code>git log</code> commit的日志<br><code>git log --pretty=oneline</code> 日志显示为缩略版<br>注：<code>git reset</code> 不加<code>--hard</code>参数对当前工作区文件不会有任何修改，只是对缓存区进行操作。一旦加了参数，操作一定要慎重，否则你当前工作区中的修改将会全部被清除。<br><code>git reset HEAD file</code> 将file退回到当前版本（仅仅是对缓存区进行操作）<br><code>git reset --hard HEAD^</code> 退回到上一版本<br><code>git reset --hard HEAD^^</code> 退回到前二的版本<br><code>git reset --hard HEAD~100</code> 退回到前100版本<br><code>git reset --hard 版本号</code> 退回到一个特定的版本<br><code>git reflog</code> 查看所有操作日志，包括分支和删除的commit<br><code>git reset --mixed</code> 将当前文件撤出缓存区，保留文件修改<br><code>git rm --cached file</code> 删除缓存区file<br><code>git checkout -- file</code> 恢复工作区file（取消工作区文件的修改）</p><h3 id="远程版本库"><a href="#远程版本库" class="headerlink" title="远程版本库"></a>远程版本库</h3><p><code>git remote add origin 远程git地址</code> 连接<br><code>git push -u origin master</code> 把本地库分支master内容推送到远程库（-u 命令在第一次关联本地库和远程库时使用）<br><code>git clone url</code> 克隆远程(url)库</p><h3 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h3><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p><code>git branch</code> 查看分支<br><code>git checkout</code> 切换分支<br><code>git checkout -b</code>  创建并切换分支<br><code>git merge</code> 合并到当前分支<br><code>git branch -d</code>删除某分支<br><code>git merge --no-ff -m &quot;注释&quot;</code>分支合并分支禁用fast forward<br><code>git stash</code> 将当前分支的工作现场保留下来<br><code>git stash list</code> 查看工作现场<br><code>git stash apply</code> 恢复内容但是你需要git stash drop删除stash<br><code>git stash pop</code> 恢复的同时把stash内容也删除<br><code>git remote</code> 查看远程库的信息<br><code>git remote -v</code> 查看远程库的详细信息<br><code>git push origin master</code> master为本地的分支名推送分支<br><code>git checkout -b dev origin/dev</code> dev为分支名，做完开发后<br><code>git push origin dev</code> 推送到远程库<br><code>git pull</code> 抓取最新的提交,并尝试自动合并到本地当前所在的分支<br><code>git fetch</code> 抓取最新的提交，不会自动合并，必须手动。<br><code>git rebase</code> 变基,将提交到某一分支上的所有修改都移至另一分支上<br><code>git rebase --continue</code> <strong><em>继续变基操作，一般用于第一次变基失败后，解决冲突文件，将冲突文件添加到缓存区，不要提交，然后再执行此命令。如果提交了，执行<code>git rebase --skip</code>命令取消rebase状态。</em></strong><br><code>git branch --set-upstream dev origin/dev</code> 指定本地dev分支（已经创建的）与远程origin/dev分支的连接<br><code>git branch -u origin/dev</code> 指定当前所在连接远程origin/dev分支的连接<br><code>git checkout --track origin/dev</code> 创建新的dev分支，制定远程连接origin/dev</p><blockquote><p>如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p></blockquote><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ol><li>每开发一个新特性可以新建一个本地特性分支，开发完成后合并到本地主线。</li><li>如果不使用特性分支开发可以使用<code>git stash</code>保存当前的工作空间。</li><li>远程代码和本地代码合并有两种方式，<code>git pull</code>和<code>git fetch</code>，<code>git pull</code>命令会自动合并远程代码，冲突后需要解决冲突后提交。<code>git fetch</code>不自动和本地代码合并，需要手动merge。</li><li>在合并时，根据项目情况使用<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">变基</a>，<code>git pull --rebase</code>可以保持自动合并的情况下进行变基。一般情况下，远程库不保留本地操作历史，所以本地与远程代码合并时最好使用变基。</li><li><strong><em>使用变基原则</em></strong>：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Utils </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么不能在foreach中执行remove/add操作</title>
      <link href="/faq/2018-07-30-foreach/"/>
      <url>/faq/2018-07-30-foreach/</url>
      
        <content type="html"><![CDATA[<p>测试代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = new Vector&lt;&gt;();</span><br><span class="line">    list.add(&quot;1&quot;);</span><br><span class="line">    list.add(&quot;2&quot;);</span><br><span class="line">    for(String it:list)&#123;</span><br><span class="line">        // 如果it==2，删除it</span><br><span class="line">        if(&quot;2&quot;.equals(it))&#123;</span><br><span class="line">            list.remove(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行上述代码，会抛出ConcurrentModificationException异常。</p><p>为什么会报错呢？</p><p><code>javap -c</code>命令查看编译后代码，了解下上述代码运行过程:</p><p><img src="/media/article/java-foreach.png" alt="foreach"></p><p>上图代码A处，可以看到foreach循环是使用的是Iterator迭代器，代码B处使用Iterator迭代器中的next方法获取集合中的值，代码C处使用list.remove()删除集合中的值。</p><p>Itr迭代器类的next方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">  synchronized (Vector.this) &#123;</span><br><span class="line">      if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">      int i = cursor;</span><br><span class="line">      if (i &gt;= elementCount)</span><br><span class="line">          throw new NoSuchElementException();</span><br><span class="line">      cursor = i + 1;</span><br><span class="line">      return elementData(lastRet = i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list.remove方法代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean removeElement(Object obj) &#123;</span><br><span class="line">   // 修改了modCount</span><br><span class="line">   modCount++;</span><br><span class="line">   int i = indexOf(obj);</span><br><span class="line">   if (i &gt;= 0) &#123;</span><br><span class="line">       removeElementAt(i);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先next方法中，首先判断modCount的值，如果modCount的值和expectedModCount值不一致，就会抛出ConcurrentModificationException异常。而恰恰remove方法中就修改了modCount的值，而未修改expectedModCount的值，从而导致我们的测试代码抛出ConcurrentModificationException异常。</p><p>抛错的源头找到了，可是为什么会出现这种问题呢？</p><p>我们看下导致抛出源头的两个参数modCount和expectedModCount。modCount是类Vector的成员变量，主要记录Vector的修改次数；expectedModCount是内部迭代器类Itr的成员变量，初始化时等于modCount。我们使用foreach去remove集合内的值时，调用的是Vector类的remove方法，不是迭代器Itr的remove方法，所以只会修改modCount的值，而不更新expectedModCount的值。所以在测试代码中报错是因为在第一次删除后，modCount值+1，而expectedModCount的值未变化，所以在迭代器再次调用next方法获取集合内的值时就会抛出ConcurrentModificationException异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> FAQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机问题排查工具</title>
      <link href="/jvm/2018-04-07-jvm-tools/"/>
      <url>/jvm/2018-04-07-jvm-tools/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JDK命令行工具"><a href="#1-JDK命令行工具" class="headerlink" title="1. JDK命令行工具"></a>1. JDK命令行工具</h2><p>JDK命令行工具主要用于JVM性能监控和故障处理。</p><h3 id="1-1-jps"><a href="#1-1-jps" class="headerlink" title="1.1 jps"></a>1.1 jps</h3><p>虚拟机进程状况工具。 显示当前所有java进程pid的命令。</p><p>-l 输出主类的全名，如果进程执行的是Jar包，输出Jar路径</p><p>-v 输出虚拟机进程启动时JVM参数</p><p>-q 只输出LVMID，省略主类的名称</p><p>-m 输出虚拟机进程启动时传递给主类main()函数的参数</p><h3 id="1-2-jstat"><a href="#1-2-jstat" class="headerlink" title="1.2 jstat"></a>1.2 jstat</h3><p> 虚拟机统计信息监视工具，用于监视虚拟机各种运行状态信息的命令。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾回收、JIT编译等运行数据。运行期定位虚拟机性能问题的首选工具。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-class：监视类装载、卸载数量、总空间以及类装载所耗时间。</span><br><span class="line"></span><br><span class="line">-gc：监视JAVA堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间，GC已用时间合计等信息；</span><br><span class="line"></span><br><span class="line">-gccapacity：监视内容与-gc基本相同，但输出主要关注 java堆各个区域使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcutil：监视内容与-gc基本相同，便输出主要关注已使用空间占总空间的百分比；</span><br><span class="line"></span><br><span class="line">-gccause：与-gcutil功能一样，但是会额外输出导致 一次GC产生的原因；</span><br><span class="line"></span><br><span class="line">-gcnew：监视新生代GC状态；</span><br><span class="line"></span><br><span class="line">-gcnewcapacity：监视内容与-gcnew基本相同，输出最要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcold：监视老年代GC状况；</span><br><span class="line"></span><br><span class="line">-gcoldcapacity：监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcpermcapacity：监视永久代使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-compiler：输入JIT编译器编译过的方法，耗时等信息；</span><br><span class="line"></span><br><span class="line">-printcompilation：输出已经被JIT编译的方法；</span><br></pre></td></tr></table></figure><h3 id="1-3-jinfo"><a href="#1-3-jinfo" class="headerlink" title="1.3 jinfo"></a>1.3 jinfo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-flag &lt;name&gt; ：可查看虚拟机启动时显式指定的参数列表。</span><br><span class="line">-flag [+|-]&lt;name&gt;：设置或取消VM参数</span><br><span class="line">-flag &lt;name&gt;=&lt;value&gt;：给VM参数设置新值</span><br><span class="line">-flags：可查看所有VM参数；</span><br><span class="line">-sysprops：查看java系统参数;</span><br><span class="line">&lt;no option&gt;：表示在不给定任何选项时，打印出以上所有的VM参数</span><br></pre></td></tr></table></figure><p> 实时的查看和调整虚拟机的各项参数。</p><h3 id="1-4-jmap"><a href="#1-4-jmap" class="headerlink" title="1.4 jmap"></a>1.4 jmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-dump：生成java堆转储快照，格式为：-dump[live, ] format=b, file=&lt;filename&gt;,其中live子参数说明是否只dump出存活对象；</span><br><span class="line"></span><br><span class="line">-finalizerinfo：显示在F-QueuiK 等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-heap：显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-histo：显示堆中对象统计信息，包括类、实例数量、合计容量；</span><br><span class="line"></span><br><span class="line">-permstat：以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台有效；</span><br><span class="line"></span><br><span class="line">-F：当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，只在Linux/Solaris平台有效</span><br></pre></td></tr></table></figure><p> Java内存映像工具。用于生成堆转储快照，还可以查询finalize()执行队列，Java堆和永久代的详细信息，如空间使用率、当前使用的哪种收集器等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jmap -dump:format=b,file=D:\test.bin 2768</span><br><span class="line">Dumping heap to D:\test.bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h3 id="1-5-jhat"><a href="#1-5-jhat" class="headerlink" title="1.5 jhat"></a>1.5 jhat</h3><p><code>jhat D:\test.bin</code></p><p> 分析jmap生成的堆转储快照，在浏览器查看。</p><h3 id="1-6-jstack"><a href="#1-6-jstack" class="headerlink" title="1.6 jstack"></a>1.6 jstack</h3><p> 用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合，生成快照的目的是定位线程出现长时间停顿的原因。</p><p>-F    当正常输出的请求不被响应时，强制输出线程堆栈</p><p>-l    除堆栈外，显示关于锁的附加信息</p><p>-m    如果调用到本地方法的话，可以显示c/c++的堆栈</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">//        Thread t1 = new Worker(1);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        t1.start();</span><br><span class="line">        final A a = new A();</span><br><span class="line">        final B b = new B();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                a.getBLock(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                b.getALock(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getBLock(B b)&#123;</span><br><span class="line"></span><br><span class="line">        b.getALock(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getALock(A a)&#123;</span><br><span class="line">        a.getBLock(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会产生死锁，使用jstack命令可以打印出线程死锁信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">1904 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">11540 Jps -m</span><br><span class="line">13204 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/inte</span><br><span class="line">llij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/i</span><br><span class="line">dea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.j</span><br><span class="line">ar;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br><span class="line">4488</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jstack -F 1904</span><br><span class="line">Attaching to process ID 1904, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.161-b12</span><br><span class="line">Deadlock Detection:</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193ce108 (Object@0x00000000d6129700, a com/zhongyp/B),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193cb878 (Object@0x00000000d6127d20, a com/zhongyp/A),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line"></span><br><span class="line">Found a total of 1 deadlock.</span><br><span class="line"></span><br><span class="line">Thread 1: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 18: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=0, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=2, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$2.run() @bci=18, line=38 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 17: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=0, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=2, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$1.run() @bci=18, line=26 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 16: (state = IN_NATIVE)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.accept0(int, java.net.InetSocketAddress[]) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.socketAccept(java.net.SocketImpl) @bci=37, line=131 (Interpreted frame)</span><br><span class="line"> - java.net.AbstractPlainSocketImpl.accept(java.net.SocketImpl) @bci=7, line=409 (Interpreted frame)</span><br><span class="line"> - java.net.PlainSocketImpl.accept(java.net.SocketImpl) @bci=42, line=199 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.implAccept(java.net.Socket) @bci=60, line=545 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.accept() @bci=48, line=513 (Interpreted frame)</span><br><span class="line"> - com.intellij.rt.execution.application.AppMain$1.run() @bci=13, line=79 (Interpreted frame)</span><br><span class="line"> - java.lang.Thread.run() @bci=11, line=748 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 10: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 9: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 8: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 7: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.Object.wait() @bci=2, line=502 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference.tryHandlePending(boolean) @bci=54, line=191 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference$ReferenceHandler.run() @bci=1, line=153 (Interpreted frame)</span><br></pre></td></tr></table></figure><h2 id="2-JDK可视化工具"><a href="#2-JDK可视化工具" class="headerlink" title="2. JDK可视化工具"></a>2. JDK可视化工具</h2><p>JConsole: Java监视与管理控制台。基于JMX的可视化监视和管理工具。监视Java堆和永久代的的变化趋势。</p><p>VisualVM: 多合一故障处理工具。</p><h3 id="2-1-MAT-堆dump文件分析工具"><a href="#2-1-MAT-堆dump文件分析工具" class="headerlink" title="2.1 MAT: 堆dump文件分析工具"></a>2.1 MAT: 堆dump文件分析工具</h3><h4 id="2-1-1-Histogram可以列出内存中的对象，对象的个数以及大"><a href="#2-1-1-Histogram可以列出内存中的对象，对象的个数以及大" class="headerlink" title="2.1.1 Histogram可以列出内存中的对象，对象的个数以及大"></a>2.1.1 Histogram可以列出内存中的对象，对象的个数以及大</h4><p>Class Name:类名称，java类名</p><p>Objects:类的对象的数量，这个对象被创建了多少个</p><p>Shallow Heap:一个对象内存的消耗大小，不包含对其他对象的引用，Shallow Heap堆中的对象是它的大小和保留内存大小相同的对象是堆内存的数量时,将释放对象被垃圾收集。<br>对象自身占用的内存大小，不包括它引用的对象。<br>针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。<br>针对数组类型的对象，它的大小是数组元素对象的大小总和。</p><p>Retained Heap:是shallow Heap的总和，也就是该对象被GC之后所能回收到内存的总和。<br>Retained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)<br>换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。<br>不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被被当做Garbage。</p><h4 id="2-1-2-Dominator-Tree可以列出那个线程，以及线程下面的那些对象占用的空间"><a href="#2-1-2-Dominator-Tree可以列出那个线程，以及线程下面的那些对象占用的空间" class="headerlink" title="2.1.2 Dominator Tree可以列出那个线程，以及线程下面的那些对象占用的空间"></a>2.1.2 Dominator Tree可以列出那个线程，以及线程下面的那些对象占用的空间</h4><h4 id="2-1-3-Top-consumers通过图形列出最大的object"><a href="#2-1-3-Top-consumers通过图形列出最大的object" class="headerlink" title="2.1.3 Top consumers通过图形列出最大的object"></a>2.1.3 Top consumers通过图形列出最大的object</h4><h4 id="2-1-4-Leak-Suspects通过MA自动分析泄漏的原因"><a href="#2-1-4-Leak-Suspects通过MA自动分析泄漏的原因" class="headerlink" title="2.1.4 Leak Suspects通过MA自动分析泄漏的原因"></a>2.1.4 Leak Suspects通过MA自动分析泄漏的原因</h4><h2 id="3-内存问题分析"><a href="#3-内存问题分析" class="headerlink" title="3. 内存问题分析"></a>3. 内存问题分析</h2><p><a href="https://www.javatang.com/archives/2017/10/19/33151873.html" target="_blank" rel="noopener">JVM故障分析系列</a></p><p><a href="https://wensong.iteye.com/blog/1986449" target="_blank" rel="noopener">Memory Analyzer Tool 使用手记</a></p><p><a href="http://blog.csdn.net/jackesy/article/details/47039865" target="_blank" rel="noopener">使用Eclipse Memory Analyzer分析内存</a></p><p><a href="http://www.blogjava.net/rosen/archive/2010/05/21/321575.html" target="_blank" rel="noopener">使用Memory Analyzer tool(MAT)分析内存泄漏（一）</a></p><p><a href="https://www.yourkit.com/docs/java/help/sizes.jsp" target="_blank" rel="noopener">Shallow and retained sizes</a></p><p><a href="http://www.infoq.com/cn/articles/jvm-memory-collection" target="_blank" rel="noopener">JVM内存回收理论与实现</a></p><p><a href="https://www.yourkit.com/docs/java/help/gc_roots.jsp" target="_blank" rel="noopener">GC roots</a></p><p><a href="http://tivan.iteye.com/blog/1487855" target="_blank" rel="noopener">一次使用Eclipse Memory Analyzer分析Tomcat内存溢出</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.iteye.com/blog/bjyzxxds-1532937" target="_blank" rel="noopener">Shallow heap &amp; Retained heap</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高性能MySQL -- 摘自《高性能MySQL第三版》</title>
      <link href="/mysql/2018-04-02-mysql/"/>
      <url>/mysql/2018-04-02-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MySQL的逻辑架构：</p><p><img src="/media/article/mysql-logic-structure.png" alt=""></p><p>–摘自《高性能MySQL 第3版》1.1 小节</p><h3 id="优化与执行"><a href="#优化与执行" class="headerlink" title="优化与执行"></a>优化与执行</h3><ul><li>MySQL会解析查询，并创建内部数据结构，然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引。</li><li>用户可以通过特殊的关键字提示(hint)优化器，影响它的决策过程。</li><li>也可以请求优化器解释(explain)优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的。</li><li>对于SELECT语句，在解析查询之前，服务器会先检查查询缓存(Query Cache)，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</li></ul><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>共享锁、排他锁。</p><h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p>表锁是最基本的锁策略，并且是开销最小的策略。</p><p>行级锁可以最大程度的支持并发处理。行级锁仅在存储引擎中实现，如InnoDB和XtraDB。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>原子性、一致性、隔离性、持久性。</p><p>事务的隔离级别又分为：未提交读、提交读、可重复读、可串行化。</p><h4 id="未提交读（脏读）"><a href="#未提交读（脏读）" class="headerlink" title="未提交读（脏读）"></a>未提交读（脏读）</h4><h4 id="提交读（不可重复读）"><a href="#提交读（不可重复读）" class="headerlink" title="提交读（不可重复读）"></a>提交读（不可重复读）</h4><p>大多数数据库默认是提交读，MySQL不是。同一个事务中执行两次相同的查询可能得到不一样的结果。</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>解决了脏读问题，同一事务中多次读取相同的记录结果是一致的。但是存在幻读问题，当前某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取范围的记录时，读取不到新事务插入的新值，会产生幻行。</p><p>当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。</p><p>MySQL的默认数据库隔离级别。</p><h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><p>最高的隔离级别。通过强制事务串行执行，避免了前面说的幻读问题。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>InnoDB提供检测死锁的处理，将持有最少排他锁的事务回滚。</p><h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>悲观锁，乐观锁</p><h2 id="引擎篇"><a href="#引擎篇" class="headerlink" title="引擎篇"></a>引擎篇</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li><p>Myisam是Mysql的默认存储引擎，当create创建新表时，未指定新表的存储引擎时，默认使用Myisam。</p></li><li><p>每个MyISAM在磁盘上存储成三个文件。文件名都和表名相同，扩展名分别是.frm（存储表定义）、.MYD (MYData，存储数据)、.MYI (MYIndex，存储索引)。数据文件和索引文件可以放置在不同的目录，平均分布io，获得更快的速度。</p></li><li><p>它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一 。</p></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li><p>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比Myisam的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</p></li><li><p>用于事务处理应用程序，具有众多特性，包括ACID 事务支持。</p></li><li>InnoDB可通过Sphinx实现全文索引。</li><li>InnoDB表基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引必须包含主键列。</li><li>InnoDB根据主键引用被索引的行。</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>将所有数据保存在RAM 中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。</p><table><tr></tr><tr></tr><tr><td>特点</td><td>Myisam</td><td> BDB</td><td> Memory</td><td>InnoDB</td><td> Archive</td></tr><tr><td>存储限制</td><td>没有</td><td>没有</td><td>有</td><td>64TB</td><td>没有</td></tr><tr><td>事务安全</td><td></td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>锁机制</td><td>表锁</td><td>页锁</td><td>表锁</td><td>行锁</td><td>行锁</td></tr><tr><td>B 树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr><td>数据缓存</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>空间使用</td><td>低</td><td>低</td><td>N/A</td><td> 高</td><td>非常低</td></tr><tr><td>内存使用</td><td>低</td><td>低</td><td>中等</td><td>高</td><td>低</td></tr><tr><td>批量插入的速度</td><td>高</td><td>高</td><td>高</td><td>低</td><td>非常高</td></tr><tr><td>支持外键</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr></tr></table><h2 id="Schema与数据类型优化"><a href="#Schema与数据类型优化" class="headerlink" title="Schema与数据类型优化"></a>Schema与数据类型优化</h2><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li><p>一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p></li><li><p>简单的数据类型通常需要更少的CPU周期。</p></li><li><p>尽量避免使用NULL，原因是由于NULL可能需要单独的位（bit）去存储或者NULL使得索引、索引统计、值比较都更为复杂。</p></li></ul><h3 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h3><ul><li><p>范式化的更新操作会比反范式化的快。</p></li><li><p>当数据较好范式化的时候，只有很少或者没有重复数据，所以只需要修改更少的数据。</p></li><li><p>范式化的表通常更小。</p></li><li><p>很少有冗余数据意味着检索列表数据更少需要distinct或者group by语句。</p></li></ul><h3 id="反范式的优点和缺点"><a href="#反范式的优点和缺点" class="headerlink" title="反范式的优点和缺点"></a>反范式的优点和缺点</h3><ul><li>反范式的schema所有数据都在一张表中，可以很好的避免关联，还可以避免随机IO(和存储引擎有关)。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>尽可能避免过度设计，例如会导致复杂查询的schema设计，或者有很多列的表的设计。</p></li><li><p>使用小而简单的合适数据类型，除非真实数据模型中确切的需要，否则应尽可能的避免NULL值。</p></li><li><p>尽量使用相同的数据类型存储相似或者相关的值，尤其是在关联条件中要使用的列。</p></li><li><p>避免使用MySQL已经遗弃的特性，例如浮点数的精度，或者整数的显示宽度。</p></li><li><p>小心使用ENUM和SET。避免使用BIT。</p></li></ul><h2 id="MySQL查询性能优化"><a href="#MySQL查询性能优化" class="headerlink" title="MySQL查询性能优化"></a>MySQL查询性能优化</h2><h3 id="捕获SQL查询日志"><a href="#捕获SQL查询日志" class="headerlink" title="捕获SQL查询日志"></a>捕获SQL查询日志</h3><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志是开销最低，精度最高的测量查询时间的工具。不需要考虑性能消耗，但是需要注意日志量太大导致占用太多磁盘空间。<br>慢查询日志中V/M列提供了方差均值比的详细数据，方差均值比也就是常说的离差指数。离差指数高的查询对应的执行时间的变化较大。</p><h4 id="抓去TCP包"><a href="#抓去TCP包" class="headerlink" title="抓去TCP包"></a>抓去TCP包</h4><p>通过tcpdump将网络包数据保存到磁盘，然后使用pt-query-digest的–type=tcpdump解析查询。</p><h3 id="分析查询日志"><a href="#分析查询日志" class="headerlink" title="分析查询日志"></a>分析查询日志</h3><p>工具：pt-query-digest。</p><h4 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h4><p><code>set profiling = 1</code><br><code>show profiles</code><br><code>show prifle for query 1</code><br>输出结果根据执行顺序排序，不使用show profile也可以直接查询infomation_schema中对应的表。</p><h4 id="show-status"><a href="#show-status" class="headerlink" title="show status"></a>show status</h4><p>这是一个计数器，可以清楚的知道句柄、临时文件和表的次数。是否是磁盘表。</p><h3 id="诊断问题工具"><a href="#诊断问题工具" class="headerlink" title="诊断问题工具"></a>诊断问题工具</h3><p>show Global status，可以将这个命令的数据绘制成图像。</p><p>show processlist， 观察是否存在大量线程处于不正常的状态或者有其他不正常的特征。</p><p>上面两个工具性能消耗很低，可以交叉或者频繁多次调用获取数据分析问题。</p><h3 id="捕获诊断数据"><a href="#捕获诊断数据" class="headerlink" title="捕获诊断数据"></a>捕获诊断数据</h3><p>监控工具：pt-stalk、pt-collect<br>监控变量：系统的状态、CPU利用率、磁盘使用率和可用空间、ps的输出采样、内存利用率，show status、show processlist和show innodb status。</p><h2 id="高性能索引创建"><a href="#高性能索引创建" class="headerlink" title="高性能索引创建"></a>高性能索引创建</h2><p>系统从磁盘读取数据到内存是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页（page）的概念，页是其磁盘管理的最小单位。</p><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><h4 id="B-Tree索引（平衡多路查找树）"><a href="#B-Tree索引（平衡多路查找树）" class="headerlink" title="B-Tree索引（平衡多路查找树）"></a>B-Tree索引（平衡多路查找树）</h4><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree.png?raw=true" alt="b-tree"></p><p>B-Tree 通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。B-Tree索引能够加快访问数据的速度，存储引擎不需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放指向<strong><em>子节点的指针</em></strong>，存储引擎根据这些指针向下层查找。指针中定义了子节点页中值的上限和下限。最终找到该值或者不存在。</p><p>叶子节点比较特殊，他们指向的是被索引的数据，而不是其他的节点页。</p><p>索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</p><p>B-Tree索引的查询类型适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于根据最左前缀查找。</p><p>树的深度和表的大小直接相关。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree1.png?raw=true" alt="b-tree"></p><p>可以使用B-Tree索引的查询类型：</p><p>全值匹配：全值匹配指的是和索引的所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen 1960-01-01。</p><p>匹配最左前缀：可用于查找索引的第一列。</p><p>匹配列前缀：也可以匹配某一列的值的开头部分。</p><p>匹配范围值：遵循最左前缀的前提下，范围查找。</p><p>精确匹配某一列并范围匹配另外一列：可用于查找所有姓为Allen,并且名字是字母K开头的人。</p><p>只访问索引的查询：B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。</p><p>B-Tree使用限制：</p><ul><li>必须遵循最左原则。</li><li>不能跳过索引中的列。</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li><li>如果查询中某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li></ul><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>在B-tree的基础上，为叶子节点增加链表指针，而且所有的关键字都在叶子节点中出现，且数据只存储在叶子节点中。非叶子节点的关键字仅作为叶子节点的索引。</p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><p>在MySQL中，只有Memory引擎显式支持哈希索引且支持非唯一哈希索引的。</p><p>哈希索引每个槽点编号是有序的。</p><p>哈希索引使用限制：</p><p>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</p><p>哈希索引并不是按照索引值顺序存储的，所以无法用于排序。</p><p>哈希索引也不支持部分索引列的匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</p><p>哈希索引支持等值比较查询，包括=、in()、&lt;=&gt;也不支持任何范围查询，例如WHERE price &gt; 100。</p><p>访问哈希索引的数据非常快，除非有很多哈希冲突。</p><p>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。</p><p>除了Memory引擎外，NDB集群引擎也支持唯一哈希索引，且在NDB集群引擎中作用非常特殊。</p><p>InnoDB引擎有一个特殊的功能叫“自适应哈希索引”。当InnoDB引擎注意到某些索引值被使用的非常频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型索引，它查找的是文本中的关键词，而不是直接比较索引中的值。适用于MATCH AGINST操作，而不是普通的WHERE条件操作。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li><p>索引大大减少了服务器需要扫描的数据量。</p></li><li><p>索引可以帮助服务器避免排序和临时表。</p></li><li><p>索引可以将随机IO变为顺序IO。</p></li></ul><h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><h3 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h3><h3 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h3><p>维护表有3个目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。</p><h4 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h4><p>表损坏（corruption）是件很糟糕的事情。对于MyISAM，表损坏通常是系统崩溃导致的。</p><p>损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时甚至还会导致数据库的崩溃。</p><p>修复：</p><ul><li><p>check table，能找出大多数表和索引错误。有些存储引擎不支持该命令。</p></li><li><p>repair table，和check类似。</p></li><li><p>alter table innodb_tbl engine=innodb，修改表的存储引擎为当前引擎重建表。</p></li><li><p>离线工具myisamchk</p></li><li><p>将数据导出在重新导入。</p></li><li><p>如果损坏的是行数据或者系统区域，以上办法无效。</p></li><li><p>如果损坏系统区域或者行数据，可以从备份中恢复表，或者尝试从损坏的数据文件中尽可能的恢复数据。</p></li></ul><p>如果InnoDB引擎的表出现损坏，那么一定是发生了严重的错误，需要立刻调查原因。具体细节可以查看MySQL手册。</p><h4 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h4><h4 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三个原则：</p><ul><li><p>单行访问时很慢的。最好读取块中能包含尽可能多的所需要的行。使用索引可以创建位置引用以提升效率。</p></li><li><p>按顺序访问范围数据是很快的，这有两个原因。第一、顺序IO不需要多次磁盘寻道，所以比随机IO快很多。第二、如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且group by查询也无需再做排序和将行按组进行聚合计算了。</p></li><li><p>索引覆盖查询是很快的。</p></li></ul><p>一般来说，我们建议按响应时间来对查询进行分析。</p><p>如果一个查询无法从所有可能的索引中获益，则应该看看是否可以创建一个更合适的索引来提升性能。</p><h2 id="剖析MySQL查询"><a href="#剖析MySQL查询" class="headerlink" title="剖析MySQL查询"></a>剖析MySQL查询</h2><p>对查询进行性能剖析有两种方式，每种方式都有各自的问题。</p><h3 id="剖析服务器负载"><a href="#剖析服务器负载" class="headerlink" title="剖析服务器负载"></a>剖析服务器负载</h3><p>服务器端可以有效的审计效率低下的查询。</p><h4 id="捕获MySQL的查询到日志文件中"><a href="#捕获MySQL的查询到日志文件中" class="headerlink" title="捕获MySQL的查询到日志文件中"></a>捕获MySQL的查询到日志文件中</h4><p>慢查询日志是一种轻量而且功能全面的性能剖析工具，是优化服务器查询的利器。可以通过修改针对每个链接的long_query_time的阈值来捕获所以的查询。</p><p>通用日志在查询请求到服务器时进行记录，所以不包含响应时间和执行计划等重要信息。日志信息记录到数据库表中。</p><h4 id="分析查询日志-1"><a href="#分析查询日志-1" class="headerlink" title="分析查询日志"></a>分析查询日志</h4><p>工具：pt-query-digest</p><p>剖析报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest1.png?raw=true" alt="查询日志"></p><p>详细报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest2.png?raw=true" alt="详细查询日志"></p><h3 id="剖析单条查询"><a href="#剖析单条查询" class="headerlink" title="剖析单条查询"></a>剖析单条查询</h3><h4 id="show-profile-1"><a href="#show-profile-1" class="headerlink" title="show profile"></a>show profile</h4><p>show profile命令是在5.1版本之后引入的，默认是禁用的，可以通过<code>set profiling=1</code>动态的修改。这个功能有一定的作用，将来能会被Performance Schema所取代。</p><p>下面是对一个视图的剖析结果：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling1.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling2.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling3.png?raw=true" alt="详细查询日志"></p><p>剖析报告给出查询执行每个步骤花费的时间，看结果无法快速确定哪个步骤花费时间最多，因为输出是按照执行顺序排序，而不是花费的时间排序的。如果不使用show profile命令。还可以直接查询information_schema中对应的表，按照格式化输出。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/information_schema.png?raw=true" alt="详细查询日志"></p><p>效果比看show profile输出的结果好很多，可以很直观的看到哪些步骤花费时长较长。</p><h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="查询慢的原因"><a href="#查询慢的原因" class="headerlink" title="查询慢的原因"></a>查询慢的原因</h3><p>查询最重要的是响应时间，如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行更快。</p><p>MySQL执行查询的时候，查询需要在不同的地方花费时间，如网络、cpu、生成统计信息和执行计划、锁等待等。在每一个消耗大量时间的查询案例中，我们都能看到一些不必要的额外操作、某些操作被额外的执行了很多次、某些操作执行的太慢等。</p><p>优化查询的目的就是减少和消除这些操作所花费的时间。</p><h3 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h3><p>查询性能低下最基本的原因是访问的数据太多。某些查询不可避免的需要筛选大量数据，大部分查询都可以通过减少访问的数据量的方式进行优化。对于低效查询可以分为两个步骤分析：</p><ul><li><p>1.确认应用程序是否检索大量超过需要的数据。如访问过多的行或者列。</p></li><li><p>2.确定MySQL服务器层是否在分析大量超过需要的数据行。</p></li></ul><h4 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h4><ul><li><p>查询不需要的记录</p></li><li><p>多表关联返回全部的列</p></li><li><p>总是取出全部的列</p></li><li><p>重复查询相同的数据</p></li></ul><h4 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h4><p>在确定查询只返回需要的数据以后，最简单的衡量查询开销的三个指标如下：</p><ul><li><p>响应时间</p></li><li><p>扫描的行数</p></li><li><p>返回的行数</p></li></ul><p>响应时间：响应时间只是一个表面上的值。响应时间是服务时间和排队时间。服务时间指数据库处理这个时间花费的时间。排队时间指服务器因为等待某些资源而没有真正执行查询的时间。</p><p>快速上限估计：了解查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以在具体硬件条件下一次IO的消耗时间。</p><p>扫描的行数和返回的行数： 分析查询时，查看扫描的行数一定程度上可以反映出该查询找到需要的数据的效率高不高。</p><p>扫描的行数和访问类型：在explain语句中的type列反映了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。从慢到快，扫描的行数从小到大。</p><p>如果查询没有找到合适的访问类型，那么解决的最好办法通常是增加一个合适的索引。</p><p>例如：</p><p><code>select * from sakila.film_actor where film_id = 1;</code></p><p>这个查询返回10行数据，从explain的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/ref.png?raw=true" alt="详细查询日志"></p><p>explain的结果也显示MySQL预估需要访问10行数据。查询优化器认为这种访问类型可以高效的完成查询。如果我们删除索引再来运行：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/where.png?raw=true" alt="详细查询日志"></p><p>正如我们预料的，查询变成全表扫描，MySQL预估会扫描5073条记录来完成查询。</p><p>一般MySQL使用如下三种方式应用WHERE条件，从好到坏依次是：</p><ul><li><p>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</p></li><li><p>使用索引覆盖扫描（Extra:using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录。</p></li><li><p>从数据表中返回数据（Extra:using where），然后过滤不满足条件的记录。这是在服务器层完成的，MySQL需要从数据表中读出来然后再进行过滤。</p></li></ul><p>虽然例子说明了好的索引多么重要，但是也不是说增加了索引就能让扫描的行数等于返回的行数。例如使用聚合函数的查询：</p><p><code>select actor_id,count(*) from sakila.film_actor group by actor_id</code></p><p>这个例子没有什么索引能够让这样的查询减少需要扫描的行数。</p><p>通常如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试使用下面的技巧去优化：</p><ul><li><p>使用覆盖索引扫描，把所有需要的列放到索引中，这样存储引擎无需回表获取对应行就可以返回结果了。</p></li><li><p>改变库表结构。例如使用单独的汇总表。</p></li><li><p>重写复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</p></li></ul><h3 id="重构查询的方式非锁"><a href="#重构查询的方式非锁" class="headerlink" title="重构查询的方式非锁"></a>重构查询的方式非锁</h3><h4 id="一个复杂的查询还是多个简单的查询"><a href="#一个复杂的查询还是多个简单的查询" class="headerlink" title="一个复杂的查询还是多个简单的查询"></a>一个复杂的查询还是多个简单的查询</h4><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><p>将大查询分为小查询，每个查询功能完全一样，只完成一小部分，每次返回一小部分查询结果。删除旧数据就是一个很好的例子</p><h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><p>对每一个表进行一次单表查询，然后将结果在应用程序中关联。</p><p>分解关联查询的优点：</p><ul><li><p>让缓存效率跟高。</p></li><li><p>执行单个查询可以减少锁的竞争。</p></li><li><p>做应用层关联，可以更好的对数据库拆分，更容易做到，高性能可扩展。</p></li><li><p>查询效率本身效率也可能会有所提升。</p></li><li><p>可以减少冗余记录的查询。</p></li><li><p>这样做相当于在应用中实现了哈希关联而不是MySQL的嵌套循环关联。</p></li></ul><h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><p>查询执行路径：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/process.png?raw=true" alt="查询执行路径"></p><h3 id="MySQL查询优化器的局限性"><a href="#MySQL查询优化器的局限性" class="headerlink" title="MySQL查询优化器的局限性"></a>MySQL查询优化器的局限性</h3><h3 id="查询优化器的提示"><a href="#查询优化器的提示" class="headerlink" title="查询优化器的提示"></a>查询优化器的提示</h3><h3 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h3><h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><h2 id="MySQL的高级特性"><a href="#MySQL的高级特性" class="headerlink" title="MySQL的高级特性"></a>MySQL的高级特性</h2><ul><li><p>分区表</p></li><li><p>视图</p></li><li><p>外键约束</p></li><li><p>MySQL内部存储代码</p></li><li><p>游标</p></li><li><p>绑定变量</p></li><li><p>用户自定义函数</p></li><li><p>插件</p></li><li><p>字符集和校对</p></li><li><p>全文索引</p></li><li><p>分布式（XA）事务</p></li><li><p>查询缓存</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">高性能MySQL 第3版 中文 宁海元，周振兴，彭立勋，翟卫祥，刘辉译.</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/what-is-mysql.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL优化</title>
      <link href="/mysql/2018-04-02-sql/"/>
      <url>/mysql/2018-04-02-sql/</url>
      
        <content type="html"><![CDATA[<h2 id="常用SQL技巧"><a href="#常用SQL技巧" class="headerlink" title="常用SQL技巧"></a>常用SQL技巧</h2><h3 id="1-1-检索包含最大和最小值的行"><a href="#1-1-检索包含最大和最小值的行" class="headerlink" title="1.1 检索包含最大和最小值的行"></a>1.1 检索包含最大和最小值的行</h3><p><code>select max(test_score),min(test_score) from student</code></p><h3 id="1-2-巧用rand-rand-n-提取随机行"><a href="#1-2-巧用rand-rand-n-提取随机行" class="headerlink" title="1.2 巧用rand()/rand(n)提取随机行"></a>1.2 巧用rand()/rand(n)提取随机行</h3><p><code>select * from table order by rand()</code></p><h3 id="1-3-group-by的with-rollup子句做统计"><a href="#1-3-group-by的with-rollup子句做统计" class="headerlink" title="1.3 group by的with rollup子句做统计"></a>1.3 group by的with rollup子句做统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table sales(</span><br><span class="line"></span><br><span class="line">year int not null,</span><br><span class="line">country varchar(20) not null,</span><br><span class="line">product varchar(32) not null,</span><br><span class="line">profit int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2001);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2002);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2003);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2004);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2005);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2006);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2007);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2008);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2009);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2010);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2011);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2012);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year;</span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year with rollup;</span><br></pre></td></tr></table></figure><p>当你使用ROLLUP时, 你不能同时使用ORDER BY子句进行结果排序。换言之， ROLLUP和ORDER BY 是互相排斥的LIMIT 用在ROLLUP 后面。</p><h3 id="1-4-bit-group-functions做统计"><a href="#1-4-bit-group-functions做统计" class="headerlink" title="1.4 bit group functions做统计"></a>1.4 bit group functions做统计</h3><p>bit_count:用来计算二进制数中包含1的个数</p><p>bit_or:就是对两个二进制数进行或运算</p><p>bit_and:就是对两个二进制数进行并运算</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="通过show-status和应用特点了解各种SQL的执行频率。"><a href="#通过show-status和应用特点了解各种SQL的执行频率。" class="headerlink" title="通过show status和应用特点了解各种SQL的执行频率。"></a>通过show status和应用特点了解各种SQL的执行频率。</h3><p>首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)</p><p>show status</p><p>常用的:</p><p>show status like ‘uptime’ ; </p><p>show stauts like ‘com_select’  show status like ‘com_insert’ …类推 update  delete</p><p>show session或global status like …. 如果你不写session或global,默认是session 会话，指取出当前窗口的执行，如果你想看所有session,从mysql 启动到现在，则应该 global。</p><p>show status like ‘connections’; </p><p>//显示慢查询次数</p><p>show status like ‘slow_queries’;</p><p>以下几个参数对Myisam 和Innodb 存储引擎都计数：</p><ol><li><p>Com_select 执行select 操作的次数，一次查询只累加1；</p></li><li><p>Com_insert 执行insert 操作的次数，对于批量插入的insert 操作，只累加一次；</p></li><li><p>Com_update 执行update 操作的次数；</p></li><li><p>Com_delete 执行delete 操作的次数；</p></li></ol><p>以下几个参数是针对Innodb 存储引擎计数的，累加的算法也略有不同：</p><ol><li><p>Innodb_rows_read select 查询返回的行数；</p></li><li><p>Innodb_rows_inserted 执行Insert 操作插入的行数；</p></li><li><p>Innodb_rows_updated 执行update 操作更新的行数；</p></li><li><p>Innodb_rows_deleted 执行delete 操作删除的行数；</p></li></ol><p>对于事务型的应用，通过Com_commit 和Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。</p><p>此外，以下几个参数便于我们了解数据库的基本情况：</p><ol><li><p>Connections 试图连接Mysql 服务器的次数</p></li><li><p>Uptime 服务器工作时间</p></li><li><p>Slow_queries 慢查询的次数</p></li></ol><h3 id="定位执行效率较低的SQL"><a href="#定位执行效率较低的SQL" class="headerlink" title="定位执行效率较低的SQL"></a>定位执行效率较低的SQL</h3><p>可以通过以下两种方式定位执行效率较低的SQL 语句：</p><ol><li><p>可以通过慢查询日志定位那些执行效率较低的sql 语句，用–log-slowqueries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过long_query_time 秒的SQL语句的日志文件。可以链接到管理维护中的相关章节。</p></li><li><p>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist 命令查看当前MySQL 在进行的线程，包括线程的状态，是否锁表等等，可以实时的查看SQL 执行情况，同时对一些锁表操作进行优化。</p></li></ol><h3 id="通过explain分析低效SQL的执行计划"><a href="#通过explain分析低效SQL的执行计划" class="headerlink" title="通过explain分析低效SQL的执行计划"></a>通过explain分析低效SQL的执行计划</h3><h4 id="select-type：-select-类型"><a href="#select-type：-select-类型" class="headerlink" title="select_type： select 类型"></a>select_type： select 类型</h4><p>A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个</p><p>B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</p><p>C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union</p><p>D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响</p><p>E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</p><p>F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</p><p>G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</p><p>H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</p><h4 id="table：-输出结果集的表"><a href="#table：-输出结果集的表" class="headerlink" title="table： 输出结果集的表"></a>table： 输出结果集的表</h4><p>显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的<derived n="">就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的<union m,n="">，与<derived n="">类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</derived></union></derived></p><h4 id="type：-表示表的连接类型"><a href="#type：-表示表的连接类型" class="headerlink" title="type： 表示表的连接类型"></a>type： 表示表的连接类型</h4><p>当表中仅有一行是type的值为system是最佳的连接类型；</p><p>当select操作中使用索引进行表连接时type的值为ref；</p><p>当select的表连接没有使用索引时，经常会看到type的值为ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。</p><p>依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</p><p>A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p><p>B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</p><p>C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</p><p>D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</p><p>E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p><p>F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</p><p>G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</p><p>H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p><p>I：range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</p><p>J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</p><p>K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p><p>L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p><h4 id="possible-keys：-表示查询时-可以使用的索引列"><a href="#possible-keys：-表示查询时-可以使用的索引列" class="headerlink" title="possible_keys： 表示查询时,可以使用的索引列."></a>possible_keys： 表示查询时,可以使用的索引列.</h4><h4 id="key：-表示使用的索引"><a href="#key：-表示使用的索引" class="headerlink" title="key： 表示使用的索引"></a>key： 表示使用的索引</h4><h4 id="key-len：-索引长度"><a href="#key-len：-索引长度" class="headerlink" title="key_len： 索引长度"></a>key_len： 索引长度</h4><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p><h4 id="rows：-扫描范围"><a href="#rows：-扫描范围" class="headerlink" title="rows： 扫描范围"></a>rows： 扫描范围</h4><h4 id="Extra：-执行情况的说明和描述"><a href="#Extra：-执行情况的说明和描述" class="headerlink" title="Extra： 执行情况的说明和描述"></a>Extra： 执行情况的说明和描述</h4><p>A：distinct：在select部分使用了distinc关键字</p><p>B：no tables used：不带from字句的查询或者From dual查询</p><p>C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</p><p>D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</p><p>E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p><p>F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。</p><p>G：using sort_union，using_union，using intersect，using sort_intersection：</p><p>using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集</p><p>using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集</p><p>using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。</p><p>H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</p><p>I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition</p><p>J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个</p><p>K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p><p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息</p><h3 id="确定问题并采取响应的优化措施"><a href="#确定问题并采取响应的优化措施" class="headerlink" title="确定问题并采取响应的优化措施"></a>确定问题并采取响应的优化措施</h3><h3 id="索引的存储分类"><a href="#索引的存储分类" class="headerlink" title="索引的存储分类"></a>索引的存储分类</h3><p>myisam 表的数据文件和索引文件是自动分开的；innodb 的数据和索引是存储在<br>同一个表空间里面，但可以有多个文件组成。<br>创建索引语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</span><br><span class="line">[USING index_type]</span><br><span class="line">ON tbl_name (index_col_name,...)</span><br><span class="line">index_col_name:</span><br><span class="line">col_name [(length)] [ASC | DESC]</span><br></pre></td></tr></table></figure><p>索引的存储类型目前只有两种（btree 和hash），具体和表的模式相关：</p><p>myisam btree</p><p>innodb btree</p><p>memory/heap hash，btree</p><p>mysql 目前不支持函数索引，只能对列的前一部分（length）进行索引，例：</p><p><code>create index ind_test on table1(name(5))</code></p><p>对于char 和varchar 列，使用前缀索引将大大节省空间。</p><h3 id="MySQL如何使用索引"><a href="#MySQL如何使用索引" class="headerlink" title="MySQL如何使用索引"></a>MySQL如何使用索引</h3><p>索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高SELECT 操作性能的最佳途径。</p><p>查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。</p><p>下列情况下，Mysql 不会使用已有的索引：</p><p>1.如果mysql 估计使用索引比全表扫描更慢，则不使用索引。例如：如果key_part1均匀分布在1 和100 之间，下列查询中使用索引就不是很好：</p><p><code>SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90</code></p><p>2.如果使用heap 表并且where 条件中不用＝索引列，其他&gt; 、&lt;、&gt;=、&lt;=均不使用索引；</p><p>3.如果不是索引列的第一部分；</p><p>4.如果like 是以％开始；</p><p>5.对where 后边条件为字符串的一定要加引号，字符串如果为数字mysql 会自动转为字符串，但是不使用索引。</p><h3 id="查看索引的使用情况"><a href="#查看索引的使用情况" class="headerlink" title="查看索引的使用情况"></a>查看索引的使用情况</h3><p>如果索引正在工作，Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。</p><p>Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明表索引不正确或写入的查询没有利用索引。</p><p><code>show status like &#39;Handler_read%&#39;;</code></p><h3 id="定期分析表"><a href="#定期分析表" class="headerlink" title="定期分析表"></a>定期分析表</h3><h4 id="ANALYZE-TABLE"><a href="#ANALYZE-TABLE" class="headerlink" title="ANALYZE TABLE"></a>ANALYZE TABLE</h4><p>语法：</p><p><code>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM, BDB 和InnoDB 表有作用。对于MyISAM 表，本语句与使用myisamchk -a 相当。</p><h4 id="CHECK-TABLE"><a href="#CHECK-TABLE" class="headerlink" title="CHECK TABLE"></a>CHECK TABLE</h4><p>语法：</p><p><code>CHECK TABLE tbl_name [, tbl_name] ... [option] ...</code></p><p><code>option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}</code></p><p>检查一个或多个表是否有错误。CHECK TABLE 对MyISAM 和InnoDB 表有作用。对于MyISAM 表，关键字统计数据被更新。</p><p>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。</p><h4 id="CHECKSUM-TABLE"><a href="#CHECKSUM-TABLE" class="headerlink" title="CHECKSUM TABLE"></a>CHECKSUM TABLE</h4><p>语法：</p><p><code>CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]</code></p><p>报告一个表校验和。</p><h3 id="使用optimize-table"><a href="#使用optimize-table" class="headerlink" title="使用optimize table"></a>使用optimize table</h3><h4 id="OPTIMIZE-TABLE"><a href="#OPTIMIZE-TABLE" class="headerlink" title="OPTIMIZE TABLE"></a>OPTIMIZE TABLE</h4><p>语法：</p><p><code>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>如果已经删除了表的一大部分，或者如果您已经对含有可变长度行的表（含有VARCHAR, BLOB 或TEXT 列的表）进行了很多更改，则应使用OPTIMIZE TABLE。被删除的记录被保持在链接清单中，后续的INSERT 操作会重新使用旧的记录位置。您可以使用OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。</p><p>OPTIMIZE TABLE 只对MyISAM, BDB 和InnoDB 表起作用。</p><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><h4 id="对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。"><a href="#对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。" class="headerlink" title="对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。"></a>对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tblname DISABLE KEYS;</span><br><span class="line">loading the data</span><br><span class="line">ALTER TABLE tblname ENABLE KEYS;</span><br></pre></td></tr></table></figure><p>这两个命令用来打开或者关闭Myisam 表非唯一索引的更新。在导入大量的数据到一个非空的Myisam 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的Myisam 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。</p><h4 id="而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率："><a href="#而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率：" class="headerlink" title="而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率："></a>而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率：</h4><p>a. 因为Innodb 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果Innodb 表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。</p><p>b. 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SETUNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p><p>c. 如果应用使用自动提交的方式，建议在导入前执行SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p><h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><p>如果你同时从同一客户插入很多行，使用多个值表的INSERT 语句。这比使用分开INSERT 语句快(在一些情况中几倍)。</p><p><code>Insert into test values(1,2),(1,3),(1,4)…</code></p><p>如果你从不同客户插入很多行，能通过使用INSERT DELAYED 语句得到更高的速度。Delayed 的含义是让insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘；这比每条语句分别插入要快的多；LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完后才进行插入。</p><p><code>Insert delayed into test values(1,2),(1,3),(1,4)…</code></p><p><code>Insert low_priority into test values(1,2),(1,3),(1,4)…</code></p><p>将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）。</p><p>如果进行批量插入，可以增加bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对myisam 表使用。</p><p>在my.cnf中添加如下语句，将insert语句的长度设为最大。</p><p><code>Max_allowed_packet=1M</code></p><p><code>Net_buffer_length=2k</code></p><p>当从一个文本文件装载一个表时，使用LOAD DATA INFILE。这通常比使用很多INSERT 语句快20 倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//数据</span><br><span class="line"></span><br><span class="line">1669,Jim,Smith</span><br><span class="line">337,Mary,Jones</span><br><span class="line">2005,Linda,Black</span><br><span class="line"></span><br><span class="line">示例语句：</span><br><span class="line"></span><br><span class="line">load data infile &quot;/data/mysql/e.sql&quot; into table tablename fields terminated by &apos;,&apos;;</span><br></pre></td></tr></table></figure><p>根据应用情况使用replace 语句代替insert。<code>replace low_priority into ta values(1,2);</code><br>replace具备替换拥有唯一索引或者主键索引重复数据的能力，也就是如果使用replaceinto插入的数据的唯一索引或者主键索引与之前的数据有重复的情况，将会删除原先的数据，然后再进行添加。</p><p>根据应用情况使用ignore 关键字忽略重复记录。<br><code>insert ignore into</code><br>当插入数据时，如出现错误时，如重复数据，将不返回错误，只以警告形式返回。所以使用ignore请确保语句本身没有问题，否则也会被忽略掉。例如：<code>INSERT IGNORE INTO books (name) VALUES (&#39;MySQL Manual&#39;)</code></p><h3 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h3><p>默认情况下，MySQL 排序所有GROUP BY col1，col2，….。查询的方法如同在查询中指定ORDER BY col1，col2，…。如果显式包括一个包含相同的列的ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。</p><p>如果查询包括GROUP BY 但你想要避免排序结果的消耗，你可以指定ORDER BY NULL禁止排序。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO foo</span><br><span class="line">SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;</span><br></pre></td></tr></table></figure><h3 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h3><p>在某些情况中，MySQL 可以使用一个索引来满足ORDER BY 子句，而不需要额外的排序。where 条件和order by 使用相同的索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或者都是降序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如：下列sql 可以使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1,key_part2,... ;</span><br><span class="line">SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2</span><br><span class="line">DESC;</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</span><br><span class="line">但是以下情况不使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;</span><br><span class="line">--order by 的字段混合ASC 和DESC</span><br><span class="line">SELECT * FROM t1 WHERE key2=constant ORDER BY key1;</span><br><span class="line">--用于查询行的关键字与ORDER BY 中所使用的不相同</span><br><span class="line">SELECT * FROM t1 ORDER BY key1, key2;</span><br><span class="line">--对不同的关键字使用ORDER BY。</span><br></pre></td></tr></table></figure><h3 id="优化join语句"><a href="#优化join语句" class="headerlink" title="优化join语句"></a>优化join语句</h3><p>Mysql4.1 开始支持SQL 的子查询。这个技术可以使用SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。</p><p>假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><p><code>SELECT * FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerIDFROM salesinfo)</code></p><p>如果使用连接(JOIN).. 来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID 建有索引的话，性能将会更好，查询如下：</p><p><code>SELECT * FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL</code></p><p>连接(JOIN).. 之所以更有效率一些，是因为MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h3 id="mysql如何优化or条件"><a href="#mysql如何优化or条件" class="headerlink" title="mysql如何优化or条件"></a>mysql如何优化or条件</h3><p>对于or 子句，如果要利用索引，则or 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。</p><h3 id="查询优先还是更新优先"><a href="#查询优先还是更新优先" class="headerlink" title="查询优先还是更新优先"></a>查询优先还是更新优先</h3><p>MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。</p><p>我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。</p><p>下面我们提到的改变调度策略的方法主要是针对Myisam 存储引擎的，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。</p><p>MySQL 的默认的调度策略可用总结如下：</p><ol><li><p>写入操作优先于读取操作。</p></li><li><p>对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。</p></li><li><p>对某张数据表的多个读取操作可以同时地进行。</p></li></ol><p>MySQL 提供了几个语句调节符，允许你修改它的调度策略：</p><ol><li><p>LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE。</p></li><li><p>HIGH_PRIORITY关键字应用于SELECT和INSERT语句。</p></li><li><p>DELAYED关键字应用于INSERT和REPLACE语句。</p></li></ol><p>如果写入操作是一个LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在LOW_PRIORITY 写入操作永远被阻塞的情况。</p><p>SELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的SELECT 在正常的SELECT 语句之前执行，因为这些语句会被写入操作阻塞。</p><p>如果你希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么请使用–low-priority-updates 选项来启动服务器。通过使用INSERT HIGH_PRIORITY 来把INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT 语句的影响。</p><h3 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h3><p><code>SELECT SQL_BUFFER_RESULTS ...</code></p><p>将强制MySQL 生成一个临时结果集。只要所有临时结果集生成后，所有表上的锁定均被释放。这能在遇到表锁定问题时或要花很长时间将结果传给客户端时有所帮助。</p><p>当处理一个会让客户端耗费点时间才能处理的大结果集时， 可以考虑使用SQL_BUFFER_RESULT 提示字。这样可以告诉MySQL 将结果集保存在一个临时表中，这样可以尽早的释放各种锁。</p><h4 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h4><p>在你查询语句中表名的后面，添加USE INDEX 来提供你希望MySQ 去参考的索引列表，就可以让MySQL 不再考虑其他可用的索引。</p><p><code>Eg:SELECT * FROM mytable USE INDEX (mod_time, name) ...</code></p><h4 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h4><p>如果你只是单纯的想让MySQL 忽略一个或者多个索引，可以使用IGNORE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytale IGNORE INDEX (priority) ...</code></p><h4 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h4><p>为强制MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytable FORCE INDEX (mod_time) ...</code></p><h3 id="其他优化措施"><a href="#其他优化措施" class="headerlink" title="其他优化措施"></a>其他优化措施</h3><ol><li><p>使用持久的连接数据库以避免连接开销。</p></li><li><p>经常检查所有查询确实使用了必要的索引。</p></li><li><p>避免在频繁更新的表上执行复杂的SELECT 查询，以避免与锁定表有关的由于读、写冲突发生的问题。</p></li><li><p>对于没有删除的行操作的MyISAM 表，插入操作和查询操作可以并行进行，因为没有删除操作的表查询期间不会阻塞插入操作．对于确实需要执行删除操作的表，尽量在空闲时间进行批量删除操作，避免阻塞其他操作。</p></li><li><p>充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少MySQL 需要做的语法分析从而提高插入速度。</p></li><li><p>对经常访问的可以重构的数据使用内存表，可以显著提高访问的效率。</p></li><li><p>通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份期间对应用的影响，可以在复制服务器上执行备份操作。</p></li><li><p>表的字段尽量不使用自增长变量，在高并发情况下该字段的自增可能对效率有比较大的影响，推荐通过应用来实现字段的自增长。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机运行时数据区域</title>
      <link href="/jvm/2018-03-27-jvm-runtime-data-area/"/>
      <url>/jvm/2018-03-27-jvm-runtime-data-area/</url>
      
        <content type="html"><![CDATA[<h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1 运行时数据区域"></a>1 运行时数据区域</h2><p><img src="/media/article/jvm-1.7-later.png" alt="jvm 1.7"></p><h3 id="1-1-程序计数器（Program-Counter-Register）"><a href="#1-1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.1 程序计数器（Program Counter Register）"></a>1.1 程序计数器（Program Counter Register）</h3><ul><li>线程私有的。</li><li>当前线程所执行字节码的行号指示器，字节码解释器的作用是通过改变计数器的值来选取下一条需要执行的字节码指令。</li><li>如果执行的方法不是native的，计数器包含当前正在执行的Java虚拟机指令的地址。</li><li>如果当前执行的是native方法，则这个计数器为<code>undefined</code>。</li><li>Java虚拟机中<strong><em>唯一</em></strong>没有OOM的区域。</li></ul><h3 id="1-2-Java虚拟机栈-（Java-Virtual-Machine-Stacks）"><a href="#1-2-Java虚拟机栈-（Java-Virtual-Machine-Stacks）" class="headerlink" title="1.2 Java虚拟机栈 （Java Virtual Machine Stacks）"></a>1.2 Java虚拟机栈 （Java Virtual Machine Stacks）</h3><ul><li>线程私有的。</li><li>虚拟机栈描述的是Java方法执行的内存模型，生命周期与线程相同。</li><li><strong><em>每个方法运行都会创建一个栈帧</em></strong>，存储局部变量表(Local Variable Table)，局部结果集等信息。</li><li><strong><em>在编译期分配</em></strong>局部变量表存放各种基本数据类型、对象引用类型和returnAddress(指向一条字节码指令的地址)。</li><li>如果请求的栈深度大于最大可用栈深度时，系统就会抛出StackOverflowError错误。</li><li>如果虚拟机动态扩展无法申请到足够的的内存时会抛出OOM异常。大部分虚拟机都可以动态扩展，当然也允许固定长度虚拟机栈。</li></ul><blockquote><p>returnAddress类型的值是指向Java虚拟机指令的操作码的指针。与数字基本类型不同，returnAddress类型不对应任何Java编程语言类型，并且不能由正在运行的程序修改。</p></blockquote><h3 id="1-3-本地方法栈（Native-Method-Stack）"><a href="#1-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="1.3 本地方法栈（Native Method Stack）"></a>1.3 本地方法栈（Native Method Stack）</h3><ul><li>线程私有的。</li><li>虚拟机栈为执行Java方法服务，本地方法栈为Native方法服务。</li><li>会出现OOM或者StackOverflowError，原因和虚拟机栈类似。</li></ul><h3 id="1-4-Java堆（Heap）"><a href="#1-4-Java堆（Heap）" class="headerlink" title="1.4 Java堆（Heap）"></a>1.4 Java堆（Heap）</h3><ul><li>虚拟机启动时创建被所有线程共享的内存区域，为了存储所有对象实例和数组。垃圾回收的主要区域。</li></ul><h3 id="1-5-方法区（Method-Area）"><a href="#1-5-方法区（Method-Area）" class="headerlink" title="1.5 方法区（Method Area）"></a>1.5 方法区（Method Area）</h3><ul><li>别名：“永久代“、”非堆，各个线程共享的内存区域，<strong><em>存储虚拟机已加载的类信息，静态变量、常量、即时编译器编译后的代码数据</em></strong>。默认最小为16MB，最大为64MB，可以通过-XX:PermSize和-XX:MaxPermSize 参数限制方法区大小。</li><li>Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做元空间。</li></ul><h3 id="1-6-运行时常量池（Runtime-Constant-Pool）"><a href="#1-6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="1.6 运行时常量池（Runtime Constant Pool）"></a>1.6 运行时常量池（Runtime Constant Pool）</h3><ul><li>运行时常量池：jdk1.6及之前是方法区的一部分，其中的主要内容来自于JVM对Class的加载。Java7中已经将运行时常量池从方法区（永久代）移除，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。</li><li><strong><em>类加载后</em></strong>存储编译器生成的常量（各种字面量和符号引用）。符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：<a href="https://blog.csdn.net/zhangjg_blog/article/details/21487287" target="_blank" rel="noopener">类和接口的全限定名、字段名称和描述符、方法名称和描述符</a>。</li><li>由于运行时常量池从方法区移动到堆，所以jdk1.6和jdk1.7及之后的版本对于常量池的使用还是有些区别的，<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern</a></li><li>运行时常量池是类文件中constant_pool表的每类或每接口运行时表示。它包含几种常量，从编译时已知的数字值到必须在运行时解析的方法和字段引用。运行时常量池提供类似于传统编程语言的符号表的功能，尽管它包含比典型符号表更宽范围的数据。</li></ul><h3 id="1-7-直接内存-Direct-Memory"><a href="#1-7-直接内存-Direct-Memory" class="headerlink" title="1.7 直接内存(Direct Memory)"></a>1.7 直接内存(Direct Memory)</h3><ul><li>堆外内存，JVM虚拟机各个区域内存总和大于机器物理内存可能会导致OOM。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a><br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.1" target="_blank" rel="noopener">Chapter 2. The Structure of the Java Virtual Machine</a><br><a href="https://www.jianshu.com/p/cf78e68e3a99" target="_blank" rel="noopener">JVM常量池浅析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机内存管理</title>
      <link href="/jvm/2018-03-27-jvm-memory/"/>
      <url>/jvm/2018-03-27-jvm-memory/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JVM的自动内存管理机制"><a href="#1-JVM的自动内存管理机制" class="headerlink" title="1. JVM的自动内存管理机制"></a>1. JVM的自动内存管理机制</h2><h3 id="1-1-对象状态算法"><a href="#1-1-对象状态算法" class="headerlink" title="1.1 对象状态算法"></a>1.1 对象状态算法</h3><ul><li><p>引用计数算法： 很难解决对象之间相互引用的问题，内存泄露。</p></li><li><p>跟搜索算法：通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索的路径成为引用链，当一个对象到GC Root没有一个引用时，则证明此对象是不可用的。</p></li></ul><p>注：1. GC对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI。2. 跟搜索算法中，没有引用的对象并非非死不可，还有经历两次标记，第一次发现没有引用，则进行标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或finalize()已经被调用过，虚拟机将这两种情况都视为没有必要执行。</p><h3 id="1-2-回收方法区"><a href="#1-2-回收方法区" class="headerlink" title="1.2 回收方法区"></a>1.2 回收方法区</h3><p>方法区主要回收废弃变量和无用的类。无用的类：该类所有实例都已被回收，加载该类的ClassLoader被回收，该类对应的java.lang.Class对象没有在任何地方被引用。只有同时满足无用的类的三个条件，才<strong><em>可以</em></strong>被回收。反射、动态代理、CGLib等bytecode框架场景以及频繁定义ClassLoader的场景都需要具备卸载功能，以保证永久代不会溢出。</p><h3 id="1-3-垃圾收集算法"><a href="#1-3-垃圾收集算法" class="headerlink" title="1.3 垃圾收集算法"></a>1.3 垃圾收集算法</h3><ul><li><p>标记清除算法： 标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。效率问题，空间问题（内存碎片）。</p></li><li><p>复制算法： 新生代使用复制算法回收，由于新生代98%的对象都是朝生夕死的，所以不需要1:1的比例划分内存空间（Hotspot默认8:1），而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一个Survivor。当回收时，将Eden和Survivor中还存活的对象一次性的拷贝到另一块的Survivor上。最后清理掉Eden和刚才使用过的Survivor。当Survivor空间不够用时，需要依赖其他的老年代进行分配担保（Handle Promotion）。分配担保：如果Survivor空间没有足够的空间存放上次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p></li><li><p>标记-整理算法：让所有存活的对象向一端移动，然后清理掉端边界以外的内存。老年代常用的算法。</p></li><li><p>分代收集算法： 根据对象的存活周期不同，将内存划分为几块，根据各个年代的特点进行垃圾回收。</p></li></ul><h3 id="1-4-垃圾收集器"><a href="#1-4-垃圾收集器" class="headerlink" title="1.4 垃圾收集器"></a>1.4 垃圾收集器</h3><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/gc.jpg?raw=true" alt="垃圾回收器"><br><a href="#垃圾收集器">图片来自《深入理解Java虚拟机》</a><br>如果两个收集器之间存在连线，就说明他们可以搭配使用。</p><ol><li><p>Serial</p><p> 复制算法，新生代的单线程收集器，简单高效，stop the world。</p></li><li><p>ParNew</p><p> 复制算法，Serial的多线程版本，stop the world。首选的新生代收集器。</p></li><li><p>Parallel Scavenge</p><p> 新生代收集器，使用复制算法，多线程并行, stop the world。目标达到可控制的吞吐量。运行用户代码时间/CPU消耗总时常=吞吐量。该收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMills参数及直接设置吞吐量大小的-XX:GCTimeRatio参数。MaxGCPauseMills参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。GCTimeRatio参数的值应该是一个大于0的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。除了这两个参数，还有一个-XX:+UseAdaptiveSizePolicy值得关注。打开这个参数后，不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大吞吐量这种方式称为GC自适应的调节策略（GC Ergonomics）</p></li><li><p>Serial Old</p><p> Serial收集器的老年代版本，单线程收集器，使用标记-整理算法，stop the world。主要有两个用途：1. 在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候用。</p></li><li><p>Parallel Old</p><p> Parallel Scavenge的老年代版本，标记-整理算法，stop the world。</p></li><li><p>CMS（Concurrent Mark Sweep）收集器</p></li></ol><p>最短回收停顿时间为目标的收集器，重视服务响应速度，标记-清除算法实现。第一款并发收集器，可与用户线程并发执行。执行过程分为4个步骤：初始标记(CMS initial mark)、并发标记(CMS concurrent mark)、重新标记(CMS remark)、并发清除(CMS concurrent sweep)。初始和重新stop the world。初始标记只是标记GCRoots能直接关联的对象，速度很快，并发标记进行GCROOTs Tracing的过程。重新标记为了修复并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。<br>优点：并发收集、低停顿。<br>缺点：1. 对CPU资源非常敏感，解决方案，减少GC线程的独占时间。2. 无法处理浮动垃圾。CMS运行期间，用户线程产生的垃圾为浮动垃圾，CMS无法在本次收集中个清理这些浮动垃圾。如果CMS运行期间，内存无法满足用户线程要求，就会出现Concurrent Mode Failure失败，可能导致另一个FullGC产生，启动预备方案 Serial Old。3. 产生大量的空间碎片。</p><ol start="7"><li><p>G1收集器</p><p> 标记整理算法实现，精确的控制停顿，指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。G1将整个Java堆（老年代，新生代）划分多个大小固定的独立区域（Region），并且追踪这些区域里面的垃圾堆积程度。在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ol><h3 id="1-5-内存分配与回收"><a href="#1-5-内存分配与回收" class="headerlink" title="1.5 内存分配与回收"></a>1.5 内存分配与回收</h3><p>对象在Eden中分配内存，没有足够的空间进行垃圾回收。MinorGC。</p><pre><code>MinorGC: 新生代垃圾回收的动作，频繁且速度快。MajorGC（FullGC）: 指发生在老年代的GC，慢，清理新生代和老年代，CMS</code></pre><p>大对象指需要大量连续空间的Java对象。典型就是很长的字符串和数组。直接进入老年代分配，避免在Eden及Survivor中大量复制拷贝。</p><p>长期生活的对象进入老年代。对象年龄计数器，每一次MinorGC增长1岁。默认15岁进入老年代。</p><p>动态对象年龄判断，如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄段的对象直接进入老年代。</p><p>空间担保分配，每次MinorGC,检测升级到老年代的大小是否大于老年代的空间，如果大于，则进行FullGC。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程简介</title>
      <link href="/concurrency/2017-03-16-thread-brief/"/>
      <url>/concurrency/2017-03-16-thread-brief/</url>
      
        <content type="html"><![CDATA[<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h3><p>现代操作系统在运行程序时，会为其创建一个进程。比如你现在用的浏览器，系统就会为其创建一个甚至多个进程。<strong><em>引入进程的目的是为了更好的使操作系统并发执行程序。来提高资源利用率和系统吞吐量，增加并发程度。</em></strong><br>线程是现代操作系统调度的基本单元，是运行在进程上下文中的逻辑流，是程序执行流的最小单元，也叫轻量级进程（Light Weight Process），也可以称之为CPU的执行单元。一个程序作为一个进程来运行，程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行一个处理器核心上。<strong><em>引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。线程不拥有系统资源（代码，数据、堆、共享库、文件），只拥有运行中必不可少的资源（线程ID, 栈，栈指针，程序计数器、通用目的寄存器和条件码）。</em></strong><br>线程是调度的抽象。<strong><em>Java中将线程的执行和执行对象抽象开来，JDK包中执行的有Thread类，Executor框架，可执行目标有Runaable，Callable。</em></strong></p><h4 id="1-1-线程的优点"><a href="#1-1-线程的优点" class="headerlink" title="1.1 线程的优点"></a>1.1 线程的优点</h4><ol><li>多处理器使用： 提高资源利用率和系统吞吐量。</li></ol><h4 id="1-2-线程的风险"><a href="#1-2-线程的风险" class="headerlink" title="1.2 线程的风险"></a>1.2 线程的风险</h4><ol><li>安全风险：对于共享变量的访问、操作容易造成安全风险。</li><li>活跃度风险：死锁引发活动度失败。</li><li>性能风险：线程之间频繁调度导致上下文切换导致巨大的系统开销。</li></ol><h3 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2. 线程的状态"></a>2. 线程的状态</h3><p><img src="/media/article/ThreadStatus.png" alt="ThreadStatus"><br><a href="#线程简介">图片来自：Java并发编程的艺术-</a></p><ul><li>新建(NEW)：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（READY）。</li></ul><p><strong><em>注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</em></strong></p><ul><li><p>运行状态(RUNNABLE)：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行中”。</p></li><li><p>就绪(READY)：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。</p></li><li><p>运行(RUNNING)：处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>等待状态(WAITING)：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程作出一些特定动作（通知或中断）。</p></li><li><p>超时等待状态(TIME_WAITING)：该状态不同于WAITING，它是可以在指定的时间自行返回的。</p></li><li><p>阻塞(BLOCKED)：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a>关于BLOCKED的描述：Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.翻译：阻塞线程是等待获取同步监视器锁的线程。线程等待获取同步监视器锁进入同步代码块/方法,或者调用Object.wait方法后,被唤醒后等待获取同步监视器锁,<strong><em>重入</em></strong>同步代码块/方法。</p></li><li><p>死亡(DEAD)：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ul><h3 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3. 线程优先级"></a>3. 线程优先级</h3><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。</p><p><strong><em>注：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</em></strong></p><h3 id="4-Daemon线程"><a href="#4-Daemon线程" class="headerlink" title="4. Daemon线程"></a>4. Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用做程序中后台调度及支持性工作。<br><strong><em> 注意：构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</em></strong></p><p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</span><br><span class="line">• Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">    * 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line">    * 该方法必须在启动线程前调用。</span><br><span class="line">    * 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。</span><br><span class="line">    * 这可能抛出 SecurityException（在当前线程中）。   </span><br><span class="line">    *   参数：</span><br><span class="line">    *      on - 如果为 true，则将该线程标记为守护线程。    </span><br><span class="line">    *   抛出：    </span><br><span class="line">    *     IllegalThreadStateException - 如果该线程处于活动状态。    </span><br><span class="line">    *     SecurityException - 如果当前线程无法修改该线程。</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">public final void setDaemon(boolean on)</span><br></pre></td></tr></table></figure><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p><a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">Java多线程详解</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程（1）-读Thread类源码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>红黑树</title>
      <link href="/algorithm/2018-03-07-redblacktree/"/>
      <url>/algorithm/2018-03-07-redblacktree/</url>
      
        <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是很多平衡二叉搜索树中的一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为O(logn)。</p><p>满足下面红黑性质的二叉搜索树就是红黑树：</p><ul><li>每个节点要么是红色的，要么是黑色的。</li><li>跟节点是黑色的。</li><li>每个叶子节点是黑色的。</li><li>如果一个节点是红色的，则它的两个子节点都是黑色的。</li><li>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数量的黑色节点。</li></ul><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>红黑树每条路径的黑色节点数目都相同，所以随意遍历一条路径，计算这条路上的黑色节点的数目。以该数据为标杆，和其他路径的黑色节点数目作比较，判断是否都相同。<br>如果当前节点是红颜色并且它有父节点，那么再判断父节点的颜色是否也是红色，这样就能判断该树是否满足连续两个节点不能同时为红色这一性质。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><h2 id="红黑树和平衡二叉树的区别"><a href="#红黑树和平衡二叉树的区别" class="headerlink" title="红黑树和平衡二叉树的区别"></a>红黑树和平衡二叉树的区别</h2><ul><li><p>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。</p></li><li><p>平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p></li></ul><p>平衡二叉树又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。构造与调整方法 平衡二叉树的常用算法有红黑树、AVL、Treap等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">算法导论(原书第3版) 殷建平，徐云，王刚，刘晓光，苏明，邹恒明，王宏志译 机械工业出版社.</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>经典面试题整理</title>
      <link href="/interfaceview/2018-03-02-classic-interview-questions/"/>
      <url>/interfaceview/2018-03-02-classic-interview-questions/</url>
      
        <content type="html"><![CDATA[<h2 id="corejava"><a href="#corejava" class="headerlink" title="corejava"></a>corejava</h2><h3 id="1-hashcode-相等两个类一定相等么？equals呢？相反呢？"><a href="#1-hashcode-相等两个类一定相等么？equals呢？相反呢？" class="headerlink" title="1. hashcode 相等两个类一定相等么？equals呢？相反呢？"></a>1. hashcode 相等两个类一定相等么？equals呢？相反呢？</h3><h3 id="2-介绍一下集合框架"><a href="#2-介绍一下集合框架" class="headerlink" title="2. 介绍一下集合框架"></a>2. 介绍一下集合框架</h3><h3 id="3-hashmap-hashtable-底层实现什么区别？hashtale和concurrenthashmap呢？"><a href="#3-hashmap-hashtable-底层实现什么区别？hashtale和concurrenthashmap呢？" class="headerlink" title="3. hashmap hashtable 底层实现什么区别？hashtale和concurrenthashmap呢？"></a>3. hashmap hashtable 底层实现什么区别？hashtale和concurrenthashmap呢？</h3><h3 id="4-hashmap和treemap-什么区别？底层数据结构呢？"><a href="#4-hashmap和treemap-什么区别？底层数据结构呢？" class="headerlink" title="4. hashmap和treemap 什么区别？底层数据结构呢？"></a>4. hashmap和treemap 什么区别？底层数据结构呢？</h3><h3 id="5-线程池用过么？都有什么参数？底层如何实现的？"><a href="#5-线程池用过么？都有什么参数？底层如何实现的？" class="headerlink" title="5. 线程池用过么？都有什么参数？底层如何实现的？"></a>5. 线程池用过么？都有什么参数？底层如何实现的？</h3><h3 id="6-sychnized和Lock什么区别？sychnize什么情况是对象锁，什么时候是全局锁？为什么？"><a href="#6-sychnized和Lock什么区别？sychnize什么情况是对象锁，什么时候是全局锁？为什么？" class="headerlink" title="6. sychnized和Lock什么区别？sychnize什么情况是对象锁，什么时候是全局锁？为什么？"></a>6. sychnized和Lock什么区别？sychnize什么情况是对象锁，什么时候是全局锁？为什么？</h3><h3 id="7-ThreadLocal-是什么？底层如何实现？写一个例子？"><a href="#7-ThreadLocal-是什么？底层如何实现？写一个例子？" class="headerlink" title="7. ThreadLocal 是什么？底层如何实现？写一个例子？"></a>7. ThreadLocal 是什么？底层如何实现？写一个例子？</h3><h3 id="8-volitile的工作原理？"><a href="#8-volitile的工作原理？" class="headerlink" title="8. volitile的工作原理？"></a>8. volitile的工作原理？</h3><h3 id="9-cas知道么？如何实现的？"><a href="#9-cas知道么？如何实现的？" class="headerlink" title="9. cas知道么？如何实现的？"></a>9. cas知道么？如何实现的？</h3><h3 id="10-请用至少四种写法？写一个单例模式？"><a href="#10-请用至少四种写法？写一个单例模式？" class="headerlink" title="10. 请用至少四种写法？写一个单例模式？"></a>10. 请用至少四种写法？写一个单例模式？</h3><h3 id="11-Hashmap为什么不用平衡树？"><a href="#11-Hashmap为什么不用平衡树？" class="headerlink" title="11. Hashmap为什么不用平衡树？"></a>11. Hashmap为什么不用平衡树？</h3><h3 id="12-Java有哪些队列？"><a href="#12-Java有哪些队列？" class="headerlink" title="12. Java有哪些队列？"></a>12. Java有哪些队列？</h3><h3 id="13-HashMap了解么吗？说一下put方法过程"><a href="#13-HashMap了解么吗？说一下put方法过程" class="headerlink" title="13. HashMap了解么吗？说一下put方法过程"></a>13. HashMap了解么吗？说一下put方法过程</h3><h3 id="14-HashMap是不是线程安全？"><a href="#14-HashMap是不是线程安全？" class="headerlink" title="14. HashMap是不是线程安全？"></a>14. HashMap是不是线程安全？</h3><h3 id="15-ConcurrentHashMap如何保证线程安全？"><a href="#15-ConcurrentHashMap如何保证线程安全？" class="headerlink" title="15. ConcurrentHashMap如何保证线程安全？"></a>15. ConcurrentHashMap如何保证线程安全？</h3><h3 id="16-深入问了乐观锁，悲观锁及其实现。"><a href="#16-深入问了乐观锁，悲观锁及其实现。" class="headerlink" title="16. 深入问了乐观锁，悲观锁及其实现。"></a>16. 深入问了乐观锁，悲观锁及其实现。</h3><h3 id="17-设计模式了解吗？讲一下"><a href="#17-设计模式了解吗？讲一下" class="headerlink" title="17. 设计模式了解吗？讲一下"></a>17. 设计模式了解吗？讲一下</h3><h3 id="18-private-修饰的方法可以通过反射访问，那么private意义是什么？"><a href="#18-private-修饰的方法可以通过反射访问，那么private意义是什么？" class="headerlink" title="18. private 修饰的方法可以通过反射访问，那么private意义是什么？"></a>18. private 修饰的方法可以通过反射访问，那么private意义是什么？</h3><h3 id="19-Java类的初始化顺序？"><a href="#19-Java类的初始化顺序？" class="headerlink" title="19. Java类的初始化顺序？"></a>19. Java类的初始化顺序？</h3><h3 id="20-对方法区和永久区的理解以及它们之间的关系？"><a href="#20-对方法区和永久区的理解以及它们之间的关系？" class="headerlink" title="20. 对方法区和永久区的理解以及它们之间的关系？"></a>20. 对方法区和永久区的理解以及它们之间的关系？</h3><h3 id="21-一个Java文件有3个类编译后有几个类文件？"><a href="#21-一个Java文件有3个类编译后有几个类文件？" class="headerlink" title="21. 一个Java文件有3个类编译后有几个类文件？"></a>21. 一个Java文件有3个类编译后有几个类文件？</h3><h3 id="22-局部变量使用前需要显式的赋值，否则编译不通过，为什么？"><a href="#22-局部变量使用前需要显式的赋值，否则编译不通过，为什么？" class="headerlink" title="22. 局部变量使用前需要显式的赋值，否则编译不通过，为什么？"></a>22. 局部变量使用前需要显式的赋值，否则编译不通过，为什么？</h3><h3 id="23-ReadWriteLock读写之间互斥么？"><a href="#23-ReadWriteLock读写之间互斥么？" class="headerlink" title="23. ReadWriteLock读写之间互斥么？"></a>23. ReadWriteLock读写之间互斥么？</h3><h3 id="24-写一个你认为最好的单例模式"><a href="#24-写一个你认为最好的单例模式" class="headerlink" title="24. 写一个你认为最好的单例模式"></a>24. 写一个你认为最好的单例模式</h3><h3 id="25-B树和B-树是解决什么样的问题的，怎样演化的，之间的区别？"><a href="#25-B树和B-树是解决什么样的问题的，怎样演化的，之间的区别？" class="headerlink" title="25. B树和B+树是解决什么样的问题的，怎样演化的，之间的区别？"></a>25. B树和B+树是解决什么样的问题的，怎样演化的，之间的区别？</h3><h3 id="26-写一个生产者和消费者模式"><a href="#26-写一个生产者和消费者模式" class="headerlink" title="26. 写一个生产者和消费者模式"></a>26. 写一个生产者和消费者模式</h3><h3 id="27-写一个死锁"><a href="#27-写一个死锁" class="headerlink" title="27. 写一个死锁"></a>27. 写一个死锁</h3><h3 id="28-cpu-100-定位"><a href="#28-cpu-100-定位" class="headerlink" title="28. cpu 100%定位"></a>28. cpu 100%定位</h3><h3 id="29-String-a-”ab”-String-a-“a”-”b”-a-b是否相等，为什么。"><a href="#29-String-a-”ab”-String-a-“a”-”b”-a-b是否相等，为什么。" class="headerlink" title="29. String a=”ab”;String a = “a”+”b”;a==b是否相等，为什么。"></a>29. String a=”ab”;String a = “a”+”b”;a==b是否相等，为什么。</h3><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><h3 id="1-AQS知道吗？知道哪一些呢？讲一讲。"><a href="#1-AQS知道吗？知道哪一些呢？讲一讲。" class="headerlink" title="1. AQS知道吗？知道哪一些呢？讲一讲。"></a>1. AQS知道吗？知道哪一些呢？讲一讲。</h3><h3 id="2-CLH同步队列是怎么实现非公平和公平的？"><a href="#2-CLH同步队列是怎么实现非公平和公平的？" class="headerlink" title="2. CLH同步队列是怎么实现非公平和公平的？"></a>2. CLH同步队列是怎么实现非公平和公平的？</h3><h3 id="3-ReetrantLock和synchronized的区别"><a href="#3-ReetrantLock和synchronized的区别" class="headerlink" title="3. ReetrantLock和synchronized的区别"></a>3. ReetrantLock和synchronized的区别</h3><h3 id="4-如何才能得到一个线程安全的HashMap？"><a href="#4-如何才能得到一个线程安全的HashMap？" class="headerlink" title="4. 如何才能得到一个线程安全的HashMap？"></a>4. 如何才能得到一个线程安全的HashMap？</h3><h3 id="5-线程池的参数"><a href="#5-线程池的参数" class="headerlink" title="5. 线程池的参数"></a>5. 线程池的参数</h3><h3 id="6-CAS的问题，讲一下解决方案。"><a href="#6-CAS的问题，讲一下解决方案。" class="headerlink" title="6. CAS的问题，讲一下解决方案。"></a>6. CAS的问题，讲一下解决方案。</h3><h3 id="7-有没有更好的计数器解决策略"><a href="#7-有没有更好的计数器解决策略" class="headerlink" title="7. 有没有更好的计数器解决策略"></a>7. 有没有更好的计数器解决策略</h3><h3 id="8-原子变量的实现原理"><a href="#8-原子变量的实现原理" class="headerlink" title="8. 原子变量的实现原理"></a>8. 原子变量的实现原理</h3><h3 id="9-wait-和sleep-的区别"><a href="#9-wait-和sleep-的区别" class="headerlink" title="9. wait()和sleep()的区别"></a>9. wait()和sleep()的区别</h3><h3 id="10-线程池的原理以及各种线程池的应用场景"><a href="#10-线程池的原理以及各种线程池的应用场景" class="headerlink" title="10. 线程池的原理以及各种线程池的应用场景"></a>10. 线程池的原理以及各种线程池的应用场景</h3><h3 id="11-线程池中使用有限的阻塞队列和无限的阻塞队列的区别"><a href="#11-线程池中使用有限的阻塞队列和无限的阻塞队列的区别" class="headerlink" title="11. 线程池中使用有限的阻塞队列和无限的阻塞队列的区别"></a>11. 线程池中使用有限的阻塞队列和无限的阻塞队列的区别</h3><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-请介绍一下JVM内存模型？用过什么垃圾回收器，都说说？"><a href="#1-请介绍一下JVM内存模型？用过什么垃圾回收器，都说说？" class="headerlink" title="1. 请介绍一下JVM内存模型？用过什么垃圾回收器，都说说？"></a>1. 请介绍一下JVM内存模型？用过什么垃圾回收器，都说说？</h3><h3 id="2-线上发送频繁full-gc如何处理？CPU使用率过高怎么办？如何定位问题？如何解决？说一下解决思路和处理方法。"><a href="#2-线上发送频繁full-gc如何处理？CPU使用率过高怎么办？如何定位问题？如何解决？说一下解决思路和处理方法。" class="headerlink" title="2. 线上发送频繁full gc如何处理？CPU使用率过高怎么办？如何定位问题？如何解决？说一下解决思路和处理方法。"></a>2. 线上发送频繁full gc如何处理？CPU使用率过高怎么办？如何定位问题？如何解决？说一下解决思路和处理方法。</h3><h3 id="3-知道字节码么？字节码都有那些？Integer-5-int-y-5-比较x-y-都经过那些步骤？"><a href="#3-知道字节码么？字节码都有那些？Integer-5-int-y-5-比较x-y-都经过那些步骤？" class="headerlink" title="3. 知道字节码么？字节码都有那些？Integer * 5,int y=5, 比较x==y 都经过那些步骤？"></a>3. 知道字节码么？字节码都有那些？Integer * 5,int y=5, 比较x==y 都经过那些步骤？</h3><h3 id="4-讲讲类加载机制？都有哪些类加载器，这些类加载器都加载哪些文件？手写一下类加载Demo"><a href="#4-讲讲类加载机制？都有哪些类加载器，这些类加载器都加载哪些文件？手写一下类加载Demo" class="headerlink" title="4. 讲讲类加载机制？都有哪些类加载器，这些类加载器都加载哪些文件？手写一下类加载Demo"></a>4. 讲讲类加载机制？都有哪些类加载器，这些类加载器都加载哪些文件？手写一下类加载Demo</h3><h3 id="5-知道osgi么？他是如何实现的？"><a href="#5-知道osgi么？他是如何实现的？" class="headerlink" title="5. 知道osgi么？他是如何实现的？"></a>5. 知道osgi么？他是如何实现的？</h3><h3 id="6-请问你做过哪些JVM优化？使用什么方法？达到什么效果？"><a href="#6-请问你做过哪些JVM优化？使用什么方法？达到什么效果？" class="headerlink" title="6. 请问你做过哪些JVM优化？使用什么方法？达到什么效果？"></a>6. 请问你做过哪些JVM优化？使用什么方法？达到什么效果？</h3><h3 id="7-class-forName-“java-lang-String”-和String-class-getClassLoader-loadClass-“java-lang-String”-什么区别？"><a href="#7-class-forName-“java-lang-String”-和String-class-getClassLoader-loadClass-“java-lang-String”-什么区别？" class="headerlink" title="7. class.forName(“java.lang.String”)和String.class.getClassLoader.loadClass(“java.lang.String”)什么区别？"></a>7. class.forName(“java.lang.String”)和String.class.getClassLoader.loadClass(“java.lang.String”)什么区别？</h3><h3 id="8-讲一下JVM的内存结构"><a href="#8-讲一下JVM的内存结构" class="headerlink" title="8. 讲一下JVM的内存结构"></a>8. 讲一下JVM的内存结构</h3><h3 id="9-JVM-里-new-对象时，堆会发生抢占吗？你是怎么去设计JVM的堆的线程安全的？"><a href="#9-JVM-里-new-对象时，堆会发生抢占吗？你是怎么去设计JVM的堆的线程安全的？" class="headerlink" title="9. JVM 里 new 对象时，堆会发生抢占吗？你是怎么去设计JVM的堆的线程安全的？"></a>9. JVM 里 new 对象时，堆会发生抢占吗？你是怎么去设计JVM的堆的线程安全的？</h3><h3 id="10-讲一下JVM常用垃圾回收期？"><a href="#10-讲一下JVM常用垃圾回收期？" class="headerlink" title="10. 讲一下JVM常用垃圾回收期？"></a>10. 讲一下JVM常用垃圾回收期？</h3><h3 id="11-JVM内存模型"><a href="#11-JVM内存模型" class="headerlink" title="11. JVM内存模型"></a>11. JVM内存模型</h3><h3 id="12-Java怎么加载类？"><a href="#12-Java怎么加载类？" class="headerlink" title="12. Java怎么加载类？"></a>12. Java怎么加载类？</h3><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="1-spring都有哪些机制？AOP底层如何实现的？IOC？"><a href="#1-spring都有哪些机制？AOP底层如何实现的？IOC？" class="headerlink" title="1. spring都有哪些机制？AOP底层如何实现的？IOC？"></a>1. spring都有哪些机制？AOP底层如何实现的？IOC？</h3><h3 id="2-cglib知道么？它和JDK动态代理有什么区别？手写一个jdk动态代理？"><a href="#2-cglib知道么？它和JDK动态代理有什么区别？手写一个jdk动态代理？" class="headerlink" title="2. cglib知道么？它和JDK动态代理有什么区别？手写一个jdk动态代理？"></a>2. cglib知道么？它和JDK动态代理有什么区别？手写一个jdk动态代理？</h3><h3 id="3-如何解决bean的循环依赖问题？"><a href="#3-如何解决bean的循环依赖问题？" class="headerlink" title="3. 如何解决bean的循环依赖问题？"></a>3. 如何解决bean的循环依赖问题？</h3><h3 id="4-讲一讲Spring和Springboot的区别"><a href="#4-讲一讲Spring和Springboot的区别" class="headerlink" title="4. 讲一讲Spring和Springboot的区别"></a>4. 讲一讲Spring和Springboot的区别</h3><h3 id="5-讲一下ORM框架Hibernate"><a href="#5-讲一下ORM框架Hibernate" class="headerlink" title="5. 讲一下ORM框架Hibernate"></a>5. 讲一下ORM框架Hibernate</h3><h3 id="6-Spring-AOP原理是什么？怎么使用？什么是切点，什么是切面？最好是举个例子"><a href="#6-Spring-AOP原理是什么？怎么使用？什么是切点，什么是切面？最好是举个例子" class="headerlink" title="6. Spring AOP原理是什么？怎么使用？什么是切点，什么是切面？最好是举个例子"></a>6. Spring AOP原理是什么？怎么使用？什么是切点，什么是切面？最好是举个例子</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1-使用mysql索引都有哪些原则？索引什么数据结构？B-tree和B-tree什么区别？"><a href="#1-使用mysql索引都有哪些原则？索引什么数据结构？B-tree和B-tree什么区别？" class="headerlink" title="1. 使用mysql索引都有哪些原则？索引什么数据结构？B+tree和B tree什么区别？"></a>1. 使用mysql索引都有哪些原则？索引什么数据结构？B+tree和B tree什么区别？</h3><h3 id="2-mysql有哪些存储引擎啊？都有啥区别？要详细？"><a href="#2-mysql有哪些存储引擎啊？都有啥区别？要详细？" class="headerlink" title="2. mysql有哪些存储引擎啊？都有啥区别？要详细？"></a>2. mysql有哪些存储引擎啊？都有啥区别？要详细？</h3><h3 id="3-设计高并发系统数据库层面该怎么设计？数据库锁有哪些类型？如何实现？"><a href="#3-设计高并发系统数据库层面该怎么设计？数据库锁有哪些类型？如何实现？" class="headerlink" title="3. 设计高并发系统数据库层面该怎么设计？数据库锁有哪些类型？如何实现？"></a>3. 设计高并发系统数据库层面该怎么设计？数据库锁有哪些类型？如何实现？</h3><h3 id="4-数据库事务有哪些？"><a href="#4-数据库事务有哪些？" class="headerlink" title="4. 数据库事务有哪些？"></a>4. 数据库事务有哪些？</h3><h3 id="5-讲一讲MySQL的索引结构？"><a href="#5-讲一讲MySQL的索引结构？" class="headerlink" title="5. 讲一讲MySQL的索引结构？"></a>5. 讲一讲MySQL的索引结构？</h3><h3 id="6-你设计的数据库遵循的范式？"><a href="#6-你设计的数据库遵循的范式？" class="headerlink" title="6.你设计的数据库遵循的范式？"></a>6.你设计的数据库遵循的范式？</h3><h3 id="7-讲一下B树和B-树的区别"><a href="#7-讲一下B树和B-树的区别" class="headerlink" title="7. 讲一下B树和B+树的区别"></a>7. 讲一下B树和B+树的区别</h3><h3 id="8-数据库索引了解吗？讲一下"><a href="#8-数据库索引了解吗？讲一下" class="headerlink" title="8. 数据库索引了解吗？讲一下"></a>8. 数据库索引了解吗？讲一下</h3><h3 id="9-自己实现一个二阶段提交，如何设计？"><a href="#9-自己实现一个二阶段提交，如何设计？" class="headerlink" title="9. 自己实现一个二阶段提交，如何设计？"></a>9. 自己实现一个二阶段提交，如何设计？</h3><h3 id="10-如果你发现你的sql语句始终走另一个索引，但是你希望它走你想要的索引，怎么办？"><a href="#10-如果你发现你的sql语句始终走另一个索引，但是你希望它走你想要的索引，怎么办？" class="headerlink" title="10. 如果你发现你的sql语句始终走另一个索引，但是你希望它走你想要的索引，怎么办？"></a>10. 如果你发现你的sql语句始终走另一个索引，但是你希望它走你想要的索引，怎么办？</h3><h3 id="11-mysql执行计划"><a href="#11-mysql执行计划" class="headerlink" title="11. mysql执行计划"></a>11. mysql执行计划</h3><h3 id="12-数据库索引为什么用b-树？"><a href="#12-数据库索引为什么用b-树？" class="headerlink" title="12. 数据库索引为什么用b+树？"></a>12. 数据库索引为什么用b+树？</h3><h3 id="13-你在做sql优化主要从哪几个方面做，用到哪些方法工具？"><a href="#13-你在做sql优化主要从哪几个方面做，用到哪些方法工具？" class="headerlink" title="13. 你在做sql优化主要从哪几个方面做，用到哪些方法工具？"></a>13. 你在做sql优化主要从哪几个方面做，用到哪些方法工具？</h3><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="1-如何设计可以动态扩容缩容的分库分表方案？"><a href="#1-如何设计可以动态扩容缩容的分库分表方案？" class="headerlink" title="1. 如何设计可以动态扩容缩容的分库分表方案？"></a>1. 如何设计可以动态扩容缩容的分库分表方案？</h3><h3 id="2-用过哪些分库分表的中间件，有啥优点和缺点，讲一下你了解的分库分表中间件的底层实现原理。"><a href="#2-用过哪些分库分表的中间件，有啥优点和缺点，讲一下你了解的分库分表中间件的底层实现原理。" class="headerlink" title="2. 用过哪些分库分表的中间件，有啥优点和缺点，讲一下你了解的分库分表中间件的底层实现原理。"></a>2. 用过哪些分库分表的中间件，有啥优点和缺点，讲一下你了解的分库分表中间件的底层实现原理。</h3><h3 id="3-我现在有一个未分库分表的系统，以后系统需要分库分表，如何设计，让未分库分表的系统动态切换到分库分表系统上？"><a href="#3-我现在有一个未分库分表的系统，以后系统需要分库分表，如何设计，让未分库分表的系统动态切换到分库分表系统上？" class="headerlink" title="3. 我现在有一个未分库分表的系统，以后系统需要分库分表，如何设计，让未分库分表的系统动态切换到分库分表系统上？"></a>3. 我现在有一个未分库分表的系统，以后系统需要分库分表，如何设计，让未分库分表的系统动态切换到分库分表系统上？</h3><h3 id="4-分布式事务知道么？-你们怎么解决的？-TCC-那若出现网络原因，网络连不通怎么办啊？"><a href="#4-分布式事务知道么？-你们怎么解决的？-TCC-那若出现网络原因，网络连不通怎么办啊？" class="headerlink" title="4. 分布式事务知道么？ 你们怎么解决的？ TCC?那若出现网络原因，网络连不通怎么办啊？"></a>4. 分布式事务知道么？ 你们怎么解决的？ TCC?那若出现网络原因，网络连不通怎么办啊？</h3><h3 id="5-为什么分库分表？"><a href="#5-为什么分库分表？" class="headerlink" title="5. 为什么分库分表？"></a>5. 为什么分库分表？</h3><h3 id="6-分布式寻址方式都有哪些算法？知道一致hash么？手写一下Java实现代码？你若userId取模分片，那我要查一段连续时间里的数据怎么办？"><a href="#6-分布式寻址方式都有哪些算法？知道一致hash么？手写一下Java实现代码？你若userId取模分片，那我要查一段连续时间里的数据怎么办？" class="headerlink" title="6. 分布式寻址方式都有哪些算法？知道一致hash么？手写一下Java实现代码？你若userId取模分片，那我要查一段连续时间里的数据怎么办？"></a>6. 分布式寻址方式都有哪些算法？知道一致hash么？手写一下Java实现代码？你若userId取模分片，那我要查一段连续时间里的数据怎么办？</h3><h3 id="7-如何解决分库分表主键问题？有什么实现方案？"><a href="#7-如何解决分库分表主键问题？有什么实现方案？" class="headerlink" title="7. 如何解决分库分表主键问题？有什么实现方案？"></a>7. 如何解决分库分表主键问题？有什么实现方案？</h3><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="1-redis和memched-什么区别？为什么单线程的redis比多线程的memched效率要高？"><a href="#1-redis和memched-什么区别？为什么单线程的redis比多线程的memched效率要高？" class="headerlink" title="1. redis和memched 什么区别？为什么单线程的redis比多线程的memched效率要高？"></a>1. redis和memched 什么区别？为什么单线程的redis比多线程的memched效率要高？</h3><h3 id="2-redis有什么数据类型？都在哪些场景下使用？"><a href="#2-redis有什么数据类型？都在哪些场景下使用？" class="headerlink" title="2. redis有什么数据类型？都在哪些场景下使用？"></a>2. redis有什么数据类型？都在哪些场景下使用？</h3><h3 id="3-redis的主从复制是怎么实现的？redis的集群模式是如何实现的呢？redis的key是如何寻址的？"><a href="#3-redis的主从复制是怎么实现的？redis的集群模式是如何实现的呢？redis的key是如何寻址的？" class="headerlink" title="3. redis的主从复制是怎么实现的？redis的集群模式是如何实现的呢？redis的key是如何寻址的？"></a>3. redis的主从复制是怎么实现的？redis的集群模式是如何实现的呢？redis的key是如何寻址的？</h3><h3 id="4-使用redis如何设计分布式锁？使用zk可以么？如何实现？这两种哪个效率更高？"><a href="#4-使用redis如何设计分布式锁？使用zk可以么？如何实现？这两种哪个效率更高？" class="headerlink" title="4. 使用redis如何设计分布式锁？使用zk可以么？如何实现？这两种哪个效率更高？"></a>4. 使用redis如何设计分布式锁？使用zk可以么？如何实现？这两种哪个效率更高？</h3><h3 id="5-知道redis的持久化么？有什么优点和缺点？具体底层实现呢？"><a href="#5-知道redis的持久化么？有什么优点和缺点？具体底层实现呢？" class="headerlink" title="5. 知道redis的持久化么？有什么优点和缺点？具体底层实现呢？"></a>5. 知道redis的持久化么？有什么优点和缺点？具体底层实现呢？</h3><h3 id="6-redis过期策略都有哪些？LRU？写一下Java版本代码？"><a href="#6-redis过期策略都有哪些？LRU？写一下Java版本代码？" class="headerlink" title="6. redis过期策略都有哪些？LRU？写一下Java版本代码？"></a>6. redis过期策略都有哪些？LRU？写一下Java版本代码？</h3><h3 id="7-讲一下redis的数据结构"><a href="#7-讲一下redis的数据结构" class="headerlink" title="7. 讲一下redis的数据结构"></a>7. 讲一下redis的数据结构</h3><h3 id="8-redis缓存同步问题"><a href="#8-redis缓存同步问题" class="headerlink" title="8. redis缓存同步问题"></a>8. redis缓存同步问题</h3><h3 id="9-redis分布式锁"><a href="#9-redis分布式锁" class="headerlink" title="9. redis分布式锁"></a>9. redis分布式锁</h3><h3 id="10-在项目中，并发量大的情况下，如何才能够保证数据的一致性？"><a href="#10-在项目中，并发量大的情况下，如何才能够保证数据的一致性？" class="headerlink" title="10. 在项目中，并发量大的情况下，如何才能够保证数据的一致性？"></a>10. 在项目中，并发量大的情况下，如何才能够保证数据的一致性？</h3><h3 id="11-为什么使用Redis作为缓存"><a href="#11-为什么使用Redis作为缓存" class="headerlink" title="11. 为什么使用Redis作为缓存"></a>11. 为什么使用Redis作为缓存</h3><h3 id="12-讲一下Redis分布式锁的实现"><a href="#12-讲一下Redis分布式锁的实现" class="headerlink" title="12. 讲一下Redis分布式锁的实现"></a>12. 讲一下Redis分布式锁的实现</h3><h3 id="13-讲一下redis的数据类型和使用场景"><a href="#13-讲一下redis的数据类型和使用场景" class="headerlink" title="13. 讲一下redis的数据类型和使用场景"></a>13. 讲一下redis的数据类型和使用场景</h3><h2 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h2><h3 id="1-说一下dubbo的实现过程，注册中心挂了可以继续通信么？"><a href="#1-说一下dubbo的实现过程，注册中心挂了可以继续通信么？" class="headerlink" title="1. 说一下dubbo的实现过程，注册中心挂了可以继续通信么？"></a>1. 说一下dubbo的实现过程，注册中心挂了可以继续通信么？</h3><h3 id="2-zk原理知道么？zk都可以干什么？paxos算法知道么？说一下原理和实现？"><a href="#2-zk原理知道么？zk都可以干什么？paxos算法知道么？说一下原理和实现？" class="headerlink" title="2. zk原理知道么？zk都可以干什么？paxos算法知道么？说一下原理和实现？"></a>2. zk原理知道么？zk都可以干什么？paxos算法知道么？说一下原理和实现？</h3><h3 id="3-dubbo支持哪些序列化协议？hessian？说一下hessian的数据结构？PB知道么？为啥PB效率是最高的？"><a href="#3-dubbo支持哪些序列化协议？hessian？说一下hessian的数据结构？PB知道么？为啥PB效率是最高的？" class="headerlink" title="3. dubbo支持哪些序列化协议？hessian？说一下hessian的数据结构？PB知道么？为啥PB效率是最高的？"></a>3. dubbo支持哪些序列化协议？hessian？说一下hessian的数据结构？PB知道么？为啥PB效率是最高的？</h3><h3 id="4-知道netty么？netty可以干嘛？NIO-BIO-AIO都是什么啊？有什么区别？"><a href="#4-知道netty么？netty可以干嘛？NIO-BIO-AIO都是什么啊？有什么区别？" class="headerlink" title="4. 知道netty么？netty可以干嘛？NIO,BIO,AIO都是什么啊？有什么区别？"></a>4. 知道netty么？netty可以干嘛？NIO,BIO,AIO都是什么啊？有什么区别？</h3><h3 id="5-dubbo复制均衡策略和高可用策略都有哪些？动态代理策略呢？"><a href="#5-dubbo复制均衡策略和高可用策略都有哪些？动态代理策略呢？" class="headerlink" title="5. dubbo复制均衡策略和高可用策略都有哪些？动态代理策略呢？"></a>5. dubbo复制均衡策略和高可用策略都有哪些？动态代理策略呢？</h3><h3 id="6-为什么要进行系统拆分啊？拆分不用dubbo可以么？dubbo和thrift什么区别啊？"><a href="#6-为什么要进行系统拆分啊？拆分不用dubbo可以么？dubbo和thrift什么区别啊？" class="headerlink" title="6. 为什么要进行系统拆分啊？拆分不用dubbo可以么？dubbo和thrift什么区别啊？"></a>6. 为什么要进行系统拆分啊？拆分不用dubbo可以么？dubbo和thrift什么区别啊？</h3><h2 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h2><h3 id="1-为什么使用消息队列？消息队列有什么优点和缺点？"><a href="#1-为什么使用消息队列？消息队列有什么优点和缺点？" class="headerlink" title="1. 为什么使用消息队列？消息队列有什么优点和缺点？"></a>1. 为什么使用消息队列？消息队列有什么优点和缺点？</h3><h3 id="2-如何保证消息队列的高可用？如何保证消息不被重复消费？"><a href="#2-如何保证消息队列的高可用？如何保证消息不被重复消费？" class="headerlink" title="2. 如何保证消息队列的高可用？如何保证消息不被重复消费？"></a>2. 如何保证消息队列的高可用？如何保证消息不被重复消费？</h3><h3 id="3-kafka，activemq，rabbitmq，rocketmq都有什么优点和缺点？"><a href="#3-kafka，activemq，rabbitmq，rocketmq都有什么优点和缺点？" class="headerlink" title="3. kafka，activemq，rabbitmq，rocketmq都有什么优点和缺点？"></a>3. kafka，activemq，rabbitmq，rocketmq都有什么优点和缺点？</h3><h3 id="4-如果让你写一个消息队列，该如何进行架构设计？说一下你的思路？"><a href="#4-如果让你写一个消息队列，该如何进行架构设计？说一下你的思路？" class="headerlink" title="4. 如果让你写一个消息队列，该如何进行架构设计？说一下你的思路？"></a>4. 如果让你写一个消息队列，该如何进行架构设计？说一下你的思路？</h3><h2 id="分布式搜索引擎"><a href="#分布式搜索引擎" class="headerlink" title="分布式搜索引擎"></a>分布式搜索引擎</h2><h3 id="1-es的工作过程实现是如何的？如何实现分布式的啊？"><a href="#1-es的工作过程实现是如何的？如何实现分布式的啊？" class="headerlink" title="1. es的工作过程实现是如何的？如何实现分布式的啊？"></a>1. es的工作过程实现是如何的？如何实现分布式的啊？</h3><h3 id="2-es在数据量很大的情况下，如何提高查询效率？"><a href="#2-es在数据量很大的情况下，如何提高查询效率？" class="headerlink" title="2. es在数据量很大的情况下，如何提高查询效率？"></a>2. es在数据量很大的情况下，如何提高查询效率？</h3><h3 id="3-es的查询是一个怎么的工作过程？底层的lucence介绍一下？倒排索引知道么？es和mongodb什么区别？都在什么场景下使用？"><a href="#3-es的查询是一个怎么的工作过程？底层的lucence介绍一下？倒排索引知道么？es和mongodb什么区别？都在什么场景下使用？" class="headerlink" title="3. es的查询是一个怎么的工作过程？底层的lucence介绍一下？倒排索引知道么？es和mongodb什么区别？都在什么场景下使用？"></a>3. es的查询是一个怎么的工作过程？底层的lucence介绍一下？倒排索引知道么？es和mongodb什么区别？都在什么场景下使用？</h3><h2 id="高并发高可用架构设计"><a href="#高并发高可用架构设计" class="headerlink" title="高并发高可用架构设计"></a>高并发高可用架构设计</h2><h3 id="1-如何设计一个高并发高可用系统？"><a href="#1-如何设计一个高并发高可用系统？" class="headerlink" title="1. 如何设计一个高并发高可用系统？"></a>1. 如何设计一个高并发高可用系统？</h3><h3 id="2-如何限流？工程中怎么做的，说一下具体实现？"><a href="#2-如何限流？工程中怎么做的，说一下具体实现？" class="headerlink" title="2. 如何限流？工程中怎么做的，说一下具体实现？"></a>2. 如何限流？工程中怎么做的，说一下具体实现？</h3><h3 id="3-缓存如何使用的？缓存使用不会造成什么后果？"><a href="#3-缓存如何使用的？缓存使用不会造成什么后果？" class="headerlink" title="3. 缓存如何使用的？缓存使用不会造成什么后果？"></a>3. 缓存如何使用的？缓存使用不会造成什么后果？</h3><h3 id="4-如何熔断？熔断框架都有哪些？具体实现原理知道么？"><a href="#4-如何熔断？熔断框架都有哪些？具体实现原理知道么？" class="headerlink" title="4. 如何熔断？熔断框架都有哪些？具体实现原理知道么？"></a>4. 如何熔断？熔断框架都有哪些？具体实现原理知道么？</h3><h3 id="5-如何降级？-如何进行系统拆分？如何数据库拆分？"><a href="#5-如何降级？-如何进行系统拆分？如何数据库拆分？" class="headerlink" title="5. 如何降级？ 如何进行系统拆分？如何数据库拆分？"></a>5. 如何降级？ 如何进行系统拆分？如何数据库拆分？</h3><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><h3 id="1-说一下TCP-IP-四层？"><a href="#1-说一下TCP-IP-四层？" class="headerlink" title="1. 说一下TCP/IP 四层？"></a>1. 说一下TCP/IP 四层？</h3><h3 id="2-http的工作流程？-http1-0-http1-1-http2-0具体哪些区别？"><a href="#2-http的工作流程？-http1-0-http1-1-http2-0具体哪些区别？" class="headerlink" title="2. http的工作流程？ http1.0 http1.1 http2.0具体哪些区别？"></a>2. http的工作流程？ http1.0 http1.1 http2.0具体哪些区别？</h3><h3 id="3-TCP三次握手，四层分手的工作流程？画一下流程图？为什么不是四次五次或者两次？"><a href="#3-TCP三次握手，四层分手的工作流程？画一下流程图？为什么不是四次五次或者两次？" class="headerlink" title="3. TCP三次握手，四层分手的工作流程？画一下流程图？为什么不是四次五次或者两次？"></a>3. TCP三次握手，四层分手的工作流程？画一下流程图？为什么不是四次五次或者两次？</h3><h3 id="4-画一下https的工作流程？具体如何实现？如何防止被抓包？"><a href="#4-画一下https的工作流程？具体如何实现？如何防止被抓包？" class="headerlink" title="4. 画一下https的工作流程？具体如何实现？如何防止被抓包？"></a>4. 画一下https的工作流程？具体如何实现？如何防止被抓包？</h3><h3 id="5-TCP三次握手，四次挥手。"><a href="#5-TCP三次握手，四次挥手。" class="headerlink" title="5. TCP三次握手，四次挥手。"></a>5. TCP三次握手，四次挥手。</h3><h3 id="6-讲一讲NIO和BIO的区别"><a href="#6-讲一讲NIO和BIO的区别" class="headerlink" title="6. 讲一讲NIO和BIO的区别"></a>6. 讲一讲NIO和BIO的区别</h3><h3 id="7-Tcp和udp区别"><a href="#7-Tcp和udp区别" class="headerlink" title="7. Tcp和udp区别"></a>7. Tcp和udp区别</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="1-45亿阿拉伯数字，如何进行去重？如何找出最大的那个数？"><a href="#1-45亿阿拉伯数字，如何进行去重？如何找出最大的那个数？" class="headerlink" title="1. 45亿阿拉伯数字，如何进行去重？如何找出最大的那个数？"></a>1. 45亿阿拉伯数字，如何进行去重？如何找出最大的那个数？</h3><h3 id="2-常见排序算法"><a href="#2-常见排序算法" class="headerlink" title="2. 常见排序算法"></a>2. 常见排序算法</h3><h3 id="3-算法题：给一堆硬币的array，返回所有的组合"><a href="#3-算法题：给一堆硬币的array，返回所有的组合" class="headerlink" title="3. 算法题：给一堆硬币的array，返回所有的组合"></a>3. 算法题：给一堆硬币的array，返回所有的组合</h3><h3 id="4-给一个set打印出所有子集；"><a href="#4-给一个set打印出所有子集；" class="headerlink" title="4. 给一个set打印出所有子集；"></a>4. 给一个set打印出所有子集；</h3><h3 id="5-多线程从多个文件中读入数据，写到同一个文件中；"><a href="#5-多线程从多个文件中读入数据，写到同一个文件中；" class="headerlink" title="5. 多线程从多个文件中读入数据，写到同一个文件中；"></a>5. 多线程从多个文件中读入数据，写到同一个文件中；</h3><h3 id="6-判断ip是否在给定范围内；"><a href="#6-判断ip是否在给定范围内；" class="headerlink" title="6. 判断ip是否在给定范围内；"></a>6. 判断ip是否在给定范围内；</h3><h3 id="7-打乱一副扑克牌，不能用额外空间，证明为什么是随机的。"><a href="#7-打乱一副扑克牌，不能用额外空间，证明为什么是随机的。" class="headerlink" title="7. 打乱一副扑克牌，不能用额外空间，证明为什么是随机的。"></a>7. 打乱一副扑克牌，不能用额外空间，证明为什么是随机的。</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-红黑树和AVL树有什么区别？"><a href="#1-红黑树和AVL树有什么区别？" class="headerlink" title="1. 红黑树和AVL树有什么区别？"></a>1. 红黑树和AVL树有什么区别？</h3><h3 id="2-二叉树和红黑树"><a href="#2-二叉树和红黑树" class="headerlink" title="2. 二叉树和红黑树"></a>2. 二叉树和红黑树</h3><p><a href="https://www.jianshu.com/p/a07d1d4004b0" target="_blank" rel="noopener">博文推荐</a></p><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><h3 id="1-linux常用命令有哪些？"><a href="#1-linux常用命令有哪些？" class="headerlink" title="1. linux常用命令有哪些？"></a>1. linux常用命令有哪些？</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式原理及应用场景</title>
      <link href="/java/2018-01-10-pattern/"/>
      <url>/java/2018-01-10-pattern/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/zhongyp/Demo/tree/master/src/main/java/com/zhongyp/advanced/pattern" target="_blank" rel="noopener">本篇博客中涉及的所有设计模式源码都这在里，点击即可访问</a></p><h2 id="深入浅出设计模式原则："><a href="#深入浅出设计模式原则：" class="headerlink" title="深入浅出设计模式原则："></a>深入浅出设计模式原则：</h2><ul><li><p>封装变化： 找出应用中可能需要变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。</p></li><li><p>合成服用原则：多用组合，少用继承，组合使系统具有弹性，不仅可以将算法封装成类，还可以在运行是动态的改变行为。</p></li><li><p>依赖倒转原则：针对接口编程，不针对实现编程， 程序利用多态针对超类型（supertype）编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上。</p></li><li><p>接口隔离原则：为交互对象之间的松耦合设计而努力</p></li><li><p>里式代换原则：任何基类可以出现的地方，子类一定可以出现。</p></li><li><p>开闭原则OCP：类应该对扩展开放，对修改关闭</p></li><li><p>依赖抽象，不要依赖具体类。</p></li><li><p>最少知道原则：只和朋友交谈。 </p></li><li><p>类应该只有一个改变的理由。</p></li></ul><h2 id="访问模式-Visitor"><a href="#访问模式-Visitor" class="headerlink" title="访问模式(Visitor)"></a>访问模式(Visitor)</h2><h2 id="策略模式-stragety"><a href="#策略模式-stragety" class="headerlink" title="策略模式(stragety)"></a>策略模式(stragety)</h2><p>定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。体现封装变化、多用组合少用继承、针对接口编程，不针对实现编程。</p><p>Strategy模式有下面的一些优点：</p><ul><li><p>相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为。 继承有助于析取出这些算法中的公共功能。</p></li><li><p>提供了可以替换继承关系的办法： 继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类，从而给它以不同的行为。但这会将行为硬行编制到 Context中，而将算法的实现与Context的实现混合起来,从而使Context难以理解、难以维护和难以扩展，而且还不能动态地改变算法。最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。 将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。</p></li><li><p>消除了一些if else条件语句 ：Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 ,很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句。含有许多条件语句的代码通常意味着需要使用Strategy模式。</p></li><li><p>实现的选择 Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间 /空间权衡取舍要求从不同策略中进行选择。</p></li></ul><p>Strategy模式缺点:</p><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类:  本模式有一个潜在的缺点，就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。</p></li><li><p>Strategy和Context之间的通信开销 ：无论各个ConcreteStrategy实现的算法是简单还是复杂, 它们都共享Strategy定义的接口。因此很可能某些 ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；简单的 ConcreteStrategy可能不使用其中的任何信息！这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。</p></li><li><p>策略模式将造成产生很多策略类：可以通过使用享元模式在一定程度上减少对象的数量。 增加了对象的数目 Strategy增加了一个应用中的对象的数目。有时你可以将 Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由 Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的 Strategy不应在各次调用之间维护状态。</p></li></ul><p>应用场景：比较器Comparator和布局管理器LayoutManager</p><ul><li><p>在该比较架构中，Comparator就是一个抽象的策略；一个类实现该结构，并实现里面的compare方法，该类成为具体策略类；Collections类就是环境角色，他将集合的比较封装成静态方法对外提供api。</p></li><li><p>在Java SE开发中，用户需要对容器对象Container中的成员对象如按钮、文本框等GUI控件进行布局(Layout)，在程序运行期间由客户端动态决定一个Container对象如何布局，Java语言在JDK中提供了几种不同的布局方式，封装在不同的类中，如BorderLayout、FlowLayout、GridLayout、GridBagLayout和CardLayout等。</p></li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖他的对象都会收到通知并自动更新。体现封装变化、针对接口编程、多用组合，少用继承、交互对象之间的松耦合设计。</p><p>观察者模式的效果有以下的优点：</p><ul><li><p>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。</p></li><li><p>由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。</p></li><li><p>观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知，</p></li></ul><p>观察者模式有下面的缺点：</p><ul><li><p>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</p></li><li><p>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。</p></li><li><p>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。</p></li><li><p>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。</p></li></ul><p>应用场景：</p><p>spring的事件驱动模型使用的是观察者模式，通过ApplicationEvent抽象类和ApplicationListener接口,可以实现ApplicationContext事件处理，监听器在处理Event时,通常会进行判断传入的Event是不是自己所想要处理的,使用instanceof关键字，ApplicationEventMulticaster事件广播器实现了监听器的注册,一般不需要我们实现,只需要显示的调用applicationcontext.publisherEvent方法即可。</p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>动态的将责任附加到对象上，若要扩展功能，装饰者提供了比集成更具有弹性的替代方案。</p><p>优点：</p><ul><li>动态的给一个对象添加一些额外的职责，就扩展功能而言，比生成子类方式更为灵活。</li></ul><p>缺点：</p><ul><li>利用装饰器模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。</li></ul><p>FileInputStream、StringBufferInputStream、ByteArrayInputStream为被装饰的组件类。</p><p>PushbackInputStream、BufferInputStream、DataInputStream、LineNumberInputStream为具体装饰者类。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>三种形态：</p><ul><li><p>简单工厂模式：又称静态工厂方法 (对于增加新的产品，无能为力)</p></li><li><p>工厂方法模式：又称多态性工厂模式或虚拟构造子模式 (支持增加任意产品)</p></li><li><p>抽象工厂模式：又称工具箱模式 (对于增加新的产品，无能为力；支持增加产品族)</p></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>确保一个类只有一个实例，并提供全局访问点。</p><p>单例模式的几种实现方式<br>单例模式的实现有多种方式，如下所示：</p><ul><li><ol><li>懒汉式，线程不安全</li></ol></li></ul><p>是否 Lazy 初始化：是</p><p>是否多线程安全：否</p><p>实现难度：易</p><p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p><p>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</p><ul><li><ol start="2"><li>懒汉式，线程安全</li></ol></li></ul><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p><p>优点：第一次调用才初始化，避免内存浪费。</p><p>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</p><p>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>饿汉式</li></ol></li></ul><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式比较常用，但容易产生垃圾对象。</p><p>优点：没有加锁，执行效率会提高。</p><p>缺点：类加载时就初始化，浪费内存。</p><p>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li>双检锁/双重校验锁（DCL，即 double-checked locking）</li></ol></li></ul><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：较复杂</p><p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><p>getInstance() 的性能对应用程序很关键。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getSingleton() &#123;  </span><br><span class="line">    if (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">        if (singleton == null) &#123;  </span><br><span class="line">            singleton = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>登记式/静态内部类</li></ol></li></ul><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：一般</p><p>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p><p>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">    return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="6"><li>枚举</li></ol></li></ul><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</p><p>不能通过 reflection attack 来调用私有构造方法。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumTest &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    private Test test;</span><br><span class="line"></span><br><span class="line">    private EnumTest()&#123;</span><br><span class="line">        test = new Test();</span><br><span class="line">    &#125;</span><br><span class="line">    public Test getInstance()&#123;</span><br><span class="line">        return test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>了解<a href="/java/2019-05-01-java-enum/">枚举</a></p></blockquote><p>经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p><p>优点</p><ul><li>类间解耦：调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command 抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。</li><li>可扩展性：Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严 重的代码耦合。</li><li>命令模式结合其他模式会更优秀：命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少 Command子类的膨胀问题。</li></ul><p>缺点</p><ul><li>命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来 了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项 目中慎重考虑使用。</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p><p>优点</p><ul><li><p>松散耦合</p></li><li><p>使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；</p></li><li><p>简单易用</p></li><li><p>客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟Facade类交互即可。</p></li><li><p>更好的划分访问层次</p></li><li><p>有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。</p></li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使用子类可以在不改变算法结构的情况下，重新定义算法中的步骤。</p><p>优点</p><ul><li><p>封装不变部分，扩展可变部分。把认为不变部分的算法封装到父类中实现，而可变部分的则可以通过继承来继续扩展。</p></li><li><p>提取公共部分代码，便于维护。</p></li><li><p>行为由父类控制，子类实现。</p></li></ul><p>缺点</p><ul><li>按照设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类负责完成具体的事务属性和方法，但是模板方式正好相反，子类执行的结果影响了父类的结果，会增加代码阅读的难度。</li></ul><p>模板方法模式是通过父类建立框架，子类在重写了父类部分方法之后，在调用从父类继承的方法，产生不同的效果，通过修改子类，影响父类行为的结果，模板方法在一些开源框架中应用非常多，它提供了一个抽象类，然后开源框架写了一堆子类，如果需要扩展功能，可以继承此抽象类，然后覆写protected基本方法，然后在调用一个类似TemplateMethod()的模板方法，完成扩展开发。</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><p>应用实例：JAVA 中的 iterator。</p><p>优点：</p><ul><li><p>它支持以不同的方式遍历一个聚合对象。</p></li><li><p>迭代器简化了聚合类。 </p></li><li><p>在同一个聚合上可以有多个遍历。 </p></li><li><p>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p></li></ul><p>缺点：</p><ul><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li></ul><p>使用场景： </p><ul><li><p>访问一个聚合对象的内容而无须暴露它的内部表示。 </p></li><li><p>需要为聚合对象提供多种遍历方式。 </p></li><li><p>为遍历不同的聚合结构提供一个统一的接口。</p></li></ul><p>注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象及对象组合。</p><p>应用实例： </p><ul><li><p>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 </p></li><li><p>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p></li></ul><p>优点：</p><ul><li><p>高层模块调用简单。</p></li><li><p>节点自由增加。</p></li></ul><p>缺点：</p><ul><li>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</li></ul><p>使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。</p><p>注意事项：定义时为具体类。</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>抽象变化，封装各自变化</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p><p>State模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中, 所以通过定义新的子类可以很容易的增加新的状态和转换。另一个方法是使用数据值定义内部状态并且让 Context操作来显式地检查这些数据。但这样将会使整个Context的实现中遍布看起来很相似的条件if else语句或switch case语句。增加一个新的状态可能需要改变若干个操作, 这就使得维护变得复杂了。State模式避免了这个问题, 但可能会引入另一个问题, 因为该模式将不同状态的行为分布在多个State子类中。这就增加了子类的数目，相对于单个类的实现来说不够紧凑。但是如果有许多状态时这样的分布实际上更好一些, 否则需要使用巨大的条件语句。正如很长的过程一样，巨大的条件语句是不受欢迎的。它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。 State模式提供了一个更好的方法来组织与特定状态相关的代码。决定状态转移的逻辑不在单块的 i f或s w i t c h语句中, 而是分布在State子类之间。将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。</p><p>优点：</p><ul><li><p>它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p></li><li><p>它使得状态转换显式化: 当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且, State对象可保证Context不会发生内部状态不一致的情况，因为从 Context的角度看，状态转换是原子的—只需重新绑定一个变量(即Context的State对象变量)，而无需为多个变量赋值</p></li><li><p>State对象可被共享 如果State对象没有实例变量—即它们表示的状态完全以它们的类型来编码—那么各Context对象可以共享一个State对象。当状态以这种方式被共享时, 它们必然是没有内部状态, 只有行为的轻量级对象。</p></li></ul><p>缺点:</p><ul><li><p>状态模式的使用必然会增加系统类和对象的个数。</p></li><li><p>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</p></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为另一个对象提供一个替身或者占位符以控制对这个对象的访问。</p><p>优点：</p><ul><li>只有真正去调用的时候才会创建实例。有些情况下，程序不会真正的调用被调用对象的某个方法时，这种情况无需去创建被调用这对象的实例。在这种情况下，代理模式可以调程序的性能。宏观上减少了系统开销。</li></ul><p>应用：hibernate延时加载</p><h2 id="复合模式"><a href="#复合模式" class="headerlink" title="复合模式"></a>复合模式</h2><p>复合模式结合两个或以上的模式，组合一个解决方案，解决一再发生的一般性问题</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入浅出设计模式</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ArrayList</title>
      <link href="/java/2018-01-11-arraylist/"/>
      <url>/java/2018-01-11-arraylist/</url>
      
        <content type="html"><![CDATA[<h2 id="1-接口实现"><a href="#1-接口实现" class="headerlink" title="1. 接口实现"></a>1. 接口实现</h2><p><img src="/media/article/collection-arraylist.png" alt="arraylist"></p><p>ArrayList继承AbstractList类，实现List，RandomAccess，Cloneable，Serializable接口。AbstractList提供 List 接口的骨干实现，从而最大限度地减少了实现由“随机访问”数据存储（如数组）支持的接口所需的工作。对于连续的访问数据（如链表），应优先使用AbstractSequentialList，而非此类。<br>AbstractCollection是集合类的抽象类，主要提供集合层面的一些操作。<br>RandomAccess是随机访问的接口标志，如果继承RandomAccess则说明当前类是支持随机访问的。</p><h2 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h2><p>ArrayList默认构造方式有三种:</p><p>第一种: 给定初始化大小；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">   if (initialCapacity &gt; 0) &#123;</span><br><span class="line">       this.elementData = new Object[initialCapacity];</span><br><span class="line">   &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">       this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                          initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种: 默认初始化大小，默认初始化为10；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">   this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三种: 集合大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   elementData = c.toArray();</span><br><span class="line">   if ((size = elementData.length) != 0) &#123;</span><br><span class="line">       // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">       if (elementData.getClass() != Object[].class)</span><br><span class="line">           elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       // replace with empty array.</span><br><span class="line">       this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们看下add方法的扩容流程:</p><p><strong>注意：为了方便看源码，我会将一些方法的源码组合到add方法中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    // 首先判断是否是默认初始化大小，如果是，比较默认的数组大小和当前数组大小size+1，相比，取较大的那个</span><br><span class="line">   int minCapacity = size + 1;</span><br><span class="line">   if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">       minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   // 记录数组的修改次数（这个参数可以在常见变量解释小结中说明）</span><br><span class="line">   modCount++;</span><br><span class="line">   // overflow-conscious code</span><br><span class="line">   // 判断当前的minCapacity是否大于当前数组的容量，进行扩容操作</span><br><span class="line">   if (minCapacity - elementData.length &gt; 0)&#123;</span><br><span class="line">       // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        // 新的数组大小为oldCapacity+1/2 * oldCapacity</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        // 判断下新数组大小是否小于minCapacity</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        // 判断新的数组大小是否大于Integer.MAX - 8</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)&#123;</span><br><span class="line">            if (minCapacity &lt; 0) // overflow</span><br><span class="line">                throw new OutOfMemoryError();</span><br><span class="line">            // 如果新容量大于Integer.MAX - 8，则新容量为Integer.MAX</span><br><span class="line">            newCapacity = (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;   </span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   elementData[size++] = e;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList所有方法涉及扩容的原理都差不多，可以参考上述的代码注释了解。</p><h2 id="3-参数"><a href="#3-参数" class="headerlink" title="3. 参数"></a>3. 参数</h2><p>modCount: modCount是一个AbstractList的一个成员变量，主要的作用是，子类的迭代器用于判断fail-fast的参数。具体可以详见<a href="https://zhongyp.me/faq/2018-07-30-foreach/">为什么不能在foreach中执行remove/add操作？</a>，虽然这篇博客只讲了一个问题，但是可以管中窥豹。</p><p>size: size是ArrayList的元素数量，元素可以为null。</p><p>MAX_ARRAY_SIZE: 为什么ArrayList数组的最大大小为Integer.MAX-8，原因是Some VMs reserve some header words in an array.Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><a href="https://zhongyp.me/faq/2018-07-30-foreach/">为什么不能在foreach中执行remove/add操作？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存模型</title>
      <link href="/concurrency/2018-03-04-java-memory-model/"/>
      <url>/concurrency/2018-03-04-java-memory-model/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型（Java Memory Model，简称：JMM），下文中如果没有特殊说明，JMM即代表“Java内存模型”。<br>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p><p>注： 这里说的变量包括了实例变量、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有，不会被共享，自然就不存在竞争问题。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-缓存一致性"><a href="#1-1-缓存一致性" class="headerlink" title="1.1 缓存一致性"></a>1.1 缓存一致性</h3><p>在并发编程模型中，需要处理两个关键的问题：<strong>线程之间以何种机制交换信息（通信）及如何控制不同线程之间操作发生相对顺序的机制（同步）</strong>。<br>线程之间的通信机制有两种：共享内存和消息传递，每种通信机制对应不同的内存模型。<br>共享内存模型：线程之间通过读-写内存中的公共状态进行隐式通信。<br>消息传递模型：线程之间没有公共状态，线程之间必须通过发送消息来显示的进行通信。<br><strong><em>Java并发采用的是共享内存模型</em></strong>。<br>在共享的内存模型，多处理器体系架构中，每个<a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2" target="_blank" rel="noopener">处理器</a>都有自己的缓存，并且周期性的与主内存协调一致。处理器架构提供了不同级别的缓存一致性（cache coherence），有些仅提供最小的保证，几乎在任何时间内，都允许不同的处理器在相同位置上看到不同的值。<br>举个简单的例子：在java中，执行下面这个语句：</p><p><code>i  = 10++;</code></p><p>1) 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p><p>2) 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p><p>3) 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</p><p>4) 最终结果i的值是11，而不是12。这就是缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p><p><strong>注：</strong><br>同步：<strong>指程序中用于控制不同线程间操作发生相对顺序的机制</strong>，意味着某种形式的原子性或者互斥。<br>共享内存的并发模型中，同步是显式，程序员必须显示的指定某个方法或某段代码需要在线程之间互斥执行。消息传递的并发模型中，消息的发送必须在消息的接收之前，因此同步是隐式的。</p><p>想要保证每个处理器能在任意时间内获知其他处理器正在处理的工作，代价很高而且很多时候这些信息都是不必要的，所以就牺牲掉存储的一致性来保证性能。为了共享数据时能得到存储协调的保证，Java提供了自己的JMM解决与底层平台存储模型的差异化。</p><h3 id="1-2-重排序"><a href="#1-2-重排序" class="headerlink" title="1.2 重排序"></a>1.2 重排序</h3><p>除了上述的缓存一致性问题外，在执行程序时，为了提高程序的性能，使得处理器内部的运算单元被充分利用，编译器和处理器常常会对指令做重排序。<br>从Java源代码到最终执行的指令序列，会分别经历下面的三种重排序：<br><img src="/media/article/java-resort.png" alt="resort"><br>图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><ol><li>编译器重排序。编译器不改变单线程语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级重排序。现代处理器采用指令级并行技术将多条指令重叠执行。<strong><em>如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</em></strong></li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>编译器和处理器重排序时会遵守数据依赖性，编译器、运行时和处理器都必须遵守as-if-serial语义。<br><strong>注：</strong><br>数据依赖性：编译器和处理器不会改变存在数据以来关系的两个操作的执行顺序。<strong>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</strong><br>as-if-serial：内部线程类似顺序化语义。不管如何的重排序，单线程程序的执行结果不能被改变。</p><h4 id="1-2-1-重排序的影响"><a href="#1-2-1-重排序的影响" class="headerlink" title="1.2.1 重排序的影响"></a>1.2.1 重排序的影响</h4><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public void writer()&#123;</span><br><span class="line">        a = 1; // 1</span><br><span class="line">        flag = true; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    public void reader()&#123;</span><br><span class="line">        if (flag)&#123; // 3</span><br><span class="line">            int i = a * a; // 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设线程A先执行writrer方法，随后线程B执行reader方法，线程执行操作4时，不一定能看到1处的赋值。原因如下图：<br><img src="/media/article/resort.png" alt="resort"><br>图片来自<a href="#2-4-happens-before">Java并发编程艺术</a><br>由于操作1和2没有依赖关系，所以编译器和处理器可以对这两个操作重排序，线程A首先标记了flag，随后线程B读取flag。由于flag=true，线程B可以读取a，但是此时的a并为被线程A赋值。所以这里的多线程程序的语义被破坏了。JMM提供同步机制来抑制编译器、运行时和硬件对存储操作的各种方式的重排序，保证内存的可见性。                                              </p><h2 id="2-JMM设计"><a href="#2-JMM设计" class="headerlink" title="2. JMM设计"></a>2. JMM设计</h2><p><img src="/media/article/jmm-abs.png" alt="JMM的抽象结构"><br>JMM在内存中的抽象结构，图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><p>JMM属于语言级别的内存模型，确保在不同的编译和不同处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，决定一个线程对共享变量的写入何时对另一个线程可见，提供内存可见性保证。<br>从JDK5开始，Java使用JSR-133内存模型。JSR-133使用<strong>happens-before概念保证内存的可见性</strong>。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ol><li><p><strong><em>程序次序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</em></strong></p></li><li><p><strong><em>监视器锁规则：一个unLock操作先行发生于后面对同一个锁的lock操作。</em></strong></p></li><li><p><strong><em>volatile变量规则：对一个volatile变量的写操作，happens-before于后续对这个volatile变量的读操作。</em></strong></p></li><li><p><strong><em>传递性：如果操作A happens-before操作B，而操作B happens-before操作C，则可以得出操作A happens-before操作C。</em></strong></p></li><li><p>start()规则：Thread对象的start()方法happens-before此线程的每个一个动作</p></li><li><p>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p></li></ol><p><img src="/media/article/happens-before-design.png" alt="happens-before-design"><br>JMM设计图，图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><h2 id="3-JMM的可见性保证"><a href="#3-JMM的可见性保证" class="headerlink" title="3. JMM的可见性保证"></a>3. JMM的可见性保证</h2><ul><li>单线程程序。<strong><em>单线程程序不会出现内存可见性问题。</em></strong>编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li>正确<strong><em>同步</em></strong>的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。JMM通过根据happens-before原则限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li><li>未同步/未正确同步的多线程程序。JMM为他们提供最小的安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么时默认值（0、null、false）。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.importnew.com/24082.html" target="_blank" rel="noopener">你真的了解volatile关键字吗？</a></p><p><a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">Java中Volatile关键字详解</a></p><p><a href="">Java并发编程艺术</a></p><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a></p><p><a href="">Java并发编程实践</a></p><p><a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2" target="_blank" rel="noopener">每个程序员都应该了解的 CPU 高速缓存</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库事务</title>
      <link href="/transaction/2018-02-28-Transaction/"/>
      <url>/transaction/2018-02-28-Transaction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。</p></blockquote><h2 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h2><p>事务是程序中一系列严密的操作，所有操作执行必须成功完成，否则在每个操作所做的更改将会被撤销，这也是事务的原子性（要么成功，要么失败）。</p><h2 id="事务特性："><a href="#事务特性：" class="headerlink" title="事务特性："></a>事务特性：</h2><p>事务特性分为四个：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）简称ACID。</p><ul><li><p>原子性（Atomicity）:事务是数据库逻辑工作单元，事务中包含的操作要么都执行成功，要么都执行失败。</p></li><li><p>一致性（Consistency）：事务执行的结果必须是使数据库数据从一个一致性状态变到另外一种一致性状态。当事务执行成功后就说数据库处于一致性状态。如果在执行过程中发生错误，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这是数据库就处于不一致状态。</p></li><li><p>隔离性（Isolation）：一个事务的执行过程中不能影响到其他事务的执行，即一个事务内部的操作及使用的数据对其他事务是隔离的，并发执行各个事务之间无不干扰。</p></li><li><p>持续性（Durability）：即一个事务执一旦提交，它对数据库数据的改变是永久性的。之后的其它操作不应该对其执行结果有任何影响。</p></li></ul><h2 id="事务的隔离级别："><a href="#事务的隔离级别：" class="headerlink" title="事务的隔离级别："></a>事务的隔离级别：</h2><p>事务的隔离级别也分为四种，由低到高依次分别为：read uncommited（未提交读）、read commited（提交读）、read repeatable（重复读）、serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><ul><li><p>read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。</p></li><li><p>read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</p></li><li><p>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。</p></li><li><p>serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。</p></li></ul><p>脏读、不可重复读、幻象读概念说明：</p><ul><li>脏读：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。</li></ul><ul><li>不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。</li></ul><ul><li>幻象读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/zhangqian1031/p/6542037.html" target="_blank" rel="noopener">PittBlogger-什么是事务、事务特性、事务隔离级别、spring事务传播特性-博客园</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>书单</title>
      <link href="/life/2017-1-1-books/"/>
      <url>/life/2017-1-1-books/</url>
      
        <content type="html"><![CDATA[<blockquote><p>夫君子之行，静以修身，俭以养德。非澹泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！</p></blockquote><p>– 2017、2018、2019年书单</p><h2 id="书架👈🏻👈🏻👈🏻"><a href="#书架👈🏻👈🏻👈🏻" class="headerlink" title="书架👈🏻👈🏻👈🏻"></a><a href="https://github.com/zhongyp/mybook" target="_blank" rel="noopener">书架👈🏻👈🏻👈🏻</a></h2><ul><li><p>architecture</p><ul><li>SOA服务管控和治理四.pdf</li><li>Zabbi 监控系统深度实践 带书签目录 完整版.pdf</li><li>ZooKeeper在携程的使用和场景.pdf</li><li>zookeeper双数据中心容灾研究.pdf</li><li>中国区块链技术和应用发展白皮书.pdf</li><li>亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统.pdf</li><li>从PAXOS到ZOOKEEPER分布式一致性原理与实践.pdf</li><li>全面认识微服务&amp;SpringCloud_Jack_张振华.pdf</li><li>分布式Java应用：基础与实践.pdf</li><li>分布式服务框架原理与实践_李林锋著.pdf</li><li>分布式混合云DevOps实践.pdf</li><li>基于区块链的分布式超级计算项目（分布式渲染） supercomputing.pdf</li><li>大型分布式网站架构设计与实践.带目录书签.完整版.pdf</li><li>大型网站系统与Java中间件实践(jb51.net).pdf</li><li>大数据 互联网大规模数据挖掘与分布式处理 第2版 2015.7.pdf</li><li>尽在双⒒_阿里巴巴技术演进与超越.pdf</li><li>微信 朋友圈技术之道wechat_moments_architecture_201512.pdf</li><li>微服务架构如何落地实践.pdf</li><li>服务治理中间件dubbo原理解析.pdf</li><li>程序员必读之软件架构.pdf</li><li>阿里分布式消息系统ONS原理与实践.pdf</li></ul></li><li><p>chm</p><ul><li>JAVA设计模式.chm    </li><li>Spring2.5-.chm</li></ul></li><li><p>coder</p><ul><li>Effective Java第二版</li><li>Go语言实战</li><li>Netty权威指南</li><li>利用python进行数据分析</li><li>Netty实战.epub</li><li>Netty实战.mobi</li><li>UNIX环境高级编程（中文第2版）.pdf</li><li>UNIX网络编程卷1：套接字联网API（第3版）.pdf</li><li>UNIX网络编程卷2：进程间通信（第2版）.pdf</li></ul></li><li><p>java</p><ul><li>Java_TCPIP_Socket网络编程</li><li>Java并发艺术</li><li>Effective Java第二版</li><li>Effective Unit Testing</li><li>Java8实战</li><li>Java NIO（中文版）</li><li>Java多线程设计模式</li><li>Java并发编程实践</li><li>Java问题定位技术</li><li>TCP-IP详解卷一</li><li>实战Java高并发程序设计</li></ul></li><li><p>smart</p><ul><li>周志华-机器学习</li><li>周志华-数据挖掘与机器学习</li><li>Spark机器学习</li><li>Machine Learning in Action</li><li>机器学习十大算法</li><li>机器学习实战</li><li>Machine Learning in Action SourceCode</li></ul></li><li><p>framework</p><ul><li>Hibernate开发指南</li><li>SpringGuide</li><li>Spring源码深度解析</li><li>dubbo源码解析2.0</li><li>ZooKeeper</li><li>Dubbo设计原则和实现原理</li><li>Dubbo监控中心的介绍与简易监控中心的安装</li><li>Dubbo-基础篇-持续集成篇-Hudson持续集成服务器的安装配置与使用</li><li>Jenkins权威指南</li><li>Spring boot实战（丁雪丰）</li><li>Spring boot张卫滨</li><li>分布式系统原理与范型</li><li>框架设计原则（梁飞）</li><li>Dubbo项目结构解析</li><li>Kafka深度解析</li></ul></li></ul><ul><li><p>database</p><ul><li>高性能MySQL 第3版</li><li>MySQL技术内幕</li><li>Redis实战</li><li>MongoDB权威指南</li><li>MyCat_In_Action_中文版</li><li>Oracle 11g 从入门到精通</li><li>redis设计与实现</li><li>网易分布式数据库DDB</li></ul></li><li><p>utils</p><ul><li>Git和特性开发</li><li>HTTPS权威指南</li><li>idea使用教程</li><li>intellij idea 快捷键整理</li><li>Linux命令行与shell脚本编程大全</li><li>Nginx开发</li><li>Shell高级编程（中文版）</li><li>深入理解JVM虚拟机</li></ul></li></ul><ul><li>other<ul><li>产品经理手册</li><li>经济学原理</li><li>你要如何衡量你的人生</li><li>牛津通识精选</li><li>三体2 黑暗森林</li><li>手把手教你读财报</li><li>More Effective C++</li><li>[英]-奥斯丁-傲慢与偏见.mobi</li><li>东野圭吾《信》.mobi</li><li>人类简史.mobi</li><li>你的第一本哲学书.mobi</li><li>关键对话.mobi</li><li>叶嘉莹先生作品10册套装.mobi</li><li>在路上</li><li>在路上.mobi</li><li>如何听如何说-莫提默·J.艾德勒.mobi</li><li>如何阅读一本书.mobi</li><li>学会提问-尼尔•布朗.mobi    </li><li>当年明月-明朝那些事儿（1-9）.mobi</li><li>批判性思维工具-理查德•保罗.mobi</li><li>把时间当作朋友（第3版）.mobi</li><li>指数基金投资指南-银行螺丝钉.mobi</li><li>最好的告别.mobi</li><li>杀死一只知更鸟史上最受喜爱的小说之一畅销全球的良知启蒙善良与爱不可辜负.mobi</li><li>百年孤独-加西亚·马尔克斯.mobi</li><li>远山淡影+-+[Ӣ]+石黑一雄.mobi</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冒泡排序</title>
      <link href="/algorithm/2015-08-04-BubbleSort/"/>
      <url>/algorithm/2015-08-04-BubbleSort/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>冒泡排序是依次比较数列相邻的两个数字的大小，按照从大到小或者从小到大的规则进行交换，重复遍历数列直至没有可交换的数列，排序完成。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>数列：[3,5,1,7,4]</p><p>规则：从小到大</p><p>排序：</p><ul><li>比较3-5，5大于3，不交换，数列不变[3,5,1,7,4]</li><li>比较5-1,5大于1，交换，数列变化[3,1,5,7,4]</li><li>比较5-7,7大于5，不交换，数列不变[3,1,5,7,4]</li><li>比较7-4,7大约4，交换，数列变化[3,1,5,4,7]</li><li>然后重复遍历数列,直至最后没有可以交换的数列。</li></ul><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    public static void bubbleSort()&#123;</span><br><span class="line">//        int[] arr = &#123;3,5,7,1,4&#125;;</span><br><span class="line">        int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">        int i,j,temp,len=arr.length;</span><br><span class="line">        //是否已经完成排序的标志</span><br><span class="line">        boolean flag;</span><br><span class="line">        //排序</span><br><span class="line">        for(i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            for(j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">                if(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    flag = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                System.out.println(&quot;第&quot; + (i+1) + &quot;趟结束了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出数组</span><br><span class="line">        for(int o:arr)&#123;</span><br><span class="line">            System.out.print(&quot; &quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>最坏情况下：第1趟排序需要比较(n-1)次，… 第(n-1)趟比较1次，O(n)=((n-1)+1)<em>(n-1)/2=n</em>(n-1)/2=n^2。</p><p>最好情况下：比较(n-1)次。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
