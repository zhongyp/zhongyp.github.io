<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java对象创建</title>
      <link href="/jvm/2020-06-22/"/>
      <url>/jvm/2020-06-22/</url>
      
        <content type="html"><![CDATA[<p>Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来。虚拟机遇到一个new 指令时，首先将会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过、解析、初始化过。</p><p>类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p><p>虚拟根据堆内存是否规整使用不同的内存分配方式：如果内存是规整的，则仅仅是把指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为“指针碰撞”。如果Java堆中的内存并不是规整的，已使用内存和未使用内存相互交错，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，这种分配方式称为“空闲列表”。</p><p>并发情况下，创建对象并不是线程安全的，针对指针碰撞有两种解决方案，一种时候对分配内存空间的动作同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种方式是把内存分配动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。</p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为0值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象时哪个类的实例、如果才能找到类的元数据信息、对象的hash码、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)中。</p><p>之后执行new指令后会接着执行<init>方法，把对象按照程序员的意愿进行初始化。</init></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Performance Companion</title>
      <link href="/jvm/2020-05-20-g1/"/>
      <url>/jvm/2020-05-20-g1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://www.oreilly.com/library/view/java-performance-companion/9780133796896/" target="_blank" rel="noopener">Charlie H, Monica B, Poonam P, Bengt R. Java Performance Companion</a></p></blockquote><h2 id="G1概览"><a href="#G1概览" class="headerlink" title="G1概览"></a>G1概览</h2><p>G1 GC在回收暂停期间回收其大部分堆region。唯一的例外是多阶段并行标记周期的清理阶段。在清理阶段，如果G1 GC遇到全是垃圾的的region，它可以立即回收这些region并将它们返回到空闲region的列表；因此，释放这些region不必等待下一个垃圾回收 pause。</p><p>G1 GC具有三种主要类型的垃圾回收周期：年轻代的回收周期，多阶段并发标记周期和混合的回收周期。还有一个单线程的回退暂停，称为“完全”垃圾回收 pause，这是G1 GC的故障安全机制，以防GC遇到疏散失败的情况。</p><blockquote><p>疏散失败也被称为升迁失败，空间耗尽甚至空间溢出。失败通常发生在没有更多的可用空间来升级对象时。面对这种情况，所有Java HotSpot VM GC都会尝试扩展其堆。但是，如果堆已经达到最大，则GC会尝试保留成功复制对象的region并更新其引用。对于G1 GC，将无法复制的对象保留在位。然后，所有GC的引用都将自动转发。这些自我转发的引用在垃圾回收周期结束时被删除。</p></blockquote><p>在年轻代回收期间，G1 GC会 pause应用程序线程，以将活动对象从年轻region移动到survivor region，或者将它们提升到old region，或者两者同时进行。对于Mixed GC，G1 GC还将存活对象从最“efficient”的old region移动到free region，这些region成为老年代的一部分。</p><blockquote><p>“ GC efficient”实际上是指要回收的空间与回收该region的GC耗时之比。由于缺乏更好的术语，在本书中，我们将使用堆region排序来确定候选region，计算“ GC efficient”。使用相同术语的原因是，GC efficient评估回收region的成本与回收region的收益。而且，我们在这里所指的“efficient”完全取决于活跃度的计算，因此仅是回收region的成本。例如，与其他耗时更多的old region相比，回收耗时较少的old region被视为efficient高的region。efficient最高的region将是region排序数组中的第一个region。</p></blockquote><h2 id="G1年轻代"><a href="#G1年轻代" class="headerlink" title="G1年轻代"></a>G1年轻代</h2><p>G1 GC是由年轻一代和老一代组成的世代GC。大多数分配，除了少数例外，例如对象太大而无法放入线程的本地分配缓冲区（也称为TLAB），但被认为小于是“庞大”的对象，当然还包括等于“庞大”对象本身（请参见部分中的“ Humongous Regions”部分），将由任意特定线程放入该线程的TLAB。由于拥有的Java线程能够以无锁方式进行分配，因此TLAB可使分配速度更快。这些TLAB来自G1 regions，已成为年轻代的一部分。除非在命令行上明确指定，否则当前的年轻代大小是根据初始和最大的年轻代大小边界计算的（从JDK 8u45开始，默认值为初始年轻代大小的Java堆总数的5％（-XX：G1NewSizePercent ）和Java堆总数的60％（最大年轻代大小）（-XX：G1MaxNewSizePercent）和应用程序的最大 pause时间（-XX：MaxGCPauseMillis）。</p><blockquote><p>如果未在命令行上设置-XX：MaxGCPauseMillis，则G1 GC将选择默认的200ms。如果用户设置-Xmn或相关的年轻代大小调整命令行选项（例如-XX：NewRatio），则G1 GC可能无法基于 pause时间目标来调整年轻代大小，因此应用程序的最大 pause时间可能会变成无意义配置。</p></blockquote><p>根据Java应用程序的对象分配率，根据需要将新的空闲region添加到年轻代中，直到满足所需的年轻代大小为止。堆region大小是在JVM启动时确定的。堆region大小必须为2的幂，范围可以从1MB到32MB。 JVM分为大约2048个region，并相应地设置堆region大小（堆region大小=堆大小/ 2048）。对齐并调整堆region的大小，使其落在1MB至32MB的范围内，边界必须为2的幂。通过使用-XX：G1HeapRegionSize = n设置，可以在命令行上覆盖堆region大小的自适应选择。第3章，“垃圾优先的垃圾回收器性能调整”，包含有关何时覆盖JVM自动大小调整的更多信息。</p><h2 id="年轻代垃圾回收暂停"><a href="#年轻代垃圾回收暂停" class="headerlink" title="年轻代垃圾回收暂停"></a>年轻代垃圾回收暂停</h2><p>年轻的代由指定为eden region的G1 GC region和指定为survivor region G1 GC region 组成。当JVM无法分配到eden region时，即eden满了时，将触发年轻代垃圾回收。然后，GC介入以释放一些空间。年轻代第一次垃圾回收将把所有存活对象从eden region转移到survivor region。这就是所谓的“幸存者副本”。从那时起，任何年轻垃圾回收都将把整个年轻一代（即eden和survivor region）的存活对象复制到新的region，这些region现在是新的survivor region。当年轻代垃圾回收达到一个预定的提升阀值，它们偶尔还会将一些对象提升到老一代之外的地区。这称为“aging”存活对象。将存活对象从年轻代提升到老年代的过程称为“tenuring”对象，因此年龄阈值称为“tenuring阈值”。将对象提升到survivor region或升级到老年代时，发生在Promoting GC线程的本地分配的缓冲区（也称为Promotion Lab，简称PLAB）中。对于survivor和老年代来说，每个GC线程都有PLAB。</p><p>在每个年轻代垃圾回收 pause期间，G1 GC根据执行当前操作所需的总时间来计算要对当前年轻代大小执行的扩展或收缩（即，G1 GC决定添加或删除free region） 回收；Remembered Sets或RSets的大小（有关详细信息，请参阅本章后面的“Remembered Sets及其重要性”部分）；当前，最大和最小的年轻代容量；和 pause时间目标。因此，在垃圾回收 pause结束时调整了年轻代的大小。可以通过查看-XX：+ PrintGCDetails的输出来观察和计算年轻代的上一个和下一个大小。让我们看一个例子。 （请注意，在整本书中，所有输出行都进行了包装，以适合本书的页面。）</p><h2 id="对象老化与老年代"><a href="#对象老化与老年代" class="headerlink" title="对象老化与老年代"></a>对象老化与老年代</h2><p>正如上一节“年轻代垃圾回收 pause”中简要介绍的那样，在每个年轻代垃圾回收期间，G1 GC都会维护每个对象的年龄字段。当前年轻代 回收的任何特定对象幸存的总数称为该对象的“年龄”。 GC在称为“age table”的表中维护年龄信息以及已提升为该年龄的对象的总大小。根据age table，survivor region对象存活比率，幸存者年龄阀值（由-XX：TargetSurvivorRatio（默认值= 50）确定）和-XX：MaxTenuringThreshold（默认值= 15），JVM会为所有存活对象自适应地设置最大tenuring阈值。一旦这些对象超过了最大tenuring阈值，它们就会被提升/tenured到老一代region。当这些保留对象在老年代中死亡时，可以通过混合 回收或在清理过程中释放它们的空间（但前提是可以回收整个region），作为最后的选择，或者在完全垃圾 回收时 回收。</p><h2 id="Humongous-Regions"><a href="#Humongous-Regions" class="headerlink" title="Humongous Regions"></a>Humongous Regions</h2><p>对于G1 GC， 回收单位是一个region。因此，堆region大小（-XX：G1HeapRegionSize）是重要的参数，因为它确定对象可以放入region的大小。堆region的大小还确定了哪些对象被称为“巨大”。巨大的对象是非常大的物体，占G1 GC region的50％或更多。这样的对象并没有遵循通常的快速分配方式，而是直接从老年代中分配出来。标记为Humongous region的region。</p><p>在JDK 8u40之前，如果任何巨大的region都是完全空闲的，则只能在并发 回收周期的清理 pause期间 回收它。为了优化短期生存的大型对象的 回收，JDK 8u40进行了值得注意的更改，使得如果确定大型region没有传入的引用，则可以在年轻代的 回收期间将其回收并返回到空闲region列表中。完整的垃圾 回收 pause还将 回收完全空闲的大型region。</p><blockquote><p>这里需要强调一个重要的潜在问题或困惑。假设当前的G1region大小为2MB。并说一个字节数组的长度对齐为1MB。此字节数组仍将被认为是一个庞大的对象，因此需要进行分配，因为1MB的数组长度不包括该数组的对象标头大小。</p></blockquote><h2 id="混合垃圾回收暂停"><a href="#混合垃圾回收暂停" class="headerlink" title="混合垃圾回收暂停"></a>混合垃圾回收暂停</h2><p>随着越来越多的对象被提升到老年代中，或者当庞大的对象被分配到庞大的region中时，老年代的占用率因此增加了Java堆的总占用量。为了避免堆空间用完，JVM进程需要启动垃圾回收，该垃圾回收不仅覆盖年轻代的region，而且还向混合region添加一些old region。请参阅上一节中关于hummongousregion的内容，以了解有关hummongous对象的特殊处理（分配和回收）的信息。<br>为了识别出垃圾最多的old region，G1 GC启动了一个并发标记周期，这有助于标记根并最终标识所有存活对象，并计算每个region的活动因子。在分配和提升的速率以及此标记周期的触发之间必须达到微妙的平衡，以使JVM进程不会耗尽Java堆空间。因此，在JVM进程开始时设置了占用阈值。至少在JDK 8u45之前，此占用阈值是不自适应的，可以通过命令行选项-XX：InitiatingHeapOccupancyPercent（我称其为IHOP）来设置。</p><blockquote><p>在G1中，IHOP阈值默认为Java总堆的45％。重要的是要注意，此堆占用百分比适用于整个Java堆，这与CMS GC所使用的堆占用命令行选项不同，后者仅适用于旧版本。在G1 GC中，没有物理上分离的老年代-只有一个空闲region池，可以将其分配为eden，survivor，老年代或humongous。同样，分配的region数量（例如eden）可以随时间变化。因此，老年代的百分比并没有多大意义。</p></blockquote><p>-当老一代占用率达到（或超过）IHOP阈值时，将启动并发标记周期。在标记即将结束时，G1 GC计算每个旧region的活动物体数量。另外，在清理阶段，G1 GC根据旧region的“ GC效率”对旧region进行排名。现在可以进行混合 回收了！在混合 回收 pause期间，G1 GC不仅 回收年轻一代中的所有region，而且还 回收一些候选的旧region，以便回收垃圾最多的旧region。</p><blockquote><p>比较CMS和G1日志时要记住的重要一点是，G1中的多阶段并发周期比CMS中的多阶段并发周期要少。</p></blockquote><p>单个混合垃圾回收器类似于年轻代垃圾回收期 pause，并通过复制实现存活对象的压缩。唯一的区别是，在混合垃圾回收期间，垃圾回收还包含一些efficient的old region。根据一些参数（如本章稍后所述），可能会有一个以上的mixed Collection pause。这称为“mixed Collection周期”。只有在超过标记/ IHOP阈值之后以及完成并行标记周期之后，才可能发生mixed Collection周期。<br>有两个重要的参数可帮助确定混合回收周期中混合回收的次数和什么时候结束mixed gc：-XX：G1MixedGCCountTarget和-XX：G1HeapWastePercent。<br>-XX：G1MixedGCCountTarget（默认值为8（JDK 8u45））是混合GC计数目标参数，其目的是对标记周期完成后将出现的mixed Collection的region数量进行物理限制。 G1 GC将可回收的候选old region总数除以-XX：G1MixedGCCountTarget，并将其设置为每个mixed Collection pause要回收的最小old region数。这可以表示为以下等式：<br>每个mixed Collection pause 回收的最小old CSet = 在一个mixed Collection周期中所有的候选old region总数/ G1MixedGCCountTarget。<br>-XX：G1HeapWastePercent缺省为Java总堆的5％（JDK 8u45），它是控制mixed Collection周期中要回收的旧region数量的重要参数。对于每个mixed Collection pause，G1 GC都会根据可以回收的死对象空间来标识可回收堆的数量。一旦G1 GC达到此堆G1HeapWastePercent，G1 GC就会停止启动mixed Collection pause，从而达到混合 回收周期的终点。设置堆G1HeapWastePercent基本上可以帮助限制你设置允许浪费的堆大小，以有效地加快mixed Collection周期。<br>因此，每个mixed Collection周期的mixed Collection数量可以通过每个mixed Collection pause回收的最小 old CSet和G1HeapWastePercent来控制。</p><h2 id="Collection-Sets-与-它的重要性"><a href="#Collection-Sets-与-它的重要性" class="headerlink" title="Collection Sets 与 它的重要性"></a>Collection Sets 与 它的重要性</h2><p>在任何垃圾回收pause期间，将释放CSet中的所有region。 CSet是在垃圾回收pause期间要回收的一组region。这些候选region中的所有存活对象将在回收过程中复制转移，这些region将返回到空闲region列表中。在年轻代回收期间，CSet只能包含要回收的年轻代region。另一方面，混合垃圾回收不仅会在其CSet中添加所有年轻代region，还会添加一些old regions（基于它们的GC效率）。<br>有两个重要的参数有助于选择混合垃圾回收的CSet的候选old region：-XX：G1MixedGCLiveThresholdPercent和-XX：G1OldCSetRegionThresholdPercent。<br><strong><em>-XX：G1MixedGCLiveThresholdPercent（默认值为G1 GCregion的85％（JDK 8u45））是活动阈值，是一个设置限制，用于从混合垃圾回收的CSet中排除最耗时的old region。 G1 GC设置了一个限制，以使任何低于此活动性阈值的old region都包含在混合集合的CSet中。</em></strong><br>-XX：G1OldCSetRegionThresholdPercent，默认为Java堆总数的10％（JDK 8u45），它设置了每个混合垃圾回收pause可回收的old region数的最大限制。该阈值取决于JVM进程可用的Java总堆，并表示为Java总堆的百分比。</p><h2 id="Remembered-Sets与它的重要性"><a href="#Remembered-Sets与它的重要性" class="headerlink" title="Remembered Sets与它的重要性"></a>Remembered Sets与它的重要性</h2><p>分代垃圾回收器根据对象的使用期限将对象隔离在堆中的不同region中。堆中的这些不同region称为世代。然后，分代垃圾回收器可以将其大部分垃圾回收工作集中在最近分配的对象上，因为它希望发现大多数对象早早的死掉。堆中的这些世代可以独立回收。独立回收有助于降低响应时间，因为GC不必扫描整个堆，而且（例如，在复制世代回收器的情况下）不必来回复制较旧的长期存在的对象，从而减少了复制和引用更新的开销。</p><p> 为了促进垃圾回收的独立性，许多垃圾回收器为它们的代维护RSets。 RSet是一种数据结构，可帮助维护和跟踪对其自身的引用（在G1 GC的情况下是一个region），从而无需扫描整个堆以获取此类信息。当G1 GC执行STW垃圾回收（年轻或混合）时，它将扫描其CSet中包含的region的RSet。一旦移动了该region中的存活对象，它们的传入引用就会更新。<br>使用G1 GC，在任何年轻或混合垃圾回收期间，始终会完整垃圾回收年轻代，从而无需跟踪其包含对象驻留在年轻代中的引用。这减少了RSet开销。因此，G1 GC仅需要在以下两种情况下维护RSets：</p><ul><li>老年代到年轻代的引用-G1 GC维护从老年代region到年轻代region的指针。年轻代region被称为“属于” RSet，因此该region被称为“拥有” region 的Rset。</li><li>老年代到老年代的引用-来自老年代中不同region的指针将保留在“own”老年代region的RSet中。</li></ul><p><img src="/media/article/g1-rset.png" alt="g1-rset"></p><p> 在图2.3中，我们可以看到一个young region（x region）和两个old region（y region和z region）。region x具有来自region z的传入引用。在region x的RSet中记录了此参考。我们还观察到，region z有两个传入引用，一个来自region x，另一个来自region y。region Z的RSet只需要记下来自region y的传入参考，而不必记住来自region x的参考，因为如前所述，年轻代总是被完整地垃圾回收。最后，对于region y，我们看到来自region x的传入引用，这在region y的RSet中未注明，因为region x是young region。<br>如图2.3所示，每个region只有一个RSet。根据应用程序的不同，可能是某个特定region（因此它的RSet）是“popular”，因此在同一region甚至在同一位置可能会有许多更新。这在Java应用程序中并不罕见。<br>G1 GC具有处理此类popular需求的方式；它通过更改RSets的密度来实现。 RSets的密度遵循三个级别的粒度，即稀疏，细粒度和粗粒度。对于一般region，RSet可能会被粗化以容纳来自其他各个region的指针。这将反映在这些region的RSet扫描时间中。 这三种粒度级别中的每一种都有一个针对任何特定RSet的PRT(per-region-table, PRT)抽象容器。由于G1 GC region在内部进一步划分为块，在G1 GC region级别中，可实现的最低粒度是512字节堆块，称为“card”（请参见图2.4）。全局卡表维护所有卡。</p><p>当指针引用RSet的所属region时，在PRT中会记录包含该指针的card。稀疏的PRT本质上是那些card索引的哈希表。这种简单的实现可加快垃圾回收器的扫描速度。另一方面，细粒度的PRT和粗粒度的bit map以不同的方式处理。对于细粒度的PRT，其开放哈希表中的每个entry都对应一个region（具有对所属region的引用），该region中的卡片索引存储在bit map中。细粒度的PRT有一个最大限制，当超过该值时，会在粗粒度bit map中设置一个位（称为“粗粒度位”）。设置了粗粒度位后，将删除细粒度PRT中的相应entry。粗粒度的bit map就是一个bit map，每个region有一个位，这样一个设置位就意味着相应的region可能包含对所属region的引用。因此，必须扫描与设置位关联的整个region以找到引用。因此，将Remembered set粗化为粗粒度bit map对于扫描垃圾回收器而言是最慢的。</p><p>在任何回收周期中，当扫描Remembered set并因此扫描PRT中的card时，G1 GC都会在全局卡表中标记相应的entry，以避免重新扫描该card。在回收周期结束时，此卡表被清除；这在GC输出（用-XX：+ PrintGCDetails打印）中显示为Clear CT，并且紧接在GC线程完成的并行工作之后（例如，外部根扫描，更新和扫描Remembered set，对象复制，和终止协议）。还有其他顺序活动，例如选择和释放CSet以及引用处理和排队。这是使用JDK 8u45构建的-XX：+ UseG1GC -XX：PrintGCDetails -XX：PrintGCTimeStamps的示例输出。 RSet和card表活动突出显示。</p><h2 id="并发优化线程与屏障"><a href="#并发优化线程与屏障" class="headerlink" title="并发优化线程与屏障"></a>并发优化线程与屏障</h2><p>高级的RSet结构以写入障碍和并发“细化”线程的形式带来了其自身的维护成本。<br>屏障是在托管运行中执行某些语句时执行的native代码段。垃圾回收算法中使用屏障的方法已经很成熟，由于本机指令路径长度增加，执行屏障代码的相关成本也相应的增加。<br>OpenJDK HotSpot的Parallel Old和CMS GC使用写屏障，该屏障在HotSpot JVM执行对象引用写操作时执行：</p><p><code>object.field = some_other_object;</code></p><p>屏障更新了卡片表类型的结构[2]，以跟踪跨代引用。在minor垃圾回收期间将扫描卡表。写屏障算法基于UrsHölzle的快速写屏障[3]，可将屏障开销减少中只有两条额外的编译后的代码指令。<br>G1 GC采用pre-write和post-write屏障。前者在实际应用程序分配之前执行，并在并发标记部分中进行了详细介绍，而后者在分配之后执行，并在此处进行了详细描述。</p><p>每当引用更新时，G1 GC都会发出写屏障。例如，考虑以下伪代码中的更新：</p><p><code>object.field = some_other_object;</code></p><p>该分配将触发屏障代码。由于屏障是在写入任何引用之后发出的，因此称为“post-write”屏障。写障碍指令顺序会变得非常昂贵，并且应用程序的吞吐量将与屏障代码的复杂性成比例地下降；因此，由于需要在拥有region的RSet中捕获跨region引用更新，因此G1 GC会进行最少的工作量来确定引用更新是否为跨region更新。对于G1 GC，屏障代码包括一种过滤技术，该过滤技术在“Older-First Garbage Collection in Practice”中[4]进行了简要讨论，该技术涉及一个简单的检查，当更新在同一region时，该检查的结果为零。以下伪代码说明了G1 GC的写障碍：</p><p><code>(&amp;object.field XOR &amp;some_other_object) &gt;&gt; RegionSize</code></p><p>每当进行跨region更新时，G1 GC都会将相应的card排入称为“更新日志缓冲区”或“dirty card队列”的缓冲区中。在我们的更新示例中，包含card的对象记录在更新日志缓冲区中。</p><p>并发优化线程是专用于通过以下方式维护线程的线程：通过扫描已填充日志缓冲区中的已记录卡，然后为那些region更新remembered sets来维护remembered sets。优化线程的最大数量由–XX：G1ConcRefinementThreads确定。从JDK 8u45开始，如果未在命令行上设置–XX：G1ConcRefinementThreads，则按照人体工程学将其设置为与–XX：ParallelGCThreads相同。</p><p>一旦更新日志缓冲区达到其容纳容量，它将被淘汰，并分配一个新的日志缓冲区。然后，card入队在此新缓冲区中发生。retired的缓冲区放置在全局列表中。一旦优化线程在全局列表中找到entry，它们就会开始并发处理retired的缓冲区。优化线程始终处于活动状态，尽管最初只有几个可用。 G1 GC以分层的方式处理并发优化线程的部署，添加了更多线程以跟上已填充的日志缓冲区的数量。激活阈值由以下标志设置：-XX：G1ConcRefinementGreenZone，-XX：G1ConcRefinementYellowZone和-XX：G1ConcRefinementRedZone。如果并发的优化线程无法跟上已填充缓冲区的数量，请向mutator线程寻求帮助。此时，mutator线程将停止其工作，并帮助并发的优化线程完成对已填充日志缓冲区的处理。 GC术语中的mutator线程是Java应用程序线程。因此，当并发​​优化​​线程无法满足已填充缓冲区的数量时，Java应用程序将被暂停，直到处理已填充日志缓冲区为止。因此，应采取措施避免这种情况。</p><blockquote><p>不应要求用户手动调整三个优化region中的任何一个。有时很少需要调整–XX：G1ConcRefinementThreads或–XX：ParallelGCThreads。</p></blockquote><h2 id="G1-GC的并发标记"><a href="#G1-GC的并发标记" class="headerlink" title="G1 GC的并发标记"></a>G1 GC的并发标记</h2><p>随着G1 GC region的引入和每个region的活跃度统计，很明显，需要一种增量且完整的并发标记算法。 Taiichi Yuasa提出了一种增量标记和扫描GC的算法，其中他采用了“snapshot-at-the-beginning”（SATB）标记算法[5]。</p><p>Yuasa的SATB标记优化集中在mark-sweep GC的并发标记阶段。 SATB标记算法非常适合G1 GC的region化堆结构，并解决了有关HotSpot JVM的CMS GC算法的主要抱怨，即潜在的长时间注释暂停。</p><p>G1 GC建立了标记阈值，该阈值表示为Java总堆的百分比，默认为45％。超过此阈值时，可以使用-XX：InitiatingHeapOccupancyPercent（IHOP）选项在命令行中设置该阈值，将启动并发标记周期。标记任务被划分为多个块，以使大多数工作在mutator线程处于活动状态时同时完成。目标是在整个Java堆达到其最大容量之前对其进行标记。</p><p>SATB算法仅创建一个对象图，该对象图是堆的逻辑“snapshot”。 SATB标记可确保快照将识别并发标记阶段开始时存在的所有垃圾对象。<strong><em>在并发标记阶段分配的对象将被视为存活对象，但不会跟踪它们，从而减少了标记开销。</em></strong> 该技术确保在标记阶段开始时仍处于活动状态的所有存活对象被标记和跟踪，并且在标记周期内由并发的mutator线程进行的任何新分配都被标记为存活，因此不会被收集。</p><p>标记数据结构仅包含两个bitmap：previous和next。previous bitmap保存最后的完整标记信息。当前标记周期创建并更新next bitmap。随着时间的流逝，先前的标记信息变得越来越陈旧。最终，next bitmap将在标记周期完成时替换previous bitmap。</p><p>对应于next bitmap和previous bitmap，每个G1 GC堆region都有两个标记开始（TAMS）字段，分别称为previous TAMS（或PTAMS）和 next TAMS（或NTAMS）。 TAMS字段可用于标识在标记周期内分配的对象。</p><p><img src="/media/article/g1-marking.png" alt="g1-marking"></p><p>在标记周期开始时，NTAMS字段设置为每个region的当前顶部，如图2.5所示。自标记周期开始以来已分配（或已死亡）的对象位于相应的TAMS值之上，并被认为是隐式存在的。 TAMS下的存活对象需要明确标记。让我们来看一个例子：</p><p><img src="/media/article/g1-marking2.png" alt="g1-marking2"></p><p>在图2.6中，我们看到了并发标记，如图所示，带有“previous bitmap”，“next bitmap”，“ PTAMS”，“ NTAMS”和“Top”。 PTAMS与堆的Bottom（在图中表示为“Bottom”）之间的活动对象均已标记并保留在先前的位图中，如图2.7所示。如图2.8所示，PTAMS与堆区顶部之间的所有对象都是隐式活动的（相对于以前的位图）。这些包括在并发标记期间分配的对象，因此被分配在NTAMS上方，并且相对于next bitmap隐式存在，如图2.10所示。标记暂停后，PTAMS上方和NTAMS下方的所有活动对象都被完全标记，如图2.9所示。如前所述，在并发标记周期中分配的对象将分配给NTAMS之上，并被视为相对于next bitmap隐式存在（请参见图2.10）。</p><p><img src="/media/article/g1-marking3.png" alt="g1-marking3"></p><h2 id="并发标记阶段"><a href="#并发标记阶段" class="headerlink" title="并发标记阶段"></a>并发标记阶段</h2><p>标记任务块几乎同时执行。在短暂的STW期间，一些任务已完成。现在让我们谈谈这些任务的重要性。</p><h3 id="Initial-Mark-Stop-the-World-Event"><a href="#Initial-Mark-Stop-the-World-Event" class="headerlink" title="Initial Mark(Stop the World Event)"></a>Initial Mark(Stop the World Event)</h3><p>在初始标记期间，mutator线程将停止，以便于标记Java堆中所有可由GC Roots直接访问的对象（也称为根对象）。</p><blockquote><p>根对象是可以从Java堆外部访问的对象。本机堆栈对象和JNI（Java本机接口）本地或全局对象是一些示例。</p></blockquote><p>由于mutator线程已停止，因此初始标记阶段是“STW”阶段。另外，由于年轻代也可以追溯到roots，因此可以与常规的年轻代同时进行初始标记（方便且省时）。这也称为“piggybacking”。在初始标记暂停期间，每个region的NTAMS值将设置为该region的当前Top（请参见图2.5）。重复进行此操作，直到处理完堆的所有region为止。</p><p><img src="/media/article/g1-marking.png" alt="g1-marking"></p><h3 id="Root-region-Scanning"><a href="#Root-region-Scanning" class="headerlink" title="Root region Scanning"></a>Root region Scanning</h3><p>在为每个区域设置TAMS之后，重新启动mutator线程，并且G1 GC现在与mutator线程并发工作。为确保标记算法的正确性，在Initial-Mark年轻代垃圾回收期间需要扫描复制到survivor region的对象，并将其视为marking roots。因此，G1 GC开始扫描survivor region。从survivor region引用的任何对象都被标记。因此，将以此方式扫描的survivor region称为“root regions”。<br>root region扫描阶段必须在下一个垃圾回收暂停之前完成，因为从survivor region引用的所有对象都必须被识别并标记，然后才能扫描整个堆中的活动对象。</p><h3 id="Concurrent-Marking"><a href="#Concurrent-Marking" class="headerlink" title="Concurrent Marking"></a>Concurrent Marking</h3><p>并发标记阶段是并发和多线程的。设置要使用的并发线程数的命令行选项是-XX：ConcGCThreads。默认情况下，G1 GC将线程总数设置为并行线程(-XX:ParallelGCThreads)的四分之一，并行GC线程是在VM启动时由JVM计算的。并发线程一次扫描一个region，并使用“finger”指针优化来标识该region。这种“finger”指针优化类似于CMS GC的“finger”优化，可以在[2]中进行研究。<br>如“ RSets及其重要性”部分所述，G1 GC还使用pre-write屏障来执行SATB并发标记算法所需的操作。当应用程序更改其对象图时，在标记开始时可到达的对象和快照的一部分可能会被<strong>标记线程发现和跟踪之前</strong>被覆盖。因此，SATB标记保证要求修改变量线程在SATB日志队列/缓冲区中记录需要修改的指针的先前值。这被称为“并发标记/ SATB pre-write屏障”，因为屏障代码是在更新之前执行的。pre-write屏障可以记录对象引用字段的previous value，以便并发标记可以通过值被覆盖的对象进行标记。</p><p>marking_is_active条件是对thread-local标志的简单检查，该标志在 initial-mark pause期间在标记开始时设置为true。通过此检查来保护其余的屏障前代码，可减少标记未激活时执行屏障代码其余部分的开销。由于该标志是线程本地的，并且其值可能会多次加载，因此任何单个检查都可能会命中缓存，从而进一步减少了屏障的开销。<br>satb_enqueue（）首先尝试将先前的值放入线程本地缓冲区（称为SATB缓冲区）中。 SATB缓冲区的初始大小为256个entries，并且每个应用程序线程都有一个SATB缓冲区。如果没有空间将pre_val放置在SATB缓冲区中，则会调用JVM runtime。该线程的当前SATB缓冲区将retired，并放置在已填充SATB缓冲区的全局列表中，为该线程分配一个新的SATB缓冲区，并记录pre_val。并发标记线程的工作是定期检查和处理已填充的缓冲区，以启用对已记录对象的标记。<br>通过遍历每个缓冲区并通过设置来标记每个记录的对象，从全局列表中处理（在标记阶段）已填充的SATB缓冲区标记bitmap中的相应位（如果对象位于finger后面，则将对象推到本地标记堆栈上）。标记然后遍历标记bitmap的一部分中的设置位，跟踪标记对象的字段引用，在标记bitmap中设置更多位，并根据需要推送对象。<br>实时数据记帐在标记操作中进行。因此，每次标记一个对象时，该对象也会被计数（即，其字节将添加到该region的总数中）。仅标记和计数NTAMS以下的对象。在此阶段结束时，将清除next标记bitmap，以便在下一个标记周期开始时准备就绪。这是与mutator线程同时完成的。</p><blockquote><p>JDK 8u40引入了一个新的命令行选项-XX：+ ClassUnloadingWithConcurrentMark，默认情况下，它启用带有并发标记的类卸载。因此，并发标记可以跟踪类并计算其活跃度。在备注阶段，可以卸载不可达的类。</p></blockquote><p><img src="/media/article/concurrent-marking.png" alt=""></p><h3 id="Remark-Stop-the-World-Event"><a href="#Remark-Stop-the-World-Event" class="headerlink" title="Remark(Stop the World Event)"></a>Remark(Stop the World Event)</h3><p>Remark阶段是最后的标记阶段。在这个STW的阶段，G1 GC完全耗尽了所有剩余的SATB日志缓冲区并处理了所有更新。 G1 GC还可以遍历所有未访问的活动对象。从JDK 8u40开始，备注阶段是STW，因为更改程序线程负责更新SATB日志缓冲区，并因此“own”了这些缓冲区。因此，最终的STW是必要的，以覆盖所有实时数据并安全地完成实时数据记帐。为了减少在此暂停中花费的时间，使用多个GC线程并行处理日志缓冲区。 -XX：ParallelGCThreads帮助设置任何GC暂停期间可用的GC线程数。引用处理也是备注阶段的一部分。</p><blockquote><p>任何大量使用引用对象（弱引用，软引用，虚引用或强引用）的应用程序都可能由于引用处理开销而导致较高的remark时间。我们将在第3章中了解更多信息。</p></blockquote><p><img src="/media/article/remark-phase.png" alt=""></p><h3 id="Cleanup-Stop-the-World-Event-and-Concurrent"><a href="#Cleanup-Stop-the-World-Event-and-Concurrent" class="headerlink" title="Cleanup(Stop the World Event and Concurrent)"></a>Cleanup(Stop the World Event and Concurrent)</h3><p>在清理暂停期间，两个标记bitmap会互换角色：next bitmap成为previous bitmap（假定当前标记周期已完成，并且previous bitmap现在具有一致的标记信息），并且previous bitmap将成为next bitmap（将在下一个循环中用作当前标记bitmap）。同样，PTAMS和NTAMS也会互换角色。清理暂停的三个主要作用是识别完全空闲的region，对堆region进行排序以识别用于混合垃圾回收的有效旧region以及RSet清理。当前的启发式排名根据活动性对region进行排序（具有大量活动对象的region的收集确实非常耗时，因为复制是一项耗时的操作）和Remembered Set的大小（同样，具有大Remembered Set的region因region‘s popularity 回收而非常耗时）。目标是首先回收/疏散被认为耗时较少（存活较少，较低的popular）的候选region。<br>识别每个region中存活对象的一个​​优势是，遇到完全空闲的region（即没有存活对象的region）时，可以不必等待回收（混合）垃圾器回收暂停，清除其Remembered Set，并且可以立即回收该region并将其返回到空闲region列表中，而不是将其放置在GC-efficient的已排序数组中。 RSet清理还有助于检测过时的引用。例如，如果标记发现某个特定card上的所有对象均已失效，则该特定card的entry将从“owning” RSet中清除。</p><p><img src="/media/article/clean-up.png" alt=""></p><h2 id="Copying-Stop-the-World-Event"><a href="#Copying-Stop-the-World-Event" class="headerlink" title="(*) Copying(Stop the World Event)"></a>(*) Copying(Stop the World Event)</h2><p>These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as [GC pause (young)]. Or both young and old generation regions which are logged as [GC Pause (mixed)].</p><p>疏散或者复制存活对象到新的未使用regions。这个可以发生在年轻代regions，被标记为<code>[GC pause(young)]</code>。或者年轻代和老年代regions都发生，被标记为<code>[GC Pause (mixed)]</code>。</p><p><img src="/media/article/copying-phase.png" alt=""></p><h2 id="疏散失败和全部回收"><a href="#疏散失败和全部回收" class="headerlink" title="疏散失败和全部回收"></a>疏散失败和全部回收</h2><p>有时，G1 GC在尝试从young region复制存活对象时或在从old region撤离期间尝试复制存活对象时找不到空闲region。此类故障在GC日志中报告为空间耗尽故障，并且故障持续时间在日志中进一步显示为疏散故障时间（在以下示例中为331.5ms）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111.912: [GC pause (G1 Evacuation Pause) (young) (to-space exhausted), 0.6773162 secs]</span><br><span class="line">&lt;snip&gt;</span><br><span class="line">[Evacuation Failure: 331.5 ms]</span><br></pre></td></tr></table></figure><p>有时，大型分配可能无法在老年代中找到用于分配大型对象的连续region。<br>此时，G1 GC将尝试增加其对Java堆的使用。如果无法成功扩展Java堆空间，则G1 GC触发其故障保护机制，并退回到serial（单线程）full gc。</p><p>在full gc期间，单个线程在整个堆上运行，并做标记，清除和压缩构成世代的所有region（昂贵或其他）。回收完成之后，生成的堆现在由存活对象组成，并且所有世代都已完全压缩。</p><blockquote><p>在JDK 8u40之前，只能在full gc中卸载类。</p></blockquote><p>serial full gc的单线程性质以及该集合跨越整个堆的事实会使它成为非常耗时的垃圾回收操作，尤其是在堆大小相当大的情况下。因此，强烈建议在这样的情况下进行非常规的调优测试，在这种情况下，经常发生full gc。</p><p>选项和默认值：<br>-XX：+ UseG1GC    使用G1垃圾回收器<br>-XX：MaxGCPauseMillis = n    设置最大GC pause时间的目标。这是一个软目标，JVM将尽最大的努力来实现它。<br>-XX：InitiatingHeapOccupancyPercent = n    启动并发GC周期的（整个）堆占用百分比。GC使用它来触发GC，该GC基于整个堆的占用来触发并发GC周期，而不仅仅是世代之一（例如，G1）。值为0表示“进行恒定的GC循环”。默认值为45。<br>-XX：NewRatio = n    年轻代/老年代内存占比。预设值为2。<br>-XX：SurvivorRatio = n     eden/survior空间大小之比。预设值为8。<br>-XX：MaxTenuringThreshold = n 年轻代升级阀值。预设值为15。<br>-XX：ParallelGCThreads = n    设置在垃圾回收器的并行阶段使用的线程数。缺省值随运行JVM的平台而异。<br>-XX：ConcGCThreads = n    并发垃圾 回收器将使用的线程数。缺省值随运行JVM的平台而异。<br>-XX：G1ReservePercent = n    保留空间，虚拟机至少保证晋升时有这么多的空间可以使用，默认10%<br>-XX：G1HeapregionSize = n    使用G1，Java堆可细分为大小一致的region。这将设置各个细分的大小。该参数的默认值是根据堆大小按人机工程学确定的。最小值为1Mb，最大值为32Mb。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a><br><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a><br><a href="https://www.jianshu.com/p/aef0f4765098" target="_blank" rel="noopener">G1垃圾回收器详解  </a><br><a href="https://cloud.tencent.com/developer/article/1459638" target="_blank" rel="noopener">详解 JVM Garbage First(G1) 垃圾 回收器</a><br><a href="">Charlie H, Monica B, Poonam P, Bengt R. Java Performance Companion</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMQ 学习随笔</title>
      <link href="/middleware/2020-02-21-rabbitmq/"/>
      <url>/middleware/2020-02-21-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于RabbitMQ的Connection"><a href="#1-关于RabbitMQ的Connection" class="headerlink" title="1. 关于RabbitMQ的Connection"></a>1. 关于RabbitMQ的Connection</h2><p>Connection可以用来创建多个Channel实例，但是Channel实例不能在线程间共享。某些情况下Channel的操作可以并发运行，但是在其他情况下会导致网络上出现错误的通信帧交错，同时也会影响发送方确认(publisher confirm)机制的运行，所以多线程间共享Channel是非线程安全的。</p><p>应用程序应该为每一个线程开辟一个Channel。</p><h2 id="2-慎用方法"><a href="#2-慎用方法" class="headerlink" title="2. 慎用方法"></a>2. 慎用方法</h2><ul><li>isOpen，这个方法返回值依赖shutdownCause，会引起锁竞争。</li></ul><h2 id="3-交换器声明参数说明"><a href="#3-交换器声明参数说明" class="headerlink" title="3. 交换器声明参数说明"></a>3. 交换器声明参数说明</h2><p><code>exchangeDeclare(String exchange, String type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; args) throws IOException;</code></p><ul><li>exchange: 交换器名称。</li><li>type: 交换器名称，四种: direct、fanout、topic、headers。</li><li>durable: 设置是否持久化。durable设置为true表示持久化，反之是非持久化。</li><li>autoDelete: 设置是否自动删除，设置为true表示自动删除，自动删除的前提是: 至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。</li><li>internal: 设置是否是内置的，设置为true表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到这个交换器这种方式。</li><li>argument: 其他的一些结构化参数。alternate-exchange。</li></ul><p>其他重载方法参数说明：</p><p><code>exchangeDeclareNoWait(String exchange, String type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; args) throws IOException;</code></p><p>nowait 参数指AMQP中定义队列不需要服务器返回，返回值为void。<strong><em>不建议使用</em></strong></p><p><code>exechangeDeclarePassive(String name)</code>这个方法主要用来检测交换器是否存在，存在正常返回，不存在抛出异常。</p><p>ifUnused: 设置是否在交换器没有被使用情况下删除。否则任何情况下都可以删除。</p><h2 id="4-队列参数说明"><a href="#4-队列参数说明" class="headerlink" title="4. 队列参数说明"></a>4. 队列参数说明</h2><p><code>queueDeclare(String queue, boolean durable, boolean execlusive, boolean autoDelete, Map&lt;String, Object arguments) throws IOException;</code></p><ul><li>queue: 队列名称。</li><li>durable: 设置是否持久化。为true则设置队列持久化。</li><li>exclusive: 设置是否排他。如果设置为排他，则仅对首次声明它的连接可见，并在连接断开时（即使设置了持久化）自动删除。排他队列是基于连接(Connection)可见的，同一个连接断开时自动删除。排他是基于连接的，同一个连接的不同信道是可以同时访问同一连接创建的排他队列。</li><li>autoDelete: 设置是否自动删除，自动删除的前提是: 至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。</li><li>arguments: 设置队列的其他参数。x-message-ttl、x-expires、x-max-length、x-max-length-bytes、x-dead-letter-exchange、x-dead-letter-routing-key、x-max-priority等。</li></ul><p>消费者在信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，将信道设置为“传输”。</p><p>ifEmpty: 设置为true,表示在队列为空的情况下才能删除。</p><h2 id="5-发送消息参数说明"><a href="#5-发送消息参数说明" class="headerlink" title="5. 发送消息参数说明"></a>5. 发送消息参数说明</h2><p><code>void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException;</code></p><ul><li>exchange: 交换器名称，如果设置为空，则消息会发送到默认交换器中。</li><li>routingKey: 路由健， 交换器根据路由健将消息存储到相应的队列中。</li><li>props: 消息的基本属性集: 其中包含属性成员，分别有contentType、contentEncoding、headers(Map&lt;String, Object&gt;)、deliverMode、priority、correlationId、replyTo、expriation、messageId、timestamp、type、userId、appId、clusterId。</li><li>byte[] body: 消息体。</li><li>mandatory: 设置为true时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ会调用Basic.return命令将消息返回给生产者。否则消息直接被丢弃。</li><li>immediate: 设置为true时， 如果交换器在将消息路由到队列都没有消费者时，该消息会通过Basic.Return返回至生产者。</li></ul><h2 id="6-使用mandatory参数时如何获取没有被正确路由到合适队列的消息"><a href="#6-使用mandatory参数时如何获取没有被正确路由到合适队列的消息" class="headerlink" title="6. 使用mandatory参数时如何获取没有被正确路由到合适队列的消息"></a>6. 使用mandatory参数时如何获取没有被正确路由到合适队列的消息</h2><p>可以通过调用channel.addReturnListener来添加ReturnListener监听器实现。</p><h2 id="7-消费消息参数说明"><a href="#7-消费消息参数说明" class="headerlink" title="7. 消费消息参数说明"></a>7. 消费消息参数说明</h2><p><code>String basicConsume(String queue, boolean actoAck, String consumerTag, boolean noLocal, boolean exclusive, Map&lt;String, Object&gt; arguments, Consumer callback) throws IOException;</code></p><ul><li>queue: 队列的名称。</li><li>autoAck: 设置是否自动确认。</li><li>consumerTag: 消费者标签，用来区分多个消费者。</li><li>noLocal: 设置true表示不能将同一个Connection中生产者发送的消息传送给这个Connection中的消费者。</li><li>exclusive: 设置是否排他。只允许当前连接消费。</li><li>argument: 设置消费者的其他参数。</li><li>callback: 设置消费者的回调函数。</li></ul><h2 id="8-确认消息参数说明"><a href="#8-确认消息参数说明" class="headerlink" title="8. 确认消息参数说明"></a>8. 确认消息参数说明</h2><p><code>void basicAck(long deliveryTag, boolean multiple) throws IOException;</code></p><ul><li>deliveryTag: 当一个消费者向RabbitMQ注册后，RabbitMQ会用 basic.deliver方法向消费者推送消息，这个方法携带了一个delivery tag，它在一个channel中唯一代表了一次投递。delivery tag的唯一标识范围限于channel（待验证）。delivery tag是单调递增的正整数，客户端获取投递的方法用dellivery tag作为一个参数。</li><li>mutiple: ack unack 的mutiple参数设置为true，则可以一次性应答delivery_tag小于等于传入值的所有应答。</li></ul><h2 id="9-备份交换器"><a href="#9-备份交换器" class="headerlink" title="9. 备份交换器"></a>9. 备份交换器</h2><p>如果不设置mandatory参数，那么在消息在未被路由的情况下将会丢失，设置了mandatory参数，那么需要添加ReturnListener的编程逻辑，生产者代码将变的复杂。</p><p>如果不想采取上述措施取确保消息发送成功，可以通过声明备份交换器，声明交换器时使用alternate-exchange参数实现，也可以通过Policy方式实现。</p><p>备份交换器如下特殊情况：</p><ul><li>如果设置的备份交换器不存在，则不会有异常出现，消息丢失。</li><li>如果设置的备份交换器未绑定任何队列，则不会有异常出现，消息丢失。</li><li>如果设置的备份交换器未匹配任何队列，则不会有异常出现，消息丢失。</li><li>如果备份交换器和mandatory一起使用，则mandatory失效。</li></ul><h2 id="10-消息过期时间"><a href="#10-消息过期时间" class="headerlink" title="10. 消息过期时间"></a>10. 消息过期时间</h2><p>目前有两种方式设置消息的过期时间：</p><ol><li><p>通过队列属性设置，所有消息都有相同的过期时间。设置队列属性x-message-ttl或者通过Policy设置。也可以通过HTTP API。消息过期会被立即删除。</p></li><li><p>通过对消息本身单独设置。在basicPulish方法中添加expiration的属性参数。也可以通过HTTP API。消息过期不会被立即删除，只有当消费者消费消息时判定消息是否过期。</p></li></ol><p>如果两种方式一块使用，则以过期时间较小的为准。</p><p>消息一旦到达过期时间，就会变成死信。</p><p>如果不设置ttl，则消息不会过期；如果ttl设置为0，此时除非将消息直接投递给消费者，否则该消息会被立即丢弃。</p><p>设置消息队列x-expires参数可以控制自动删除前处于未使用状态的时间。未使用的意思是队列上没有任何消费者，队列也没有被重新声明，并且在过期时间段内也未调用过Basic.Get命令。</p><h2 id="11-死信队列、死信交换器（Dead-Letter-Exchange）"><a href="#11-死信队列、死信交换器（Dead-Letter-Exchange）" class="headerlink" title="11. 死信队列、死信交换器（Dead-Letter-Exchange）"></a>11. 死信队列、死信交换器（Dead-Letter-Exchange）</h2><p>当一个消息在一个队列中变成死信时，它可以被重新发送到另一个交换器(DLX)中，绑定DLX的就被称为私信队列。</p><h2 id="12-延迟队列"><a href="#12-延迟队列" class="headerlink" title="12. 延迟队列"></a>12. 延迟队列</h2><p>延迟队列存储的对象时对应的延迟消息。延迟消息指消息被发送后（生产者？），并不想让消费者立即拿到这个消息，而是等待特定时间后，消费者才能拿这个消息消费。</p><h2 id="13-优先级队列"><a href="#13-优先级队列" class="headerlink" title="13. 优先级队列"></a>13. 优先级队列</h2><p>具有高优先级的队列具有高的被优先消费的特权。设置x-max-priority参数实现。</p><h2 id="14-RPC"><a href="#14-RPC" class="headerlink" title="14. RPC"></a>14. RPC</h2><p>时序图：</p><p><img src="/media/article/rabbitmq-rpc-seq.png" alt="rabbitmq-rpc-seq"></p><p>流程图：<br><img src="/media/article/rabbitmq-rpc-logic.png" alt="rabbitmq-rpc-logic"></p><h2 id="15-持久化"><a href="#15-持久化" class="headerlink" title="15. 持久化"></a>15. 持久化</h2><p>RabbitMQ持久化分为3个部分：交换器、队列、消息持久化。</p><p>交换器和队列通过durable设置持久化；消息持久化通过投递模式(deliveryMode)设置为2实现。</p><p>注意：<strong><em>持久化消息正确存入RabbitMQ时，还需要一定时间才能存入磁盘。</em></strong>为了解决这个问题，可以引入RabbitMQ的队列镜像机制，如果主节点挂掉，可以自动切换到从节点，这样就保证了队列的可靠性。</p><h2 id="16-生产者确认"><a href="#16-生产者确认" class="headerlink" title="16. 生产者确认"></a>16. 生产者确认</h2><p>为了保证消息正确存入RabbitMQ，有两种解决方式：</p><ul><li>事务方式: 虽然保证了数据的正确性，但是损耗RabbitMQ性能非常大（每次多一次命令帧的交互）。</li><li>通过发送方确认实现: 消息被发送到匹配队列后，RabbitMQ就会发送一个Basic.Ack给生产者。如果消息和队列是可持久化的，那么消息被写入磁盘后，才会发出ack确认。</li></ul><p>发送方确认有4种方式: 事务和普通confirm，批量和异步confirm。</p><p>批量confirm: 发送一批数据后，调用waitForConfirms方法，等待服务器确认返回。缺点是，如果存在一条NACK，则全部需要重新发送，容易造成重复数据。<br>异步confirm: 提供一个回调方法，服务端确认了一条或者多条消息后客户端会回调这个方法处理。</p><p>事务机制和发送确认机制是互斥的。</p><p>事务机制和发送确认机制确保消息能够正确的发至RabbitMQ，这里的发至指正确的发往至RabbitMQ的交换器，如果此时交换器没有绑定队列，消息丢失。</p><h2 id="17-消费消息"><a href="#17-消费消息" class="headerlink" title="17. 消费消息"></a>17. 消费消息</h2><p>消费消息需要注意：</p><ul><li>消息分发: 轮询的方式。</li><li>消息的顺序性: 消费者消息的消息和发布消息的顺序是一致的。RabbitMQ的顺序保障是从消息存入队列开始的。</li><li>弃用QueueingConsumer</li></ul><p><code>basicQos(int prefetchCount, int PrefetchSize,  boolean global)</code>参数说明：</p><ul><li>prefetchCount: 设置为0表示消息数量没有上限。</li><li>prefetchSize: 表示消费者所能接收为确认的总体大小上限，单位为B，设置为0表示没有上限。</li><li>global: true表示信道上所有的消费者都要遵从prefetchCount的限定值；false表示信道上新的消费者需要遵循prefetchCount的限定值。</li></ul><p>如果需要保证消息的顺序性，可以在消息体内加入序列来保持消息消费的有序性。</p><p>QueueingConsumer存在的问题:</p><ul><li>消费者内存溢出，导致服务宕机，队列堆积。</li><li>拖累同一个Connection的所有信道，使其性能降低。</li><li>同步递归调用QueueingConsumer会导致死锁。</li><li>RabbitMQ的自动连接恢复机制不支持QueueingConsumer。</li><li>QueueingConsumer不是事件驱动的。</li></ul><p>建议尽量使用继承DefaultConsumer的方式。</p><h2 id="18-消息传输保障"><a href="#18-消息传输保障" class="headerlink" title="18. 消息传输保障"></a>18. 消息传输保障</h2><p>At most once: 最多一次。可能丢失，但不重复。</p><p>At least once: 最少一次。不会丢失，可能重复。</p><p>Exactly once: 恰好一次。不会丢失，不会重复。此方式RabbitMQ无法保证。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/27591386/" target="_blank" rel="noopener">RabbitMQ实战指南</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 中间件 </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring AMQP</title>
      <link href="/spring/2020-02-13-spring-amqp/"/>
      <url>/spring/2020-02-13-spring-amqp/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ConnectionFactory"><a href="#1-ConnectionFactory" class="headerlink" title="1. ConnectionFactory"></a>1. ConnectionFactory</h2><p>工厂类的一些属性：</p><p>Connection and Channel Listeners用来监听Connection和Channel相关的事件（创建、关闭、终止)。</p><p>Channel关闭事件日志策略。</p><p>运行时缓存属性配置。在运行时动态的修改连接属性，比如，channel缓存大小、事务channel缓存大小。</p><p>RabbitMQ 自动的连接和拓扑恢复。</p><p>添加自定义客户端连接属性。<br><code>connectionFactory.getRabbitConnectionFactory().getClientProperties().put(&quot;thing1&quot;, &quot;thing2&quot;);</code></p><h3 id="1-1-CachingConnectionFactory"><a href="#1-1-CachingConnectionFactory" class="headerlink" title="1.1 CachingConnectionFactory"></a>1.1 CachingConnectionFactory</h3><p>CachingConnectionFactory有两种缓存模式：Connection和Channel。</p><p>CachingConnectionFactory是一个Connection工厂实现类（当缓存模式是<code>CachingConnectionFactory.CacheMode.CHANNEL</code>（默认）时，返回所有<code>createConnection()</code>调用都返回相同的Connection，忽略对<code>Connection.close()</code>的调用并缓存<code>Channel</code>）。<br>默认情况下，只缓存25个Channel，并根据需要创建和处理其他请求的Channel。在高并发情况下考虑提高<code>channelCacheSize</code>的值。<code>channelCacheSize</code>不限制channel的创建数量，如果需要限制，可以使用<code>channelCheckoutTimeout</code>，当此 <code>channelCheckoutTimeout</code> 大于零时，channelCacheSize将成为可以在连接上创建的 channel 数量的限制。如果达到限制，则调用线程将阻塞，直到 channel 可用或达到此超时，在这种情况下抛出AmqpTimeoutException。</p><p>当缓存模式是<code>CachingConnectionFactory.CacheMode.CONNECTION</code>时，每个<code>createConnection()</code>都会使用一个新的（缓存的）Connection；连接将根据<code>connectionCacheSize</code>的值缓存。在这种模式下，Connections和Channels都会被缓存。<code>connectionLimit</code>可以用来限制创建Connection的数量，当数量到达时可以使用<code>channelCheckoutTimeLimit</code>等待缓存中的连接空闲，如果超时，将抛出<code>AmqpTimeoutException</code>。</p><p>当使用比较大数量的Connection时，应该考虑在<code>CachingConnectionFactory</code>设置自定义的<code>executor</code>。<code>executor</code>的线程池应不受限制，或应针对预期用途进行适当设置（通常一个线程一个连接）。如果在每个Connection创建多个Channel，线程池的大小影响并发。因此，可变（或简单缓存）线程池执行程序将是最合适的。</p><p><code>CachingConnectionFactory.CacheMode.CONNECTION</code>模式和Rabbit Admin自动声明的队列不兼容。</p><p>CachingConnectionFactory要求显式关闭从其Connection获得的所有Channel。通常，代码都需要显式的关闭所有的Channel。但是，对于此ConnectionFactory，必须使用显式关闭才能真正使Channel重用。如果有空间（channelCacheSize），Channel.close（）会将通道返回到缓存，否则物理上关闭该通道。</p><h3 id="1-2-SimpleRoutingConnectionFactory"><a href="#1-2-SimpleRoutingConnectionFactory" class="headerlink" title="1.2 SimpleRoutingConnectionFactory"></a>1.2 SimpleRoutingConnectionFactory</h3><p>对多个ConnectionFactory进行管理。</p><ol><li>SimpleResourceHolder绑定lookupKey</li><li>RabbitTemplate表达式支持</li></ol><h2 id="2-AmqpTemplate"><a href="#2-AmqpTemplate" class="headerlink" title="2. AmqpTemplate"></a>2. AmqpTemplate</h2><h3 id="2-1-添加重试机制"><a href="#2-1-添加重试机制" class="headerlink" title="2.1 添加重试机制"></a>2.1 添加重试机制</h3><p>第一种方式是在rabbitTemplate中注入RetryTemplate，这种方式如果使用RecoveryCallback则只能在重试上下文中使用lastThrowable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public AmqpTemplate rabbitTemplate() &#123;</span><br><span class="line">    RabbitTemplate template = new RabbitTemplate(connectionFactory());</span><br><span class="line">    RetryTemplate retryTemplate = new RetryTemplate();</span><br><span class="line">    ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();</span><br><span class="line">    backOffPolicy.setInitialInterval(500);</span><br><span class="line">    backOffPolicy.setMultiplier(10.0);</span><br><span class="line">    backOffPolicy.setMaxInterval(10000);</span><br><span class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</span><br><span class="line">    template.setRetryTemplate(retryTemplate);</span><br><span class="line">    return template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种方式是直接使用retryTemplate进行重试，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">retryTemplate.execute(</span><br><span class="line">    new RetryCallback&lt;Object, Exception&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object doWithRetry(RetryContext context) throws Exception &#123;</span><br><span class="line">            context.setAttribute(&quot;message&quot;, message);</span><br><span class="line">            return rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, new RecoveryCallback&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object recover(RetryContext context) throws Exception &#123;</span><br><span class="line">            Object message = context.getAttribute(&quot;message&quot;);</span><br><span class="line">            Throwable t = context.getLastThrowable();</span><br><span class="line">            // Do something with message</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方式你可以在上下文中获取属性信息。</p><h3 id="2-2-怎样确认异步消息的成功和失败"><a href="#2-2-怎样确认异步消息的成功和失败" class="headerlink" title="2.2 怎样确认异步消息的成功和失败"></a>2.2 怎样确认异步消息的成功和失败</h3><p>默认情况下，rabbitmq将会删除不能被路由的消息，对于成功的消息，会返回一个异步的确认信息。<br>考虑如下两种情况：</p><ul><li>发送消息没有匹配的队列</li><li>发送消息没有匹配exchange</li></ul><p>第一种情况可以使用消息返回处理；第二种情况消息被删除，不会返回消息，channel关闭并抛出异常。这种情况你可以注册ChannelListener。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">this.connectionFactory.addConnectionListener(new ConnectionListener() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Connection connection) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    // signal中包含reson信息</span><br><span class="line">    public void onShutDown(ShutdownSignalException signal) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-3-发送消息确认与返回"><a href="#2-3-发送消息确认与返回" class="headerlink" title="2.3 发送消息确认与返回"></a>2.3 发送消息确认与返回</h3><h4 id="2-3-1-消息返回"><a href="#2-3-1-消息返回" class="headerlink" title="2.3.1 消息返回"></a>2.3.1 消息返回</h4><p>消息返回必须设置<code>mandatory</code>属性，或者发送消息时针对特定消息设置<code>mandatory-expression</code>属性。</p><p>消息返回可以通过rabbitTemplate设置返回回调。</p><p><code>rabbitTemplate.setReturnCallback(ReturnCallback callback)</code></p><p><strong><em> 注意：一个rabbitTemplate实例仅支持一个ReturnCallback。</em></strong></p><h4 id="2-3-2-消息确认"><a href="#2-3-2-消息确认" class="headerlink" title="2.3.2 消息确认"></a>2.3.2 消息确认</h4><p>消息确认需要设置<code>publisherConfirms</code>属性。</p><p>消息确认同样可以设置<code>ConfirmCallback</code>，用来处理消息返回确认。</p><p>值得特别注意的是使用消息确认时，需要等到最后一个消息确认完成时再关闭channel。</p><p>因为当connectfactory的channelCacheSize满了时，框架会在保持5秒channel后关闭channel，有可能导致没有足够的时间确认和消息返回。<br>当仅使用返回时，channel保持5秒开启。</p><p>只要返回回调在60秒或更短时间内执行，就可以保证在确认之前仍接收到返回的消息。确认在返回回调退出后或60秒后（以先到者为准）进行传递。</p><p>自从2.1版本开始，开始使用<code>CorrelationData</code>,而不是ConfirmCallback。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData cd1 = new CorrelationData();</span><br><span class="line">this.templateWithConfirmsEnabled.convertAndSend(&quot;exchange&quot;, queue.getName(), &quot;foo&quot;, cd1);</span><br><span class="line">assertTrue(cd1.getFuture().get(10, TimeUnit.SECONDS).isAck());</span><br></pre></td></tr></table></figure><p>另外，当同时启用确认和返回，<code>CorrelationData</code>由返回消息组成。它保证在使用将来设置ack之前发生这种情况。</p><h3 id="2-4-一种更简单的等待发布者确认的机制"><a href="#2-4-一种更简单的等待发布者确认的机制" class="headerlink" title="2.4 一种更简单的等待发布者确认的机制"></a>2.4 一种更简单的等待发布者确认的机制</h3><p>有时可能希望更好地控制通道的使用，并确保在同一通道上执行全部操作。</p><p>从2.0版本，提供了<code>invoke</code>方法，并带有一个<code>OperationCallback</code>。任何操作在callback的范围内及在提供的<code>RabbitOpertions</code>参数中执行都使用相同的<code>Channel</code>，这个channel在结束时关闭（不返回至缓存）。如果<code>Channel</code>是<code>PublisherCallbackChannel</code>，它在所有确认收到后返回至缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface OperationsCallback&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T doInRabbit(RabbitOperations operations);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可能需要这样做的一个示例是，如果您希望在基础Channel上使用waitForConfirms（）方法。如前所述，Spring API以前并未公开此方法，因为通常是对通道进行缓存和共享。<strong><em> RabbitTemplate现在提供了waitForConfirms（long timeout）和waitForConfirmsOrDie（long timeout），它们委托给OperationsCallback范围内使用特定channel。由于明显的原因，不能在该范围之外使用这些方法。</em></strong></p><p>如果您只想等待broker确认交付，则可以使用以下示例中显示的技术：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; messages = getMessagesToSend();</span><br><span class="line">Boolean result = this.template.invoke(t -&gt; &#123;</span><br><span class="line">    messages.forEach(m -&gt; t.convertAndSend(ROUTE, m));</span><br><span class="line">    t.waitForConfirmsOrDie(10_000);</span><br><span class="line">    return true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果您希望在OperationsCallback范围内的同一通道上调用RabbitAdmin操作，则必须使用与调用操作相同的RabbitTemplate构造admin。</p><p>如果在现有事务的范围内已经执行了template操作，例如，当在事务处理的listener container线程上运行并在事务处理的template上执行操作时，前面的讨论就没有什么意义了。在这种情况下，操作将在该通道上执行，并在线程返回到容器时提交。在这种情况下，不必使用invoke。</p><h3 id="2-5-Publisher使用单独的连接"><a href="#2-5-Publisher使用单独的连接" class="headerlink" title="2.5 Publisher使用单独的连接"></a>2.5 Publisher使用单独的连接</h3><p>从2.0.2版本开始，将<code>usePublisherConnection</code>属性设置为true，以便可能的情况下使用与listener容器使用的连接不同的连接。</p><p>如果声明的是独占队列，会因为使用不同的连接，导致其中某一个连接获取不到队列<br>通常，不应将RabbitAdmin与具有此设置为 true 的模板一起使用。使用带有连接工厂的RabbitAdmin构造函数;如果使用其他构造函数来获取模板，请确保模板的 property 为 false。这是因为通常使用 admin 来为 listener 容器声明队列;使用 property 设置为 true 的模板意味着将在与 listener 容器使用的连接不同的连接上声明独占队列(例如AnonymousQueue)。在这种情况下，容器不能使用队列。</p><h2 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3. 发送消息"></a>3. 发送消息</h2><h3 id="3-1-Message创建API"><a href="#3-1-Message创建API" class="headerlink" title="3.1 Message创建API"></a>3.1 Message创建API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(&quot;123&quot;)</span><br><span class="line">    .setHeader(&quot;bar&quot;, &quot;baz&quot;)</span><br><span class="line">    .build();</span><br><span class="line">Message message = MessageBuilder.withBody(&quot;foo&quot;.getBytes())</span><br><span class="line">    .andProperties(props)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Message message = MessageBuilder.withBody(&quot;foo&quot;.getBytes())</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(&quot;123&quot;)</span><br><span class="line">    .setHeader(&quot;bar&quot;, &quot;baz&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="3-2-批处理"><a href="#3-2-批处理" class="headerlink" title="3.2 批处理"></a>3.2 批处理</h3><p><code>BatchingRabbitTemplate</code></p><p>批量数据保存在 memory 中;未发送的消息可能会在系统故障的 event 中丢失。</p><p><code>BatchingRabbitTemplate</code>根据SimpleBatchingStrategy发送消息。它支持将消息发送到单个 exchange/routing key。它有 properties:</p><ul><li><p>batchSize - 发送前批处理中的消息数</p></li><li><p>bufferLimit - 批量消息的最大大小;如果超过，将抢占batchSize，并导致发送部分批次</p></li><li><p>timeout - 一个 time，当没有新的活动向批处理添加消息时，将发送部分批处理</p></li></ul><p>SimpleBatchingStrategy通过在每个嵌入消息之前使用4字节二进制长度来格式化批处理。通过将springBatchFormat message property 设置为lengthHeader4，将其传达给接收系统。</p><h2 id="3-3-消费消息"><a href="#3-3-消费消息" class="headerlink" title="3.3 消费消息"></a>3.3 消费消息</h2><h3 id="3-3-1-轮询消费者"><a href="#3-3-1-轮询消费者" class="headerlink" title="3.3.1 轮询消费者"></a>3.3.1 轮询消费者</h3><p>默认情况下，如果没有可用消息，则立即返回null;没有阻挡。从 version 1.5 开始，您现在可以设置receiveTimeout(以毫秒为单位)，接收方法将阻塞，知道最大过期时间。value 小于零意味着无限期地阻塞(或者至少在与 broker 的连接丢失之前)。 Version 1.6 引入了receive方法的变体，允许在每次调用时传递超时时间。</p><p>这种轮询操作会为每一个消息创建一个<code>QueueingConsumer</code>。所以不适用于大数据量的环境。</p><h3 id="3-3-2-异步消费者"><a href="#3-3-2-异步消费者" class="headerlink" title="3.3.2 异步消费者"></a>3.3.2 异步消费者</h3><h4 id="3-3-2-1-MessageListener"><a href="#3-3-2-1-MessageListener" class="headerlink" title="3.3.2.1 MessageListener"></a>3.3.2.1 MessageListener</h4><p>异步消息接收，涉及专用的回调容器。回调则是我们与消息集成的地方。MessageListener就是这种回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageListener &#123;</span><br><span class="line">    void onMessage(Message message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您的回调逻辑出于任何原因依赖于 AMQP Channel 实例，您可以改为使用ChannelAwareMessageListener。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ChannelAwareMessageListener &#123;</span><br><span class="line">    void onMessage(Message message, Channel channel) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-2-MessageListenerAdapter"><a href="#3-3-2-2-MessageListenerAdapter" class="headerlink" title="3.3.2.2 MessageListenerAdapter"></a>3.3.2.2 MessageListenerAdapter</h4><p>如果您希望在 application 逻辑和消息传递 API 之间保持更严格的分离，则可以依赖 framework 提供的适配器 implementation。这通常被称为“Message-driven POJO”支持。</p><p>从 version 2.0 开始，提供了方便的FunctionalInterface：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface ReplyingMessageListener&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">R handleMessage(T t);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这有助于使用 Java 8 lamdas 方便地配置适配器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new MessageListenerAdapter((ReplyingMessageListener&lt;String, String&gt;) data -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-3-消费者优先权"><a href="#3-3-2-3-消费者优先权" class="headerlink" title="3.3.2.3 消费者优先权"></a>3.3.2.3 消费者优先权</h4><p>从RabbitMQ Version 3.2开始，broker 现在支持 consumer 优先级(参见在 RabbitMQ 中使用 Consumer 优先级)。通过在 consumer 上设置x-priority参数来启用此功能。 SimpleMessageListenerContainer现在支持设置 consumer arguments：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">container.setConsumerArguments(Collections.</span><br><span class="line">&lt;String, Object&gt; singletonMap(&quot;x-priority&quot;, Integer.valueOf(10)));</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-4-容器监听自动删除队列"><a href="#3-3-2-4-容器监听自动删除队列" class="headerlink" title="3.3.2.4 容器监听自动删除队列"></a>3.3.2.4 容器监听自动删除队列</h4><p>当容器配置为侦听auto-delete queue(s)，或者队列具有x-expires选项或 Broker 上配置了Time-To-Live policy 时，broker 在容器停止时删除队列(最后 consumer 被取消)。在 version 1.3 之前，由于队列丢失，无法重新启动容器;当连接是 closed/opens 时，RabbitAdmin仅自动重新声明队列等，当容器为 stopped/started 时不会发生。</p><p>从 version 1.3 开始，容器现在将使用RabbitAdmin在启动期间重新声明任何丢失的队列。</p><p>您还可以使用条件声明和auto-startup=”false”一起来管理延迟声明队列，直到容器启动。</p><p>在这种情况下，队列和交换由containerAdmin声明，它具有auto-startup=”false”，因此在 context 初始化期间不会声明元素。此外，出于同样的原因，容器未启动。稍后启动容器时，它会使用 reference containerAdmin来声明元素。</p><h4 id="3-3-2-5-批处理消息"><a href="#3-3-2-5-批处理消息" class="headerlink" title="3.3.2.5 批处理消息"></a>3.3.2.5 批处理消息</h4><p>批处理的消息（由生产者创建）由侦听器容器自动分批处理（使用springBatchFormat消息头）。拒绝批次中的任何消息都会导致整个批次被拒绝。有关批处理的更多信息，请参见批处理。</p><p>设置容器属性ConsumerBatchEnabled以启用此功能。 deBatchingEnabled也必须为true，以便容器负责处理这两种类型的批次。当ConsumerBatchEnabled为true时，实现BatchMessageListener或ChannelAwareBatchMessageListener。有关将此功能与@RabbitListener一起使用的信息，请参阅带有批处理的@RabbitListener。</p><h4 id="3-3-2-6-消费者事件"><a href="#3-3-2-6-消费者事件" class="headerlink" title="3.3.2.6 消费者事件"></a>3.3.2.6 消费者事件</h4><p>每当侦听器（消费者）遇到某种类型的故障时，容器就会发布应用程序事件。事件ListenerContainerConsumerFailedEvent具有以下属性：</p><ul><li>container: 消费者遇到问题的侦听器容器。</li><li>reason: 失败的文字原因。</li><li>fatal: 指示失败是否致命的布尔值。对于非致命异常，容器将根据recoveryInterval或recoveryBackoff（对于SimpleMessageListenerContainer）或monitorInterval（对于DirectMessageListenerContainer）尝试重新启动消费者。</li><li>throwable: 被捕获的Throwable。</li></ul><p>如果消费者由于默认情况下不专门使用其队列以及发布事件而失败，那么将发出WARN日志。要更改此日志记录行为，请在SimpleMessageListenerContainer实例的ExclusiveConsumerExceptionLogger属性中提供自定义的ConditionalExceptionLogger。另请参阅记录通道关闭事件。</p><p>致命错误始终记录在ERROR级别。这是不可修改的。</p><p>在容器生命周期的各个阶段还发布了其他一些事件：</p><ul><li><p>AsyncConsumerStartedEvent：启动消费者时。</p></li><li><p>AsyncConsumerRestartedEvent：消费者在发生故障后重新启动时-仅SimpleMessageListenerContainer。</p></li><li><p>AsyncConsumerTerminatedEvent：消费者正常停止时。</p></li><li><p>AsyncConsumerStoppedEvent：消费者停止时-仅SimpleMessageListenerContainer。</p></li><li><p>ConsumeOkEvent：当从Broker接收到一个consumerOk时，包含队列名称和consumerTag</p></li><li><p>ListenerContainerIdleEvent：请参阅检测空闲的异步消费者。</p></li></ul><h4 id="3-3-2-7-消费者标签"><a href="#3-3-2-7-消费者标签" class="headerlink" title="3.3.2.7 消费者标签"></a>3.3.2.7 消费者标签</h4><p>默认情况下，消费者标签由broker提供。你可以使用ConsumerTagStrategy实现自己的命名策略。</p><h4 id="3-3-2-8-注解驱动的侦听器端点"><a href="#3-3-2-8-注解驱动的侦听器端点" class="headerlink" title="3.3.2.8 注解驱动的侦听器端点"></a>3.3.2.8 注解驱动的侦听器端点</h4><p>异步接收消息的最简单方法是使用带注释的侦听器端点基础结构。简而言之，它使您可以将托管bean的方法公开为Rabbit侦听器端点。以下示例显示了如何使用@RabbitListener批注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">    public void processOrder(String data) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式，绑定了已经存在的队列。除了上述的方式，你还可以使用自动声明队列的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">  @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue(value = &quot;myQueue&quot;, durable = &quot;true&quot;),</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.exch&quot;, ignoreDeclarationExceptions = &quot;true&quot;),</span><br><span class="line">        key = &quot;orderRoutingKey&quot;)</span><br><span class="line">  )</span><br><span class="line">  public void processOrder(Order order) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue,</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.exch&quot;),</span><br><span class="line">        key = &quot;invoiceRoutingKey&quot;)</span><br><span class="line">  )</span><br><span class="line">  public void processInvoice(Invoice invoice) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @RabbitListener(queuesToDeclare = @Queue(name = &quot;$&#123;my.queue&#125;&quot;, durable = &quot;true&quot;))</span><br><span class="line">  public String handleWithSimpleDeclare(String data) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一个示例中，队列myQueue与交换（如果需要）一起自动（持久）声明，并与路由键绑定到交换。在第二个示例中，声明并绑定了一个匿名（专有的，自动删除）队列。可以提供多个QueueBinding条目，让侦听器侦听多个队列。在第三个示例中，如有必要，将声明一个具有从属性my.queue检索到的名称的队列，并使用该队列名称作为路由键将其默认绑定到默认交换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue(value = &quot;auto.headers&quot;, autoDelete = &quot;true&quot;,</span><br><span class="line">                        arguments = @Argument(name = &quot;x-message-ttl&quot;, value = &quot;10000&quot;,</span><br><span class="line">                                                type = &quot;java.lang.Integer&quot;)),</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.headers&quot;, type = ExchangeTypes.HEADERS, autoDelete = &quot;true&quot;),</span><br><span class="line">        arguments = &#123;</span><br><span class="line">                @Argument(name = &quot;x-match&quot;, value = &quot;all&quot;),</span><br><span class="line">                @Argument(name = &quot;thing1&quot;, value = &quot;somevalue&quot;),</span><br><span class="line">                @Argument(name = &quot;thing2&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">)</span><br><span class="line">public String handleWithHeadersExchange(String foo) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RabbitListener属性参数：</p><ul><li>String id</li><li>String containerFactory</li><li>String[] queues</li><li>Queue[] queuesToDeclare</li><li>boolean exclusive</li><li>String priority</li><li>String admin</li><li>QueueBinding[] bindings<ul><li>Queue value</li><li>Exchange exchange</li><li>String[] key // routingKey</li><li>String ignoreDeclarationExceptions</li><li>Argument[] arguments</li><li>String declare // 如果admin存在，需要声明此属性</li><li>String[] admins</li></ul></li><li>String group // 如果存在Listener容器，则可以将容器的beanName赋予此属性</li><li>String returnExceptions // 设置为true时，设置为true会导致Listener抛出的异常使用正常的<code>replyto/SendTo</code>语义发送给发送者，设置false时，将异常抛出到Listener容器并执行正常的重试/死信处理。</li><li>String errorHandler //如果Listener容器出现异常，则处理异常</li><li>String concurrency</li><li>String autoStartup // 延迟创建队列，交换器</li></ul><h4 id="3-3-2-9-创建自己的监听注解-元注解"><a href="#3-3-2-9-创建自己的监听注解-元注解" class="headerlink" title="3.3.2.9 创建自己的监听注解(元注解)"></a>3.3.2.9 创建自己的监听注解(元注解)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue,</span><br><span class="line">        exchange = @Exchange(value = &quot;metaFanout&quot;, type = ExchangeTypes.FANOUT)))</span><br><span class="line">public @interface MyAnonFanoutListener &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MetaListener &#123;</span><br><span class="line"></span><br><span class="line">    @MyAnonFanoutListener</span><br><span class="line">    public void handle1(String foo) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @MyAnonFanoutListener</span><br><span class="line">    public void handle2(String foo) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2.3 版本开始，支持@AliasFor以允许在元注释的注释上覆盖属性。而且，用户注释现在可以是@Repeatable的，从而允许为一个方法创建多个容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">static class MetaAnnotationTestBean &#123;</span><br><span class="line"></span><br><span class="line">    @MyListener(&quot;queue1&quot;)</span><br><span class="line">    @MyListener(&quot;queue2&quot;)</span><br><span class="line">    public void handleIt(String body) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Repeatable(MyListeners.class)</span><br><span class="line">static @interface MyListener &#123;</span><br><span class="line"></span><br><span class="line">    @AliasFor(annotation = RabbitListener.class, attribute = &quot;queues&quot;)</span><br><span class="line">    String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">static @interface MyListeners &#123;</span><br><span class="line"></span><br><span class="line">    MyListener[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-10-启用侦听器端点注释"><a href="#3-3-2-10-启用侦听器端点注释" class="headerlink" title="3.3.2.10 启用侦听器端点注释"></a>3.3.2.10 启用侦听器端点注释</h4><p>要启用对@RabbitListener批注的支持，可以将@EnableRabbit添加到您的@Configuration类之一。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        factory.setConcurrentConsumers(3);</span><br><span class="line">        factory.setMaxConcurrentConsumers(10);</span><br><span class="line">        factory.setContainerCustomizer(container -&gt; /* customize the container */);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从2.0版开始，DirectMessageListenerContainerFactory也可用。它创建DirectMessageListenerContainer实例。</p><p>从2.2.2版开始，您可以提供ContainerCustomizer实现（如上所示）。创建和配置容器后，可以使用该方法进一步配置容器。例如，您可以使用它来设置容器工厂未公开的属性。</p><p>默认情况下，底层将查找名为RabbitListenerContainerFactory的bean作为工厂的源，以用于创建消息侦听器容器。在这种情况下，忽略了RabbitMQ底层设置，可以使用三个线程的核心池大小和十个线程的最大池大小来调用processOrder方法。</p><p>您可以定制用于每个注释的侦听器容器工厂，也可以通过实现RabbitListenerConfigurer接口来配置显式默认值。仅当至少一个端点在没有特定容器工厂的情况下注册时，才需要使用默认值。有关完整的详细信息和示例，请参见Javadoc。</p><p>容器工厂提供了添加MessagePostProcessor实例的方法，这些实例在接收消息之后（调用侦听器之前）和发送回复之前应用。</p><p>从版本2.0.6开始，可以将RetryTemplate和RecoveryCallback添加到侦听器容器工厂。发送回复时使用。重试用尽时将调用RecoveryCallback。您可以使用SendRetryContextAccessor从上下文中获取信息。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">factory.setRetryTemplate(retryTemplate);</span><br><span class="line">factory.setReplyRecoveryCallback(ctx -&gt; &#123;</span><br><span class="line">    Message failed = SendRetryContextAccessor.getMessage(ctx);</span><br><span class="line">    Address replyTo = SendRetryContextAccessor.getAddress(ctx);</span><br><span class="line">    Throwable t = ctx.getLastThrowable();</span><br><span class="line">    ...</span><br><span class="line">    return null;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从2.0版开始，@RabbitListener批注具有并发属性。它支持SpEL表达式（＃{…}）和属性占位符（$ {…}）。其含义和允许的值取决于容器类型，如下所示：</p><ul><li><p>对于DirectMessageListenerContainer，该值必须是单个整数值，该值设置容器上的consumersPerQueue属性。</p></li><li><p>对于SimpleRabbitListenerContainer，该值可以是一个单个整数值，该值在容器上设置了concurrentConsumers属性，也可以具有m-n的形式，其中m是parallelConsumers属性，n是maxConcurrentConsumers属性。</p></li></ul><p>无论哪种情况，此设置都将覆盖出厂设置。以前，如果您有需要不同并发性的侦听器，则必须定义不同的容器工厂。</p><p>该注释还允许通过autoStartup和executor（自2.2起）注释属性覆盖工厂的autoStartup和taskExecutor属性。为每个执行程序使用不同的执行程序可能有助于在日志和线程转储中标识与每个侦听器关联的线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(id = &quot;manual.acks.1&quot;, queues = &quot;manual.acks.1&quot;, ackMode = &quot;MANUAL&quot;)</span><br><span class="line">public void manual1(String in, Channel channel,</span><br><span class="line">    @Header(AmqpHeaders.DELIVERY_TAG) long tag) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    channel.basicAck(tag, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-11-带注释方法的消息转换"><a href="#3-3-2-11-带注释方法的消息转换" class="headerlink" title="3.3.2.11 带注释方法的消息转换"></a>3.3.2.11 带注释方法的消息转换</h4><p>调用侦听器之前，管道中有两个转换步骤。第一步使用MessageConverter将传入的Spring AMQP消息转换为Spring消息。调用目标方法时，如有必要，消息将转换为方法参数类型。</p><p>第一步的默认MessageConverter是Spring AMQP SimpleMessageConverter，它处理到String和java.io.Serializable对象的转换。所有其他的都保留为byte []。在下面的讨论中，我们称其为“消息转换器”。</p><p>第二步的默认转换器是GenericMessageConverter，它委派给转换服务（DefaultFormattingConversionService的实例）。在下面的讨论中，我们将其称为“方法参数转换器”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    ...</span><br><span class="line">    factory.setMessageConverter(new Jackson2JsonMessageConverter());</span><br><span class="line">    ...</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.6之前的版本中，必须在消息头中提供用于转换JSON的类型信息，或者需要自定义ClassMapper。从版本1.6开始，如果没有类型信息标头，则可以从目标方法参数中推断类型。</p><p>自定义消息转换器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() &#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();</span><br><span class="line">        factory.setMessageConverter(new GenericMessageConverter(myConversionService()));</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConversionService myConversionService() &#123;</span><br><span class="line">        DefaultConversionService conv = new DefaultConversionService();</span><br><span class="line">        conv.addConverter(mySpecialConverter());</span><br><span class="line">        return conv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-12-程序化端点注册"><a href="#3-3-2-12-程序化端点注册" class="headerlink" title="3.3.2.12 程序化端点注册"></a>3.3.2.12 程序化端点注册</h4><p>RabbitListenerEndpoint提供了Rabbit端点的模型，并负责为该模型配置容器。除了RabbitListener批注检测到的端点之外，基础结构还允许您以编程方式配置端点。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();</span><br><span class="line">        endpoint.setQueueNames(&quot;anotherQueue&quot;);</span><br><span class="line">        endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">            // processing</span><br><span class="line">        &#125;);</span><br><span class="line">        registrar.registerEndpoint(endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的示例中，我们使用了SimpleRabbitListenerEndpoint，它提供了实际的MessageListener来调用，但是您也可以构建自己的端点变体来描述自定义调用机制。</p><p>应该注意的是，您也可以完全跳过@RabbitListener的使用，并通过RabbitListenerConfigurer以编程方式注册端点。</p><h4 id="3-3-2-13-带注释的端点方法签名"><a href="#3-3-2-13-带注释的端点方法签名" class="headerlink" title="3.3.2.13 带注释的端点方法签名"></a>3.3.2.13 带注释的端点方法签名</h4><p>到目前为止，我们已经在端点中注入了一个简单的String，但实际上它可以具有非常灵活的方法签名。以下示例将其重写为使用自定义标头注入Order：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;myQueue&quot;)</span><br><span class="line">    public void processOrder(Order order, @Header(&quot;order_type&quot;) String orderType) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下列表显示了可以在侦听器端点中注入的主要元素：</p><ul><li><p>原始的org.springframework.amqp.core.Message。</p></li><li><p>接收消息的com.rabbitmq.client.Channel。</p></li><li><p>代表传入的AMQP消息的org.springframework.messaging.Message。请注意，此消息同时包含自定义标头和标准标头（由AmqpHeaders定义）。</p></li></ul><p>例如，如果我们想在处理订单之前确保其有效，则可以使用@Valid注释有效负载并配置必要的验证器，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRabbit</span><br><span class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() &#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();</span><br><span class="line">        factory.setValidator(myValidator());</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-14-监听多个队列"><a href="#3-3-2-14-监听多个队列" class="headerlink" title="3.3.2.14 监听多个队列"></a>3.3.2.14 监听多个队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &#123; &quot;queue1&quot;, &quot;queue2&quot; &#125; )</span><br><span class="line">    public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;#&#123;&apos;$&#123;property.with.comma.delimited.queue.names&#125;&apos;.split(&apos;,&apos;)&#125;&quot; )</span><br><span class="line">    public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-15-回复管理"><a href="#3-3-2-15-回复管理" class="headerlink" title="3.3.2.15 回复管理"></a>3.3.2.15 回复管理</h4><p>MessageListenerAdapter中的现有支持已经使您的方法具有非空返回类型。在这种情况下，调用的结果将封装在一条消息中，该消息发送到原始消息的ReplyToAddress标头中指定的地址或侦听器上配置的默认地址。您可以使用消息传递抽象的@SendTo批注设置该默认地址。</p><p>假设我们的processOrder方法现在应该返回一个OrderStatus，我们可以如下编写它以自动发送回复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(destination = &quot;myQueue&quot;)</span><br><span class="line">@SendTo(&quot;status&quot;)</span><br><span class="line">public OrderStatus processOrder(Order order) &#123;</span><br><span class="line">    // order processing</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要以与传输无关的方式设置其他标头，则可以返回一条Message，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RabbitListener(destination = &quot;myQueue&quot;)</span><br><span class="line">@SendTo(&quot;status&quot;)</span><br><span class="line">public Message&lt;OrderStatus&gt; processOrder(Order order) &#123;</span><br><span class="line">    // order processing</span><br><span class="line">    return MessageBuilder</span><br><span class="line">        .withPayload(status)</span><br><span class="line">        .setHeader(&quot;code&quot;, 1234)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者，可以在beforeSendReplyMessagePostProcessors容器工厂属性中使用MessagePostProcessor添加更多标头。从版本2.2.3开始，在答复消息中可以使用被调用的bean/方法，可以在消息后处理器中使用它来将信息传达回调用方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">factory.setBeforeSendReplyPostProcessors(msg -&gt; &#123;</span><br><span class="line">    msg.getMessageProperties().setHeader(&quot;calledBean&quot;,</span><br><span class="line">            msg.getMessageProperties().getTargetBean().getClass().getSimpleName());</span><br><span class="line">    msg.getMessageProperties().setHeader(&quot;calledMethod&quot;,</span><br><span class="line">            msg.getMessageProperties().getTargetMethod().getName());</span><br><span class="line">    return m;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从版本2.2.5开始，您可以配置ReplyPostProcessor在发送回复消息之前对其进行修改；在为相关请求设置了relatedId标头之后，将调用此方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;test.header&quot;, group = &quot;testGroup&quot;, replyPostProcessor = &quot;echoCustomHeader&quot;)</span><br><span class="line">public String capitalizeWithHeader(String in) &#123;</span><br><span class="line">    return in.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public ReplyPostProcessor echoCustomHeader() &#123;</span><br><span class="line">    return (req, resp) -&gt; &#123;</span><br><span class="line">        resp.getMessageProperties().setHeader(&quot;myHeader&quot;, req.getMessageProperties().getHeader(&quot;myHeader&quot;));</span><br><span class="line">        return resp;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@SendTo值被假定为跟随exchange / routingKey模式的回复交换和routingKey对，其中这些部分之一可以省略。有效值如下：</p><p>something1 / thing2：replyTo交换和routingKey。 something1 /：replyTo交换和默认（空）routingKey。 something2或/ thing2：replyTo routingKey和默认（空）交换。 /或为空：replyTo默认交换和默认routingKey。</p><p>此外，您可以使用不带值属性的@SendTo。这种情况下等于一个空的sendTo模式。仅当入站邮件没有ReplyToAddress属性时才使用@SendTo。</p><p>从版本1.5开始，@SendTo值可以是bean初始化SpEL表达式，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;test.sendTo.spel&quot;)</span><br><span class="line">@SendTo(&quot;#&#123;spelReplyTo&#125;&quot;)</span><br><span class="line">public String capitalizeWithSendToSpel(String foo) &#123;</span><br><span class="line">    return foo.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@Bean</span><br><span class="line">public String spelReplyTo() &#123;</span><br><span class="line">    return &quot;test.sendTo.reply.spel&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于动态回复路由，消息发送者应包括reply_to消息属性或使用备用运行时SpEL表达式（在下一个示例之后进行描述）。</p><p>从版本1.6开始，@SendTo可以是SpEL表达式，在运行时将根据请求和答复对它进行评估，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;test.sendTo.spel&quot;)</span><br><span class="line">@SendTo(&quot;!&#123;&apos;some.reply.queue.with.&apos; + result.queueName&#125;&quot;)</span><br><span class="line">public Bar capitalizeWithSendToSpel(Foo foo) &#123;</span><br><span class="line">    return processTheFooAndReturnABar(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpEL表达式的运行时性质由！{…}分隔符指示。表达式的评估上下文#root对象具有三个属性：</p><ul><li><p>request：o.s.amqp.core.Message请求对象。</p></li><li><p>来源：转换后的o.s.messaging.Message &lt;？&gt;。</p></li><li><p>结果：方法结果。</p></li></ul><p>上下文具有一个map属性访问器，一个标准类型转换器和一个bean解析器，该解析器允许引用上下文中的其他bean（例如@ someBeanName.determineReplyQ（request，result））。</p><p>总而言之，＃{…}在初始化期间被初始化一次，其中#root对象是应用程序上下文。 Bean由其名称引用。在运行时为每条消息评估！{…}，根对象具有前面列出的属性。 Bean的名称以@开头。</p><p>从2.1版开始，还支持简单的属性占位符（例如$ {some.reply.to}）。对于早期版本，可以将以下内容用作替代方法，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;foo&quot;)</span><br><span class="line">@SendTo(&quot;#&#123;environment[&apos;my.send.to&apos;]&#125;&quot;)</span><br><span class="line">public String listen(Message in) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-16-多方法侦听器"><a href="#3-3-2-16-多方法侦听器" class="headerlink" title="3.3.2.16 多方法侦听器"></a>3.3.2.16 多方法侦听器</h4><p>从1.5.0版开始，您可以在类级别指定@RabbitListener注释。与新的@RabbitHandler批注一起，这使单个侦听器可以根据传入消息的有效负载类型调用不同的方法。最好用一个例子来描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(id=&quot;multi&quot;, queues = &quot;someQueue&quot;)</span><br><span class="line">@SendTo(&quot;my.reply.queue&quot;)</span><br><span class="line">public class MultiListenerBean &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public String thing2(Thing2 thing2) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public String cat(Cat cat) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public String hat(@Header(&quot;amqp_receivedRoutingKey&quot;) String rk, @Payload Hat hat) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler(isDefault = true)</span><br><span class="line">    public String defaultMethod(Object object) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Repeatable @RabbitListener<br>从版本1.6开始，@RabbitListener批注标记为@Repeatable。这意味着注释可以多次出现在相同的注释元素（方法或类）上。在这种情况下，将为每个注释创建一个单独的侦听器容器，每个注释容器都调用相同的侦听器@Bean。可重复的注释可以与Java 8或更高版本一起使用。使用Java 7或更早版本时，可以通过使用@RabbitListeners“容器”注释和@RabbitListener注释数组来达到相同的效果。</p><h4 id="3-3-2-17-代理-RabbitListener和泛型"><a href="#3-3-2-17-代理-RabbitListener和泛型" class="headerlink" title="3.3.2.17 代理@RabbitListener和泛型"></a>3.3.2.17 代理@RabbitListener和泛型</h4><p>如果要代理您的服务（例如，对于@Transactional），则在接口具有通用参数时，应牢记一些注意事项。考虑以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface TxService&lt;P&gt; &#123;</span><br><span class="line"></span><br><span class="line">   String handle(P payload, String header);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class TxServiceImpl implements TxService&lt;Foo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @RabbitListener(...)</span><br><span class="line">    public String handle(Foo foo, String rk) &#123;</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用通用接口和特定实现，您将不得不切换到CGLIB目标类代理，因为接口句柄方法的实际实现是桥接方法。在事务管理的情况下，通过使用注释选项来配置CGLIB的使用：@EnableTransactionManagement（proxyTargetClass = true）。在这种情况下，必须在实现中的目标方法上声明所有注释，如以下示例所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static class TxServiceImpl implements TxService&lt;Foo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Transactional</span><br><span class="line">    @RabbitListener(...)</span><br><span class="line">    public String handle(@Payload Foo foo, @Header(&quot;amqp_receivedRoutingKey&quot;) String rk) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-18-处理异常"><a href="#3-3-2-18-处理异常" class="headerlink" title="3.3.2.18 处理异常"></a>3.3.2.18 处理异常</h4><p>默认情况下，如果带注释的侦听器方法引发异常，则将其引发到容器中，并根据容器和代理的配置，将消息重新排队并重新传递，丢弃或路由到死信交换。什么也没有退还给发送者。</p><p>从2.0版开始，@RabbitListener批注具有两个新属性：errorHandler和returnExceptions。</p><p>这些默认情况下未配置。</p><p>您可以使用errorHandler来提供RabbitListenerErrorHandler实现的bean名称。此功能接口有一种方法，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface RabbitListenerErrorHandler &#123;</span><br><span class="line"></span><br><span class="line">    Object handleError(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt; message,</span><br><span class="line">              ListenerExecutionFailedException exception) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，您可以访问从容器接收的原始消息，由消息转换器生成的spring-messaging Message &lt;？&gt;对象以及由侦听器引发的异常（包装在ListenerExecutionFailedException中）。错误处理程序可以返回某些结果（作为答复发送），也可以引发原始异常或新异常（根据returnExceptions设置，将其抛出到容器中或返回给发送者）。</p><p>returnExceptions属性为true时，会将异常返回给发送方。异常包装在RemoteInvocationResult对象中。在发送方，有一个可用的RemoteInvocationAwareMessageConverterAdapter，如果将其配置到RabbitTemplate中，则会重新引发服务器端异常，并包装在AmqpRemoteException中。服务器异常的堆栈跟踪是通过合并服务器和客户端堆栈跟踪来综合的。</p><p>该机制通常仅适用于使用Java序列化的默认SimpleMessageConverter。异常通常不是“杰克逊友好的”，并且不能序列化为JSON。如果使用JSON，请考虑在引发异常时使用errorHandler返回其他一些Jackson友好的Error对象。</p><p>在版本2.1中，此接口从软件包o.s.amqp.rabbit.listener移至o.s.amqp.rabbit.listener.api。</p><p>从版本2.1.7开始，通道在消息头中可用。使用AcknowledgeMode.MANUAL时，这允许您确认或拒绝失败的消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object handleError(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt; message,</span><br><span class="line">          ListenerExecutionFailedException exception) &#123;</span><br><span class="line">              ...</span><br><span class="line">              message.getHeaders().get(AmqpHeaders.CHANNEL, Channel.class)</span><br><span class="line">                  .basicReject(message.getHeaders().get(AmqpHeaders.DELIVERY_TAG, Long.class),</span><br><span class="line">                               true);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-19-容器管理"><a href="#3-3-2-19-容器管理" class="headerlink" title="3.3.2.19 容器管理"></a>3.3.2.19 容器管理</h4><p>为注释创建的容器未在应用程序上下文中注册。您可以通过调用RabbitListenerEndpointRegistry bean上的getListenerContainers（）获得所有容器的集合。然后，您可以遍历此集合，例如，停止或启动所有容器，或在注册表本身上调用Lifecycle方法，这将在每个容器上调用操作。</p><p>您还可以通过使用单个容器的ID来获取对单个容器的引用，例如，使用上面的代码段创建的容器，使用getListenerContainer（String id）-例如，registry.getListenerContainer（“ multi”）。</p><p>从1.5.2版开始，您可以使用getListenerContainerIds（）获得已注册容器的ID值。</p><p>从1.5版开始，您现在可以将组分配给RabbitListener端点上的容器。这提供了一种获取对容器子集的引用的机制。添加组属性会导致将Collection 类型的Bean注册到具有组名的上下文中。</p><h4 id="3-3-2-20-批量接收消息-RabbitmqListener"><a href="#3-3-2-20-批量接收消息-RabbitmqListener" class="headerlink" title="3.3.2.20 批量接收消息 @RabbitmqListener"></a>3.3.2.20 批量接收消息 @RabbitmqListener</h4><p>当接收到一批消息时，通常由容器执行分批处理，并且一次仅用一条消息来调用侦听器。从2.2版开始，您可以将侦听器容器工厂和侦听器配置为在一个调用中接收整个批次，只需设置工厂的batchListener属性，并将方法有效负载参数设为List：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory());</span><br><span class="line">    factory.setBatchListener(true);</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.1&quot;)</span><br><span class="line">public void listen1(List&lt;Thing&gt; in) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.2&quot;)</span><br><span class="line">public void listen2(List&lt;Message&lt;Thing&gt;&gt; in) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将batchListener属性设置为true会自动关闭工厂创建的容器中的deBatchingEnabled容器属性（除非ConsumerBatchEnabled为true，请参见下文）。实际上，分批处理已从容器移动到侦听器适配器，并且适配器创建了传递到侦听器的列表。</p><p>启用批处理的工厂不能与多方法侦听器一起使用。</p><p>同样从2.2版开始。一次接收批处理的消息时，最后一条消息包含设置为true的布尔标头。可以通过将@Header（AmqpHeaders.LAST_IN_BATCH）布尔值last`参数添加到您的侦听器方法中来获取此标头。头是从MessageProperties.isLastInBatch（）映射的。此外，AmqpHeaders.BATCH_SIZE填充有每个消息片段中的批处理大小。</p><p>此外，新属性consumerBatchEnabled已添加到SimpleMessageListenerContainer。如果为真，则容器将创建一批消息，最大为batchSize；如果receiveTimeout过去了，但没有新消息到达，则将分批交付。如果收到生产者创建的批次，则将其分批并添加到消费者方批次；因此，实际传递的消息数可能超过batchSize，该大小代表从代理接收到的消息数。当ConsumerBatchEnabled为true时，deBatchingEnabled必须为true；否则为false。集装箱工厂将执行此要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory consumerBatchContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">    factory.setConsumerTagStrategy(consumerTagStrategy());</span><br><span class="line">    factory.setBatchListener(true); // configures a BatchMessageListenerAdapter</span><br><span class="line">    factory.setBatchSize(2);</span><br><span class="line">    factory.setConsumerBatchEnabled(true);</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当将consumerBatchEnabled与@RabbitListener一起使用时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;batch.1&quot;, containerFactory = &quot;consumerBatchContainerFactory&quot;)</span><br><span class="line">public void consumerBatch1(List&lt;Message&gt; amqpMessages) &#123;</span><br><span class="line">    this.amqpMessagesReceived = amqpMessages;</span><br><span class="line">    this.batch1Latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.2&quot;, containerFactory = &quot;consumerBatchContainerFactory&quot;)</span><br><span class="line">public void consumerBatch2(List&lt;org.springframework.messaging.Message&lt;Invoice&gt;&gt; messages) &#123;</span><br><span class="line">    this.messagingMessagesReceived = messages;</span><br><span class="line">    this.batch2Latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;batch.3&quot;, containerFactory = &quot;consumerBatchContainerFactory&quot;)</span><br><span class="line">public void consumerBatch3(List&lt;Invoice&gt; strings) &#123;</span><br><span class="line">    this.batch3Strings = strings;</span><br><span class="line">    this.batch3Latch.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>第一个是使用未转换的原始org.springframework.amqp.core.Message调用的。</p></li><li><p>第二个是通过org.springframework.messaging.Message &lt;？&gt;调用的，其中包含转换后的有效负载和映射的标头/属性。</p></li><li><p>第三个调用是使用转换后的有效负载进行的，而无法访问标头/属性。</p></li></ul><p>您还可以添加一个通道参数，该参数通常在使用手动确认模式时使用。这对于第三个示例不是很有用，因为您无权访问delivery_tag属性。</p><h4 id="3-3-2-21-使用容器工厂"><a href="#3-3-2-21-使用容器工厂" class="headerlink" title="3.3.2.21 使用容器工厂"></a>3.3.2.21 使用容器工厂</h4><p>引入了侦听器容器工厂以支持@RabbitListener并向RabbitListenerEndpointRegistry注册容器，如“编程端点注册”中所述。</p><p>从2.1版开始，它们可用于创建任何侦听器容器-甚至是没有侦听器的容器（例如在Spring Integration中使用的容器）。当然，必须在启动容器之前添加侦听器。</p><p>有两种创建此类容器的方法：</p><ul><li><p>使用SimpleRabbitListenerEndpoint</p></li><li><p>创建后添加侦听器</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer factoryCreatedContainerSimpleListener(</span><br><span class="line">        SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) &#123;</span><br><span class="line">    SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();</span><br><span class="line">    endpoint.setQueueNames(&quot;queue.1&quot;);</span><br><span class="line">    endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    return rabbitListenerContainerFactory.createListenerContainer(endpoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer factoryCreatedContainerNoListener(</span><br><span class="line">        SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = rabbitListenerContainerFactory.createListenerContainer();</span><br><span class="line">    container.setMessageListener(message -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    container.setQueueNames(&quot;test.no.listener.yet&quot;);</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论哪种情况，侦听器也可以是ChannelAwareMessageListener，因为它现在是MessageListener的子接口。</p><p>如果您希望创建多个具有相似属性的容器或使用预先配置的容器工厂（例如，Spring Boot自动配置提供的容器或同时使用两者），则这些技术很有用。</p><p>用这种方法创建的容器是普通的@Bean实例，并且未在RabbitListenerEndpointRegistry中注册。</p><h4 id="3-3-2-22-异步-RabbitListener返回类型"><a href="#3-3-2-22-异步-RabbitListener返回类型" class="headerlink" title="3.3.2.22 异步@RabbitListener返回类型"></a>3.3.2.22 异步@RabbitListener返回类型</h4><p>从2.1版开始，可以使用异步返回类型ListenableFuture &lt;？&gt;和Mono &lt;？&gt;指定@RabbitListener（和@RabbitHandler）方法，从而使答复以异步方式发送。</p><p>必须使用AcknowledgeMode.MANUAL配置侦听器容器工厂，以便消费者线程不会确认该消息。相反，异步完成将在异步操作完成时确认或拒绝消息。当异步结果有错误完成时，是否重新排队消息取决于抛出的异常类型，容器配置和容器错误处理程序。默认情况下，除非容器的defaultRequeueRejected属性设置为false（默认情况下为true），否则将重新排队该消息。如果异步结果是通过AmqpRejectAndDontRequeueException完成的，则不会重新排队该消息。如果容器的defaultRequeueRejected属性为false，则可以通过将Future的异常设置为InstantRequeueException来覆盖该值，然后将消息重新排队。如果在侦听器方法中发生了一些阻止创建异步结果对象的异常，则您必须捕获该异常并返回适当的返回对象，该对象将导致消息被确认或重新排队。</p><h4 id="3-3-2-23-线程和异步消费者"><a href="#3-3-2-23-线程和异步消费者" class="headerlink" title="3.3.2.23 线程和异步消费者"></a>3.3.2.23 线程和异步消费者</h4><p>当RabbitMQ Client传递新消息时，使用SimpleMessageListenerContainer中配置的TaskExecutor的线程来调用MessageListener。如果未配置，则使用SimpleAsyncTaskExecutor。如果使用池执行器，则需要确保池大小足以处理配置的并发。使用DirectMessageListenerContainer，可以直接在RabbitMQ客户端线程上调用MessageListener。在这种情况下，taskExecutor用于监视消费者的任务。</p><p>使用默认的SimpleAsyncTaskExecutor时，对于在其上调用侦听器的线程，在threadNamePrefix中使用侦听器容器beanName。这对于日志分析很有用。我们通常建议始终在日志记录附加程序配置中包括线程名称。通过容器上的taskExecutor属性专门提供TaskExecutor时，将按原样使用它，而无需进行修改。建议您使用类似的技术来命名由自定义TaskExecutor bean定义创建的线程，以帮助在日志消息中标识线程。</p><p>创建连接时，在CachingConnectionFactory中配置的Executor将传递到RabbitMQ Client中，并且其线程用于将新消息传递到侦听器容器。如果未配置，则客户端使用内部线程池执行程序，该执行程序的池大小为5。</p><p>使用DirectMessageListenerContainer，您需要确保连接工厂配置有任务执行程序，该任务执行程序具有足够的线程来支持使用该工厂的所有侦听器容器之间的所需并发。默认池大小只有五个。<br>RabbitMQ客户端使用ThreadFactory创建用于低级I / O（套接字）操作的线程。要修改此工厂，您需要配置基础RabbitMQ ConnectionFactory，如配置基础客户端连接工厂中所述。</p><h4 id="3-3-2-24-选择一个容器"><a href="#3-3-2-24-选择一个容器" class="headerlink" title="3.3.2.24 选择一个容器"></a>3.3.2.24 选择一个容器</h4><p>2.0版引入了DirectMessageListenerContainer（DMLC）。以前，只有SimpleMessageListenerContainer（SMLC）可用。 SMLC为每个消费者使用内部队列和专用线程。如果将一个容器配置为侦听多个队列，则使用相同的消费者线程来处理所有队列。并发是由并发消费和其他属性控制的。当消息从RabbitMQ客户端到达时，客户端线程将它们通过队列传递给使用方线程。之所以需要这种架构，是因为在RabbitMQ客户端的早期版本中，无法同时进行多个交付。较新版本的客户端具有修订的线程模型，现在可以支持并发。这允许引入DMLC，现在可以在RabbitMQ客户端线程上直接调用侦听器。因此，它的体系结构实际上比SMLC“简单”。但是，这种方法存在一些局限性，并且DMLC无法使用SMLC的某些功能。另外，并发由consumersPerQueue（和客户端库的线程池）控制。 parallelConsumers和关联的属性不适用于此容器。</p><p>以下功能可用于SMLC，但不可用于DMLC：</p><ul><li><p>batchSize：使用SMLC，您可以将其设置为控制在一个事务中传递多少消息或减少确认的数量，但是在失败后可能导致重复传递的数量增加。 （DMLC确实具有messagesPerAck，可用于减少确认，与batchSize和SMLC相同，但不能与事务一起使用-—每条消息都在单独的事务中传递和确认）。</p></li><li><p>ConsumerBatchEnabled：在消费者中批量处理离散消息；有关更多信息，请参见消息侦听器容器配置。</p></li><li><p>maxConcurrentConsumers和消费者缩放间隔或触发器-DMLC中没有自动缩放。但是，它确实允许您以编程方式更改consumersPerQueue属性，并相应地调整消费者。</p></li></ul><p>但是，DMLC比SMLC具有以下优点：</p><ul><li><p>在运行时添加和删除队列更加有效。使用SMLC，将重新启动整个消费者线程（取消并重新创建所有消费者）。使用DMLC，不会取消未受影响的消费者。</p></li><li><p>避免在RabbitMQ客户端线程和消费者线程之间进行上下文切换。</p></li><li><p>线程在消费者之间共享，而不是在SMLC中为每个消费者使用专用线程。但是，请参阅“线程和异步消费者”中有关连接工厂配置的重要说明。</p></li></ul><p>有关哪些配置属性适用于每个容器的信息，请参见消息侦听器容器配置。</p><h4 id="3-3-2-25-检测空闲的异步消费者"><a href="#3-3-2-25-检测空闲的异步消费者" class="headerlink" title="3.3.2.25 检测空闲的异步消费者"></a>3.3.2.25 检测空闲的异步消费者</h4><p>尽管效率很高，但异步消费者的一个问题是检测它们何时处于空闲状态—如果一段时间内没有消息到达，用户可能希望采取某些措施。</p><p>从1.6版开始，现在可以将侦听器容器配置为在一段时间没有消息传递的情况下发布ListenerContainerIdleEvent。当容器处于空闲状态时，每隔idleEventInterval毫秒发布一次事件。</p><p>要配置此功能，请在容器上设置idleEventInterval。以下示例显示了如何使用XML和Java（对于SimpleMessageListenerContainer和SimpleRabbitListenerContainerFactory）执行此操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">    ...</span><br><span class="line">    container.setIdleEventInterval(60000L);</span><br><span class="line">    ...</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">    factory.setIdleEventInterval(60000L);</span><br><span class="line">    ...</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-2-26-消费事件"><a href="#3-3-2-26-消费事件" class="headerlink" title="3.3.2.26 消费事件"></a>3.3.2.26 消费事件</h4><p>您可以通过实现ApplicationListener来捕获空闲事件-可以是常规侦听器，也可以是仅侦听仅接收此特定事件的侦听器。您还可以使用Spring Framework 4.2中引入的@EventListener。</p><p>以下示例将@RabbitListener和@EventListener组合到一个类中。您需要了解应用程序侦听器会获取所有容器的事件，因此，如果您要基于哪个容器处于空闲状态采取特定的操作，则可能需要检查侦听器ID。您也可以为此使用@EventListener条件。</p><p>事件具有四个属性：</p><ul><li><p>来源：侦听器容器实例</p></li><li><p>id：侦听器ID（或容器bean名称）</p></li><li><p>idleTime：事件发布时容器空闲的时间</p></li><li><p>queueNames：容器侦听的队列的名称</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Listener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(id=&quot;someId&quot;, queues=&quot;#&#123;queue.name&#125;&quot;)</span><br><span class="line">    public String listen(String foo) &#123;</span><br><span class="line">        return foo.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @EventListener(condition = &quot;event.listenerId == &apos;someId&apos;&quot;)</span><br><span class="line">    public void onApplicationEvent(ListenerContainerIdleEvent event) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件侦听器查看所有容器的事件。因此，在前面的示例中，我们根据侦听器ID缩小了接收到的事件的范围。</p><p>如果希望使用idle事件停止列表器容器，则不应在调用侦听器的线程上调用container.stop（）。这样做总是会导致延迟和不必要的日志消息。相反，您应该将事件移交给另一个线程，然后该线程可以停止容器。</p><h4 id="3-3-2-27-监视侦听器性能"><a href="#3-3-2-27-监视侦听器性能" class="headerlink" title="3.3.2.27 监视侦听器性能"></a>3.3.2.27 监视侦听器性能</h4><p>从2.2版开始，如果在类路径上检测到Micrometer且应用程序上下文中存在MeterRegistry，则侦听器容器将自动为侦听器创建和更新Micrometer Timer。可以通过将容器属性micrometerEnabled设置为false来禁用计时器。</p><p>维护两个计时器-一个用于成功调用侦听器，另一个用于失败。使用简单的MessageListener，每个配置的队列都有一对计时器。</p><p>这些计时器名为spring.rabbitmq.listener，具有以下标记：</p><ul><li><p>listenerId ：（侦听器ID或容器Bean名称）</p></li><li><p>queue ：（当consumerBatchEnabled为true时，一个简单侦听器的队列名称或已配置队列名称的列表-因为批处理可能包含来自多个队列的消息）</p></li><li><p>结果：成功或失败</p></li><li><p>异常：无或ListenerExecutionFailedException</p></li></ul><p>您可以使用micrometerTags容器属性添加其他标签。</p><h3 id="3-3-3-容器和broker命名的队列"><a href="#3-3-3-容器和broker命名的队列" class="headerlink" title="3.3.3 容器和broker命名的队列"></a>3.3.3 容器和broker命名的队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    return new Queue(&quot;&quot;, false, true, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer container() &#123;</span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(cf());</span><br><span class="line">    container.setQueues(queue());</span><br><span class="line">    container.setMessageListener(m -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    container.setMissingQueuesFatal(false);</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重置连接并建立新连接后，新队列将获得新名称。由于在容器重启和重新声明队列之间存在竞争状态，因此将容器的missingQueuesFatal属性设置为false很重要，因为容器可能最初会尝试重新连接到旧队列。</p><h3 id="3-3-4-消息转换器"><a href="#3-3-4-消息转换器" class="headerlink" title="3.3.4 消息转换器"></a>3.3.4 消息转换器</h3><p>通常不建议依赖Java序列化。 JSON（JavaScript对象表示法）是一种更通用，更灵活且可跨不同语言和平台移植的替代方法。可以在任何RabbitTemplate实例上配置该转换器，以覆盖其对SimpleMessageConverter默认值的用法。 Jackson2JsonMessageConverter使用com.fasterxml.jackson 2.x库。以下示例配置了Jackson2JsonMessageConverter：</p><p>Jackson2JsonMessageConverter默认情况下使用DefaultClassMapper。类型信息将添加到MessageProperties（并从中检索）。如果入站邮件在MessageProperties中不包含类型信息，但是您知道期望的类型，则可以使用defaultType属性配置静态类型，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Jackson2JsonMessageConverter jsonMessageConverter() &#123;</span><br><span class="line">    Jackson2JsonMessageConverter jsonConverter = new Jackson2JsonMessageConverter();</span><br><span class="line">    jsonConverter.setClassMapper(classMapper());</span><br><span class="line">    return jsonConverter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public DefaultClassMapper classMapper() &#123;</span><br><span class="line">    DefaultClassMapper classMapper = new DefaultClassMapper();</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = new HashMap&lt;&gt;();</span><br><span class="line">    idClassMapping.put(&quot;thing1&quot;, Thing1.class);</span><br><span class="line">    idClassMapping.put(&quot;thing2&quot;, Thing2.class);</span><br><span class="line">    classMapper.setIdClassMapping(idClassMapping);</span><br><span class="line">    return classMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据发送系统添加到标头的类型信息，将入站消息转换为对象。</p><p>在1.6之前的版本中，如果不存在类型信息，则转换将失败。从版本1.6开始，如果缺少类型信息，则转换器将使用Jackson的默认值（通常是地图）来转换JSON。</p><p>同样，从版本1.6开始，当您使用@RabbitListener批注（在方法上）时，推断的类型信息将添加到MessageProperties。这使转换器可以转换为目标方法的参数类型。仅当存在一个没有注释的参数或带有@Payload注释的单个参数时，这才适用。在分析期间，将忽略Message类型的参数。</p><p>默认情况下，推断的类型信息将覆盖发送系统创建的入站TypeId和相关标头。这使接收系统可以自动转换为其他域对象。仅当参数类型是具体的（不是抽象或接口）或来自java.util包时才适用。在所有其他情况下，将使用TypeId和相关标头。在某些情况下，您可能希望覆盖默认行为并始终使用TypeId信息。例如，假设您有一个@RabbitListener，它带有Thing1参数，但消息中包含Thing2，它是Thing1的子类（具体）。推断的类型将不正确。要处理这种情况，请将Jackson2JsonMessageConverter的TypePrecedence属性设置为TYPE_ID，而不是默认的INFERRED。 （该属性实际上位于转换器的DefaultJackson2JavaTypeMapper上，但为方便起见，在转换器上提供了一个setter。）如果注入自定义类型映射器，则应改为在映射器上设置该属性。</p><p>从Message转换时，传入的MessageProperties.getContentType（）必须与JSON兼容（使用contentType.contains（“ json”）进行检查）。从2.2版开始，如果没有contentType属性，或者它具有默认值application / octet-stream，则假定为application / json。要恢复到以前的行为（返回未转换的字节[]），请将转换器的假定的SupportedContentType属性设置为false。如果不支持内容类型，则发出WARN日志消息“无法转换内容类型为[…]的传入消息”，并且按原样以字节[]形式返回message.getBody（）。因此，为了满足消费者方面的Jackson2JsonMessageConverter要求，生产者必须添加contentType消息属性，例如，作为application / json或text / x-json或通过使用Jackson2JsonMessageConverter自动设置标头。下面的清单显示了许多转换器调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(@Payload Thing1 thing1, @Header(&quot;amqp_consumerQueue&quot;) String queue) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, o.s.amqp.core.Message message) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, o.s.messaging.Message&lt;Foo&gt; message) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, String bar) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener</span><br><span class="line">public void thing1(Thing1 thing1, o.s.messaging.Message&lt;?&gt; message) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>在上述清单的前四种情况下，转换器尝试转换为Thing1类型。第五个示例无效，因为我们无法确定哪个参数应接收消息有效负载。在第六个示例中，由于通用类型为通配符类型，因此应用了Jackson的默认值。</p><p>但是，您可以创建一个自定义转换器，并使用targetMethod消息属性来确定将JSON转换为哪种类型。</p><p>仅当在方法级别声明@RabbitListener批注时，才能实现此类型推断。对于类级别的@RabbitListener，转换后的类型用于选择要调用的@RabbitHandler方法。因此，基础结构提供了targetObject消息属性，您可以在自定义转换器中使用该属性来确定类型。</p><p>从1.6.11版本开始，Jackson2JsonMessageConverter以及DefaultJackson2JavaTypeMapper（DefaultClassMapper）提供了TrustedPackages选项来克服序列化小工具漏洞。默认情况下，为了实现向后兼容，Jackson2JsonMessageConverter信任所有软件包，即使用*作为选项。</p><h4 id="3-3-5-1-使用Spring-Data-映射接口"><a href="#3-3-5-1-使用Spring-Data-映射接口" class="headerlink" title="3.3.5.1 使用Spring Data 映射接口"></a>3.3.5.1 使用Spring Data 映射接口</h4><p>从2.2版开始，您可以将JSON转换为Spring Data Projection接口，而不是具体类型。这允许非常选择性和低耦合的数据绑定，包括从JSON文档中的多个位置查找值。例如，可以将以下接口定义为消息有效负载类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface SomeSample &#123;</span><br><span class="line"></span><br><span class="line">  @JsonPath(&#123; &quot;$.username&quot;, &quot;$.user.name&quot; &#125;)</span><br><span class="line">  String getUsername();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;projection&quot;)</span><br><span class="line">public void projection(SomeSample in) &#123;</span><br><span class="line">    String username = in.getUsername();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，访问器方法将用于在接收到的JSON文档中查找属性名称作为字段。 @JsonPath表达式允许自定义值查找，甚至定义多个JSON路径表达式，以便从多个位置查找值，直到表达式返回实际值为止。</p><p>要启用此功能，请在消息转换器上将useProjectionForInterfaces设置为true。您还必须将spring-data：spring-data-commons和com.jayway.jsonpath：json-path添加到类路径。</p><p>当用作@RabbitListener方法的参数时，接口类型将像往常一样自动传递给转换器。</p><h4 id="3-3-5-2-使用RabbitTemplate从消息转换"><a href="#3-3-5-2-使用RabbitTemplate从消息转换" class="headerlink" title="3.3.5.2 使用RabbitTemplate从消息转换"></a>3.3.5.2 使用RabbitTemplate从消息转换</h4><p>如前所述，类型信息在消息头中传送，以帮助从消息转换时的转换器。在大多数情况下，这可以正常工作。但是，使用泛型类型时，它只能转换简单对象和已知的“容器”对象（列表，数组和映射）。从2.0版开始，Jackson2JsonMessageConverter实现了SmartMessageConverter，它可以与带有ParameterizedTypeReference参数的新RabbitTemplate方法一起使用。这允许转换复杂的泛型类型，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thing1&lt;Thing2&lt;Cat, Hat&gt;&gt; thing1 =</span><br><span class="line">    rabbitTemplate.receiveAndConvert(new ParameterizedTypeReference&lt;Thing1&lt;Thing2&lt;Cat, Hat&gt;&gt;&gt;() &#123; &#125;);</span><br></pre></td></tr></table></figure><h4 id="3-3-5-3-MarshallingMessageConverter"><a href="#3-3-5-3-MarshallingMessageConverter" class="headerlink" title="3.3.5.3 MarshallingMessageConverter"></a>3.3.5.3 MarshallingMessageConverter</h4><p>另一个选项是MarshallingMessageConverter。它委托Spring OXM库实现Marshaller和Unmarshaller策略接口的实现。您可以在此处阅读有关该库的更多信息。就配置而言，最常见的是仅提供构造函数参数，因为Marshaller的大多数实现也实现了Unmarshaller。以下示例显示如何配置MarshallingMessageConverter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.amqp.rabbit.core.RabbitTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;rabbitConnectionFactory&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;messageConverter&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.springframework.amqp.support.converter.MarshallingMessageConverter&quot;&gt;</span><br><span class="line">            &lt;constructor-arg ref=&quot;someImplemenationOfMarshallerAndUnmarshaller&quot;/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-4-Jackson2XmlMessageConverter"><a href="#3-3-5-4-Jackson2XmlMessageConverter" class="headerlink" title="3.3.5.4 Jackson2XmlMessageConverter"></a>3.3.5.4 Jackson2XmlMessageConverter</h4><p>此类在版本2.1中引入，可用于在XML之间来回转换消息。</p><p>Jackson2XmlMessageConverter和Jackson2JsonMessageConverter具有相同的基类：AbstractJackson2MessageConverter。</p><p>引入AbstractJackson2MessageConverter类以替换已删除的类：AbstractJsonMessageConverter。</p><p>Jackson2XmlMessageConverter使用com.fasterxml.jackson 2.x库。</p><p>您可以使用它与Jackson2JsonMessageConverter相同的方式使用它，但是它支持XML而不是JSON。以下示例配置了Jackson2JsonMessageConverter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;xmlConverterWithDefaultType&quot;</span><br><span class="line">        class=&quot;org.springframework.amqp.support.converter.Jackson2XmlMessageConverter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;classMapper&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.springframework.amqp.support.converter.DefaultClassMapper&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;defaultType&quot; value=&quot;foo.PurchaseOrder&quot;/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-5-ContentTypeDelegatingMessageConverter"><a href="#3-3-5-5-ContentTypeDelegatingMessageConverter" class="headerlink" title="3.3.5.5 ContentTypeDelegatingMessageConverter"></a>3.3.5.5 ContentTypeDelegatingMessageConverter</h4><p>此类在版本1.4.2中引入，并允许基于MessageProperties中的内容类型属性委派到特定的MessageConverter。默认情况下，如果没有contentType属性或没有与配置的转换器匹配的值，它将委派给SimpleMessageConverter。以下示例配置ContentTypeDelegatingMessageConverter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;contentTypeConverter&quot; class=&quot;ContentTypeDelegatingMessageConverter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;delegates&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;application/json&quot; value-ref=&quot;jsonMessageConverter&quot; /&gt;</span><br><span class="line">            &lt;entry key=&quot;application/xml&quot; value-ref=&quot;xmlMessageConverter&quot; /&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-6-Java-反序列化"><a href="#3-3-5-6-Java-反序列化" class="headerlink" title="3.3.5.6 Java 反序列化"></a>3.3.5.6 Java 反序列化</h4><p>从不受信任的来源反序列化Java对象时，可能存在一个漏洞。</p><p>如果您接受内容类型为application / x-java-serialized-object的不受信任来源的消息，则应考虑配置允许反序列化哪些包和类。当它配置为隐式或通过配置使用DefaultDeserializer时，这对SimpleMessageConverter和SerializerMessageConverter均适用。</p><p>默认情况下，白名单为空，这意味着所有类都将反序列化。</p><p>您可以设置模式列表，例如thing1。，thing1.thing2.Cat或.MySafeClass。</p><p>顺序检查模式，直到找到匹配项。如果不匹配，则抛出SecurityException。</p><p>您可以使用这些转换器上的whiteListPatterns属性设置模式。</p><h4 id="3-3-5-7-消息属性转换"><a href="#3-3-5-7-消息属性转换" class="headerlink" title="3.3.5.7 消息属性转换"></a>3.3.5.7 消息属性转换</h4><p>MessagePropertiesConverter策略接口用于在Rabbit Client BasicProperties和Spring AMQP MessageProperties之间进行转换。默认实现（DefaultMessagePropertiesConverter）通常可以满足大多数目的，但是您可以根据需要实现自己的实现。当大小不大于1024字节时，默认属性转换器将LongString类型的BasicProperties元素转换为String实例。较大的LongString实例不会转换（请参阅下一段）。可以使用构造函数参数来覆盖此限制。</p><p>从1.6版开始，长于长字符串限制（默认值：1024）的标头现在默认情况下由DefaultMessagePropertiesConverter保留为LongString实例。您可以通过getBytes []，toString（）或getStream（）方法访问内容。</p><p>以前，DefaultMessagePropertiesConverter将此类标头“转换”为DataInputStream（实际上它只是引用了LongString实例的DataInputStream）。在输出时，未转换此标头（通过在流上调用toString（）转换为String除外，例如java.io.DataInputStream@1d057a39）。</p><p>现在，大型输入LongString标头现在也可以在输出中正确“转换”（默认情况下）。</p><p>提供了一个新的构造函数，使您可以配置转换器以像以前一样工作。以下清单显示了Javadoc注释和方法声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Construct an instance where LongStrings will be returned</span><br><span class="line"> * unconverted or as a java.io.DataInputStream when longer than this limit.</span><br><span class="line"> * Use this constructor with &apos;true&apos; to restore pre-1.6 behavior.</span><br><span class="line"> * @param longStringLimit the limit.</span><br><span class="line"> * @param convertLongLongStrings LongString when false,</span><br><span class="line"> * DataInputStream when true.</span><br><span class="line"> * @since 1.6</span><br><span class="line"> */</span><br><span class="line">public DefaultMessagePropertiesConverter(int longStringLimit, boolean convertLongLongStrings) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>同样从1.6版开始，已将一个名为correlationIdString的新属性添加到MessageProperties。以前，在RabbitMQ客户端使用的BasicProperties之间来回转换时，执行了不必要的byte [] &lt;→String转换，因为MessageProperties.correlationId是byte []，但是BasicProperties使用String。 （最终，RabbitMQ客户端使用UTF-8将String转换为字节以放入协议消息中）。</p><p>为了提供最大的向后兼容性，已将一个名为correlationIdPolicy的新属性添加到DefaultMessagePropertiesConverter。这需要一个DefaultMessagePropertiesConverter.CorrelationIdPolicy枚举参数。默认情况下，它设置为BYTES，它复制了以前的行为。</p><p>对于入站消息：</p><ul><li><p>STRING：仅映射relatedIdString属性</p></li><li><p>BYTES：仅关联ID属性被映射</p></li><li><p>BOTH：映射两个属性</p></li></ul><p>对于出站消息：</p><ul><li><p>STRING：仅映射relatedIdString属性</p></li><li><p>BYTES：仅关联ID属性被映射</p></li><li><p>BOTH：都考虑了这两个属性，其中String属性优先</p></li></ul><p>同样从1.6版开始，入站deliveryMode属性不再映射到MessageProperties.deliveryMode。而是将其映射到MessageProperties.receivedDeliveryMode。此外，入站userId属性不再映射到MessageProperties.userId。而是将其映射到MessageProperties.receivedUserId。如果将同一MessageProperties对象用于出站消息，则这些更改是为了避免这些属性的意外传播。</p><p>从2.2版开始，DefaultMessagePropertiesConverter使用getName（）而不是toString（）转换类型为Class &lt;？&gt;类型的任何自定义headers。这避免了使用应用程序必须从toString（）表示形式中解析类名称的麻烦。对于滚动升级，您可能需要更改消费者以了解两种格式，直到所有生产者都升级为止。</p><h3 id="3-3-6-修改消息-压缩等"><a href="#3-3-6-修改消息-压缩等" class="headerlink" title="3.3.6 修改消息-压缩等"></a>3.3.6 修改消息-压缩等</h3><p>存在许多扩展点。它们使您可以在将消息发送到RabbitMQ之前或在收到消息之后立即对其进行一些处理。</p><p>在消息转换器中可以看到，这样的扩展点之一是在AmqpTemplate convertAndReceive操作中，您可以在其中提供MessagePostProcessor。例如，在转换POJO之后，MessagePostProcessor允许您在Message上设置自定义标头或属性。</p><p>从版本1.4.2开始，已将其他扩展点添加到RabbitTemplate中-setBeforePublishPostPostors（）和setAfterReceivePostProcessors（）。第一个使后处理器能够在发送到RabbitMQ之前立即运行。使用批处理（请参阅批处理）时，将在组装批处理之后以及发送批处理之前调用此方法。收到消息后立即调用第二个。</p><p>这些扩展点用于压缩等功能，并为此提供了多个MessagePostProcessor实现。 GZipPostProcessor，ZipPostProcessor和DeflaterPostProcessor在发送前先压缩消息，而GUnzipPostProcessor，UnzipPostProcessor和InflaterPostProcessor则对收到的消息进行解压缩。</p><p>从版本2.1.5开始，可以使用copyProperties = true选项配置GZipPostProcessor，以复制原始消息属性。默认情况下，出于性能原因，将重用这些属性，并使用压缩内容编码和可选的MessageProperties.SPRING_AUTO_DECOMPRESS header对其进行修改。如果您保留对原始出站消息的引用，则其属性也会更改。因此，如果您的应用程序使用这些消息后处理器保留了出站消息的副本，请考虑打开copyProperties选项。<br>类似地，SimpleMessageListenerContainer也具有setAfterReceivePostProcessors（）方法，该方法允许在容器接收到消息之后执行解压缩。</p><p>从版本2.1.4开始，将addBeforePublishPostPostors（）和addAfterReceivePostProcessors（）添加到RabbitTemplate中，以允许将新的后处理器分别追加到发布前和接收后处理器的列表中。还提供了删除后处理器的方法。同样，AbstractMessageListenerContainer还添加了addAfterReceivePostProcessors（）和removeAfterReceivePostProcessor（）方法。有关更多详细信息，请参见RabbitTemplate和AbstractMessageListenerContainer的Javadoc。</p><h3 id="3-3-7-请求和回复消息"><a href="#3-3-7-请求和回复消息" class="headerlink" title="3.3.7 请求和回复消息"></a>3.3.7 请求和回复消息</h3><p>AmqpTemplate还提供了各种sendAndReceive方法，它们接受与前面针对单向发送操作（交换，routingKey和Message）所述的相同参数选项。这些方法对于请求-答复方案非常有用，因为它们在发送之前处理必需的答复属性的配置，并且可以在为此目的内部创建的排他队列上侦听答复消息。</p><p>将MessageConverter应用于请求和答复时，也可以使用类似的请求-答复方法。这些方法被称为convertSendAndReceive。有关更多详细信息，请参见AmqpTemplate的Javadoc。</p><p>从1.5.0版开始，每个sendAndReceive方法变体都有一个采用CorrelationData的重载版本。与正确配置的连接工厂一起，这可以使发布者收到操作的发送方确认。有关更多信息，请参见发布者确认和退货以及RabbitOperations的Javadoc。</p><p>从2.0版开始，这些方法有一些变体（convertSendAndReceiveAsType），它们带有一个附加的ParameterizedTypeReference参数来转换复杂的返回类型。模板必须配置有SmartMessageConverter。有关更多信息，请参见使用RabbitTemplate从消息转换。</p><p>从2.1版开始，您可以使用noLocalReplyConsumer选项配置RabbitTemplate来控制用于回复消费者的noLocal标志。默认情况下为false。</p><h4 id="3-3-7-1-回复超时"><a href="#3-3-7-1-回复超时" class="headerlink" title="3.3.7.1 回复超时"></a>3.3.7.1 回复超时</h4><p>默认情况下，发送和接收方法在五秒钟后超时并返回null。您可以通过设置replyTimeout属性来修改此行为。从版本1.5开始，如果将强制属性设置为true（或对于特定消息，则强制表达式的计算结果为true），如果无法将消息传递到队列，则会引发AmqpMessageReturnedException。此异常具有returnMessage，replyCode和replyText属性，以及用于发送的exchange和routingKey。</p><p>此功能使用发布者的退货。您可以通过在CachingConnectionFactory上将PublisherReturns设置为true来启用它（请参阅发布者确认和返回）。另外，您一定不能在RabbitTemplate中注册自己的ReturnCallback。<br>从版本2.1.2开始，添加了replyTimedOut方法，使超时可以通知子类，以便它们可以清除任何保留的状态。</p><p>从2.0.11和2.1.3版本开始，使用默认的DirectReplyToMessageListenerContainer时，可以通过设置模板的replyErrorHandler属性来添加错误处理程序。对于任何失败的传递，都会调用此错误处理程序，例如延迟答复和收到的没有相关标头的消息。传入的异常是ListenerExecutionFailedException，它具有failMessage属性。</p><h4 id="3-3-7-2-RabbitMQ直接回复"><a href="#3-3-7-2-RabbitMQ直接回复" class="headerlink" title="3.3.7.2 RabbitMQ直接回复"></a>3.3.7.2 RabbitMQ直接回复</h4><p>从3.4.0版本开始，RabbitMQ服务器支持直接回复。这消除了固定答复队列的主要原因（以避免为每个请求创建临时队列）。从Spring AMQP版本1.4.1开始，默认情况下使用直接回复（如果服务器支持），而不是创建临时回复队列。如果没有提供replyQueue（或者设置了名为amq.rabbitmq.reply-to的名称），RabbitTemplate会自动检测是否支持直接回复，然后使用直接回复还是使用临时回复队列。使用直接答复时，不需要答复侦听器，并且不应对其进行配置。<br>命名队列（amq.rabbitmq.reply-to除外）仍支持回复侦听器，从而允许控制回复并发等等。</p><p>从1.6版开始，如果您希望为每个答复使用一个临时的，排他的，自动删除队列，请将useTemporaryReplyQueues属性设置为true。如果设置了ReplyAddress，则将忽略此属性。</p><p>您可以通过将RabbitTemplate子类化并覆盖useDirectReplyTo（）来检查其他条件，从而更改指示是否使用直接答复的条件。发送第一个请求时，该方法仅被调用一次。</p><p>在2.0版之前，RabbitTemplate为每个请求创建一个新消费者，并在收到答复（或超时）时取消该消费者。现在，该模板改为使用DirectReplyToMessageListenerContainer，让消费者重新使用。模板仍然负责将回复相关联，因此没有延迟回复发送给其他发件人的危险。如果要还原为以前的行为，请将useDirectReplyToContainer（使用XML配置时直接回复到容器）属性设置为false。</p><p>AsyncRabbitTemplate没有此类选项。使用直接回复时，它始终使用DirectReplyToContainer进行回复。</p><h4 id="3-3-7-3-消息与回复队列的关联"><a href="#3-3-7-3-消息与回复队列的关联" class="headerlink" title="3.3.7.3 消息与回复队列的关联"></a>3.3.7.3 消息与回复队列的关联</h4><p>使用固定答复队列（amq.rabbitmq.reply-to除外）时，必须提供相关数据，以便将答复与请求相关。请参阅RabbitMQ远程过程调用（RPC）。默认情况下，标准的correlationId属性用于保存相关数据。但是，如果希望使用自定义属性来保存关联数据，则可以在上设置correlation-key属性。将该属性显式设置为correlationId与省略该属性相同。客户端和服务器必须将相同的标头用于关联数据。</p><p>Spring AMQP 1.1版对此数据使用了一个名为spring_reply_correlation的自定义属性。如果您希望使用当前版本恢复到此行为（可能是为了保持与使用1.1的其他应用程序的兼容性），则必须将属性设置为spring_reply_correlation。<br>默认情况下，模板会生成自己的关联ID（忽略任何用户提供的值）。如果您希望使用自己的关联ID，请将RabbitTemplate实例的userCorrelationId属性设置为true。</p><p>相关ID必须唯一，以避免针对请求返回错误回复的可能性。</p><h4 id="3-3-7-4-回复侦听容器"><a href="#3-3-7-4-回复侦听容器" class="headerlink" title="3.3.7.4 回复侦听容器"></a>3.3.7.4 回复侦听容器</h4><p>当使用3.4.0之前的RabbitMQ版本时，每个答复都会使用一个新的临时队列。但是，可以在模板上配置单个答复队列，这样可以提高效率，还可以在该队列上设置参数。但是，在这种情况下，您还必须提供一个子元素。此元素为答复队列提供一个侦听器容器，其中模板为侦听器。元素上允许上允许的所有消息侦听器容器配置属性，但从模板的配置继承的connection-factory和message-converter除外。</p><p>如果您运行应用程序的多个实例或使用多个RabbitTemplate实例，则必须为每个实例使用唯一的答复队列。 RabbitMQ无法从队列中选择消息，因此，如果它们都使用相同的队列，则每个实例都将争夺答复，而不一定会收到自己的消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:template id=&quot;amqpTemplate&quot;</span><br><span class="line">        connection-factory=&quot;connectionFactory&quot;</span><br><span class="line">        reply-queue=&quot;replies&quot;</span><br><span class="line">        reply-address=&quot;replyEx/routeReply&quot;&gt;</span><br><span class="line">    &lt;rabbit:reply-listener/&gt;</span><br><span class="line">&lt;/rabbit:template&gt;</span><br></pre></td></tr></table></figure><p>容器和模板共享连接工厂时，它们不共享通道。因此，请求和答复不在同一事务中执行（如果是事务性的）。<br>在1.5.0之前的版本中，reply-address属性不可用。始终使用默认交换和答复队列名称作为路由关键字来路由答复。这仍然是默认设置，但是您现在可以指定新的reply-address属性。回复地址可以包含格式为 / 的地址，并且回复被路由到指定的交换机，并被路由到与路由键绑定的队列。回复地址优先于回复队列。当仅使用回复地址时，必须将配置为单独的组件。回复地址和回复队列（或上的queues属性）必须在逻辑上引用同一队列。</p><p>通过这种配置，SimpleListenerContainer用于接收答复，其中RabbitTemplate为MessageListener。如上例所示，当使用命名空间元素定义模板时，解析器将模板中的容器和连线定义为侦听器。</p><p>当模板不使用固定的ReplyQueue时（或使用直接答复者-参见RabbitMQ直接答复者），则不需要侦听器容器。使用RabbitMQ 3.4.0或更高版本时，首选直接答复机制。</p><p>如果将RabbitTemplate定义为或使用@Configuration类将其定义为@Bean，或者在以编程方式创建模板时，则需要自己定义并连接答复侦听器容器。如果您无法执行此操作，则模板将永远不会收到答复，并最终超时并返回null作为对sendAndReceive方法的调用的答复。</p><p>从1.5版开始，RabbitTemplate会检测它是否已配置为MessageListener来接收回复。否则，尝试发送和接收带有回复地址的消息失败，并出现IllegalStateException（因为从未收到回复）。</p><p>此外，如果使用简单的ReplyAddress（队列名称），则回复侦听器容器将验证它正在侦听具有相同名称的队列。如果回复地址是交换和路由密钥，并且写入了调试日志消息，则无法执行此检查。</p><p>自己连接回复侦听器和模板时，务必确保模板的ReplyAddress和容器的队列（或queueNames）属性引用相同的队列。该模板将回复地址插入到出站邮件的ReplyTo属性中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;amqpTemplate&quot; class=&quot;org.springframework.amqp.rabbit.core.RabbitTemplate&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;exchange&quot; value=&quot;foo.exchange&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;routingKey&quot; value=&quot;foo&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;replyQueue&quot; ref=&quot;replyQ&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;replyTimeout&quot; value=&quot;600000&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;useDirectReplyToContainer&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean class=&quot;org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;connectionFactory&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;queues&quot; ref=&quot;replyQ&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;messageListener&quot; ref=&quot;amqpTemplate&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;replyQ&quot; name=&quot;my.reply.queue&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RabbitTemplate amqpTemplate() &#123;</span><br><span class="line">   RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());</span><br><span class="line">   rabbitTemplate.setMessageConverter(msgConv());</span><br><span class="line">   rabbitTemplate.setReplyAddress(replyQueue().getName());</span><br><span class="line">   rabbitTemplate.setReplyTimeout(60000);</span><br><span class="line">   rabbitTemplate.setUseDirectReplyToContainer(false);</span><br><span class="line">   return rabbitTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleMessageListenerContainer replyListenerContainer() &#123;</span><br><span class="line">   SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</span><br><span class="line">   container.setConnectionFactory(connectionFactory());</span><br><span class="line">   container.setQueues(replyQueue());</span><br><span class="line">   container.setMessageListener(amqpTemplate());</span><br><span class="line">   return container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue replyQueue() &#123;</span><br><span class="line">   return new Queue(&quot;my.reply.queue&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此测试用例中，显示了一个RabbitTemplate的完整示例，该示例连接了固定的答复队列以及处理请求并返回答复的“远程”侦听器容器。</p><p>当回复超时（replyTimeout）时，sendAndReceive（）方法将返回null。</p><p>在1.3.6版之前，仅记录对超时消息的最新答复。现在，如果收到延迟答复，则拒绝该答复（模板将引发AmqpRejectAndDontRequeueException）。如果将答复队列配置为将拒绝的邮件发送到死信交换，则可以检索答复以进行以后的分析。为此，请使用与回复队列名称相同的路由键将队列绑定到已配置的死信交换。</p><p>有关配置无效字母的更多信息，请参见RabbitMQ无效字母文档。您还可以查看FixedReplyQueueDeadLetterTests测试用例的示例。</p><h4 id="3-3-7-5-AsyncRabbitTemplate"><a href="#3-3-7-5-AsyncRabbitTemplate" class="headerlink" title="3.3.7.5 AsyncRabbitTemplate"></a>3.3.7.5 AsyncRabbitTemplate</h4><p>1.6版引入了AsyncRabbitTemplate。这具有与AmqpTemplate上相似的sendAndReceive（和convertSendAndReceive）方法。但是，它们不是阻塞而是返回一个ListenableFuture。</p><p>sendAndReceive方法返回RabbitMessageFuture。 convertSendAndReceive方法返回RabbitConverterFuture。</p><p>您可以稍后通过将来调用get（）来同步检索结果，也可以注册一个与结果异步调用的回调。下面的清单显示了两种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private AsyncRabbitTemplate template;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public void doSomeWorkAndGetResultLater() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ListenableFuture&lt;String&gt; future = this.template.convertSendAndReceive(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">    // do some more work</span><br><span class="line"></span><br><span class="line">    String reply = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        reply = future.get();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ExecutionException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doSomeWorkAndGetResultAsync() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    RabbitConverterFuture&lt;String&gt; future = this.template.convertSendAndReceive(&quot;foo&quot;);</span><br><span class="line">    future.addCallback(new ListenableFutureCallback&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(String result) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(Throwable ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了mandatory，并且消息无法传递，则将来会引发ExecutionException，其原因是AmqpMessageReturnedException，该异常封装了返回的消息和有关返回的信息。</p><p>如果设置了enableConfirms，则future将具有一个名为Confirm的属性，该属性本身是一个ListenableFuture ，其中true表示成功发布。如果确认未来为假，RabbitFuture具有另一个名为nackCause的属性，其中包含失败的原因（如果有）。</p><p>如果在回复后收到确认，则发布者确认将被丢弃，因为回复表示成功发布。<br>您可以在模板上设置receiveTimeout属性以使答复超时（默认为30000-30秒）。如果发生超时，则将来会通过AmqpReplyTimeoutException完成。</p><p>该模板实现SmartLifecycle。在有挂起的答复时停止模板会导致挂起的Future实例被取消。</p><p>从2.0版开始，异步模板现在支持直接答复而不是配置的答复队列。要启用此功能，请使用以下构造函数之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public AsyncRabbitTemplate(ConnectionFactory connectionFactory, String exchange, String routingKey)</span><br><span class="line"></span><br><span class="line">public AsyncRabbitTemplate(RabbitTemplate template)</span><br></pre></td></tr></table></figure><p>请参阅RabbitMQ直接答复以将直接答复与同步RabbitTemplate一起使用。</p><p>2.0版引入了这些方法的变体（convertSendAndReceiveAsType），这些变体采用附加的ParameterizedTypeReference参数来转换复杂的返回类型。您必须使用SmartMessageConverter配置基础RabbitTemplate。有关更多信息，请参见使用RabbitTemplate从消息转换。</p><h4 id="3-3-7-6-Spring-Remoting-with-AMQP"><a href="#3-3-7-6-Spring-Remoting-with-AMQP" class="headerlink" title="3.3.7.6 Spring Remoting with AMQP"></a>3.3.7.6 Spring Remoting with AMQP</h4><p>Spring框架具有常规的远程处理功能，允许使用各种传输方式的远程过程调用（RPC）。 Spring-AMQP通过客户端上的AmqpProxyFactoryBean和服务器上的AmqpInvokerServiceExporter支持类似的机制。这提供了基于AMQP的RPC。在客户端，如前所述使用RabbitTemplate。在服务器端，调用程序（配置为MessageListener）接收消息，调用配置的服务，并使用入站消息的ReplyTo信息返回答复。</p><p>您可以将客户端工厂bean注入任何bean（通过使用其serviceInterface）。然后，客户端可以调用代理上的方法，从而通过AMQP进行远程执行。</p><p>对于默认的MessageConverter实例，方法参数和返回值必须是Serializable实例。<br>在服务器端，AmqpInvokerServiceExporter同时具有AmqpTemplate和MessageConverter属性。当前，未使用模板的MessageConverter。如果需要提供自定义消息转换器，则应通过设置messageConverter属性来提供它。在客户端，您可以向AmqpTemplate添加自定义消息转换器，该转换器通过使用其amqpTemplate属性提供给AmqpProxyFactoryBean。</p><p>以下清单显示了示例客户端和服务器配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;client&quot;</span><br><span class="line">class=&quot;org.springframework.amqp.remoting.client.AmqpProxyFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name=&quot;amqpTemplate&quot; ref=&quot;template&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;serviceInterface&quot; value=&quot;foo.ServiceInterface&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:template id=&quot;template&quot; connection-factory=&quot;connectionFactory&quot; reply-timeout=&quot;2000&quot;</span><br><span class="line">routing-key=&quot;remoting.binding&quot; exchange=&quot;remoting.exchange&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:admin connection-factory=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue name=&quot;remoting.queue&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:direct-exchange name=&quot;remoting.exchange&quot;&gt;</span><br><span class="line">&lt;rabbit:bindings&gt;</span><br><span class="line">&lt;rabbit:binding queue=&quot;remoting.queue&quot; key=&quot;remoting.binding&quot; /&gt;</span><br><span class="line">&lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:direct-exchange&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;listener&quot;</span><br><span class="line">class=&quot;org.springframework.amqp.remoting.service.AmqpInvokerServiceExporter&quot;&gt;</span><br><span class="line">&lt;property name=&quot;serviceInterface&quot; value=&quot;foo.ServiceInterface&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;service&quot; ref=&quot;service&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;amqpTemplate&quot; ref=&quot;template&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;service&quot; class=&quot;foo.ServiceImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:template id=&quot;template&quot; connection-factory=&quot;connectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue name=&quot;remoting.queue&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot;&gt;</span><br><span class="line">&lt;rabbit:listener ref=&quot;listener&quot; queue-names=&quot;remoting.queue&quot; /&gt;</span><br><span class="line">&lt;/rabbit:listener-container&gt;</span><br></pre></td></tr></table></figure><p>AmqpInvokerServiceExporter只能处理格式正确的消息，例如从AmqpProxyFactoryBean发送的消息。如果收到无法解释的消息，则会发送序列化的RuntimeException作为答复。如果邮件没有replyToAddress属性，则如果未配置死信交换，则邮件将被拒绝并永久丢失。</p><p>默认情况下，如果无法传递请求消息，则调用线程最终超时，并引发RemoteProxyFailureException。默认情况下，超时为五秒。您可以通过在RabbitTemplate上设置ReplyTimeout属性来修改该持续时间。从版本1.5开始，将强制性属性设置为true并在连接工厂上启用返回（请参见发布者确认和返回），调用线程将引发AmqpMessageReturnedException。有关更多信息，请参见回复超时。</p><h3 id="3-3-8-配置Broker"><a href="#3-3-8-配置Broker" class="headerlink" title="3.3.8 配置Broker"></a>3.3.8 配置Broker</h3><p>AMQP规范描述了如何使用协议在代理上配置队列，交换和绑定。这些操作（可从0.8规范及更高版本移植）在org.springframework.amqp.core软件包的AmqpAdmin界面中。该类的RabbitMQ实现是RabbitAdmin，位于org.springframework.amqp.rabbit.core包中。</p><p>AmqpAdmin界面基于使用Spring AMQP域抽象，并在以下列表中显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface AmqpAdmin &#123;</span><br><span class="line"></span><br><span class="line">    // Exchange Operations</span><br><span class="line"></span><br><span class="line">    void declareExchange(Exchange exchange);</span><br><span class="line"></span><br><span class="line">    void deleteExchange(String exchangeName);</span><br><span class="line"></span><br><span class="line">    // Queue Operations</span><br><span class="line"></span><br><span class="line">    Queue declareQueue();</span><br><span class="line"></span><br><span class="line">    String declareQueue(Queue queue);</span><br><span class="line"></span><br><span class="line">    void deleteQueue(String queueName);</span><br><span class="line"></span><br><span class="line">    void deleteQueue(String queueName, boolean unused, boolean empty);</span><br><span class="line"></span><br><span class="line">    void purgeQueue(String queueName, boolean noWait);</span><br><span class="line"></span><br><span class="line">    // Binding Operations</span><br><span class="line"></span><br><span class="line">    void declareBinding(Binding binding);</span><br><span class="line"></span><br><span class="line">    void removeBinding(Binding binding);</span><br><span class="line"></span><br><span class="line">    Properties getQueueProperties(String queueName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getQueueProperties（）方法返回有关队列的一些有限信息（消息计数和消费者计数）。返回的属性的键在RabbitTemplate中可以作为常量使用（QUEUE_NAME，QUEUE_MESSAGE_COUNT和QUEUE_CONSUMER_COUNT）。 RabbitMQ REST API在QueueInfo对象中提供了更多信息。</p><p>no-argclarifyQueue（）方法使用自动生成的名称定义代理上的队列。此自动生成的队列的其他属性是Exclusive = true，autoDelete = true和持久= false。</p><p>defineQueue（Queue queue）方法接受一个Queue对象，并返回已声明队列的名称。如果提供的Queue的name属性为空字符串，则代理将使用生成的名称声明队列。该名称将返回给呼叫者。该名称也被添加到队列的actualName属性中。您只能通过直接调用RabbitAdmin来以编程方式使用此功能。在应用程序上下文中以声明方式定义队列时，当管理员使用自动声明时，可以将name属性设置为“”（空字符串）。然后，代理创建名称。从2.1版开始，侦听器容器可以使用这种类型的队列。有关更多信息，请参见以容器和代理命名的队列。</p><p>这与AnonymousQueue相反，在AnonymousQueue中，框架生成唯一（UUID）名称，并将持久性设置为false和Exclusive，将autoDelete设置为true。名称属性为空（或缺少）的始终会创建一个AnonymousQueue。</p><p>请参阅AnonymousQueue以了解为什么AnonymousQueue优先于代理生成的队列名称，以及如何控制名称格式。从版本2.1开始，默认情况下，匿名队列使用参数x-queue-master-locator声明为本地客户端声明。这样可以确保在与应用程序连接的节点上声明队列。声明性队列必须具有固定的名称，因为它们可能在上下文中的其他地方被引用，例如在以下示例中所示的侦听器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:listener-container&gt;</span><br><span class="line">    &lt;rabbit:listener ref=&quot;listener&quot; queue-names=&quot;#&#123;someQueue.name&#125;&quot; /&gt;</span><br><span class="line">&lt;/rabbit:listener-container&gt;</span><br></pre></td></tr></table></figure><p>该接口的RabbitMQ实现是RabbitAdmin，当使用Spring XML进行配置时，它类似于以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:admin id=&quot;amqpAdmin&quot; connection-factory=&quot;connectionFactory&quot;/&gt;</span><br></pre></td></tr></table></figure><p>当CachingConnectionFactory缓存模式为CHANNEL（默认）时，RabbitAdmin实现将自动延迟声明在同一ApplicationContext中声明的队列，交换和绑定。一旦向代理打开连接，便声明这些组件。有一些名称空间功能使此操作非常方便。例如，在Stocks示例应用程序中，我们具有以下功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;tradeQueue&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;marketDataQueue&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;fanout-exchange name=&quot;broadcast.responses&quot;</span><br><span class="line">                 xmlns=&quot;http://www.springframework.org/schema/rabbit&quot;&gt;</span><br><span class="line">    &lt;bindings&gt;</span><br><span class="line">        &lt;binding queue=&quot;tradeQueue&quot;/&gt;</span><br><span class="line">    &lt;/bindings&gt;</span><br><span class="line">&lt;/fanout-exchange&gt;</span><br><span class="line"></span><br><span class="line">&lt;topic-exchange name=&quot;app.stock.marketdata&quot;</span><br><span class="line">                xmlns=&quot;http://www.springframework.org/schema/rabbit&quot;&gt;</span><br><span class="line">    &lt;bindings&gt;</span><br><span class="line">        &lt;binding queue=&quot;marketDataQueue&quot; pattern=&quot;$&#123;stocks.quote.pattern&#125;&quot;/&gt;</span><br><span class="line">    &lt;/bindings&gt;</span><br><span class="line">&lt;/topic-exchange&gt;</span><br></pre></td></tr></table></figure><p>在前面的示例中，我们使用匿名队列（实际上，在内部，只是具有由框架而不是由代理生成的名称的队列），并通过ID引用它们。我们还可以使用显式名称声明队列，这些队列还用作上下文中其bean定义的标识符。以下示例使用明确的名称配置队列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;stocks.trade.queue&quot;/&gt;</span><br></pre></td></tr></table></figure><p>您可以提供id和name属性。这使您可以通过独立于队列名称的ID来引用队列（例如，在绑定中）。它还允许使用标准的Spring功能（例如队列名的属性占位符和SpEL表达式）。当您使用名称作为Bean标识符时，这些功能不可用。</p><p>默认情况下，当发生任何异常时，RabbitAdmin将立即停止处理所有声明。这可能会导致下游问题，例如侦听器容器无法初始化，因为未声明另一个队列（在错误的一个之后定义）。</p><p>可以通过在RabbitAdmin实例上将ignore-declaration-exceptions属性设置为true来修改此行为。该选项指示RabbitAdmin记录异常并继续声明其他元素。使用Java配置RabbitAdmin时，此属性称为ignoreDeclarationExceptions。这是适用于所有元素的全局设置。队列，交换和绑定具有类似的属性，仅适用于那些元素。</p><p>在1.6版之前的版本中，仅当通道上发生IOException时（例如，当前属性与所需属性不匹配时），此属性才生效。现在，此属性对任何异常（包括TimeoutException和其他异常）都生效。</p><p>另外，任何声明异常都会导致产生一个DeclarationExceptionEvent，这是一个ApplicationEvent，可以由上下文中的任何ApplicationListener消费。该事件包含对admin，已声明的元素和Throwable的引用。</p><h4 id="3-3-8-1-Header-交换器"><a href="#3-3-8-1-Header-交换器" class="headerlink" title="3.3.8.1 Header 交换器"></a>3.3.8.1 Header 交换器</h4><p>从版本1.3开始，您可以配置HeadersExchange以匹配多个Header。您也可以指定是否必须匹配任何Header。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:headers-exchange name=&quot;headers-test&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding queue=&quot;bucket&quot;&gt;</span><br><span class="line">            &lt;rabbit:binding-arguments&gt;</span><br><span class="line">                &lt;entry key=&quot;foo&quot; value=&quot;bar&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;baz&quot; value=&quot;qux&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;x-match&quot; value=&quot;all&quot;/&gt;</span><br><span class="line">            &lt;/rabbit:binding-arguments&gt;</span><br><span class="line">        &lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:headers-exchange&gt;</span><br></pre></td></tr></table></figure><p>从版本1.6开始，您可以使用内部标志（默认为false）配置Exchange，并且可以通过RabbitAdmin在Broker上正确配置这样的Exchange（如果应用程序上下文中存在Exchange）。如果内部标志适用于交换，则RabbitMQ不允许客户端使用交换。这对于无用信交换或交换对交换绑定很有用，在这种情况下，您不希望发行人直接使用交换。</p><p>要查看如何使用Java配置AMQP基础结构，请查看Stock示例应用程序，其中有@Configuration类AbstractStockRabbitConfiguration，该类又具有RabbitClientConfiguration和RabbitServerConfiguration子类。以下清单显示了AbstractStockRabbitConfiguration的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public abstract class AbstractStockAppRabbitConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConnectionFactory connectionFactory() &#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory =</span><br><span class="line">            new CachingConnectionFactory(&quot;localhost&quot;);</span><br><span class="line">        connectionFactory.setUsername(&quot;guest&quot;);</span><br><span class="line">        connectionFactory.setPassword(&quot;guest&quot;);</span><br><span class="line">        return connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitTemplate rabbitTemplate() &#123;</span><br><span class="line">        RabbitTemplate template = new RabbitTemplate(connectionFactory());</span><br><span class="line">        template.setMessageConverter(jsonMessageConverter());</span><br><span class="line">        configureRabbitTemplate(template);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MessageConverter jsonMessageConverter() &#123;</span><br><span class="line">        return new Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TopicExchange marketDataExchange() &#123;</span><br><span class="line">        return new TopicExchange(&quot;app.stock.marketdata&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // additional code omitted for brevity</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端通过AmqpAdmin上的clarifyQueue（）方法声明另一个队列。它使用属性文件中外部化的路由模式将该队列绑定到市场数据交换。</p><h4 id="3-3-8-2-Builder-API"><a href="#3-3-8-2-Builder-API" class="headerlink" title="3.3.8.2 Builder API"></a>3.3.8.2 Builder API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> @Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    return QueueBuilder.nonDurable(&quot;foo&quot;)</span><br><span class="line">        .autoDelete()</span><br><span class="line">        .exclusive()</span><br><span class="line">        .withArgument(&quot;foo&quot;, &quot;bar&quot;)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Exchange exchange() &#123;</span><br><span class="line">  return ExchangeBuilder.directExchange(&quot;foo&quot;)</span><br><span class="line">      .autoDelete()</span><br><span class="line">      .internal()</span><br><span class="line">      .withArgument(&quot;foo&quot;, &quot;bar&quot;)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-8-3-声明交换、队列、绑定的集合"><a href="#3-3-8-3-声明交换、队列、绑定的集合" class="headerlink" title="3.3.8.3 声明交换、队列、绑定的集合"></a>3.3.8.3 声明交换、队列、绑定的集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public static class Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConnectionFactory cf() &#123;</span><br><span class="line">        return new CachingConnectionFactory(&quot;localhost&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitAdmin admin(ConnectionFactory cf) &#123;</span><br><span class="line">        return new RabbitAdmin(cf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange e1() &#123;</span><br><span class="line">    return new DirectExchange(&quot;e1&quot;, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue q1() &#123;</span><br><span class="line">    return new Queue(&quot;q1&quot;, false, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Binding b1() &#123;</span><br><span class="line">    return BindingBuilder.bind(q1()).to(e1()).with(&quot;k1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables es() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new DirectExchange(&quot;e2&quot;, false, true),</span><br><span class="line">                new DirectExchange(&quot;e3&quot;, false, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables qs() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new Queue(&quot;q2&quot;, false, false, true),</span><br><span class="line">                new Queue(&quot;q3&quot;, false, false, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">    public Declarables prototypes() &#123;</span><br><span class="line">        return new Declarables(new Queue(this.prototypeQueueName, false, false, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables bs() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new Binding(&quot;q2&quot;, DestinationType.QUEUE, &quot;e2&quot;, &quot;k2&quot;, null),</span><br><span class="line">                new Binding(&quot;q3&quot;, DestinationType.QUEUE, &quot;e3&quot;, &quot;k3&quot;, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Declarables ds() &#123;</span><br><span class="line">        return new Declarables(</span><br><span class="line">                new DirectExchange(&quot;e4&quot;, false, true),</span><br><span class="line">                new Queue(&quot;q4&quot;, false, false, true),</span><br><span class="line">                new Binding(&quot;q4&quot;, DestinationType.QUEUE, &quot;e4&quot;, &quot;k4&quot;, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2版将getDeclarablesByType方法添加到了Declarables中。例如，在声明一个或多个侦听器容器bean时，这可以方便使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public SimpleMessageListenerContainer container(ConnectionFactory connectionFactory,</span><br><span class="line">        Declarables mixedDeclarables, MessageListener listener) &#123;</span><br><span class="line"></span><br><span class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">    container.setQueues(mixedDeclarables.getDeclarablesByType(Queue.class).toArray(new Queue[0]));</span><br><span class="line">    container.setMessageListener(listener);</span><br><span class="line">    return container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-8-4-条件声明"><a href="#3-3-8-4-条件声明" class="headerlink" title="3.3.8.4 条件声明"></a>3.3.8.4 条件声明</h4><p>默认情况下，所有队列，交换和绑定都由应用程序上下文中的所有RabbitAdmin实例声明（假设它们具有auto-startup =“ true”）。</p><p>从版本2.1.9开始，RabbitAdmin具有新的属性explicitDeclarationsOnly（默认情况下为false）。当将此设置为true时，管理员将仅声明显式配置为由该RabbitAdmin声明的Bean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RabbitAdmin admin1() &#123;</span><br><span class="line">    return new RabbitAdmin(cf1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public RabbitAdmin admin2() &#123;</span><br><span class="line">    return new RabbitAdmin(cf2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    Queue queue = new Queue(&quot;foo&quot;);</span><br><span class="line">    queue.setAdminsThatShouldDeclare(admin1());</span><br><span class="line">    return queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Exchange exchange() &#123;</span><br><span class="line">    DirectExchange exchange = new DirectExchange(&quot;bar&quot;);</span><br><span class="line">    exchange.setAdminsThatShouldDeclare(admin1());</span><br><span class="line">    return exchange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Binding binding() &#123;</span><br><span class="line">    Binding binding = new Binding(&quot;foo&quot;, DestinationType.QUEUE, exchange().getName(), &quot;foo&quot;, null);</span><br><span class="line">    binding.setAdminsThatShouldDeclare(admin1());</span><br><span class="line">    return binding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-8-5-关于id和name属性的注释"><a href="#3-3-8-5-关于id和name属性的注释" class="headerlink" title="3.3.8.5 关于id和name属性的注释"></a>3.3.8.5 关于id和name属性的注释</h4><p>和元素上的name属性反映代理中实体的名称。对于队列，如果省略名称，则会创建一个匿名队列（请参阅AnonymousQueue）。</p><p>在2.0之前的版本中，该名称也被注册为Bean名称别名（类似于元素上的名称）。</p><p>这导致了两个问题：</p><ul><li><p>它阻止了队列的声明和相同名称的交换。</p></li><li><p>如果别名包含SpEL表达式（＃{…}），则无法解析。</p></li></ul><p>从2.0版开始，如果您同时使用id和name属性声明这些元素之一，则该名称不再声明为Bean名称别名。如果要声明队列并使用相同的名称进行交换，则必须提供一个ID。</p><p>如果元素只有name属性，则没有任何变化。仍然可以使用名称Bean来引用该Bean，例如在绑定声明中。但是，如果名称包含SpEL，您仍然无法引用它-您必须提供ID以供参考。</p><h4 id="3-3-8-6-AnonymousQueue"><a href="#3-3-8-6-AnonymousQueue" class="headerlink" title="3.3.8.6 AnonymousQueue"></a>3.3.8.6 AnonymousQueue</h4><p>通常，当您需要一个唯一命名的排他性自动删除队列时，建议您使用AnonymousQueue而不是broker定义的队列名称（使用“”作为队列名称会导致代理生成队列名称）。</p><p>这是因为：</p><p>建立与broker的连接时，实际上会声明队列。在创建和将bean连接在一起很长时间之后。使用队列的Bean需要知道其名称。实际上，启动应用程序时，broker甚至可能没有运行。</p><p>如果与broker的连接由于某种原因而丢失，则管理员将用相同的名称重新声明AnonymousQueue。如果使用broker声明的队列，则队列名称将更改。</p><p>您可以控制AnonymousQueue实例使用的队列名称的格式。</p><p>默认情况下，队列名称以spring.gen-为前缀，后跟UUID的base64表示形式，例如：spring.gen-MRBv9sqISkuCiPfOYfpo4g。</p><p>您可以在构造函数参数中提供AnonymousQueue.NamingStrategy实现。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue anon1() &#123;</span><br><span class="line">    return new AnonymousQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue anon2() &#123;</span><br><span class="line">    return new AnonymousQueue(new AnonymousQueue.Base64UrlNamingStrategy(&quot;something-&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue anon3() &#123;</span><br><span class="line">    return new AnonymousQueue(AnonymousQueue.UUIDNamingStrategy.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个bean生成一个队列名称，该队列名称以spring.gen-为前缀，后跟UUID的base64表示形式-例如：spring.gen-MRBv9sqISkuCiPfOYfpo4g。第二个bean生成一个以某些东西为前缀的队列名称，后跟UUID的base64表示形式。第三个bean仅通过使用UUID（不进行base64转换）来生成名称，例如f20c818a-006b-4416-bf91-643590fedb0e。</p><p>base64编码使用RFC 4648中的“ ​​URL和文件名安全字母”。尾随的填充字符（=）被删除。</p><p>您可以提供自己的命名策略，从而可以在队列名称中包括其他信息（例如应用程序名称或客户端主机）。</p><p>使用XML配置时，可以指定命名策略。 naming-strategy属性存在于实现AnonymousQueue.NamingStrategy的bean引用的元素上。以下示例显示如何以各种方式指定命名策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue id=&quot;uuidAnon&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;springAnon&quot; naming-strategy=&quot;uuidNamer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:queue id=&quot;customAnon&quot; naming-strategy=&quot;customNamer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;uuidNamer&quot; class=&quot;org.springframework.amqp.core.AnonymousQueue.UUIDNamingStrategy&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;customNamer&quot; class=&quot;org.springframework.amqp.core.AnonymousQueue.Base64UrlNamingStrategy&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;custom.gen-&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>第一个示例创建名称，例如spring.gen-MRBv9sqISkuCiPfOYfpo4g。第二个示例使用UUID的字符串表示形式创建名称。第三个示例创建名称，例如custom.gen-MRBv9sqISkuCiPfOYfpo4g。</p><p>您还可以提供自己的命名策略bean。</p><p>从版本2.1开始，默认情况下，匿名队列使用参数x-queue-master-locator声明为本地客户端声明。这样可以确保在与应用程序连接的节点上声明队列。构造实例后，可以通过调用queue.setMasterLocator（null）恢复到以前的行为。</p><h3 id="3-3-9-Broker事件监听"><a href="#3-3-9-Broker事件监听" class="headerlink" title="3.3.9 Broker事件监听"></a>3.3.9 Broker事件监听</h3><p>启用事件交换插件后，如果将类型为BrokerEventListener的bean添加到应用程序上下文中，它将发布选定的代理事件作为BrokerEvent实例，可以通过常规的Spring ApplicationListener或@EventListener方法使用它。代理将事件发布到主题交换amq.rabbitmq.event，每种事件类型具有不同的路由键。侦听器使用事件密钥，该事件密钥用于将AnonymousQueue绑定到交换，因此侦听器仅接收选定的事件。由于这是一个主题交换，因此可以使用通配符（以及显式请求特定事件），如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public BrokerEventListener eventListener() &#123;</span><br><span class="line">    return new BrokerEventListener(connectionFactory(), &quot;user.deleted&quot;, &quot;channel.#&quot;, &quot;queue.#&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用正常的Spring技术进一步缩小单个事件侦听器中接收到的事件的范围，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@EventListener(condition = &quot;event.eventType == &apos;queue.created&apos;&quot;)</span><br><span class="line">public void listener(BrokerEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-10-延迟消息交换器"><a href="#3-3-10-延迟消息交换器" class="headerlink" title="3.3.10 延迟消息交换器"></a>3.3.10 延迟消息交换器</h3><p>该插件目前被标记为实验性，但已经可用了一年多的时间（在撰写本文时）。如果需要更改插件，我们计划在可行的情况下尽快添加对此类更改的支持。因此，Spring AMQP中的这种支持也应视为试验性的。此功能已通过RabbitMQ 3.6.0和插件的0.0.1版进行了测试。</p><p>要使用RabbitAdmin将交换声明为延迟，可以将交换bean的delay属性设置为true。 RabbitAdmin使用交换类型（直接，扇出等）来设置x-delayed-type参数，并使用x-delayed-message类型声明交换。</p><p>使用XML配置交换bean时，delayed属性（默认值：false）也可用。以下示例显示了如何使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:topic-exchange name=&quot;topic&quot; delayed=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure><p>要发送延迟的消息，可以通过MessageProperties设置x-delay标头，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties properties = new MessageProperties();</span><br><span class="line">properties.setDelay(15000);</span><br><span class="line">template.send(exchange, routingKey,</span><br><span class="line">MessageBuilder.withBody(&quot;foo&quot;.getBytes()).andProperties(properties).build());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(exchange, routingKey, &quot;foo&quot;, new MessagePostProcessor() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">        message.getMessageProperties().setDelay(15000);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>若要检查消息是否延迟，请在MessageProperties上使用getReceivedDelay（）方法。这是一个单独的属性，可以避免意外传播到由输入消息生成的输出消息。</p><h3 id="3-3-11-RabbitMQ-Rest-API"><a href="#3-3-11-RabbitMQ-Rest-API" class="headerlink" title="3.3.11 RabbitMQ Rest API"></a>3.3.11 RabbitMQ Rest API</h3><p>启用管理插件后，RabbitMQ服务器将公开REST API来监视和配置代理。现在提供了API的Java绑定。 com.rabbitmq.http.client.Client是一个标准的，即时的并且因此是阻塞的API。它基于Spring Web模块及其RestTemplate实现。另一方面，com.rabbitmq.http.client.ReactorNettyClient是基于Reactor Netty项目的反应性，非阻塞实现。</p><p>跳相关性（com.rabbitmq：http-client）现在也是可选的。</p><p>有关更多信息，请参见其Javadoc。</p><h3 id="3-3-12-异常处理"><a href="#3-3-12-异常处理" class="headerlink" title="3.3.12 异常处理"></a>3.3.12 异常处理</h3><p>RabbitMQ Java客户端的许多操作都可能引发已检查的异常。例如，在很多情况下，可能会抛出IOException实例。 RabbitTemplate，SimpleMessageListenerContainer和其他Spring AMQP组件捕获这些异常，并将它们转换为AmqpException层次结构中的异常之一。这些在“ org.springframework.amqp”包中定义，AmqpException是层次结构的基础。</p><p>当侦听器引发异常时，它将包装在ListenerExecutionFailedException中。通常，消息被代理拒绝并重新排队。将defaultRequeueRejected设置为false会导致消息被丢弃（或路由到无效信件交换）。如消息侦听器和异步案例中所述，侦听器可以引发AmqpRejectAndDontRequeueException（或InstantRequeueAmqpException）来有条件地控制此行为。</p><p>但是，存在一类错误，侦听器无法控制该行为。当遇到无法转换的消息（例如，无效的content_encoding标头）时，在消息到达用户代码之前会引发一些异常。将defaultRequeueRejected设置为true（默认值）（或引发InstantRequeueAmqpException），此类消息将一遍又一遍地传递。在版本1.3.2之前，用户需要编写自定义ErrorHandler（如异常处理中所述），以避免这种情况。</p><p>从1.3.2版开始，默认的ErrorHandler现在是ConditionalRejectingErrorHandler，它拒绝（并且不重新排队）由于不可恢复的错误而失败的消息。具体来说，它拒绝失败并出现以下错误的消息：</p><p>o.s.amqp … MessageConversionException：使用MessageConverter转换传入消息有效负载时可以抛出此异常。</p><p>o.s.messaging … MessageConversionException：如果映射到@RabbitListener方法时需要额外的转换，则转换服务可以抛出该异常。</p><p>o.s.messaging … MethodArgumentNotValidException：如果在侦听器中使用了验证（例如@Valid），则可以引发此异常。</p><p>o.s.messaging … MethodArgumentTypeMismatchException：如果将入站消息转换为与目标方法不正确的类型，则可以引发该异常。例如，将该参数声明为Message ，但收到Message 。</p><p>java.lang.NoSuchMethodException：在版本1.6.3中添加。</p><p>java.lang.ClassCastException：在版本1.6.3中添加。</p><p>您可以使用FatalExceptionStrategy配置此错误处理程序的实例，以便用户可以提供自己的条件消息拒绝规则-例如，从Spring Retry（消息侦听器和异步案例）到BinaryExceptionClassifier的委托实现。另外，ListenerExecutionFailedException现在具有您可以在决策中使用的failedMessage属性。如果FatalExceptionStrategy.isFatal（）方法返回true，则错误处理程序将引发AmqpRejectAndDontRequeueException。当确定异常为致命时，默认的FatalExceptionStrategy会记录一条警告消息。</p><p>从1.6.3版开始，将用户异常添加到致命列表的便捷方法是子类ConditionalRejectingErrorHandler.DefaultExceptionStrategy并重写isUserCauseFatal（Throwable cause）方法以为致命异常返回true。</p><p>处理DLQ消息的常见模式是在这些消息以及其他DLQ配置上设置生存时间，以使这些消息过期并路由回主队列以重试。这种技术的问题在于，导致致命异常的消息会永远循环。从2.1版开始，ConditionalRejectingErrorHandler在消息上检测到x-death标头，该标头导致引发致命异常。该消息已记录并被丢弃。您可以通过将ConditionalRejectingErrorHandler上的rejectFatalsWithXDeath属性设置为false来还原为以前的行为。</p><p>从版本2.1.9开始，即使容器确认模式为MANUAL，默认情况下，具有这些致命异常的消息也将被拒绝并且不重新排队。这些异常通常在调用侦听器之前发生，因此侦听器没有机会确认或拒绝消息，因此消息以未确认状态保留在队列中。若要还原为以前的行为，请将ConditionalRejectingErrorHandler的rejectManual属性设置为false。</p><h3 id="3-3-13-事务"><a href="#3-3-13-事务" class="headerlink" title="3.3.13 事务"></a>3.3.13 事务</h3><p>Spring Rabbit框架支持同步和异步用例中的自动事务管理，具有许多不同的语义，可以通过声明方式选择这些语义，这是Spring事务的现有用户所熟悉的。这使许多（如果不是大多数）常见的消息传递模式易于实现。</p><p>有两种方法可以向框架发出所需的事务语义。在RabbitTemplate和SimpleMessageListenerContainer中，都有一个标志channelTransacted，如果为true，则告诉框架使用事务性通道并以提交或回滚（取决于结果）结束所有操作（发送或接收），但有例外表示回滚。另一个信号是使用Spring的PlatformTransactionManager实现之一提供外部事务，作为正在进行的操作的上下文。如果在框架发送或接收消息时已经有事务在进行中，并且channelTransacted标志为true，则将消息事务的提交或回滚推迟到当前事务结束为止。如果channelTransacted标志为false，则没有事务语义适用于消息传递操作（它是自动确认的）。</p><p>channelTransacted标志是配置时间设置。创建AMQP组件时，通常在应用程序启动时声明和处理一次。原则上，外部事务是动态的，因为系统在运行时响应当前线程状态。但是，实际上，当将事务以声明方式分层到应用程序时，它通常也是配置设置。</p><p>对于RabbitTemplate的同步用例，外部事务由调用方根据喜好以声明性或强制性方式提供（通常的Spring事务模型）。以下示例显示了一种声明性方法（通常首选，因为它是非侵入性的），其中已使用channelTransacted = true配置模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    String incoming = rabbitTemplate.receiveAndConvert();</span><br><span class="line">    // do some more database processing...</span><br><span class="line">    String outgoing = processInDatabaseAndExtractReply(incoming);</span><br><span class="line">    rabbitTemplate.convertAndSend(outgoing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的示例中，在标记为@Transactional的方法内，String有效负载作为消息正文被接收，转换和发送。如果数据库处理失败并发生异常，则将传入消息返回给代理，并且不发送传出消息。这适用于在交易方法链内使用RabbitTemplate进行的任何操作（例如，除非直接操纵Channel尽早提交交易）。</p><p>对于带有SimpleMessageListenerContainer的异步用例，如果需要外部事务，则容器在设置侦听器时必须请求它。为了表明需要外部事务，在配置容器时，用户向容器提供PlatformTransactionManager的实现。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ExampleExternalTransactionAmqpConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleMessageListenerContainer messageListenerContainer() &#123;</span><br><span class="line">        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">        container.setTransactionManager(transactionManager());</span><br><span class="line">        container.setChannelTransacted(true);</span><br><span class="line">        container.setQueueName(&quot;some.queue&quot;);</span><br><span class="line">        container.setMessageListener(exampleListener());</span><br><span class="line">        return container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的示例中，添加了事务管理器作为从另一个bean定义（未显示）注入的依赖项，并且channelTransacted标志也设置为true。效果是，如果侦听器因异常而失败，则事务将回滚，并且消息也将返回给代理。重要的是，如果事务提交失败（例如，由于数据库约束错误或连接性问题），则AMQP事务也会回滚，并将消息返回给代理。这有时被称为“尽力而为第一阶段提交”，并且是可靠消息传递的非常强大的模式。如果在前面的示例中将channelTransacted标志设置为false（默认值），则仍将为侦听器提供外部事务，但是所有消息传递操作将被自动确认，因此效果是即使在服务器上也提交消息传递操作。业务运营的回滚。</p><h4 id="3-3-13-1-条件退回"><a href="#3-3-13-1-条件退回" class="headerlink" title="3.3.13.1 条件退回"></a>3.3.13.1 条件退回</h4><p>在1.6.6版之前，使用外部事务管理器（例如JDBC）在容器的transactionAttribute中添加回滚规则无效。异常总是回滚事务。</p><p>另外，在容器的建议链中使用事务建议时，条件回滚并不是很有用，因为所有侦听器异常都包装在ListenerExecutionFailedException中。</p><p>第一个问题已得到纠正，现在可以正确应用规则。此外，现在提供了ListenerFailedRuleBasedTransactionAttribute。它是RuleBasedTransactionAttribute的子类，唯一的区别是它知道ListenerExecutionFailedException并将该异常的原因用于规则。该交易属性可以直接在容器中使用，也可以通过交易建议使用。</p><p>以下示例使用此规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public AbstractMessageListenerContainer container() &#123;</span><br><span class="line">    ...</span><br><span class="line">    container.setTransactionManager(transactionManager);</span><br><span class="line">    RuleBasedTransactionAttribute transactionAttribute =</span><br><span class="line">        new ListenerFailedRuleBasedTransactionAttribute();</span><br><span class="line">    transactionAttribute.setRollbackRules(Collections.singletonList(</span><br><span class="line">        new NoRollbackRuleAttribute(DontRollBackException.class)));</span><br><span class="line">    container.setTransactionAttribute(transactionAttribute);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-13-2-关于回滚收到消息的注意事项"><a href="#3-3-13-2-关于回滚收到消息的注意事项" class="headerlink" title="3.3.13.2 关于回滚收到消息的注意事项"></a>3.3.13.2 关于回滚收到消息的注意事项</h4><p>AMQP事务仅适用于发送给代理的消息和确认。因此，当发生Spring事务的回滚并且已经收到消息时，Spring AMQP不仅必须回滚该事务，而且还必须手动拒绝该消息（有点小问题，但这不是规范所称的）。拒绝消息时采取的操作与事务无关，并且取决于defaultRequeueRejected属性（默认值：true）。有关拒绝失败消息的更多信息，请参见消息侦听器和异步案例。</p><p>有关RabbitMQ事务及其限制的更多信息，请参见RabbitMQ Broker Semantics。</p><p>在RabbitMQ 2.7.0之前，此类消息（以及通道关闭或中止时未确认的消息）在Rabbit代理上进入队列的后面。从2.7.0版本开始，被拒绝的消息以与JMS回滚消息类似的方式进入队列的最前面。<br>以前，本地事务之间和提供TransactionManager时，事务回滚时的消息重新排队不一致。在前一种情况下，将应用常规的重新排队逻辑（AmqpRejectAndDontRequeueException或defaultRequeueRejected = false）（请参阅消息侦听器和异步情况）。使用事务管理器，该消息将在回滚时无条件重新排队。从版本2.0开始，行为是一致的，并且在两种情况下均采用常规的重新排队逻辑。要恢复以前的行为，可以将容器的alwaysRequeueWithTxManagerRollback属性设置为true。请参阅消息侦听器容器配置。</p><h4 id="3-3-13-3-使用RabbitTransactionManager"><a href="#3-3-13-3-使用RabbitTransactionManager" class="headerlink" title="3.3.13.3 使用RabbitTransactionManager"></a>3.3.13.3 使用RabbitTransactionManager</h4><p>RabbitTransactionManager是在外部事务中执行并与外部事务同步的Rabbit操作的替代方法。该事务管理器是PlatformTransactionManager接口的实现，应与单个Rabbit ConnectionFactory一起使用。</p><p>此策略不能提供XA事务，例如，以便在消息传递和数据库访问之间共享事务。<br>需要应用程序代码才能通过ConnectionFactoryUtils.getTransactionalResourceHolder（ConnectionFactory，boolean）（而不是带有后续通道创建的标准Connection.createChannel（））来检索事务型Rabbit资源。使用Spring AMQP的RabbitTemplate时，它将自动检测线程绑定的Channel并自动参与其事务。</p><p>使用Java配置，可以使用以下bean来设置新的RabbitTransactionManager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RabbitTransactionManager rabbitTransactionManager() &#123;</span><br><span class="line">    return new RabbitTransactionManager(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您喜欢XML配置，则可以在XML Application Context文件中声明以下bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;rabbitTxManager&quot;</span><br><span class="line">      class=&quot;org.springframework.amqp.rabbit.transaction.RabbitTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-14-消息监听容器配置"><a href="#3-3-14-消息监听容器配置" class="headerlink" title="3.3.14 消息监听容器配置"></a>3.3.14 消息监听容器配置</h3><p>用于配置与事务和服务质量相关的SimpleMessageListenerContainer（SMLC）和DirectMessageListenerContainer（DMLC）的选项很多，它们中的一些相互交互。适用于SMLC或DMLC的属性由相应列中的复选标记指示。请参阅选择容器，以获取帮助您确定哪个容器适合您的应用程序的信息。</p><p>下表显示了使用命名空间配置时的容器属性名称及其等效属性名称（在括号中）。该元素上的type属性可以是简单的（默认），也可以直接指定SMLC或DMLC。命名空间未公开某些属性。这些由属性的N / A表示。</p><h3 id="3-3-15-监听并发"><a href="#3-3-15-监听并发" class="headerlink" title="3.3.15 监听并发"></a>3.3.15 监听并发</h3><h4 id="3-3-15-1-SimpleMessageListenerContainer"><a href="#3-3-15-1-SimpleMessageListenerContainer" class="headerlink" title="3.3.15.1 SimpleMessageListenerContainer"></a>3.3.15.1 SimpleMessageListenerContainer</h4><p>默认情况下，侦听器容器启动一个消费者，该消费者从队列中接收消息。</p><p>检查上一节中的表时，您可以看到许多控制并发性的属性。最简单的是currentsconsumers，它创建并发处理消息的（固定）数量的消费者。</p><p>在1.3.0版之前，这是唯一可用的设置，必须停止容器并再次启动容器才能更改设置。</p><p>从1.3.0版开始，您现在可以动态调整parallelConsumers属性。如果在容器运行时更​​改了容器，则会根据需要添加或删除消费者，以适应新设置。</p><p>另外，添加了一个名为maxConcurrentConsumers的新属性，并且该容器根据工作负载动态调整了并发性。这与四个附加属性一起工作：ContinuousActiveTrigger，startConsumerMinInterval，continuousIdleTrigger和stopConsumerMinInterval。</p><hr><p>使用默认设置，增加使用方的算法如下：</p><p>如果尚未达到maxConcurrentConsumers且现有消费者处于连续十个周期的活动状态，并且自启动最后一个消费者以来至少经过了10秒钟，则将启动一个新消费者。如果消费者以batchSize * receiveTimeout毫秒接收至少一条消息，则认为该消费者是活动的。</p><hr><hr><p>在默认设置下，减少使用方的算法如下：</p><p>如果运行的并发消费者数量超过了，并且消费者检测到十个连续超时（空闲），并且最后一个消费者至少在60秒前停止，则该消费者将停止。超时取决于receiveTimeout和batchSize属性。如果消费者未接收到batchSize * receiveTimeout毫秒中的消息，则被视为空闲。因此，在默认超时（一秒）和batchSize为4的情况下，在40秒的空闲时间后考虑停止消费者（四个超时对应于一个空闲检测）。</p><hr><p>实际上，只有在整个容器闲置一段时间后才可以停止使用。这是因为broker在所有活跃的消费者中共享其工作。<br>每个消费者都使用一个通道，而不管配置的队列数量如何。</p><p>从2.0版开始，可以使用并发属性（例如2-4）设置parallelConsumers和maxConcurrentConsumers属性。</p><h4 id="3-3-15-2-使用-DirectMessageListenerContainer"><a href="#3-3-15-2-使用-DirectMessageListenerContainer" class="headerlink" title="3.3.15.2 使用 DirectMessageListenerContainer"></a>3.3.15.2 使用 DirectMessageListenerContainer</h4><p>使用此容器，并发性基于配置的队列和consumersPerQueue。每个队列的每个消费者都使用一个单独的通道，并发性由Rabbit客户端库控制。默认情况下，在编写本文时，它使用DEFAULT_NUM_THREADS = Runtime.getRuntime().availableProcessors()* 2个线程的池。</p><p>您可以配置taskExecutor以提供所需的最大并发性。</p><h3 id="3-3-16-排他消费者"><a href="#3-3-16-排他消费者" class="headerlink" title="3.3.16 排他消费者"></a>3.3.16 排他消费者</h3><p>从版本1.3开始，您可以使用单个独占消费者配置侦听器容器。这样可以防止其他容器从队列中使用，直到当前使用方被取消为止。这样的容器的并发性必须为1。</p><h3 id="3-3-17-监听容器队列"><a href="#3-3-17-监听容器队列" class="headerlink" title="3.3.17 监听容器队列"></a>3.3.17 监听容器队列</h3><p>1.3版引入了许多改进，用于处理侦听器容器中的多个队列。</p><p>必须将容器配置为侦听至少一个队列。以前也是如此，但是现在可以在运行时添加和删除队列。处理完任何预提取的消息后，容器将回收（取消并重新创建）消费者。有关addQueues，addQueueNames，removeQueues和removeQueueNames方法，请参见Javadoc。删除队列时，必须至少保留一个队列。</p><p>现在，如果消费者的任何队列可用，便会启动。以前，如果没有任何队列，容器将停止。现在，只有在没有可用队列的情况下才是这种情况。如果不是所有队列都可用，则容器会尝试每60秒被动声明（并消耗）丢失的队列。</p><p>同样，如果消费者从代理收到取消通知（例如，如果删除队列），则该消费者尝试恢复，并且恢复的消费者继续处理来自任何其他已配置队列的消息。以前，取消一个队列会取消整个消费者，最终，由于缺少队列，容器将停止。</p><p>如果要永久删除队列，则应在删除队列之前或之后更新容器，以避免将来尝试从中使用该容器。</p><h3 id="3-3-18-弹性：从错误和broker失败中恢复"><a href="#3-3-18-弹性：从错误和broker失败中恢复" class="headerlink" title="3.3.18 弹性：从错误和broker失败中恢复"></a>3.3.18 弹性：从错误和broker失败中恢复</h3><p>Spring AMQP提供的一些关键（也是最流行的）高级功能与协议错误或代理失败时的恢复和自动重新连接有关。我们已经在本指南中看到了所有相关组件，但是应该有助于将它们放在一起，并分别指出功能和恢复方案。</p><p>主要重新连接功能由CachingConnectionFactory本身启用。使用RabbitAdmin自动声明功能通常也很有益。另外，如果您关心保证传递，则可能还需要使用RabbitMessage和SimpleMessageListenerContainer中的channelTransacted标志以及SimpleMessageListenerContainer中的AcknowledgeMode.AUTO（如果您自己进行确认，则使用手册）。</p><h4 id="3-3-18-1-自动声明交换，队列和绑定"><a href="#3-3-18-1-自动声明交换，队列和绑定" class="headerlink" title="3.3.18.1 自动声明交换，队列和绑定"></a>3.3.18.1 自动声明交换，队列和绑定</h4><p>RabbitAdmin组件可以在启动时声明交换，队列和绑定。它通过ConnectionListener懒惰地执行此操作。因此，如果broker在启动时不存在，则没有关系。第一次使用Connection（例如，通过发送消息）时，将触发侦听器并应用管理功能。在侦听器中执行自动声明的另一个好处是，如果由于任何原因（例如，代理死亡，网络故障等）而断开连接，则在重新建立连接时会再次应用它们。</p><p>以这种方式声明的队列必须具有固定的名称-由AnonymousQueue实例的框架明确声明或生成。匿名队列是非持久的，排他的和自动删除的。<br>仅当CachingConnectionFactory缓存模式为CHANNEL（默认）时，才执行自动声明。存在此限制是因为排他队列和自动删除队列绑定到该连接。<br>从版本2.2.2开始，RabbitAdmin将检测类型为DeclarationCustomizer的bean，并在实际处理声明之前应用该函数。例如，这对于在框架内具有一流支持之前设置新参数（属性）很有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DeclarableCustomizer customizer() &#123;</span><br><span class="line">    return dec -&gt; &#123;</span><br><span class="line">        if (dec instanceof Queue &amp;&amp; ((Queue) dec).getName().equals(&quot;my.queue&quot;)) &#123;</span><br><span class="line">            dec.addArgument(&quot;some.new.queue.argument&quot;, true);</span><br><span class="line">        &#125;</span><br><span class="line">        return dec;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在不直接访问Declarable bean定义的项目中，它也很有用。</p><h4 id="3-3-18-2-同步操作失败和重试选项"><a href="#3-3-18-2-同步操作失败和重试选项" class="headerlink" title="3.3.18.2 同步操作失败和重试选项"></a>3.3.18.2 同步操作失败和重试选项</h4><p>如果您在使用RabbitTemplate时（例如）在同步序列中失去了与代理的连接，则Spring AMQP会引发AmqpException（通常但并非总是AmqpIOException）。我们不会试图掩盖存在问题的事实，因此您必须能够捕获并响应异常。如果您怀疑连接丢失（不是您的错），最简单的方法是再次尝试该操作。您可以手动执行此操作，也可以查看使用Spring Retry处理（命令式或声明式）重试。</p><p>Spring Retry提供了几个AOP拦截器，并提供了很大的灵活性来指定重试的参数（尝试次数，异常类型，退避算法等）。 Spring AMQP还为AMQP用例提供了一些方便的工厂bean，以方便的形式创建Spring Retry拦截器，并提供了可用于实现自定义恢复逻辑的强类型回调接口。有关更多详细信息，请参见Javadoc和StatefulRetryOperationsInterceptor和StatelessRetryOperationsInterceptor的属性。如果没有事务或在重试回调中启动了事务，则无状态重试是合适的。请注意，无状态重试比有状态重试更易于配置和分析，但是如果存在正在进行的事务必须回滚或肯定要回滚，则通常不适合使用。在事务中间断开连接应具有与回滚相同的效果。因此，对于在事务从堆栈开始的更高位置进行重新连接而言，有状态重试通常是最佳选择。有状态重试需要一种机制来唯一标识消息。最简单的方法是让发件人在MessageId消息属性中放置一个唯一值。提供的消息转换器提供了执行此操作的选项：您可以将createMessageIds设置为true。否则，您可以将MessageKeyGenerator实现注入到拦截器中。密钥生成器必须为每个消息返回唯一的密钥。在2.0版之前的版本中，提供了MissingMessageIdAdvice。它使没有messageId属性的消息仅被重试一次（忽略重试设置）。不再提供此建议，因为与spring-retry 1.2版一起，其功能已内置在拦截器和消息侦听器容器中。</p><p>为了向后兼容，默认情况下（在重试一次之后），具有空消息ID的消息被认为对消费者是致命的（消费者已停止）。若要复制MissingMessageIdAdvice提供的功能，可以在侦听器容器上将statefulRetryFatalWithNullMessageId属性设置为false。使用该设置，消费者继续运行，并且邮件被拒绝（在重试一次之后）。它被丢弃或路由到死信队列（如果已配置）。<br>从1.3版开始，提供了一个构建器API，以帮助使用Java（在@Configuration类中）组装这些拦截器。以下示例显示了如何执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public StatefulRetryOperationsInterceptor interceptor() &#123;</span><br><span class="line">return RetryInterceptorBuilder.stateful()</span><br><span class="line">.maxAttempts(5)</span><br><span class="line">.backOffOptions(1000, 2.0, 10000) // initialInterval, multiplier, maxInterval</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能以这种方式配置重试功能的子集。更多高级功能将需要将RetryTemplate配置为Spring bean。有关可用策略及其配置的完整信息，请参见Spring Retry Javadoc。</p><h4 id="3-3-18-3-使用批处理侦听器重试"><a href="#3-3-18-3-使用批处理侦听器重试" class="headerlink" title="3.3.18.3 使用批处理侦听器重试"></a>3.3.18.3 使用批处理侦听器重试</h4><p>不建议使用批处理侦听器配置重试，除非该批处理由生产者在单个记录中创建。有关消费者和生产者创建的批次的信息，请参阅批次消息。对于用户创建的批处理，框架不知道该批处理中的哪个消息导致了故障，因此无法在重试用完后进行恢复。对于生产者创建的批次，由于只有一条消息实际上是失败的，因此可以恢复整个消息。应用程序可能希望通过设置抛出的异常的index属性来通知自定义恢复程序在批次中发生故障的位置。</p><p>批处理侦听器的重试恢复器必须实现MessageBatchRecoverer。</p><h4 id="3-3-18-4-消息侦听器和异步情况"><a href="#3-3-18-4-消息侦听器和异步情况" class="headerlink" title="3.3.18.4 消息侦听器和异步情况"></a>3.3.18.4 消息侦听器和异步情况</h4><p>如果MessageListener因业务异常而失败，则由消息侦听器容器处理该异常，然后该容器将返回侦听另一条消息。如果故障是由断开的连接（不是业务异常）引起的，则必须取消并重新启动为侦听器收集消息的消费者。 SimpleMessageListenerContainer无缝处理此问题，并留下一条日志说正在重新启动侦听器。实际上，它无限循环，试图重新启动消费者。只有当消费者表现得很糟糕时，它才会放弃。副作用是，如果在容器启动时代理关闭，则它将继续尝试直到可以建立连接为止。</p><p>与协议错误和连接断开相反，业务异常处理可能需要更多考虑和一些自定义配置，尤其是在使用事务或容器确认的情况下。在2.8.x之前，RabbitMQ没有死信行为的定义。因此，默认情况下，由于业务异常而被拒绝或回滚的消息可以无限地重新发送。为了限制客户端的重传次数，一种选择是侦听器建议链中的StatefulRetryOperationsInterceptor。拦截器可以具有实现自定义死信操作的恢复回调-适用于您的特定环境的任何回调。</p><p>另一种选择是将容器的defaultRequeueRejected属性设置为false。这将导致所有失败的消息被丢弃。当使用RabbitMQ 2.8.x或更高版本时，这也有助于将消息传递给死信交换。</p><p>或者，可以引发AmqpRejectAndDontRequeueException。这样做可以防止消息重新排队，而不管defaultRequeueRejected属性的设置如何。</p><p>从2.1版开始，引入了InstantRequeueAmqpException以执行完全相反的逻辑：无​​论defaultRequeueRejected属性如何设置，都会重新排队消息。</p><p>通常，将两种技术结合使用。您可以将通知链中的StatefulRetryOperationsInterceptor与抛出AmqpRejectAndDontRequeueException的MessageRecoverer一起使用。当所有重试用尽后，将调用MessageRecover。 RejectAndDontRequeueRecoverer正是这样做的。默认的MessageRecoverer使用错误的消息并发出WARN消息。</p><p>从1.3版开始，提供了新的RepublishMessageRecoverer，以允许在重试用尽后发布失败的消息。</p><p>当恢复者使用了最后的例外时，该消息将被确认，并且不会发送到死信交换处（如果有的话）。</p><p>在消费者方使用RepublishMessageRecoverer时，接收到的消息在receiveDeliveryMode消息属性中具有deliveryMode。在这种情况下，deliveryMode为null。这意味着代理上的NON_PERSISTENT交付模式。从2.0版开始，您可以为deliveryMode配置RepublishMessageRecoverer，以将其设置为要重新发布的消息（如果为null）。默认情况下，它使用MessageProperties的默认值-MessageDeliveryMode.PERSISTENT。<br>以下示例显示如何将RepublishMessageRecoverer设置为恢复器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">RetryOperationsInterceptor interceptor() &#123;</span><br><span class="line">return RetryInterceptorBuilder.stateless()</span><br><span class="line">.maxAttempts(5)</span><br><span class="line">.recoverer(new RepublishMessageRecoverer(amqpTemplate(), &quot;something&quot;, &quot;somethingelse&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RepublishMessageRecoverer在消息头中发布消息以及其他信息，例如异常消息，堆栈跟踪，原始交换和路由键。可以通过创建子类并覆盖AdditionalHeaders（）来添加其他标头。也可以在additionalHeaders（）中更改deliveryMode（或任何其他属性），如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RepublishMessageRecoverer recoverer = new RepublishMessageRecoverer(amqpTemplate, &quot;error&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    protected Map&lt;? extends String, ? extends Object&gt; additionalHeaders(Message message, Throwable cause) &#123;</span><br><span class="line">        message.getMessageProperties()</span><br><span class="line">            .setDeliveryMode(message.getMessageProperties().getReceivedDeliveryMode());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从2.0.5版开始，如果堆栈跟踪太大，则可能会被截断；这是因为所有标头都必须放在一个框架中。默认情况下，如果堆栈跟踪将导致少于20,000字节（“余量”）可用于其他标头，则它将被截断。如果您需要更多或更少的空间放置其他标头，则可以通过设置恢复程序的frameMaxHeadroom属性进行调整。从版本2.1.13、2.2.3开始，此计算中包括异常消息，并且使用以下算法将最大化堆栈跟踪量：</p><p>如果仅堆栈跟踪将超出限制，则异常消息标头将被截断为97个字节加……且堆栈跟踪也将被截断。</p><p>如果堆栈跟踪很小，则消息将被截断（加……）以适合可用字节（但是堆栈跟踪本身内的消息将被截断为97字节加…）。</p><p>每当发生任何截断时，都会记录原始异常以保留完整的信息。</p><p>从2.1版开始，添加了InstantRequeueMessageRecoverer以引发InstantRequeueAmqpException，该异常通知侦听器容器重新排队当前失败的消息。</p><h4 id="3-3-18-5-Spring重试的异常分类"><a href="#3-3-18-5-Spring重试的异常分类" class="headerlink" title="3.3.18.5 Spring重试的异常分类"></a>3.3.18.5 Spring重试的异常分类</h4><p>Spring Retry在确定哪些异常可以调用重试方面具有很大的灵活性。默认配置将重试所有异常。鉴于用户异常被包装在ListenerExecutionFailedException中，我们需要确保分类检查异常原因。默认分类器仅查看顶级异常。</p><p>从Spring Retry 1.0.3开始，BinaryExceptionClassifier具有一个名为traverseCauses的属性（默认值：false）。为true时，它将遍历异常原因，直到找到匹配项或没有原因为止。</p><p>要使用此分类器进行重试，可以使用通过构造函数创建的SimpleRetryPolicy，该构造函数采用最大尝试次数，异常映射实例和布尔值（traverseCauses），然后将此策略注入RetryTemplate。</p><h3 id="3-3-19-Debugging"><a href="#3-3-19-Debugging" class="headerlink" title="3.3.19 Debugging"></a>3.3.19 Debugging</h3><p>Spring AMQP提供了广泛的日志记录，尤其是在DEBUG级别。</p><p>如果要监视应用程序和代理之间的AMQP协议，可以使用诸如WireShark之​​类的工具，该工具具有用于解码协议的插件。另外，RabbitMQ Java客户端带有一个非常有用的类，称为Tracer。默认情况下，作为主服务器运行时，它将侦听端口5673并连接到本地主机上的端口5672。您可以运行它并更改连接工厂配置以连接到本地主机上的端口5673。它在控制台上显示解码的协议。有关更多信息，请参考Tracer Javadoc。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>从2.2版开始，回调是在连接工厂的执行程序线程之一上调用的，在之前的版本中回调直接在amqp-client连接I / O线程上调用；如果执行某些RPC操作（例如打开新通道），则会死锁，因为I / O线程阻塞了等待结果，但是结果需要由I / O线程本身处理。对于那些版本，有必要将工作（例如发送消息）移交给回调中的另一个线程。由于框架现在将回调调用移交给了执行程序，因此不再需要此操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> Spring AMQP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 8 Stream</title>
      <link href="/java/2019-12-25-java8-stream/"/>
      <url>/java/2019-12-25-java8-stream/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Java8-Stream"><a href="#什么是Java8-Stream" class="headerlink" title="什么是Java8 Stream"></a>什么是Java8 Stream</h2><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚集操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。</p><p>A pipeline is a sequence of aggregate operations. The following example prints the male members contained in the collection roster with a pipeline that consists of the aggregate operations filter and forEach:</p><p>管道是一个聚集操作的序列。下面的例子使用包含聚集操作filter和forEach的管道打印包含在roster集合中男性成员的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(e -&gt; e.getGender() == Person.Sex.MALE)</span><br><span class="line">    .forEach(e -&gt; System.out.println(e.getName()));</span><br></pre></td></tr></table></figure><p>管道包含如下的组件：</p><ul><li>一个源：可以是一个集合、数组、一个生成方法，或者I/O channel。</li><li>零个或者多个中间操作。一个中间操作，例如filter，生成一个流。</li><li>一个终止操作，一个终止操作例如forEach，产生一个非流结果。例如原始值（如double值），集合，或者在forEach的情况下根本没有任何值。 </li></ul><blockquote><p>流是一个元素的序列。不像一个集合，它不是一个数据结构存储元素。相反，一个流通过管道从一个源中提取值。filter操作返回一个包含匹配它断言的要素集的新流。</p></blockquote><h2 id="聚集操作相比于Iterator的不同"><a href="#聚集操作相比于Iterator的不同" class="headerlink" title="聚集操作相比于Iterator的不同"></a>聚集操作相比于Iterator的不同</h2><ul><li>使用内部遍历： 聚集操作不包含类似于指示处理集合内的下一个元素的next方法。使用内部委派，你的应用程序确定要迭代的集合，而JDK确定如何迭代该集合。使用外部迭代，你的应用决定它迭代什么集合和它怎样迭代。但是，外部迭代仅仅可以有序的迭代集合的元素。内部迭代没有这个限制，它可以更好的发挥并行计算的优势，它可以将问题分发为子问题，同时解决这些问题，然后将解决子问题方案的结果组合。</li><li>从流中处理元素：聚集操作从流中处理元素，不是直接从集合中。因此，它们也称作流操作。</li><li>他们支持行为作为参数：对于大多数聚集操作你可以指定lambda表达式作为参数，这允许你自定义一个特定的聚集操作的行为动作。</li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><code>boolean    allMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether all elements of this stream match the provided predicate.</li><li><code>boolean    anyMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether any elements of this stream match the provided predicate.</li><li><code>static &lt;T&gt; Stream.Builder&lt;T&gt; builder()</code><br>Returns a builder for a Stream.</li><li><code>&lt;R,A&gt; R    collect(Collector&lt;? super T,A,R&gt; collector)</code><br>Performs a mutable reduction operation on the elements of this stream using a Collector.</li><li><code>&lt;R&gt; R    collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code><br>Performs a mutable reduction operation on the elements of this stream.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code><br>Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.</li><li><code>long    count()</code><br>Returns the count of elements in this stream.</li><li><code>Stream&lt;T&gt;    distinct()</code><br>Returns a stream consisting of the distinct elements (according to Object.equals(Object)) of this stream.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    empty()</code><br>Returns an empty sequential Stream.</li><li><code>Stream&lt;T&gt;    filter(Predicate&lt;? super T&gt; predicate)</code><br>Returns a stream consisting of the elements of this stream that match the given predicate.</li><li><code>Optional&lt;T&gt;    findAny()</code><br>Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.</li><li><code>Optional&lt;T&gt;    findFirst()</code><br>Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty.</li><li><code>&lt;R&gt; Stream&lt;R&gt;    flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code><br>Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>DoubleStream    flatMapToDouble(Function&lt;? super T,? extends DoubleStream&gt; mapper)</code><br>Returns an DoubleStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>IntStream    flatMapToInt(Function&lt;? super T,? extends IntStream&gt; mapper)</code><br>Returns an IntStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>LongStream    flatMapToLong(Function&lt;? super T,? extends LongStream&gt; mapper)</code><br>Returns an LongStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li><code>void    forEach(Consumer&lt;? super T&gt; action)</code><br>Performs an action for each element of this stream.</li><li><code>void    forEachOrdered(Consumer&lt;? super T&gt; action)</code><br>Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    generate(Supplier&lt;T&gt; s)</code><br>Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    iterate(T seed, UnaryOperator&lt;T&gt; f)</code><br>Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.</li><li><code>Stream&lt;T&gt;    limit(long maxSize)</code><br>Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.</li><li><code>&lt;R&gt; Stream&lt;R&gt;    map(Function&lt;? super T,? extends R&gt; mapper)</code><br>Returns a stream consisting of the results of applying the given function to the elements of this stream.</li><li><code>DoubleStream    mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code><br>Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>IntStream    mapToInt(ToIntFunction&lt;? super T&gt; mapper)</code><br>Returns an IntStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>LongStream    mapToLong(ToLongFunction&lt;? super T&gt; mapper)</code><br>Returns a LongStream consisting of the results of applying the given function to the elements of this stream.</li><li><code>Optional&lt;T&gt;    max(Comparator&lt;? super T&gt; comparator)</code><br>Returns the maximum element of this stream according to the provided Comparator.</li><li><code>Optional&lt;T&gt;    min(Comparator&lt;? super T&gt; comparator)</code><br>Returns the minimum element of this stream according to the provided Comparator.</li><li><code>boolean    noneMatch(Predicate&lt;? super T&gt; predicate)</code><br>Returns whether no elements of this stream match the provided predicate.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    of(T... values)</code><br>Returns a sequential ordered stream whose elements are the specified values.</li><li><code>static &lt;T&gt; Stream&lt;T&gt;    of(T t)</code><br>Returns a sequential Stream containing a single element.</li><li><code>Stream&lt;T&gt;    peek(Consumer&lt;? super T&gt; action)</code><br>Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.</li><li><code>Optional&lt;T&gt;    reduce(BinaryOperator&lt;T&gt; accumulator)</code><br>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.</li><li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code><br>Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.</li><li><code>&lt;U&gt; U    reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</code><br>Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions.</li><li><code>Stream&lt;T&gt;    skip(long n)</code><br>Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream.</li><li><code>Stream&lt;T&gt;    sorted()</code><br>Returns a stream consisting of the elements of this stream, sorted according to natural order.</li><li><code>Stream&lt;T&gt;    sorted(Comparator&lt;? super T&gt; comparator)</code><br>Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.</li><li><code>Object[]    toArray()</code><br>Returns an array containing the elements of this stream.</li><li><code>&lt;A&gt; A[]    toArray(IntFunction&lt;A[]&gt; generator)</code><br>Returns an array containing the elements of this stream, using the provided generator function to allocate the returned array, as well as any additional arrays that might be required for a partitioned execution or for resizing.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">Java 8 中的 Streams API 详解-陈争云, 占宇剑, 和司磊</a></p><p><a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html#pipelines" target="_blank" rel="noopener">Pipelines and Streams</a></p><p><a href="https://docs.oracle.com/javase/10/index.html" target="_blank" rel="noopener">Java™ Platform Standard Ed. 8</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库系统概念</title>
      <link href="/mysql/2019-12-05-database/"/>
      <url>/mysql/2019-12-05-database/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1. 什么是数据库？"></a>1. 什么是数据库？</h3><p>数据库管理系统（DataBase-Management System， DBMS）由一个互相关联的数据的集合和一组用以访问这些数据的程序组成。这个数据集通常称为数据库。</p><p>数据库结构的基础是数据模型（data model）。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。</p><p>数据模型可被划分为四类：</p><ul><li>关系模型（relational）：关系模型用表的集合来表示数据和数据间的联系。</li><li>实体-联系模型（entity-relationship model）：实体-联系（E-R）数据模型给予对现实世界的这样一种认识：现实世界由一组称作实体的基本对象以及这些对象间的联系构成。</li><li>基于对象的数据模型（object-based data model）：面向对象的数据模型可以看成是E-R模型增加封装、方法和对象标识等概念后的扩展。</li><li>半结构化数据模型（semistructured data model）：半结构化数据结构模型允许那些相同类型的数据项含有不同的属性集的数据定义。可扩展标记语言（eXtensible Markup Language， XML）被广泛的用来表示半结构化数据。</li></ul><h3 id="2-数据库语言"><a href="#2-数据库语言" class="headerlink" title="2. 数据库语言"></a>2. 数据库语言</h3><p>数据库操纵语言（Data-manipulationn Language）来表达数据的查询和更新。数据库定义语言（data-definition language）来定义数据库模型。</p><h3 id="3-关系数据库"><a href="#3-关系数据库" class="headerlink" title="3. 关系数据库"></a>3. 关系数据库</h3><p>关系数据库基于关系模型，使用一系列来表达数据以及这些数据之间的联系。</p><h4 id="3-1-关系数据库的结构"><a href="#3-1-关系数据库的结构" class="headerlink" title="3.1 关系数据库的结构"></a>3.1 关系数据库的结构</h4><p>关系数据库由表的集合构成，每个表有唯一的名字。</p><p>一般来说，表中一行代表了一组值之间的一种联系。由于一个表就是这种联系的一个集合，表这个概念和数学上的关系这个概念是密切相关的，这也正是关系数据模型名称的由来。</p><h3 id="4-数据库存储和查询"><a href="#4-数据库存储和查询" class="headerlink" title="4. 数据库存储和查询"></a>4. 数据库存储和查询</h3><p>存储管理器是数据库系统中负责在数据库中存储的低层数据与应用程序以及向系统提交的查询之间提供接口的部件。存储管理器负责与文件管理器交互。原始数据通过操作系统提供的文件系统存储在磁盘上。存储管理器将各种DML语句翻译为底层文件系统命令。</p><p>存储管理部件：</p><ul><li>权限及完整性管理器（authorization and integrity manager）,它检测是否满足完整性约束，并检查试图访问数据的用户的权限。</li><li>事务管理器（transaction manager），它保证即使发生了故障，数据库也保持在一致的状态，并保证并发事务的执行不发生冲突。</li><li>文件管理器（file manager），它管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构。</li><li>缓冲区管理器（buffer manager），它负责将数据从磁盘取到内存中来，并决定你哪些数据应被缓冲存储在内存中。缓冲区管理器 是数据库系统中的一个关键部分，因为它使用数据库可以处理比内存更大的数据。</li></ul><p>存储管理器实现了集中数据结构：</p><ul><li>数据文件（data files），存储数据库自身。</li><li>数据字典（data dictionary），存储关于数据库结构的元数据，尤其是数据库模式。</li><li>索引（index），提供对数据项的快速访问。</li></ul><p>查询处理器：</p><ul><li>DDL解释器（DDL interpreter），它解释DDL语句并将这些定义记录在数据字典中。</li><li>DML编译器（DML compiler），将查询语言中的 DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。</li></ul><p>一个查询通常可被翻译为多种等价的具有相同结果的执行方案的一种。DML编译器还进行查询优化（query optimization），也就是从几种选择中选出代价最小的一种。</p><ul><li>查询执行引擎（query evaluation engine），执行由DML编译器产生的低级指令。</li></ul><h3 id="5-事务管理"><a href="#5-事务管理" class="headerlink" title="5. 事务管理"></a>5. 事务管理</h3><p>事务（transaction）是数据库应用中完成单一逻辑功能的操作集合。每一个事务是一个既具有原子性又具有一致性的单元。</p><p>事务管理器（transaction manager）包括并发控制管理器和恢复管理器。</p><p>并发管理器（concurrency-control manager）控制并发事务间的相互影响，保证数据库一致性。</p><p>恢复管理器（recovery manager）负责保证原子性和持久性。</p><h3 id="6-数据库体系结构"><a href="#6-数据库体系结构" class="headerlink" title="6. 数据库体系结构"></a>6. 数据库体系结构</h3><p>数据库应用通常可分为两或三个部分。</p><p><img src="/media/article/database-structure.png" alt="database-structure"></p><h3 id="7-数据挖掘和信息检索"><a href="#7-数据挖掘和信息检索" class="headerlink" title="7. 数据挖掘和信息检索"></a>7. 数据挖掘和信息检索</h3><p>数据挖掘（data mining）这个术语指半自动地分析大型数据库并从中找出有用的模式的过程。</p><h2 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h2><h3 id="1-SQL查询语言预览"><a href="#1-SQL查询语言预览" class="headerlink" title="1. SQL查询语言预览"></a>1. SQL查询语言预览</h3><ul><li>数据定义语言 （Data-Definition Language， DDL）：SQL DDL提供定义关系模式、删除关系以及修改关系模式的命令。</li><li>数据操作语言（Data-Manipulation Language， DML）：SQL DML提供从数据库中查询信息，以及 在数据库中插入元组、删除元组、修改元组的能力。</li><li>完整性（integrity）：SQL DDL包括定义完整性约束的命令，保存在数据库中的数据必须满足所定义的完整性约束。破坏完整性约束的更新是不允许的。</li><li>视图定义 （view definition）：SQL DDL包括定义视图的命令。</li><li>事务控制（transaction control）：SQL 包括定义事务的开始和结束的命令。</li><li>嵌入式SQL和动态SQL（embedded SQL and dynamic SQL）：嵌入式和动态SQL定义SQL语句如何嵌入到通用编程语言，如C、C++和Java中。</li><li>授权（authorization）：SQL DDL包括定义对关系和视图的访问权限的命令。</li></ul><h4 id="1-1-SQL数据定义"><a href="#1-1-SQL数据定义" class="headerlink" title="1.1 SQL数据定义"></a>1.1 SQL数据定义</h4><p>基本类型：</p><ul><li>char(n)：固定长度的字符串，用户指定长度n。也可以使用全称character。</li><li>varchar(n)：可变长度的字符串，用户指定最大长度n，等价于全称character varying。</li><li>int：整数类型，等价于integer。</li><li>smallint：小整数类型。</li><li>numeric(p,d)：定点数，精度由用户指定。</li><li>real，double precision：浮点数与双精度浮点数，精度与机器相关。</li><li>float(n)：精度至少为n位的浮点数。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>两种基本的索引类型：</p><ul><li>顺序索引。基于值的顺序排序。</li><li>散列索引。介于将值平均分不到若干散列桶中。一个值所属的散列桶是由一个函数决定的，该函数称为散列函数。</li></ul><p>对于索引的考虑因素：</p><ul><li>访问类型（access type）：能有效支持的访问类型。访问类型可以包括找到具有特定属性值的记录，以及找到属性值落在某个特定范围内的记录。</li><li>访问时间（access time）：在查询中使用该技术找到一个特定数据项货数据项集所需的时间。</li><li>插入时间（insertion time）：插入一个新数据项所需的时间。该值包括找到待删除项所需的时间，以及更新索引结构所需的时间。</li><li>空间开销（space overhead）：索引结构所占用的额外存储空间。</li></ul><h3 id="1-顺序索引"><a href="#1-顺序索引" class="headerlink" title="1. 顺序索引"></a>1. 顺序索引</h3><p>顺序索引按照顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。<br>被索引的文件中的记录自身也可以按照某种排序顺序存储，正如图书馆中的书按某些属性顺序存放一样。一个文件可以有多个索引，分别基于不同的搜索码。<br><strong><em>如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为聚集索引（clustering index）</em></strong>。聚集索引也称为 主索引（primary index）；搜索码指定的顺序与文件中记录的物理顺序不同的索引称为非聚集索引（nonclustering index）或辅助索引（secondary index）。</p><h4 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h4><p>索引项（index entry）或索引记录（index record）由一个搜索码值和指向具有该搜索码值的一条或者多条记录的指针构成。指向记录的指针包括磁盘块的标识和标识磁盘块内记录的块内偏移量。<br>可以使用的顺序索引有两类：</p><ul><li>稠密索引（dense index）：在稠密索引中，文件中的每个搜索码值都有一个索引项。在稠密索引中，索引项包括搜索码值以及指向具有该搜索码的第一条数据记录的指针。具有相同搜索码值的其余记录顺序的存储在第一条数据记录之后，由于该索引是聚集索引，因此记录根据相同的索引码值排序。在稠密非聚集索引中，索引必须存储指向所有具有相同搜索码值的记录的指针列表。</li><li>稀疏索引（sparse index）：在稀疏索引中，只为搜索码的某些值建立索引项。只有当关系按搜索码排列顺序存储时才能使用稀疏索引，换句话说，只有索引是聚集索引时才能使用稀疏索引。和稠密索引一样，每个索引项也包括一个搜索码和指向具有该搜索码值的第一条记录的指针。为了定位一条记录，我们找到其最大搜索码值小于或等于所查找记录的搜索码值的索引项。然后从该索引项指向的记录开始，沿着文件的指针查找，直到找到记录为止。</li></ul><p><img src="/media/article/dense-sparse-index.png" alt="dennse-sparse"></p><h4 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h4><p>具有两级或者两级以上的索引称为多集（multilevel）索引。多级索引搜索记录于用二分法搜索记录相比需要的I/O操作要少得多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis空间优化</title>
      <link href="/redis/2019-11-13-redis-space-optimization/"/>
      <url>/redis/2019-11-13-redis-space-optimization/</url>
      
        <content type="html"><![CDATA[<p>我们项目使用Redis越来越多，可是Redis毕竟是基于内存的数据库，所以对于Redis的空间使用如果不加注意，很容易导致内存溢出。</p><h3 id="1-Redis数据结构"><a href="#1-Redis数据结构" class="headerlink" title="1. Redis数据结构"></a>1. Redis数据结构</h3><p>Redis使用了五种数据对象：字符串对象，列表对象，哈希对象，集合对象，有序集合对象。</p><p>Redis基于这五种对象也给出了优化：</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串中有int、embstr和raw（Simple Dynamic String）两种存储字符串的结构。如果只读且大小小于32字节，则使用embstr，否则使用raw，embstr只能转化为raw，raw不能转化为embstr。关于两者的区别详细了解<a href="/redis/2019-06-21-redis/#1-8-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1">Redis设计与实现</a></p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的底层数据结构在3.2版本之前可以是链表（linkedlist），也可以是压缩列表（ziplist），对于链表保存不需要连续的内存空间（是优点也是缺点，容易造成内存碎片），相比于压缩列表多了保存pre、next指针的空间，ziplist保存在连续内存空间上，不需要维护pre、next指针。当保存的字符串长度小于64字节且列表对象个数小于512时使用压缩列表。</p><p>在3.2版本之后唯一的数据结构是快表（quicklist），它是一个双向链表，而且是一个ziplist的双向链表。这是什么意思呢？我们知道，双向链表是由多个节点（Node）组成的。这个描述的意思是：quicklist的每个节点都是一个ziplist。</p><p>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</p><p>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象底层数据结构可以是ziplist和字典hashtable。ziplist存储字符串不超过32字节和总个数不超过512的数据。</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象底层数据结构是intset或者hashtable。</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合对象底层数据结构是ziplist或者是skiplist。当存储的字符串长度大于64时转为skiplist。<br>skiplist存储时使用skiplist和hashtabl两种结构进行存储，如果我们只是用字典hashtable来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p><p>需要注意的是<strong><em>字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p>使用上述对象时，需要考虑底层数据结构特性，是否会因为频繁删除增加修改，造成Redis的内存碎片化，频繁修改的数据不建议放入到Redis。不仅如此，考虑到Redis空间的复用性，对于不常用的key设置过期时间。</p><h3 id="2-Redis存储优化"><a href="#2-Redis存储优化" class="headerlink" title="2. Redis存储优化"></a>2. Redis存储优化</h3><p>本章节摘自《<a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a>》</p><ol><li><p>利用Redis内存分配器做第一层优化。例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p></li><li><p>尽量使用整型/长整型。如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。</p></li><li><p>利用共享对象，共享对象包括10000个整数，可以通过REDIS_SHARED_INTEGERS参数提高共享对象的个数。</p></li><li><p>关注内存碎片率，如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。</p></li><li><p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p></li><li><p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a></p><p><a href="https://www.cnblogs.com/kismetv/p/8654978.html#t51" target="_blank" rel="noopener">深入学习Redis(1):Redis内存模型 –编程迷思</a></p><p><a href="/redis/2019-06-21-redis/#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8%E5%AD%98%E5%82%A8%E6%95%88%E7%8E%87">quicklist存储效率</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程池</title>
      <link href="/concurrency/2019-11-07-threadpool/"/>
      <url>/concurrency/2019-11-07-threadpool/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在生产环境中，应避免直接创建线程，线程数量必须得到控制。</p></blockquote><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>为了控制线程，JDK类库提供了一套Executor框架。</p><p><img src="/media/article/executor.png" alt="executor"></p><p>线程池是JDK用来管理线程的的静态工厂。上图中ThreadPoolExecutor表示一个线程池。<br>Executor是一个接口，接口中只有<code>void execute(Runnable command)</code>方法。<br>ExecutorService也是一个接口，继承ExecutorService，增加了许多使用线程池的公用方法定义。<br>AbstactExecutorService为ExecutorService接口提供了默认实现。<br>ThreadPoolExecutor继承AbstactExecutorService抽象类。<br>Executors类是JDK1.5版本时封装的线程池工厂和工具类，这个类提供了几种默认的<a href="/concurrency/2019-11-07-threadpool/#1-2-Executor%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90">线程池类型</a>和默认线程池工厂。<br>ForkJoinPool是Java7加入的一种用于并行执行任务的框架</p><h3 id="1-1-创建线程池"><a href="#1-1-创建线程池" class="headerlink" title="1.1 创建线程池"></a>1.1 创建线程池</h3><p>创建线程池的实现其实是实例化ThreadPoolExecutor的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>corePoolSize：指定线程池中的线程数量。<br>maximumPoolSize：线程池中的最大线程数量。<br>keepAliveTime：当线程池超过corePoolSize时，多余的空闲线程的空闲时间。<br>unit：keepAliveTime的时间单位。<br>workQueue：任务队列，被提交但未被执行的任务。<br>threadFactory工厂：创建线程的工厂，一般默认就可以。<br>handler：拒绝策略，当线程池满负荷运行，如何拒绝新的任务的策略。</p><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>keepAliveTime，unit，threadFactory几个参数可根据线程池的任务场景去做简单的变化，在此不再赘述，一般自定义线程池我们的关注点大都在corePoolSize，maximumPoolSize，workQueue，handler四个参数上。</p><p>corePoolSize，根据业务的通用场景确定即可。《Java并发编程实践》书中给出了一个估算线程池corePoolSize大小的经验公式：<br>Ncpu=cpu数量<br>Ucpu=希望cpu的使用率，0&lt;Ucpu&lt;1<br>W/C=等待时间与计算时间的比率， <a href="https://www.cnblogs.com/gatsby123/p/11127158.html" target="_blank" rel="noopener">CPU计算时间计算方式</a></p><p><code>Nthreads=Ncpu*Ucpu*(1+W/C)</code></p><p>如果你处理的是阻塞比较多的任务，你可以根据上述公式大致算出需要的线程数量（一般会远远超出当前实例所在服务器的cpu数量）；如果是阻塞比较少的任务即cpu计算比重较大的任务，线程的数量可能就会相应的减少一些，避免服务器的超负荷运行。总之线程数不是精确的一个数，只要符合你业务的场景的大概数量就可以。</p><p>workQueue任务队列分为有限、无限、同步移交三种阻塞队列，常用的有如下几个：</p><ul><li>ArrayBlockingQueue: 一个基于数组结构的有界阻塞队列，此队列按照FIFO原则排序。</li><li>LinkedBlockingQueue: 一个基于链表的阻塞队列，此队列按照FIFO原则排序，吞吐量高于ArrayBlockingQueue。</li><li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须阻塞到另一个线程的移除操作。</li><li>PriorityBlockingQueue: 具有优先级的无限阻塞队列。</li></ul><p>线程池的执行过程：</p><p><img alt="threadpool-processor" src="/media/article/threadpool-processor.png" width="75%"></p><p>–图摘自《Java并发编程艺术》9.1小节-线程池的实现原理。</p><p>队列的大小和maxmumPoolSize息息相关，如果使用无界队列，则maxmumPoolSize也就失效了，如果使用的是有界队列，则当有界队列满了，则新启动线程执行任务。直到最大线程也满了之后执行拒绝策略。</p><p>最后就是拒绝策略:</p><ul><li>AbortPolicy: 直接抛出异常。</li><li>CallerRunPolicy: 使用调用者的线程执行任务。</li><li>DiscardOldestPolicy: 丢弃队列里最老的任务，并执行当前任务。</li><li>DiscardPolicy: 不处理，丢弃。</li></ul><p>除此之外还可以实现RejectExecutionHandler接口，自定义拒绝策略。</p><h3 id="1-2-Executor提供的几种类型的线程池解析"><a href="#1-2-Executor提供的几种类型的线程池解析" class="headerlink" title="1.2 Executor提供的几种类型的线程池解析"></a>1.2 Executor提供的几种类型的线程池解析</h3><ol><li>Executors.newFixedThreadPool(1);</li></ol><p>Executors.newFixedThreadPool创建的线程池可以指定核心线程数，但是使用的是无界队列，如果是IO密集型任务，可能导致内存溢出。</p><ol start="2"><li>Executors.newSingleThreadExecutor();</li></ol><p>Executors.newSingleThreadExecutor()创建一个线程的线程池，同样使用无界队列，和newFixedThreadPool的差别仅限于核心线程数。</p><ol start="3"><li>Executors.newCachedThreadPool();</li></ol><p>Executors.newCachedThreadPool()创建的线程池是一个没有队列的存储任务的线程池，线程池最大数量为Integer.MAX_VALUE。所以这个线程池会一直创建新的线程执行任务，可能导致内存溢出。适用于中小数量级的任务，且任务非CPU密集型。</p><ol start="4"><li>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory());</li></ol><p>Executors.newScheduledThreadPool(1, Executors.defaultThreadFactory())创建可以定时或延时执行任务的线程池，与Timer相比，具有更多的弹性。<a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-add1.html" target="_blank" rel="noopener">详解Java定时任务—极客学院</a></p><ol start="5"><li>Executors.newWorkStealingPool();</li></ol><p>封装的ForkJoinPool线程池，线程数量为当前运行环境的cpu数量，不处理异常，异步模式。下一小节详细介绍。</p><h3 id="1-3-ForkJoinPool线程池初探"><a href="#1-3-ForkJoinPool线程池初探" class="headerlink" title="1.3 ForkJoinPool线程池初探"></a>1.3 ForkJoinPool线程池初探</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成小任务，最终汇总小任务结果后得到大任务结果的框架。</p><p><img src="/media/article/forkjoin.png" alt="forkjoin"></p><p>–图片摘自《Java并发编程的艺术》6.4.1 什么是Fork/Join框架 小节。</p><p>缺点：在某些情况下，该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。</p><h4 id="使用ForkJoinPool"><a href="#使用ForkJoinPool" class="headerlink" title="使用ForkJoinPool"></a>使用ForkJoinPool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private static final int THRESHOLD = 2;  // 阈值 private int start;</span><br><span class="line">private int end;</span><br><span class="line">public CountTask(int start, int end) &#123;</span><br><span class="line">    this.start = start; this.end = end;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected Integer compute() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    // 如果任务足够小就计算任务</span><br><span class="line">    boolean canCompute = (end - start) &lt;= THRESHOLD; </span><br><span class="line">    if (canCompute) &#123;</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">         sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">        int middle = (start + end) / 2;</span><br><span class="line">        CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end); // 执行子任务</span><br><span class="line">        leftTask.fork();</span><br><span class="line">        rightTask.fork();</span><br><span class="line">        // 等待子任务执行完，并得到其结果</span><br><span class="line">        int leftResult=leftTask.join();</span><br><span class="line">        int rightResult=rightTask.join();</span><br><span class="line">        // 合并子任务</span><br><span class="line">        sum = leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">    // 生成一个计算任务，负责计算1+2+3+4</span><br><span class="line">    CountTask task = new CountTask(1, 4);</span><br><span class="line">    // 执行一个任务</span><br><span class="line">    Future&lt;Integer&gt; result = forkJoinPool.submit(task); </span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–示例摘自《Java并发编程的艺术》6.4.4 使用Fork/Join框架 小节。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>ForkJoinTask提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被 取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(task.isCompletedAbnormally()) &#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>ForkJoinPool继承AbstractExecutorService。</p><p>ForkJoinPool参数：</p><ul><li>parallelism线程数量；</li><li>ForkJoinWorkerThreadFactory是ForkJoin线程工厂，创建ForkJoinWorkerThread的线程类实例；</li><li>mode是使用FIFO模式（true）还是LIFO模式（false）；</li><li>UncaughtExceptionHandler是异常处理；</li><li>workerNamePrefix工作线程的名称前缀；</li></ul><p>通常来说，我们使用ForkJoinPool时如果不指定线程数量时默认取2047和当前服务器cpu数量中的最小值。简单来说就是创建了一个fork/join线程的线程池。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">Effective Java 第二版 中文版 </a><br><a href="">实战Java高并发程序设计 葛一鸣，郭超编著</a><br><a href="">Java并发编程艺术 方腾飞，魏鹏，程晓明 著</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CGLIB浅析</title>
      <link href="/java/2019-10-04-cglib/"/>
      <url>/java/2019-10-04-cglib/</url>
      
        <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><p>本文打算从这几个方面来理解CGLIB怎样生成动态代理类的：</p><ol><li><a href="#1-使用Cglib动态代理">怎样使用CGLIB？</a></li><li><a href="#2-CGLIB原理解析">CGLIB怎样生成/缓存动态代理类实例的？</a></li><li><a href="#3-CGLIB代理类调用方法原理解析">CGLIB生成的动态代理类怎样调用的，过程是怎样的，这样有什么好处？</a></li><li>常见问题<a href="#FAQ">FAQ</a></li></ol><h2 id="1-使用Cglib动态代理"><a href="#1-使用Cglib动态代理" class="headerlink" title="1. 使用Cglib动态代理"></a>1. 使用Cglib动态代理</h2><p>CGLIB的使用和JDK Proxy类似，不同的是CGLIB既可以指定接口，也可以直接代理未实现接口的普通类。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">LogInterceptor logInterceptor = new LogInterceptor();</span><br><span class="line">// 设置超类，cglib是通过继承来实现的</span><br><span class="line">enhancer.setSuperclass(UserDao.class);</span><br><span class="line">enhancer.setCallback(logInterceptor);</span><br><span class="line">/**</span><br><span class="line"> * 如果是实现指定接口，可以使用setInterfaces方法设置接口</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// enhancer.setInterfaces(new Class[]&#123;Dao.class&#125;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果使用createClass方法返回值为代理类的Class对象，需要设置CallbackType参数；当使用create方法时，CallbackType和callback都不为空时，两者类型必须相等。</span><br><span class="line"> * create方法返回的是代理类实例</span><br><span class="line"> * enhancer.setCallbackType(LogInterceptor.class);</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 创建代理类</span><br><span class="line">Dao dao = (Dao)enhancer.create();</span><br><span class="line">dao.select();</span><br></pre></td></tr></table></figure></p><p>// 方法拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">//        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">//        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>// 实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao implements Dao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;UserDao 更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-CGLIB生成动态代理类的原理解析"><a href="#2-CGLIB生成动态代理类的原理解析" class="headerlink" title="2. CGLIB生成动态代理类的原理解析"></a>2. CGLIB生成动态代理类的原理解析</h2><p>CGLIB，JDK proxy生成过程上大同小异，都是使用弱引用缓存已生成的Class对象，如果缓存中没有，则使用字节码技术生成动态代理类字节码和Class对象，只不过使用的字节码技术不太一样罢了。<br>下图是CGLIB动态代理生成代理类Class对象的流程：<a href="/media/article/cglib-processor.png">点击看大图</a></p><p><img src="/media/article/cglib-processor.png"></p><p>CGLIB动态代理基于ASM技术，使用<a href="/java/2019-10-06-asm/">ASM</a>技术的部分就是图中标红的模块。</p><p>CGLIB动态代理如果没有特殊设置也会缓存已生成的动态代理类的Class对象。</p><p><img src="/media/article/cglib-cache.png" alt="cglib-cache"></p><p>上图是CGLIB缓存动态代理类的Class对象的结构。</p><p>CGLIB第一次生成动态代理类Class对象的方法调用流程：</p><p><img src="/media/article/cglib-method.png" alt="cglib-method"></p><h2 id="3-CGLIB代理类调用方法原理解析"><a href="#3-CGLIB代理类调用方法原理解析" class="headerlink" title="3. CGLIB代理类调用方法原理解析"></a>3. CGLIB代理类调用方法原理解析</h2><blockquote><p>使用<code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;./&quot;)</code>可以输出生成的代理类的class文件。这里由于篇幅问题，只展示文章需要的内容，想看完整的代理类的字节码文件可以自己输出查看。</p></blockquote><p>CGLIB针对一个目标类一般会生成3个动态代理类，1个<code>UserDao$$EnhancerByCGLIB$$c00e2e9b extends UserDao implements Factory</code>，还有2个和调用有关的FastClass代理类<code>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc extends FastClass</code>，<code>UserDao$$FastClassByCGLIB$$890e5f18 extends FastClass</code></p><p>UserDao$$EnhancerByCGLIB$$c00e2e9b类的静态初始化块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 当前线程的缓存</span><br><span class="line">CGLIB$THREAD_CALLBACKS = new ThreadLocal();</span><br><span class="line">// 空参数对象</span><br><span class="line">CGLIB$emptyArgs = new Object[0];</span><br><span class="line">// 动态代理类的Class对象</span><br><span class="line">Class var0 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao$$EnhancerByCGLIB$$c00e2e9b&quot;);</span><br><span class="line">Class var1;</span><br><span class="line">// 只获取update和select的方法对象</span><br><span class="line">Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;update&quot;, &quot;()V&quot;, &quot;select&quot;, &quot;()V&quot;&#125;, (var1 = Class.forName(&quot;com.zhongyp.advanced.proxy.cglib.UserDao&quot;)).getDeclaredMethods());</span><br><span class="line">CGLIB$update$0$Method = var10000[0];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$update$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;update&quot;, &quot;CGLIB$update$0&quot;);</span><br><span class="line">CGLIB$select$1$Method = var10000[1];</span><br><span class="line">// 记住这里，后续我们会细聊这一块MethodProxy.create</span><br><span class="line">CGLIB$select$1$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;select&quot;, &quot;CGLIB$select$1&quot;);</span><br></pre></td></tr></table></figure><p>当动态代理类调用update()方法（update是DAO接口内的方法）时，首先调用下面这个动态生成的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * cglib使用Class对象创建对象实例(Enhancer.nextNewInstance())的时候，会反射调用CGLIB$SET_THREAD_CALLBACKS方法，将MethodInterceptor实例缓存在CGLIB$THREAD_CALLBACKS这个代理类的的ThreadLocal中，然后初始化动态代理类实例时，调用CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">public final void update() &#123;</span><br><span class="line">   // 初始化动态代理类实例时，已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">   MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   if (this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">       CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">       var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (var10000 != null) &#123;</span><br><span class="line">       var10000.intercept(this, CGLIB$update$0$Method, CGLIB$emptyArgs, CGLIB$update$0$Proxy);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       super.update();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CGLIB$BIND_CALLBACKS方法将MethodInterceptor赋值给CGLIB$CALLBACK_0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">   UserDao$$EnhancerByCGLIB$$c00e2e9b var1 = (UserDao$$EnhancerByCGLIB$$c00e2e9b)var0;</span><br><span class="line">   if (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">       var1.CGLIB$BOUND = true;</span><br><span class="line">       Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">       if (var10000 == null) &#123;</span><br><span class="line">           var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">           if (CGLIB$STATIC_CALLBACKS == null) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 也就是说，初始化动态代理类实例时，最后如果var1.CGLIB$BOUND = true，则说明已经将MethodInterceptor赋值给了CGLIB$CALLBACK_0</span><br><span class="line">       var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在调用到了MethodInterceptor的intercept方法了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">   // methodProxy.invokeSuper</span><br><span class="line">   Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>methodProxy，还记得动态代理类的static代码块么，在那时就已经初始化好了methodProxy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) &#123;</span><br><span class="line">   MethodProxy proxy = new MethodProxy();</span><br><span class="line">   // 使用Signature对象封装方法名和返回值</span><br><span class="line">   proxy.sig1 = new Signature(name1, desc);</span><br><span class="line">   proxy.sig2 = new Signature(name2, desc);</span><br><span class="line">   // 将UserDAO和UserDAO的动态代理类的Class文件放入CreateInfo对象</span><br><span class="line">   proxy.createInfo = new MethodProxy.CreateInfo(c1, c2);</span><br><span class="line">   return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了知道methodProxy怎么来的，继续往下走，invokeSuper():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       this.init();</span><br><span class="line">       MethodProxy.FastClassInfo fci = this.fastClassInfo;</span><br><span class="line">       // 这里调用的实际是FastClass代理类中的invoke方法</span><br><span class="line">       return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">   &#125; catch (InvocationTargetException var4) &#123;</span><br><span class="line">       throw var4.getTargetException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void init() &#123;</span><br><span class="line">   if (this.fastClassInfo == null) &#123;</span><br><span class="line">       Object var1 = this.initLock;</span><br><span class="line">       synchronized(this.initLock) &#123;</span><br><span class="line">           if (this.fastClassInfo == null) &#123;</span><br><span class="line">               MethodProxy.CreateInfo ci = this.createInfo;</span><br><span class="line">               MethodProxy.FastClassInfo fci = new MethodProxy.FastClassInfo();</span><br><span class="line">               // UserDAO和UserDAO的代理类分别有自己的FastClassInfo，分别使用个字的ClassInfo生成FastClass代理类</span><br><span class="line">               // 生成UserDAO的FastClass代理类</span><br><span class="line">               fci.f1 = helper(ci, ci.c1);</span><br><span class="line">               // 生成UserDAO代理类的FastClass代理类</span><br><span class="line">               fci.f2 = helper(ci, ci.c2);</span><br><span class="line">               // 生成方法索引</span><br><span class="line">               fci.i1 = fci.f1.getIndex(this.sig1);</span><br><span class="line">               fci.i2 = fci.f2.getIndex(this.sig2);</span><br><span class="line">               this.fastClassInfo = fci;</span><br><span class="line">               this.createInfo = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据索引调用方法，fci.i2的值为12，调用索引12的方法。<br>UserDao$$EnhancerByCGLIB$$c00e2e9b$$FastClassByCGLIB$$ff71decc动态代理类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123;</span><br><span class="line">   c00e2e9b var10000 = (c00e2e9b)var2;</span><br><span class="line">   int var10001 = var1;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">       switch(var10001) &#123;</span><br><span class="line">       case 0:</span><br><span class="line">           return new Boolean(var10000.equals(var3[0]));</span><br><span class="line">       case 1:</span><br><span class="line">           return var10000.toString();</span><br><span class="line">       case 2:</span><br><span class="line">           return new Integer(var10000.hashCode());</span><br><span class="line">       case 3:</span><br><span class="line">           return var10000.clone();</span><br><span class="line">       case 4:</span><br><span class="line">           var10000.update();</span><br><span class="line">           return null;</span><br><span class="line">       case 5:</span><br><span class="line">           return var10000.newInstance((Class[])var3[0], (Object[])var3[1], (Callback[])var3[2]);</span><br><span class="line">       case 6:</span><br><span class="line">           return var10000.newInstance((Callback)var3[0]);</span><br><span class="line">       case 7:</span><br><span class="line">           return var10000.newInstance((Callback[])var3[0]);</span><br><span class="line">       case 8:</span><br><span class="line">           var10000.select();</span><br><span class="line">           return null;</span><br><span class="line">       case 9:</span><br><span class="line">           var10000.setCallback(((Number)var3[0]).intValue(), (Callback)var3[1]);</span><br><span class="line">           return null;</span><br><span class="line">       case 10:</span><br><span class="line">           return c00e2e9b.CGLIB$findMethodProxy((Signature)var3[0]);</span><br><span class="line">       case 11:</span><br><span class="line">           c00e2e9b.CGLIB$STATICHOOK1();</span><br><span class="line">           return null;</span><br><span class="line">       case 12:</span><br><span class="line">           var10000.CGLIB$update$0();</span><br><span class="line">           return null;</span><br><span class="line">       case 13:</span><br><span class="line">           var10000.CGLIB$select$1();</span><br><span class="line">           return null;</span><br><span class="line">       case 14:</span><br><span class="line">           return new Boolean(var10000.CGLIB$equals$2(var3[0]));</span><br><span class="line">       case 15:</span><br><span class="line">           return var10000.CGLIB$toString$3();</span><br><span class="line">       case 16:</span><br><span class="line">           return new Integer(var10000.CGLIB$hashCode$4());</span><br><span class="line">       case 17:</span><br><span class="line">           return var10000.CGLIB$clone$5();</span><br><span class="line">       case 18:</span><br><span class="line">           var10000.setCallbacks((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 19:</span><br><span class="line">           c00e2e9b.CGLIB$SET_STATIC_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 20:</span><br><span class="line">           c00e2e9b.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">           return null;</span><br><span class="line">       case 21:</span><br><span class="line">           return var10000.getCallback(((Number)var3[0]).intValue());</span><br><span class="line">       case 22:</span><br><span class="line">           return var10000.getCallbacks();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; catch (Throwable var4) &#123;</span><br><span class="line">       throw new InvocationTargetException(var4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问流程图：</p><p><img src="/media/article/cglib-invoke.png" alt="cglib-invoke"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是CGLIB还是JDK proxy都是为了控制对象的访问，但是怎样控制访问是CGLIB和JDK proxy思想上的最大区别，JDK proxy通过接口得到method对象后使用反射直接调用目标方法，CGLIB则是更复杂的多，CGLIB先是继承目标类，然后通过字节码技术生成代理方法（CGLIB$update$0）和update（上述例子中的方法，这里用来举例），然后通过方法代理（MethodProxy）和FastClass访问机制（通过方法名和返回值生成索引，调用时直接索引至目标方法）回调目标方法。</p><blockquote><p>TIPS:其实这里还有很多想说的，但是总也感觉表达的总是不是那么的到位，所以暂且先这样了，等着后续再继续完善。</p></blockquote><p>优点：</p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似CGLIB动态代理就没有这种限制。</li><li>只操作我们关心的类，不必为其他相关类增加工作量。</li><li>高性能，高性能体现方法的调用上，CGLIB的方法调用为FastClass机制，JDK Proxy为反射调用。</li></ul><h2 id="4-一些源码"><a href="#4-一些源码" class="headerlink" title="4. 一些源码"></a>4. 一些源码</h2><p>下面是一些比较核心的一些代码解析：</p><p>入口，AbstractGenerator中的create(key)方法，参数key=KeyFactory.newInstance()。KeyFactory也是CGLIB动态生成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 参数key是Enhancer.KeyFactory(superclassname)的实例，这个KeyFactory类也是cglib动态生成的，当你new Enhancer()时，Enhancer会动态的生成该实例对象，superclassname就是上面的UserDAO。</span><br><span class="line">protected Object create(Object key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ClassLoader loader = this.getClassLoader();</span><br><span class="line">        // CACHE时WeakHashMap 第一层缓存的容器</span><br><span class="line">        Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        // 第一层缓存 key是classLoader</span><br><span class="line">        AbstractClassGenerator.ClassLoaderData data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">        if (data == null) &#123;</span><br><span class="line">            Class var5 = AbstractClassGenerator.class;</span><br><span class="line">            // 加锁意义在于CACHE时静态变量，属于该类，不是该实例对象，所以线程安全需要加锁。</span><br><span class="line">            synchronized(AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);</span><br><span class="line">                if (data == null) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; newCache = new WeakHashMap(cache);</span><br><span class="line">                    // 创建第二层缓存容器</span><br><span class="line">                    data = new AbstractClassGenerator.ClassLoaderData(loader);</span><br><span class="line">                    // 将第二层缓存容器放入第一层容器内，key为classloader</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.key = key;</span><br><span class="line">        // 使用ClassLoaderData data获取Enhancer.EnhancerFactoryData对象，Enhancer.EnhancerFactoryData对象中是代理类的Class对象，也可以直接获取KeyFactory的Class对象</span><br><span class="line">        Object obj = data.get(this, this.getUseCache());</span><br><span class="line">        // firstInstance主要是针对KeyFactory生成的Class对象，例如接口方法生成的MethodWraper的代理类Class对象，nextInstance针对Enhancer实例生成的Enhancer.EnhancerFactoryData实例，实例中存储着真正的代理类的Class对象，如果生成的代理类中有接口方法，生成代理类时，会生成接口方法的MethodWrapper的代理类实例。</span><br><span class="line">        return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);</span><br><span class="line">    &#125; catch (Error | RuntimeException var9) &#123;</span><br><span class="line">        throw var9;</span><br><span class="line">    &#125; catch (Exception var10) &#123;</span><br><span class="line">        throw new CodeGenerationException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一级缓存中的value，ClassLoaderData的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ClassLoaderData(ClassLoader classLoader) &#123;</span><br><span class="line">  if (classLoader == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;classLoader == null is not yet supported&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // 首先用弱引用封装classLoader，垃圾回收时可以直接回收</span><br><span class="line">      this.classLoader = new WeakReference(classLoader);</span><br><span class="line">      Function&lt;AbstractClassGenerator, Object&gt; load = new Function&lt;AbstractClassGenerator, Object&gt;() &#123;</span><br><span class="line">          public Object apply(AbstractClassGenerator gen) &#123;</span><br><span class="line">              Class klass = gen.generate(ClassLoaderData.this);</span><br><span class="line">              // 这里需要注意gen是Enhancer实例，还是KeyFactory$Genertor实例，两者的wrapCachedClass完全不一样，使用的数据结构也不一样。Enhancer使用的数据结构是EnhancerFactoryData，KeyFactory$Genertor使用LoadingCache</span><br><span class="line">              return gen.wrapCachedClass(klass);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      // this.generatedClasses的key是KeyFactory根据superclassName生成的key实例，将load放入LoadingCache，等下如果LoadingCache的map获取代理类为null，需要回调这个load重新生成代理类</span><br><span class="line">      this.generatedClasses = new LoadingCache(GET_KEY, load);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二级缓存的对象LoadingCache中的核心方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// key是Enhancer实例，或者是KeyFactory$Generator实例</span><br><span class="line">public V get(K key) &#123;</span><br><span class="line">   KK cacheKey = this.keyMapper.apply(key);</span><br><span class="line">   Object v = this.map.get(cacheKey);</span><br><span class="line">   return v != null &amp;&amp; !(v instanceof FutureTask) ? v : this.createEntry(key, cacheKey, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected V createEntry(final K key, KK cacheKey, Object v) &#123;</span><br><span class="line">   boolean creator = false;</span><br><span class="line">   FutureTask task;</span><br><span class="line">   Object result;</span><br><span class="line">   if (v != null) &#123;</span><br><span class="line">       task = (FutureTask)v;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       task = new FutureTask(new Callable&lt;V&gt;() &#123;</span><br><span class="line">           public V call() throws Exception &#123;</span><br><span class="line">               // 回调AbstractGenerator.ClassLoaderData构造器中的load</span><br><span class="line">               return LoadingCache.this.loader.apply(key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 获取map中的value，如果是Enhancer.EnhancerFactoryData就直接返回，如果不是，继续往下获取Class对象</span><br><span class="line">       result = this.map.putIfAbsent(cacheKey, task);</span><br><span class="line">       // 如果等于null，需要重新生成</span><br><span class="line">       if (result == null) &#123;</span><br><span class="line">           creator = true;</span><br><span class="line">           task.run();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (!(result instanceof FutureTask)) &#123;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           task = (FutureTask)result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">       result = task.get();</span><br><span class="line">   &#125; catch (InterruptedException var9) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Interrupted while loading cache item&quot;, var9);</span><br><span class="line">   &#125; catch (ExecutionException var10) &#123;</span><br><span class="line">       Throwable cause = var10.getCause();</span><br><span class="line">       if (cause instanceof RuntimeException) &#123;</span><br><span class="line">           throw (RuntimeException)cause;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       throw new IllegalStateException(&quot;Unable to load cache item&quot;, cause);</span><br><span class="line">   &#125;</span><br><span class="line">   // 新建的Class对象或者Enhancer.EnhancerFactoryData需要存起来</span><br><span class="line">   if (creator) &#123;</span><br><span class="line">       this.map.put(cacheKey, result);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Enhancer中生成动态代理类的逻辑，使用了ASM技术：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public void generateClass(ClassVisitor v) throws Exception &#123;</span><br><span class="line">   Class sc = this.superclass == null ? Object.class : this.superclass;</span><br><span class="line">   if (TypeUtils.isFinal(sc.getModifiers())) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Cannot subclass final class &quot; + sc.getName());</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">       this.filterConstructors(sc, constructors);</span><br><span class="line">       List actualMethods = new ArrayList();</span><br><span class="line">       List interfaceMethods = new ArrayList();</span><br><span class="line">       final Set forcePublic = new HashSet();</span><br><span class="line">       // 将接口中的方法获取放入到forcePublic中，获取的其实是KeyFactory生成的MethodWrapper实例 select,&#125;, void</span><br><span class="line">       // actualMethods是一个包含所有方法的数组，值类似public void com.zhongyp.advanced.proxy.cglib.UserDao.update()</span><br><span class="line">       getMethods(sc, this.interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line">       // 获取到所有的方法及访问标识</span><br><span class="line">       List methods = CollectionUtils.transform(actualMethods, new Transformer() &#123;</span><br><span class="line">           public Object transform(Object value) &#123;</span><br><span class="line">               Method method = (Method)value;</span><br><span class="line">               int modifiers = 16 | method.getModifiers() &amp; -1025 &amp; -257 &amp; -33;</span><br><span class="line">               if (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                   // 如果接口中有相同的方法，</span><br><span class="line">                   modifiers = modifiers &amp; -5 | 1;</span><br><span class="line">               &#125;</span><br><span class="line">               return ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       // 下面就是ASM的操作逻辑了</span><br><span class="line">       // 参数v是ClassVisitor</span><br><span class="line">       ClassEmitter e = new ClassEmitter(v);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), Type.getType(sc), this.useFactory ? TypeUtils.add(TypeUtils.getTypes(this.interfaces), FACTORY) : TypeUtils.getTypes(this.interfaces), &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           e.begin_class(46, 1, this.getClassName(), (Type)null, new Type[]&#123;FACTORY&#125;, &quot;&lt;generated&gt;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       // 构造器信息</span><br><span class="line">       List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line">       e.declare_field(2, &quot;CGLIB$BOUND&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       e.declare_field(9, &quot;CGLIB$FACTORY_DATA&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (!this.interceptDuringConstruction) &#123;</span><br><span class="line">           e.declare_field(2, &quot;CGLIB$CONSTRUCTED&quot;, Type.BOOLEAN_TYPE, (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(26, &quot;CGLIB$THREAD_CALLBACKS&quot;, THREAD_LOCAL, (Object)null);</span><br><span class="line">       e.declare_field(26, &quot;CGLIB$STATIC_CALLBACKS&quot;, CALLBACK_ARRAY, (Object)null);</span><br><span class="line">       if (this.serialVersionUID != null) &#123;</span><br><span class="line">           e.declare_field(26, &quot;serialVersionUID&quot;, Type.LONG_TYPE, this.serialVersionUID);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for(int i = 0; i &lt; this.callbackTypes.length; ++i) &#123;</span><br><span class="line">           e.declare_field(2, getCallbackField(i), this.callbackTypes[i], (Object)null);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.declare_field(10, &quot;CGLIB$CALLBACK_FILTER&quot;, OBJECT_TYPE, (Object)null);</span><br><span class="line">       if (this.currentData == null) &#123;</span><br><span class="line">           this.emitMethods(e, methods, actualMethods);</span><br><span class="line">           this.emitConstructors(e, constructorInfo);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.emitDefaultConstructor(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       this.emitSetThreadCallbacks(e);</span><br><span class="line">       this.emitSetStaticCallbacks(e);</span><br><span class="line">       this.emitBindCallbacks(e);</span><br><span class="line">       if (this.useFactory || this.currentData != null) &#123;</span><br><span class="line">           int[] keys = this.getCallbackKeys();</span><br><span class="line">           this.emitNewInstanceCallbacks(e);</span><br><span class="line">           this.emitNewInstanceCallback(e);</span><br><span class="line">           this.emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">           this.emitGetCallback(e, keys);</span><br><span class="line">           this.emitSetCallback(e, keys);</span><br><span class="line">           this.emitGetCallbacks(e);</span><br><span class="line">           this.emitSetCallbacks(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       e.end_class();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>CGLIB针对final方法怎么处理的呢？</li></ol><p>不处理，因为继承了目标类，所以动态代理类实例可以直接调用目标类的final方法。</p><ol start="2"><li>CGLIB动态代理是通过字节码底层继承要代理类来实现，如果被代理类被final关键字所修饰，那么代理会失败么？</li></ol><p>代理不会失败，只会直接调用目标类的final方法。如update方法是final的，代理类不会做其他的处理，会直接调用UserDAO的update方法。   </p><ol start="3"><li>CGLIB到底比JDk Proxy快在哪里？</li></ol><p>测试环境JDK1.8，平台macOS Catalina。</p><p>一般意义上认为CGLIB在创建动态代理类比JDK Proxy慢，但是在方法调用上CGLIB比JDK Proxy快。<br>但是通过个人的测试，CGLIB在创建动态代理类确实比JDK Proxy慢一点，基本上CGLIB创建一个动态代理类实例需要30ms，JDK Proxy基本上也就10ms。<br>方法调用上100w次JDK proxy用时33233ms，CGLIB用时34259ms。两者差距并不是很明显。</p><ol start="4"><li>为什么CGLIB要使用fastclass机制？</li></ol><p>JDK之前的版本对于反射调用优化不是特别好，反射方法调用很慢，所以为了避免反射带来的性能消耗，采用fastclass机制，fastclass其实就是把需要需要调用的目标方法进行封装，获取到每个方法的索引值，调用时，通过调用方法获取索引值，直接调用到封装的目标方法。这种调用和直接调用性能差别不大。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射</title>
      <link href="/java/2019-10-04-reflection/"/>
      <url>/java/2019-10-04-reflection/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这种动态获取信息以及动态创建/调用对象方法的功能称为Java语言的反射机制。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以在运行时动态的确定类型并创建实例，可以调用实例中的任意方法即是方法时private的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>相比于编译时确定类型的方式，运行时确定类型创建实例会带来一定的性能消耗。</li><li>反射需要运行时的权限，这种权限可能在安全管理器下运行时可能不存在。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。</li><li>由于反射允许代码执行非反射代码中非法的操作（例如访问私有字段和方法），因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射代码破坏了抽象，因此可能会随着平台的升级而改变行为。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><blockquote><p>反射调用慢在哪里？</p></blockquote><p>相对于在编译时确定对象类型，反射是在运行时动态创建对象并确定对象类型，所以会比编译时确定对象类型多一些性能消耗即慢。<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  User user = new User();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在4.5ms左右</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i=0; i&lt;10000; i++)</span><br><span class="line">&#123;</span><br><span class="line">  Class&lt;?&gt; clazz =  Class.forName(&quot;com.zhongyp.advanced.refect.User&quot;, true, ReflectDemo.class.getClassLoader());</span><br><span class="line">            User user = (User) clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">// 耗时基本在20ms左右</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDK动态代理浅析</title>
      <link href="/java/2019-10-04-jdk-proxy/"/>
      <url>/java/2019-10-04-jdk-proxy/</url>
      
        <content type="html"><![CDATA[<p>本文承接自<a href="/java/2019-09-09-java-proxy/">动态代理浅析</a>这篇文章，对代理没有什么概念的同学建议先读下这篇文章。</p><h2 id="1-使用JDK动态代理"><a href="#1-使用JDK动态代理" class="headerlink" title="1. 使用JDK动态代理"></a>1. 使用JDK动态代理</h2><p>JDK动态代理使用起来很简单，如下：</p><p>TestService是一个业务接口，接口中有个test方法， TestServiceImpl是TestService的实现类。<br>InvocationHandler是JDK动态代理的调用代理方法处理接口，我们JDK使用动态代理时需要实现这个接口，在这个接口的处理方法中编写处理逻辑，你想怎样控制目标方法的访问都可以在这个方法中实现。然后调用Proxy类的静态方法newProxyInstance方法即可获得到代理类实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        TestServiceImpl testService = new TestServiceImpl();</span><br><span class="line">        // 声明自己的处理类</span><br><span class="line">        MyInvokeHandler myInvokeHandler = new MyInvokeHandler(testService);</span><br><span class="line">        // 第一次生成代理类</span><br><span class="line">        TestService proxy = (TestService) Proxy.newProxyInstance(TestService.class.getClassLoader(),new Class[]&#123;TestService.class&#125;,myInvokeHandler);</span><br><span class="line">        // 代理类调用接口方法</span><br><span class="line">        proxy.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestServiceImpl implements TestService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;我要开始测试啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyInvokeHandler implements InvocationHandler&#123;</span><br><span class="line">    Object obj;</span><br><span class="line">    public MyInvokeHandler(Object obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        //在反射调用之前，可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        method.invoke(obj,args);</span><br><span class="line">        //在反射调用之后，也可以加一些处理行为</span><br><span class="line">        // doSomeThing();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface TestService&#123;</span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java通过<code>Proxy</code>类和<code>InvocationHandler</code>接口生成动态代理类<code>$Proxy0</code>。<code>Proxy</code>类是JDK生成动态代理的核心类，包含了JDK动态代理生成代理类的大部分逻辑。</p><!--![java-proxy](/media/article/java-proxy.001.png)--><h2 id="2-Java动态代理源码解析"><a href="#2-Java动态代理源码解析" class="headerlink" title="2. Java动态代理源码解析"></a>2. Java动态代理源码解析</h2><blockquote><p>Class对象每个类只有一个（同一个类加载器的情况下），该Class对象在类加载阶段生成，存储在内存中，非Java虚拟机堆，是该类对外访问的唯一入口。<a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-12.html#jls-12.4" target="_blank" rel="noopener">Java Language Specification 12.4</a></p></blockquote><p>Java生成动态代理类的核心方法是：ProxyClassFactory的<code>Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>。</p><p>参数：<code>ClassLoader loader</code>接口类加载器，<code>Class&lt;?&gt;[] interfaces</code>接口类的Class。</p><p>下面代码主要作用就是通过遍历接口数组，校验接口数组中的数据是否合法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 遍历接口类的Class数组</span><br><span class="line">  for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">      </span><br><span class="line">      Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          // 反射获得接口类Class对象</span><br><span class="line">          interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      // 校验是否是同一个类加载器，如果是不同的类加载器，生成的接口Class对象是不同的</span><br><span class="line">      if (interfaceClass != intf) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // Java动态代理仅支持接口代理</span><br><span class="line">      if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 使用Set来验证传入的接口数组中是否存在相同的接口</span><br><span class="line">      if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>下面这么多代码是为了给下面生成的代理类找到一个合理的包名和类名，如果接口数组中有非public属性的接口，如果此接口的包名不为null，则使用这个接口的包名，否则使用默认的<code>com.sun.proxy</code>包名，类名则是“上述包名+$Proxy+自增数字”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String proxyPkg = null;     </span><br><span class="line">int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">    int flags = intf.getModifiers();</span><br><span class="line">    if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">        accessFlags = Modifier.FINAL;</span><br><span class="line">        String name = intf.getName();</span><br><span class="line">        int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">        String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            proxyPkg = pkg;</span><br><span class="line">        &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (proxyPkg == null) &#123;</span><br><span class="line">    // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">    proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用自增数字区分不同的类</span><br><span class="line">long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br></pre></td></tr></table></figure><p>下面就是整个动态代理最核心的代码。生成代理类class文件的字节码，根据这个文件的字节码生成代理类的Class对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成字节数组，这个字节数组是生成的Class文件的字节数组，将这个字节流输出到class文件，就是上面的$Proxy0代理类。  </span><br><span class="line">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line"> proxyName, interfaces, accessFlags);</span><br><span class="line">try &#123;</span><br><span class="line"> // 通过刚才生成的代理类文件，生成代理类的Class对象。</span><br><span class="line"> return defineClass0(loader, proxyName,</span><br><span class="line">                     proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">&#125; catch (ClassFormatError e) &#123;</span><br><span class="line"> throw new IllegalArgumentException(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码仅仅是生成动态代理类的逻辑，不是JDK Proxy生成动态代理类实例的流程。</p><p>建议下面跟着源码一点点看如下的流程图。</p><p><img src="/media/article/weakcache.png" alt="weakcache"></p><p>第一个结构图是WeakCache的缓存结构图，WeakCache是Proxy的一个实例，每次去创建代理时，都会先去访问WeakCache，WeakCache中没有才会去创建。WeakCache采用两级缓存机制，第一层使用classloader生成的弱引用key，map实例valueMap的value在ConcurrentHashMap map中，valueMap是ConcurrentHasshMap， valueMap中使用接口数组（创建代理类传入的接口数组参数）生成的subKey，这个subKey不是弱引用，valueMap的value即可能是WeakCache.Factory实例，也可能是实现Supplier接口和继承WeakReference类的CacheValue实例。CacheValue用于封装动态生成的代理类的Class对象，WeakCache.Factory中包含生成动态代理类字节码和Class对象的逻辑，这个逻辑就是上面源码分析中的apply方法。<br>第二个是流程图，使用Proxy.newProxyInnstance生成动态代理类时，读取缓存的流程，结合着结构图和代码，应该可以理解JDK Proxy的整个缓存存储结构及读取流程。</p><p>生成的<code>$Proxy0</code>代理类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zhongyp.advanced.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">// 这个地方有两个接口，是因为我之前做测试的时候多加了一个TestService1接口。</span><br><span class="line">final class $Proxy0 extends Proxy implements TestService, TestService1 &#123;</span><br><span class="line"></span><br><span class="line">    // TestSerivce，TestService1两个接口总共就4个方法，test()，test1()，test3()，test4()，这里有7个方法，其中三个是hashCode，toString，equals。</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    private static Method m6;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m5;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 接口中的所有方法都会在代理类中生成，然后将代理类中的方法对象与方法名匹配放到InvocaotionHandler实现类实例的方法参数中</span><br><span class="line">    public final void test() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test3() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m4, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test4() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m6, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void test1() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m5, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 动态代理在初始化是会初始化所有的方法对象</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m3 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test&quot;);</span><br><span class="line">            m4 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService&quot;).getMethod(&quot;test3&quot;);</span><br><span class="line">            m6 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test4&quot;);</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m5 = Class.forName(&quot;com.zhongyp.advanced.proxy.TestService1&quot;).getMethod(&quot;test1&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于JDK动态代理的调用很简单，上面是我们上面的例子输出的动态代理类反编译的代码，我们看到接口中的每个方法<code>super.h.invoke(this, m5, (Object[])null)</code>，super就是Proxy，h是Proxy中的InvocationnHandler实例，InvocationHandler实例反射调用你的方法。InvocationHandler是在生成动态代理类的class对象后，创建动态代理类实例作为构造参数传进去的，所以虽然当前接口参数相同时，可能返回同一个动态代理类Class对象，但是只要InvocationHandler不同，他们就是不同的实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">    super(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/jdk-proxy-invoke.png" alt="jdk-proxy-invoke"></p><p>优点：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比cglib更加可靠。</li><li>平滑进行JDK版本升级，而字节码类库通常需要进行更新来保证在新版Java上能够使用。</li><li>代码实现简单。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>为什么JDK动态代理仅支持实现接口类的动态代理？</li></ol><p>这个问题我觉得可以从JDK做动态代理的初衷来说，JDK动态代理类是在运行时实现指定的接口列表的类，这个是JDK在设计实现动态代理最初就已经确定了的，所以可以看到在生成代理类的过程中，基本上就把接口类当作一个已知条件在使用，包括在定义缓存使用的subKey，代理类包名的生成规则中，反射获取Method对象等等地方，所以不存在为什么只支持实现接口类，而是JDK动态代理类的设计就是这样子的。</p><ol start="2"><li>为什么WeakCache采用两级缓存接口？</li></ol><p>这个问题我们可以从两个缓存的不同点来看，第一层缓存map是一个弱引用key，非弱引用valueMap，第二层缓存valueMap使用的是非弱引用subKey，弱引用CacheValue。我们都知道弱引用只要有垃圾回收时就会被回收，主要是为了防止缓存太多导致服务频繁的FullGC，所以第一层的作用就是当垃圾回收时，将缓存的valueMap全部清空。还有一个原因是第一层缓存使用的是classloader生成的key，所以map其实缓存的是所有当前同一个classloader生成的代理类的class对象。再说第二层缓存，第二层缓存使用的是创建代理类时传入的接口数组生成的subKey，这个是为了区分实现不同接口的动态代理类Class对象，如果说两个类都实现了同一个接口，那岂不是获取的同样的Class对象，这么说也是对的，区别在于实现的InvocationHandler接口的子类h不同，而这个h才是生成代理类实例的最终区别。第二层缓存为什么CacheValue使用弱引用，原因在于第一层缓存虽然key时弱引用，但是value不是，所以垃圾回收时只会回收key，不会回收value，value只会在下一次调用Proxy.newProxyInstance方法时才会去清空无效key的value。所以为了value能及时清空，所以CacheValue也使用了弱引用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AspectJ</title>
      <link href="/java/2019-10-04-aspectj/"/>
      <url>/java/2019-10-04-aspectj/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文引用自<a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p></blockquote><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><blockquote><p>AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言。当然，AspectJ需要使用额外的编译器。</p></blockquote><blockquote><p>AspectJ可以通过多种方式实现，包括源码织入或字节码织入，并且可以直接在虚拟机（VM）中实现。在所有情况下，AspectJ程序都将成为在Java VM中运行的有效Java程序。受切面影响的类与不受影响的类具有二进制兼容性（以保持与不受影响的原始文件编译的类兼容）。支持多种实现方式使该语言可以随着技术的变化而发展，并且与Java兼容可确保平台可用性。<br>AspectJ采用编译期织入和类加载期织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<br>使用AspectJ LTW有两个主要步骤，第一，通过JVM的-javaagent参数设置LTW的织入器类包，以代理JVM默认的类加载器；第二，LTW织入器需要一个aop.xml文件，在该文件中指定切面类和需要进行切面织入的目标类。</p></blockquote><blockquote><p>设置-javaagent JVM参数的方法:<br>(1)在Eclipse下的设置:<br>运行类-&gt;右键单击-&gt;Run As-&gt;Run…，可以在弹出的Run设置窗口设置该类的各项运行属性，切换到Arguments Tab页，在VM arguments中通过-javaagent指定AspectJ 织入器类包。<br>-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar<br>(2)在Tomcat下的设置<br>打开&lt;Tomcat_Home&gt;\bin\catalina.bat，在该批处理文件头部添加以下的设置：<br>set JAVA_OPTS=-javaagent:E:\workspace\lib\spring2.5\aspectjweaver.jar</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>知识结构图</title>
      <link href="/java/2019-09-29-knowledge-structure/"/>
      <url>/java/2019-09-29-knowledge-structure/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/article/knowledge-structure.png" alt="knowledge-structure"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>闲谈Java引用</title>
      <link href="/java/2019-09-15-reference/"/>
      <url>/java/2019-09-15-reference/</url>
      
        <content type="html"><![CDATA[<p>Java语言对对象的引用有如下四种：强引用(StrongReference)、 软引用(SoftReference)、虚引用(PhantomReference)、 弱引用(WeakReference)。</p><h2 id="1-强引用-StrongReference"><a href="#1-强引用-StrongReference" class="headerlink" title="1. 强引用(StrongReference)"></a>1. 强引用(StrongReference)</h2><p>Java中最常见的引用方式。当一个对象被一个或者一个以上的引用变量引用时，它处于激活状态，不可能被系统垃圾回收机制回收。</p><h2 id="2-软引用-SoftReference"><a href="#2-软引用-SoftReference" class="headerlink" title="2. 软引用(SoftReference)"></a>2. 软引用(SoftReference)</h2><p>软引用需要通过SoftRefrence类来实现，当一个对象只具有软引用时，可能被垃圾回收机制回收。当系统内存空间足够时，它不会被系统回收，当系统内存空间不够时，系统将会回收。</p><p>和弱引用的区别仅仅在于垃圾回收时， 是否根据空间大小回收的区别。</p><p>何时回收软引用的对象？</p><p>从1.3.1开始软可达对象将在最后被引用之后存活一段时间。默认值是堆中每MB空闲空间一秒的生存时间。这个值可以使用<code>-XX:SoftRefLRUPolicyMSPerMB</code>调整。<br>Java Hotspot服务端虚拟机使用最大可能的堆大小计算剩余可用空间。<br>Java Hotspot客户端虚拟机使用当前堆大小计算空闲空间。<br>这就意味着对于服务端虚拟机总体趋势是增长堆而不是清理软引用，因此在垃圾回收时<code>-Xmx</code>对软引用的回收有重要的影响。<br>相反，客户端虚拟机将很大趋势去清理软引用而不是增长堆。</p><p>上述行为对于1.3.1到Java SE 6版本的Java HotSpot VM都是正确的。但是，此行为不是VM规范的一部分，并且在将来的版本中可能会更改。同样，不保证-XX：SoftRefLRUPolicyMSPerMB标志在任何给定的发行版中均不存在。</p><p>在1.3.1版之前，Java HotSpot VM会在发现软引用时清除它们。</p><p>当我定期打开-verbose：gc时，我得到了很多完整的GC，已经调整了堆并且没有什么区别，这是怎么回事？</p><p>如果您使用的是RMI，则可能会遇到分布式GC。另外，某些应用程序添加了显式GC的思想，即它将使它们的应用程序更快。幸运的是，您可以在1.3及更高版本中使用命令行选项禁用此功能。尝试将-XX：+ DisableExplicitGC与-verbose：gc一起使用，看看是否有帮助。</p><h2 id="3-虚引用-PhantomReference"><a href="#3-虚引用-PhantomReference" class="headerlink" title="3. 虚引用(PhantomReference)"></a>3. 虚引用(PhantomReference)</h2><p>虚引用通过PhantomReference实现，虚引用类似于完全没有引用，虚引用对对象本身没有太大的影响。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列(ReferenceQueue)联合使用。</p><p>举例来说就是，如果垃圾回收时，发现一个实例对象除了虚引用外没有任何其他的引用，将会把这个引用放到<br><code>java.lang.ref.Reference.pending</code>队列里，GC完成时，通知ReferenceHandler这个守护线程做一些后续处理（如释放内存等等操作）。</p><h2 id="4-弱引用-WeakReference"><a href="#4-弱引用-WeakReference" class="headerlink" title="4. 弱引用(WeakReference)"></a>4. 弱引用(WeakReference)</h2><p>弱引用通过WeakReference类实现，对只有弱引用的对象而言，当系统垃圾回收机制运行时，不管内存是否足够，总会回收该对象所占用的内存。</p><h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue referenceQueue = new ReferenceQueue();</span><br><span class="line">WeakReference weakReference = new WeakReference(new TestEntity(), referenceQueue);</span><br><span class="line">((TestEntity) weakReference.get()).test();</span><br></pre></td></tr></table></figure><p>ReferenceQueue的作用是为了查看哪些WeakReference和SoftReferece被回收了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p><p><a href="https://www.jianshu.com/p/e66930caca9c" target="_blank" rel="noopener">Java PhantomReference详解</a></p><p><a href="oracle.com/technetwork/java/hotspotfaq-138619.html#gc_softrefs">Frequently Asked Questions About the Java HotSpot VM</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机知识点架构图</title>
      <link href="/jvm/2019-09-08-jvm-structure/"/>
      <url>/jvm/2019-09-08-jvm-structure/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/article/jvm-structure.png" alt="jvm-structure"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态代理浅析</title>
      <link href="/java/2019-09-09-java-proxy/"/>
      <url>/java/2019-09-09-java-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是动态代理？"><a href="#1-什么是动态代理？" class="headerlink" title="1. 什么是动态代理？"></a>1. 什么是动态代理？</h2><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问，而不是增强目标对象的功能。</p><blockquote><p>访问控制包括同步，身份验证，远程访问（RPC），惰性实例化（休眠，Mybatis），AOP（事务）。</p></blockquote><p><img src="/media/article/proxy-invoke-method.png" alt="代理方法调用"></p><p>实现代理的技术有很多，如 CGLIB(ASM)、AspectJ、Javassist、JDK Proxy等。</p><ul><li>ASM: 针对<strong><em>运行时</em></strong>动态生成和转换类（class）的Java语言工具，旨在处理已编译的Java类（class）。<a href="/java/2019-10-04-cglib/">CGLIB浅析</a></li><li>AspectJ: AspectJ采用<strong><em>编译时</em></strong>织入和<strong><em>类加载时</em></strong>织入的方式织入切面，是语言级的AOP实现，提供了完备的AOP支持。它用AspectJ语言定义切面，在编译期或类加载期将切面织入到Java类中。<br>AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）。<a href="/java/2019-10-04-aspectj/">AspectJ</a></li><li>Javassist: Javassist在Java中是一个用来编辑字节码的扩展包，它允许Java程序在<strong><em>运行时</em></strong>定义一个新类或者在JVM<strong><em>加载class文件时</em></strong>修改class文件。<br><a href="/java/2019-09-04-javassist/">Javassist</a></li><li>JDK Proxy: JDK动态代理类是在<strong><em>运行时</em></strong>实现指定的接口列表的类，该类实例上的其中一个接口进行的方法调用时，将被通过统一的接口进行编码并调用到另一个对象。因此，动态代理类可用于为接口列表创建类型安全的代理对象，而无需诸如在编译时使用编译工具预生成代理类。动态代理类实例的代理方法调用将在该代理类实例中的处理程序中通过java.lang.reflect.Method对象进行调用，该对象标识了所调用的方法和包含参数的Object类型数组，翻译自<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a>。详情<a href="/java/2019-10-04-jdk-proxy/">《JDK 动态代理浅析》</a></li></ul><p>在Java语言中，从构建代理类的时期上来看，有三种：编译时、类加载时和运行时。从方式上来说有两种，一种是静态代理，一种是动态代理。<br>动态代理则是一种方便<strong><em>运行时</em></strong>动态构建代理、动态处理代理方法调用的机制。例如ASM，Javassist，Java Proxy。</p><p><strong><em>编译时</em></strong>和<strong><em>类加载时</em></strong>构建代理类则属于静态代理。例如AspectJ。</p><h2 id="2-常用代理方式"><a href="#2-常用代理方式" class="headerlink" title="2. 常用代理方式"></a>2. 常用代理方式</h2><p>由于篇幅问题，本文进行了拆分，详细了解常用的代理方式的原理，请点击下方链接。</p><p><a href="/java/2019-10-04-jdk-proxy/">JDK proxy</a></p><p><a href="/java/2019-10-04-cglib/">CGLIB浅析</a></p><p><a href="/java/2019-10-04-aspectj/">AspectJ</a></p><p><a href="/java/2019-09-04-javassist/">Javassist</a></p><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h2><p><img src="/media/article/15688575046625.png" alt="jclasslib"><br>图片引用自<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">《美团技术团队》-字节码增强技术探索</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>1.Java生成动态代理的时候，使用WeakCache缓存已经生成的动态代理工厂，疑问点在于，为什么缓存的key使用的是<a href="/java/2019-09-15-reference/">弱引用</a>？</p><p>答: 类中的静态变量，当它持有一个指向一个对象的引用时，它就作为GC Root，第一类被列为GC Root的元素就是静态成员变量。因此若缓存不再需要时，使用强引用会让GC进行标记分析时认为从GC Root可达，不太会去标记这块内存，反之能够有效地标记这些缓存，从而提高内存回收效率。引用自<a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a></p><p>个人分析: 既然缓存代理工厂类，为什么不使用SoftReference，这样只有内存空间不够时才会进行回收。这样可以最大限度的缓存生成的代理工厂？<br>如果使用SoftReference，当服务使用动态代理较多时，可能会导致频繁的FullGC。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html" target="_blank" rel="noopener">Java动态代理机制分析及扩展，第1部分</a><br><a href="https://www.cnblogs.com/whirly/p/10154887.html" target="_blank" rel="noopener">Java 动态代理详解</a><br><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a><br><a href="https://segmentfault.com/q/1010000011711958" target="_blank" rel="noopener">为什么jdk动态代理类的缓存是弱引用</a><br><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Java Reflection API</a><br><a href="https://www.iteye.com/blog/log-cd-562056" target="_blank" rel="noopener">AspectJ LTW(Load Time Weaving)</a><br><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="noopener">Dynamic Proxy Classes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>了解ASM</title>
      <link href="/java/2019-10-06-asm/"/>
      <url>/java/2019-10-06-asm/</url>
      
        <content type="html"><![CDATA[<h2 id="ASM-是个啥"><a href="#ASM-是个啥" class="headerlink" title="ASM 是个啥"></a>ASM 是个啥</h2><blockquote><p><strong><a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a>技术是个啥？</strong><br>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br>ASM是一个通用的Java字节码操作和分析框架。它可以直接以二进制形式用于修改现有类或动态生成类。 ASM提供了一些常见的字节码转换和分析算法，可以从中构建定制的复杂转换和代码分析工具。 ASM提供与其他Java字节码框架类似的功能，但侧重于性能。因为它的设计和实现是尽可能的小和尽可能快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中使用）。<br>ASM应用广泛：OpenJDK lambda call sites，<a href="http://hg.openjdk.java.net/jdk8/jdk8/nashorn/file/096dc407d310/src/jdk/nashorn/internal/codegen/ClassEmitter.java" target="_blank" rel="noopener">Nashorn compiler</a><br>CGLIB，以动态生成代理类（用于其他项目，例如Mockito和EasyMock），Gradle，在运行时生成一些类。</p></blockquote><h2 id="ASM的原理解析"><a href="#ASM的原理解析" class="headerlink" title="ASM的原理解析"></a>ASM的原理解析</h2><p>ASM中最主要通过<a href="https://github.com/zhongyp/demo/tree/master/src/main/java/com/zhongyp/advanced/pattern/visitor" target="_blank" rel="noopener">访问模式</a>对字节码文件进行修改，读取。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机类加载机制</title>
      <link href="/jvm/2019-08-18-jvm-classloading/"/>
      <url>/jvm/2019-08-18-jvm-classloading/</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p></blockquote><p>Java 虚拟机动态的加载，连接，初始化类或者接口。</p><p>加载是一个通过特殊符号查找类或者接口类型的二进制文件，同时使用二进制文件创建类或者接口的过程。</p><p>连接是一个加载类或者接口并结合它变为Java虚拟机的运行时状态的过程，以便于它可以被Java虚拟机执行。</p><p>一个类或者接口的初始化由执行类或者接口的初始化方法<code>&lt;clinit&gt;</code>组成(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener">§2.9</a>)。</p><p>下图是类或者接口动态加载、连接、初始化的过程：</p><p><img src="/media/article/jvm-classloading.png" alt="jvm-classloading"></p><p>图片摘自<a href="">深入理解Java虚拟机</a></p><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h2><p>加载阶段：</p><ul><li><ol><li>通过一个类的全限定名来获取定义此类二进制字节流。</li></ol></li><li><ol start="2"><li>将这个字节流代表的静态存储结构转换为方法区的运行时数据结构(运行时数据结构详见第四小节<a href="#4-运行时常量池"></a>)。</li></ol></li><li><ol start="3"><li>在<strong><em>内存(Class对象比较特殊，它虽然是对象，但是存储在方法区中)</em></strong>生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol></li></ul><p>对于数组类本身不通过类加载器创建，它由Java虚拟机直接创建。数组类型却由类加载器创建，创建过程遵循以下规则：</p><ul><li>如果数组组件类型是引用类型，则数组被标记为组件类型定义的类加载器定义。否则，数组被标记为引导类加载器定义。</li><li>如果数组的组件类型不是引用类型，Java虚拟机将会把数组标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认是public。</li></ul><p>加载和连接阶段是交叉进行的。</p><h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h2><p>如果需要连接类或接口涉及验证和准备该类或接口，直接超类，直接超接口及其元素类型（如果它是数组类型）。类或接口中符号引用的解析是连接的可选部分。</p><p>只要维护了以下所有属性，此规范允许实现灵活性，以便何时发生连接活动（以及由于递归，加载）。</p><ul><li><p>类或接口在连接之前已完全加载。</p></li><li><p>在初始化之前，类或接口已完全验证并准备好。</p></li></ul><p>在连接期间检测到的错误被抛出到程序中的某个点，程序可能会直接或间接地需要连接到错误中涉及的类或接口。</p><p>例如，Java虚拟机实现可以选择在使用它时分别解析类或接口中的每个符号引用，或者在验证类时立即解析它们。这意味着在一些实现中，在初始化类或接口之后，解析过程可以继续。无论采用哪种策略，在解析期间检测到的任何错误都必须抛出到程序中（直接或间接）使用对类或接口的符号引用的位置。</p><p>因为连接涉及新数据结构的分配，所以它可能会失败OutOfMemoryError。</p><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>验证阶段会完成4个阶段的验证动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置类变量<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。进行内存分配的仅包括<strong><em>类变量[static变量]</em></strong>，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><h3 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic，这些虚拟机指令对运行时常量池进行符号引用，执行任何这些指令都需要解析其符号引用。</p><p>解析是从运行时常量池中的符号引用动态确定具体值的过程。</p><p>对出现在invokedynamic指令的相同的符号引用被解析一次并不意味着被任何其他invokedynamic指令认为已解析。</p><p>对于上述提到的所有指令，如果其中一个指令对符号引用进行了解析，则意味着任何非invokedynamic指令认为这个符号引用已经解析。</p><p>如果在解析符号引用期间发生错误，则必须在程序中(直接或间接)使用符号引用时的某一点抛出IncompatibleClassChangeError(或子类)的实例。</p><p>如果Java虚拟机尝试解析符号引用失败，抛出的错误是LinkageError(或子类)的实例，后续尝试解析引用始终失败，并且和初始解析尝试而引发的错误相同。</p><p>在执行指令之前，不得解析特定invokedynamic指令对调用site说明符的符号引用。</p><p>在<code>invokedynamic</code>指令解析失败的情况下，后续解析尝试不会重新执行引导方法。</p><p>上述某些指令在解析符号引用时需要额外的连接检查。例如，为了使getfield指令成功解析对其运行的字段的符号引用，它不仅必须完成第<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2" target="_blank" rel="noopener">5.4.3.2</a>节中给出的字段解析步骤，还要检查字段是否为静态。如果它是静态字段，则必须抛出链接异常。</p><p>值得注意的是，为了使<code>invokedynamic</code>指令成功解析对调用site说明符的符号引用，其中指定的引导方法必须正常完成并返回合适的调用站点对象。如果引导方法突然完成或返回不合适的调用站点对象，则必须抛出连接异常。</p><p>连接由特定执行特定Java虚拟机指令检查生成的异常在该指令的描述中给出，并且在本解析的一般性讨论中未涉及。请注意，此类异常虽然被描述为Java虚拟机指令执行而非解析的一部分，但仍然被视为解析失败。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h2><p>一个类的加载过程中加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，解析阶段则不一定。解析可以在初始化完成后再开始，这时为了支持Java的运行时绑定。</p><p>Java虚拟机没有进行强制约束什么时候加载，只是严格规范了5中情况必须对类进行”初始化”。</p><ul><li>遇到new、getstatic、putstatic或invokestatic这4条指令时，如果类没有进行初始化，则需要先触发其初始化。4条指令的常见场景是:使用new 关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)、以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7及以上版本的动态语言(详细了解 <a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a>)支持时，如果一个java.lang.incoke.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。</li></ul><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有 <strong><em>类变量的赋值动作</em></strong>和<strong><em>静态语句块(static{}块)中的语句</em></strong>合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语义块之前的变量，定义在它之后的变量，可以赋值，但是不能访问。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test()&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>不需要执行其父接口的<code>&lt;clinit&gt;()</code>方法。<br>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待。</p></blockquote><h2 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4. 运行时常量池"></a>4. 运行时常量池</h2><p>Java虚拟机维护每种类型常量池，这是一种运行时数据结构，它服务于常规编程语言实现的符号表的许多目的。</p><p>类或接口的二进制表示形式中的constant_pool表用于在创建类或接口对象时构造运行时常量池。运行时常量池中的所有引用最初都是符号引用。运行时常量池中的符号引用是从类或接口的二进制表示中的结构派生的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">String str = &quot;str&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">// 基本类型</span><br><span class="line">int i = 1;</span><br><span class="line"></span><br><span class="line">// 基本类型数组</span><br><span class="line">int[] arrayI = new int[3];</span><br><span class="line"></span><br><span class="line">// 引用类型数组</span><br><span class="line">A [] arrayA = new A[3];</span><br><span class="line"></span><br><span class="line">// 引用类型</span><br><span class="line">A a = new A();</span><br><span class="line"></span><br><span class="line">// 引用方法</span><br><span class="line">a.test();</span><br><span class="line"></span><br><span class="line">// 接口声明</span><br><span class="line">C c = new B();</span><br><span class="line"></span><br><span class="line">// 接口方法</span><br><span class="line">c.test();</span><br><span class="line"></span><br><span class="line">// lambda</span><br><span class="line">Runnable x = ()-&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p><code>javap -v</code>编译如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #13.#42        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #25            // str</span><br><span class="line">   #3 = Fieldref           #43.#44        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #45.#46        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #47            // com/zhongyp/test/A</span><br><span class="line">   #6 = Methodref          #5.#42         // com/zhongyp/test/A.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #7 = Methodref          #5.#48         // com/zhongyp/test/A.test:()V</span><br><span class="line">   #8 = Class              #49            // com/zhongyp/test/B</span><br><span class="line">   #9 = Methodref          #8.#42         // com/zhongyp/test/B.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #10 = InterfaceMethodref #50.#48        // com/zhongyp/test/C.test:()V</span><br><span class="line">  #11 = InvokeDynamic      #0:#55         // #0:run:()Ljava/lang/Runnable;</span><br><span class="line">  #12 = Class              #56            // com/zhongyp/test/Test</span><br><span class="line">  #13 = Class              #57            // java/lang/Object</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               LocalVariableTable</span><br><span class="line">  #19 = Utf8               this</span><br><span class="line">  #20 = Utf8               Lcom/zhongyp/test/Test;</span><br><span class="line">  #21 = Utf8               main</span><br><span class="line">  #22 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               args</span><br><span class="line">  #24 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               str</span><br><span class="line">  #26 = Utf8               Ljava/lang/String;</span><br><span class="line">  #27 = Utf8               i</span><br><span class="line">  #28 = Utf8               I</span><br><span class="line">  #29 = Utf8               arrayI</span><br><span class="line">  #30 = Utf8               [I</span><br><span class="line">  #31 = Utf8               arrayA</span><br><span class="line">  #32 = Utf8               [Lcom/zhongyp/test/A;</span><br><span class="line">  #33 = Utf8               a</span><br><span class="line">  #34 = Utf8               Lcom/zhongyp/test/A;</span><br><span class="line">  #35 = Utf8               c</span><br><span class="line">  #36 = Utf8               Lcom/zhongyp/test/C;</span><br><span class="line">  #37 = Utf8               x</span><br><span class="line">  #38 = Utf8               Ljava/lang/Runnable;</span><br><span class="line">  #39 = Utf8               lambda$main$0</span><br><span class="line">  #40 = Utf8               SourceFile</span><br><span class="line">  #41 = Utf8               Test.java</span><br><span class="line">  #42 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #43 = Class              #58            // java/lang/System</span><br><span class="line">  #44 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #45 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #46 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #47 = Utf8               com/zhongyp/test/A</span><br><span class="line">  #48 = NameAndType        #64:#15        // test:()V</span><br><span class="line">  #49 = Utf8               com/zhongyp/test/B</span><br><span class="line">  #50 = Class              #65            // com/zhongyp/test/C</span><br><span class="line">  #51 = Utf8               BootstrapMethods</span><br><span class="line">  #52 = MethodHandle       #6:#66         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #53 = MethodType         #15            //  ()V</span><br><span class="line">  #54 = MethodHandle       #6:#67         // invokestatic com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #55 = NameAndType        #68:#69        // run:()Ljava/lang/Runnable;</span><br><span class="line">  #56 = Utf8               com/zhongyp/test/Test</span><br><span class="line">  #57 = Utf8               java/lang/Object</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #64 = Utf8               test</span><br><span class="line">  #65 = Utf8               com/zhongyp/test/C</span><br><span class="line">  #66 = Methodref          #70.#71        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #67 = Methodref          #12.#72        // com/zhongyp/test/Test.lambda$main$0:()V</span><br><span class="line">  #68 = Utf8               run</span><br><span class="line">  #69 = Utf8               ()Ljava/lang/Runnable;</span><br><span class="line">  #70 = Class              #73            // java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #71 = NameAndType        #74:#78        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #72 = NameAndType        #39:#15        // lambda$main$0:()V</span><br><span class="line">  #73 = Utf8               java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #74 = Utf8               metafactory</span><br><span class="line">  #75 = Class              #80            // java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #76 = Utf8               Lookup</span><br><span class="line">  #77 = Utf8               InnerClasses</span><br><span class="line">  #78 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #79 = Class              #81            // java/lang/invoke/MethodHandles</span><br><span class="line">  #80 = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #81 = Utf8               java/lang/invoke/MethodHandles</span><br></pre></td></tr></table></figure><h3 id="4-1-CONSTANT-Class-info结构"><a href="#4-1-CONSTANT-Class-info结构" class="headerlink" title="4.1 CONSTANT_Class_info结构"></a>4.1 CONSTANT_Class_info结构</h3><p>对类或接口的符号引用是从类或接口的二进制表示形式中的CONSTANT_Class_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1" target="_blank" rel="noopener">第4.4.1节</a>派生的。这样的引用给出了Class.getName方法返回的表单中的类或接口的名称。</p><p>对于非数组类或接口，名称是类或接口的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>。</p><p>对于n维的数组类，名称以n个出现的ASCII“[”字符开头，后跟元素类型的表示：</p><ul><li><p>如果元素类型是基本类型，则它由相应的字段描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">第4.3.2节</a>表示。</p></li><li><p>否则，如果元素类型是引用类型，则它由ASCII“L”字符后跟元素类型的二进制名称<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" target="_blank" rel="noopener">第4.2.1节</a>后跟ASCII“;”符号表示。</p></li></ul><h3 id="4-2-CONSTANT-Fieldref-info结构"><a href="#4-2-CONSTANT-Fieldref-info结构" class="headerlink" title="4.2 CONSTANT_Fieldref_info结构"></a>4.2 CONSTANT_Fieldref_info结构</h3><p>对类或接口的字段的符号引用是从类或接口的二进制表示形式中的CONSTANT_Fieldref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了字段的名称和描述符，以及对要在其中找到字段的类或接口的符号引用。</p><h3 id="4-3-CONSTANT-Methodref-info结构"><a href="#4-3-CONSTANT-Methodref-info结构" class="headerlink" title="4.3 CONSTANT_Methodref_info结构"></a>4.3 CONSTANT_Methodref_info结构</h3><p>对类的方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_Methodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了方法的名称和描述符，以及对要在其中找到方法的类的符号引用。</p><h3 id="4-4-CONSTANT-InterfaceMethodref-info"><a href="#4-4-CONSTANT-InterfaceMethodref-info" class="headerlink" title="4.4 CONSTANT_InterfaceMethodref_info"></a>4.4 CONSTANT_InterfaceMethodref_info</h3><p>对接口方法的符号引用是从类或接口的二进制表示形式中的CONSTANT_InterfaceMethodref_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2" target="_blank" rel="noopener">第4.4.2节</a>派生的。这样的引用给出了接口方法的名称和描述符，以及对要在其中找到方法的接口的符号引用。</p><h3 id="4-5-CONSTANT-MethodHandle-info结构"><a href="#4-5-CONSTANT-MethodHandle-info结构" class="headerlink" title="4.5 CONSTANT_MethodHandle_info结构"></a>4.5 CONSTANT_MethodHandle_info结构</h3><p>方法句柄的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodHandle_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.8" target="_blank" rel="noopener">第4.4.8节</a>派生的。这样的引用根据方法句柄的类型给出了类或接口的字段，类的方法或接口的方法的符号引用。</p><h3 id="4-6-CONSTANT-MethodType-info结构"><a href="#4-6-CONSTANT-MethodType-info结构" class="headerlink" title="4.6 CONSTANT_MethodType_info结构"></a>4.6 CONSTANT_MethodType_info结构</h3><p>方法类型的符号引用是从类或接口的二进制表示形式中的CONSTANT_MethodType_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.9" target="_blank" rel="noopener">第4.4.9节</a>派生的。这样的引用给出了方法描述符<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">§4.3.3</a>。</p><h3 id="4-7-CONSTANT-InvokeDynamic-info结构"><a href="#4-7-CONSTANT-InvokeDynamic-info结构" class="headerlink" title="4.7 CONSTANT_InvokeDynamic_info结构"></a>4.7 CONSTANT_InvokeDynamic_info结构</h3><blockquote><h3 id="invokedynamic-instructions"><a href="#invokedynamic-instructions" class="headerlink" title="invokedynamic instructions"></a>invokedynamic instructions</h3><p>A dynamic call site is originally in an unlinked state. In this state, there is no target method for the call site to invoke.<br>动态的调用site起初处在未连接的状态。在这种状态下，调用site没有调用的目标方法。<br>Before the JVM can execute a dynamic call site (an invokedynamic instruction), the call site must first be linked. Linking is accomplished by calling a bootstrap method which is given the static information content of the call site, and which must produce a method handle that gives the behavior of the call site.<br>在JVM可以执行动态调用site（invokedynamic指令）之前，必须首先连接调用site。连接是通过调用一个bootstrap方法来完成的，该方法被赋予了调用站点的静态信息内容，并且必须产生一个方法句柄来给出调用站点的行为。<br>Each invokedynamic instruction statically specifies its own bootstrap method as a constant pool reference. The constant pool reference also specifies the call site’s name and type descriptor, just like invokevirtual and the other invoke instructions.<br>每个invokedynamic指令静态的将它自己的引导方法指定作为一个常量池引用。常量池引用也指定调用site的名称和类型描述，就像invokevirtual和其他的调用描述一样。<br>Linking starts with resolving the constant pool entry for the bootstrap method, and resolving a MethodType object for the type descriptor of the dynamic call site. This resolution process may trigger class loading. It may therefore throw an error if a class fails to load. This error becomes the abnormal termination of the dynamic call site execution. Linkage does not trigger class initialization.<br>连接从解析引导方法的常量池条目开始，并为动态调用site的类型描述符解析MethodType对象。这个解决的进程可能触发类加载。如果一个类加载失败，可能因此抛出一个error。这个error将成为动态调用site执行的异常终止。连接不能触发类的初始化。<br>The bootstrap method is invoked on at least three values:<br>引导方法至少使用3个值调用:</p><ul><li>a MethodHandles.Lookup, a lookup object on the caller class in which dynamic call site occurs</li><li>一个是MethodHandles.Lookup，发生动态调用site的调用类上的一个lookup对象。</li><li>a String, the method name mentioned in the call site</li><li>一个字符创，在调用site中提到的方法名称。</li><li>a MethodType, the resolved type descriptor of the call</li><li>一个MethodType，已解析的调用的类型描述。</li><li>optionally, between 1 and 251 additional static arguments taken from the constant pool。</li><li>可选地，从常量池中获取1到251个额外的静态参数。</li></ul></blockquote><p>对调用站点说明符的符号引用是从类或接口的二进制表示形式中的CONSTANT_InvokeDynamic_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.10" target="_blank" rel="noopener">第4.4.10节</a>派生的。这样的参考给出：</p><ul><li><p>方法句柄的符号引用，它将作为invokedynamic指令的引导方法<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic" target="_blank" rel="noopener">§invokedynamic</a>;</p></li><li><p>一系列符号引用(对类，方法类型和方法句柄)，字符串文字和运行时常量值，它们将作为引导方法的静态参数;</p></li><li><p>方法名称和方法描述符。</p></li></ul><h3 id="4-8-CONSTANT-String-info结构"><a href="#4-8-CONSTANT-String-info结构" class="headerlink" title="4.8 CONSTANT_String_info结构"></a>4.8 CONSTANT_String_info结构</h3><p>此外，某些不是符号引用的运行时值是从constant_pool表中找到的项派生的：</p><p>字符串文字是对类String实例的引用，它是从类或接口的二进制表示形式的CONSTANT_String_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3" target="_blank" rel="noopener">第4.4.3节</a>派生而来的。 CONSTANT_String_info结构给出了构成字符串文字的Unicode代码点序列。</p><p>Java编程语言要求相同的字符串文字[即包含相同代码点序列的文字]必须引用类String的相同实例(JLS§3.10.5)。此外，如果在任何字符串上调用String.intern方法，则结果是对该字符串显示为文字时将返回的同一类实例的引用。因此，以下表达式的值必须为true：</p><p><code>(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</code></p><p>为了派生字符串文字，Java虚拟机检查CONSTANT_String_info结构给出的代码点序列。</p><p>如果先前在类String的实例上调用了String.intern方法，该类包含与CONSTANT_String_info结构给出的Unicode代码点序列相同的Unicode代码点序列，则字符串文字派生的结果是对类String的同一实例的引用。</p><p>否则，将创建一个类String的新实例，其中包含CONSTANT_String_info结构给出的Unicode代码点序列;对该类实例的引用是字符串文字派生的结果。最后，调用新String实例的intern方法。</p><h3 id="4-9-其他结构"><a href="#4-9-其他结构" class="headerlink" title="4.9 其他结构"></a>4.9 其他结构</h3><p>运行时常量值是从类或接口的二进制表示形式中的CONSTANT_Integer_info，CONSTANT_Float_info，CONSTANT_Long_info或CONSTANT_Double_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">第4.4.4节，第4.4.5节</a>派生的。</p><p>请注意，CONSTANT_Float_info结构表示IEEE 754单一格式的值，CONSTANT_Double_info结构表示IEEE 754双格式<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4" target="_blank" rel="noopener">§4.4.4，§4.4.5</a>中的值。因此，从这些结构导出的运行时常数值必须是可以分别使用IEEE 754单格式和双格式表示的值。</p><p>类或接口的二进制表示的constant_pool表中的其余结构 - CONSTANT_NameAndType_info和CONSTANT_Utf8_info结构<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.6" target="_blank" rel="noopener">§4.4.6，§4.4.7</a> - 仅在派生对类，接口，方法，字段的符号引用时间接使用，方法类型和方法句柄，以及派生字符串文字和调用站点说明符时。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.infoq.cn/article/jdk-dynamically-typed-language/" target="_blank" rel="noopener">Java动态语言支持 –周志明</a></p><p><a href="">深入理解Java虚拟机</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/package-summary.html#package.description" target="_blank" rel="noopener">Package java.lang.invoke Description</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 性能诊断分析工具</title>
      <link href="/linux/2019-08-12-linux-performence/"/>
      <url>/linux/2019-08-12-linux-performence/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-性能诊断分析工具"><a href="#Linux-性能诊断分析工具" class="headerlink" title="Linux 性能诊断分析工具"></a>Linux 性能诊断分析工具</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://t.cn/Ehs6xfz" target="_blank" rel="noopener">超全整理！Linux性能分析工具汇总合集-董西孝</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM官方文档指南</title>
      <link href="/jvm/2019-08-08-offical-document/"/>
      <url>/jvm/2019-08-08-offical-document/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">Java虚拟机规范</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Data Redis的execute和executePipelined的区别</title>
      <link href="/redis/2019-08-06-execute-executePipelined/"/>
      <url>/redis/2019-08-06-execute-executePipelined/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spring-data-redis 2.0.7.RELEASE</p></blockquote><h2 id="executePipelined方法说明"><a href="#executePipelined方法说明" class="headerlink" title="executePipelined方法说明"></a>executePipelined方法说明</h2><p>executePipelined方法基于Redis的pipelining。关于pipelining官方解释如下: </p><p>A Request/Response server can be implemented so that it is able to process new requests even if the client didn’t already read the old responses. This way it is possible to send multiple commands to the server without waiting for the replies at all, and finally read the replies in a single step.<br>—摘自<a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">Redis Piplining</a></p><p>上面的意思大概是Redis服务器可以实现即使没有读取旧响应的情况下也可以发送新的请求，以这种方式可以发送多个命令到服务器而不用等待回复，最后一次获取全部的回复。这就是Redis Pipelining。</p><p>executePipelined的官方注释:</p><p>Executes the given action object on a pipelined connection, returning the results. Note that the callback cannot return a non-null value as it gets overwritten by the pipeline. This method will use the default serializers to deserialize results.</p><p>上面这句话的意思在一个<strong><em>管道连接</em></strong>中执行给定的动作对象，并返回结果。但是需要注意的是callback不能返回一个非null的值，callback的值将被pipeline覆盖。这个方法将使用默认的序列化和反序列化方式处理结果集。</p><p>例举executePipelined(SessionCallback&lt;?&gt; session, @Nullable RedisSerializer&lt;?&gt; resultSerializer) 方法源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt; executePipelined(SessionCallback&lt;?&gt; session, @Nullable RedisSerializer&lt;?&gt; resultSerializer) &#123;</span><br><span class="line">        Assert.isTrue(this.initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);</span><br><span class="line">        Assert.notNull(session, &quot;Callback object must not be null&quot;);</span><br><span class="line">        RedisConnectionFactory factory = this.getRequiredConnectionFactory();</span><br><span class="line">        // 是否开启事务管理，将当前连接注册到事务管理器</span><br><span class="line">        RedisConnectionUtils.bindConnection(factory, this.enableTransactionSupport);</span><br><span class="line"></span><br><span class="line">        List var4;</span><br><span class="line">        try &#123;</span><br><span class="line">            // this.execute其实就是execute，所以本质上来说，两个方法的区别在于executePipeline方法开启了pipeline</span><br><span class="line">            var4 = (List)this.execute((connection) -&gt; &#123;</span><br><span class="line">                // 开启管道</span><br><span class="line">                connection.openPipeline();</span><br><span class="line">                boolean pipelinedClosed = false;</span><br><span class="line"></span><br><span class="line">                List var7;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 在连接中执行SessionCallback中的动作，并获取结果集</span><br><span class="line">                    Object result = this.executeSession(session);</span><br><span class="line">                    // 如果结果集不为空，抛出InvalidDataAccessApiUsageException</span><br><span class="line">                    if (result != null) &#123;</span><br><span class="line">                        throw new InvalidDataAccessApiUsageException(&quot;Callback cannot return a non-null value as it gets overwritten by the pipeline&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    List&lt;Object&gt; closePipeline = connection.closePipeline();</span><br><span class="line">                    pipelinedClosed = true;</span><br><span class="line">                    // 获取管道返回的结果集并序列化</span><br><span class="line">                    var7 = this.deserializeMixedResults(closePipeline, resultSerializer, this.hashKeySerializer, this.hashValueSerializer);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (!pipelinedClosed) &#123;</span><br><span class="line">                        connection.closePipeline();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                // 返回管道的结果集</span><br><span class="line">                return var7;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码中<code>this.execute((connection)...</code>其实就是execute(RedisCallback&lt;?&gt; session)方法。所以executePipelined方法只是在execute内中开启了pipeline而已。</p><h2 id="execute方法说明"><a href="#execute方法说明" class="headerlink" title="execute方法说明"></a>execute方法说明</h2><p>execute相对于<code>executePipelined(SessionCallback&lt;?&gt; session)</code>比较简单，没有过多的处理，而是直接执行SessionCallback中的动作，官方注释如下:</p><p>Executes a Redis session. Allows multiple operations to be executed in the same session enabling ‘transactional’ capabilities through RedisOperations.multi() and RedisOperations.watch(Collection) operations.</p><p>大概意思是执行一个Redis会话。允许在<strong><em>同一会话</em></strong>中执行多个操作，通过RedisOperations.multi()和RedisOperations.watch(Collection)操作启用“事务”功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public &lt;T&gt; T execute(SessionCallback&lt;T&gt; session) &#123;</span><br><span class="line">        Assert.isTrue(this.initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);</span><br><span class="line">        Assert.notNull(session, &quot;Callback object must not be null&quot;);</span><br><span class="line">        RedisConnectionFactory factory = this.getRequiredConnectionFactory();</span><br><span class="line">        RedisConnectionUtils.bindConnection(factory, this.enableTransactionSupport);</span><br><span class="line"></span><br><span class="line">        Object var3;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 执行SessionCallback并获取执行SessionCallback返回的结果集</span><br><span class="line">            var3 = session.execute(this);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接返回结果集</span><br><span class="line">        return var3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="execute和executePipelined区别"><a href="#execute和executePipelined区别" class="headerlink" title="execute和executePipelined区别"></a>execute和executePipelined区别</h2><p>从上面两段源码示例可以看出，execute和executePipelined的最主要区别是executePipelined开启了pipeline。pipline与execute正常的请求/响应的区别主要在于请求/响应模式上，execute是串行化的命令请求，executePipelined请求与响应则是穿插进行。两者区别如图所示:<br>串行:<br><img src="/media/article/redis-execute.png" alt="redis-execute"></p><p>execute方法是串行的，命令请求发出后，必须得到响应数据，才能发送下一条命令请求。所以在一次Redis会话中，一次会话可能包含多次请求，即多次RTT。</p><p>穿插:</p><p><img src="/media/article/redis-executepipeline.png" alt="redis-executepipeline.png"></p><p>executePipelined是穿插的，可以批量发送命令到服务器，也可以批量获取响应数据。即可能使用一次RTT就能完成批量操作。</p><p>除了网络协议上的区别外，execute和executePipelined都支持事务管理器，支持multi，watch，exec，discard等事务操作，不过execute与executePipelined的这些操作还是有些区别的。</p><p>例如 JedisConnection开启multi:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void multi() &#123;</span><br><span class="line">   if (!this.isQueueing()) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           if (this.isPipelined()) &#123;</span><br><span class="line">               // 如果开启了pipeline，则使用Pipeline内部的multi</span><br><span class="line">               // Pipeline绑定的是client</span><br><span class="line">               this.getRequiredPipeline().multi();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // 没有开启pipeline使用jedis的multi</span><br><span class="line">               // jedis的multi绑定的是connection</span><br><span class="line">               this.transaction = this.jedis.multi();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception var2) &#123;</span><br><span class="line">           throw this.convertJedisAccessException(var2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jedis与Pipeline的命令绑定的对象不一样，前者绑定的是connection，后者绑定client。这和上面提到的请求/响应模式有关。<br>watch，exec，discard等操作也是如此。</p><p>除此之外，executePipelined的SessionCallback是不能有返回值的，executePipelined需要返回Pipleline的返回值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wuxian90/article/details/81322536" target="_blank" rel="noopener">Redis客户端与服务端交互详解</a></p><p><a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">pipelining</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> FAQ </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis 设计与实现</title>
      <link href="/redis/2019-06-21-redis/"/>
      <url>/redis/2019-06-21-redis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据结构与对象"><a href="#1-数据结构与对象" class="headerlink" title="1. 数据结构与对象"></a>1. 数据结构与对象</h2><h3 id="1-1-简单动态字符串（SDS）"><a href="#1-1-简单动态字符串（SDS）" class="headerlink" title="1.1 简单动态字符串（SDS）"></a>1.1 简单动态字符串（SDS）</h3><p>Redis没有使用C语言传统的字符串表示，而是构建了一种简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。Redis只会使用C字符串作为字面量。<br>除了用来保存数据库中的字符串值之外，SDS还被用做缓冲区(buffer): AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是SDS实现的。</p><blockquote><p>在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。</p></blockquote><h4 id="1-1-1-SDS的定义"><a href="#1-1-1-SDS的定义" class="headerlink" title="1.1.1 SDS的定义"></a>1.1.1 SDS的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    // 记录buf数组中已使用字节的数量</span><br><span class="line">    // 等于SDS所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    // 记录buf数组中未使用字节的数量</span><br><span class="line">    int free;</span><br><span class="line">    // 字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/article/15611092689335.jpg" alt="SDS示例"></p><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。</p><h4 id="1-1-2-与C字符串的区别"><a href="#1-1-2-与C字符串的区别" class="headerlink" title="1.1.2 与C字符串的区别"></a>1.1.2 与C字符串的区别</h4><ol><li>获取字符串长度复杂度：C字符串不记录长度信息，所以获取字符串长度复杂度为O(N)，SDS为O(1)。</li><li>杜绝缓冲区溢出：<code>strcat</code>函数可以将src字符串中的内容拼接到dest字符串的末尾:<br><code>char *strcat(char *dest, const char *src)</code><br>因为C字符串不记录自身的长度，所以<code>strcat</code>假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立，就会产生缓冲区溢出。SDS在执行拼接操作之前检查s的长度是否足够，在发现s目前的空间不足以拼接时，sdscat就会扩展s的空间，然后执行拼接操作。</li><li>减少修改字符串时带来的内存重分配次数：2中说道每次拼接字符串时，C字符串都要对C字符串进行一次内存重分配操作（即：在拼接操作，需要扩展空间大小，否则缓冲区溢出；在截断操作，需要释放多余空间，否则内存泄漏），因为重分配是比较耗时的操作，所以为了避免频繁修改字符串对性能造成的影响，SDS通过未使用空间接触了字符串长度和底层数组长度之间的关联：SDS中，buf的长度不一定是字符数量+1，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</li></ol><blockquote><p>空间预分配</p><ul><li>如果对SDS进行修改之后，SDS的长度小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。</li><li>如果对SDS修改之后，SDS的长度大于1MB，那么程序会分配1MB的未使用空间。</li></ul><p>惰性空间释放</p><ul><li>当 SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录下来，并等待将来使用。同时SDS提供了相应的API，在有需要时，释放SDS未使用的空间，这样就可以避免惰性空间释放策略会造成内存浪费。</li></ul></blockquote><h4 id="1-1-3-二进制安全"><a href="#1-1-3-二进制安全" class="headerlink" title="1.1.3 二进制安全"></a>1.1.3 二进制安全</h4><p>C语言字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符串，所以C字符串只能保存文本数据，不能保存二进制数据。<br>SDS的API都是二进制安全(binary-safe)的。</p><h4 id="1-1-4-兼容部分C字符串的函数"><a href="#1-1-4-兼容部分C字符串的函数" class="headerlink" title="1.1.4 兼容部分C字符串的函数"></a>1.1.4 兼容部分C字符串的函数</h4><p>虽然SDS的API都是二进制安全的，但是API总会将SDS保存的数据的末尾设置为空字符串，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数。</p><h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><p>当一个列表键包含数量比较多的元素，又或者包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区(output buffer)。</p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li><li>带链表长度的计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h3 id="1-3-字典"><a href="#1-3-字典" class="headerlink" title="1.3 字典"></a>1.3 字典</h3><h4 id="1-3-1-结构"><a href="#1-3-1-结构" class="headerlink" title="1.3.1 结构"></a>1.3.1 结构</h4><p>字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair)的抽象数据结构。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><p>字典结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">    // 类型特定函数</span><br><span class="line">    dicType *type;</span><br><span class="line">    </span><br><span class="line">    // 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line">    </span><br><span class="line">    // 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    </span><br><span class="line">    // rehash索引</span><br><span class="line">    // 当rehash不在进行时，值为-1</span><br><span class="line">    in threhash; /* rehashing not in progress if rehashidx == -1 */</span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。<br>privdata属性则保存了需要传给那些类型特定函数的可选参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dicType&#123;</span><br><span class="line"></span><br><span class="line">// 计算哈希值的函数</span><br><span class="line">unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">// 复制键的函数</span><br><span class="line">void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">// 对比键的函数</span><br><span class="line">int (*keyCompare)(void *privdata,const void *key1,const void *key);</span><br><span class="line"></span><br><span class="line">// 销毁键</span><br><span class="line">(*keyDestructor)(void *privdata,void *key);</span><br><span class="line"></span><br><span class="line">// 复制值</span><br><span class="line">void(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">// 销毁值</span><br><span class="line">void(*valDestructor)(void *privdata,void *obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ht属性是一个包含两个项的数组，数组的每项都是dictht哈希表，一般情况下只是用ht[0]，ht[1]只会在对ht[0]哈希表进行rehash时使用。<br>除ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有进行rehash，那么它的值为-1。<br><img src="/media/article/dicht.png" alt="dic"></p><h4 id="1-3-2-哈希算法"><a href="#1-3-2-哈希算法" class="headerlink" title="1.3.2 哈希算法"></a>1.3.2 哈希算法</h4><p>Redis使用的是<a href="http://code.google.com/p/smhasher/" target="_blank" rel="noopener">MurmurHash2</a>算法。</p><ol><li>算出hash值：hash=dict-&gt;type-&gt;hashFunction(key);</li><li>根据hash值计算索引值：index = hash &amp; dict-&gt;ht[x].sizemask;//x是0或1</li></ol><h4 id="1-3-4-键冲突"><a href="#1-3-4-键冲突" class="headerlink" title="1.3.4 键冲突"></a>1.3.4 键冲突</h4><p>Redis的哈希表使用链地址法(separate chaining)来解决冲突，每个哈希表节点都有一个next指针，多个哈希表节点就可以用next指针构成一个单项链表。速度考虑，最新节点添加到表头位置，复杂度O(1)。</p><h4 id="1-3-5-rehash"><a href="#1-3-5-rehash" class="headerlink" title="1.3.5 rehash"></a>1.3.5 rehash</h4><blockquote><p><strong>为什么无论是HashMap还是Redis，扩容/收缩时容量大小都是2的幂？</strong></p><ul><li>减少碰撞次数，比如1111&amp;1110=1110，1110&amp;1110=1110；</li><li>容量*2不至于分配空间过大造成浪费；</li></ul></blockquote><p>Redis对字典的rehash步骤如下：</p><ol><li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量：</li></ol><ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n；</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n；</li></ul><ol start="2"><li>将保存在ht[0]中的所有键值对rehash到ht[1]上:rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li></ol><p><strong> 哈希表的扩展与收缩 </strong></p><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p><ul><li>服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子=哈希表已保存节点数量/哈希表大小</span><br><span class="line">load_factor = ht[0].used/ht[0].size</span><br></pre></td></tr></table></figure><p>执行BGSAVE或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，大多数操作系统都采用写时复制(copy-on-write)技术优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子。<br>当哈希表的负载因子小于0.1时，程序自动开始执行收缩操作。</p><h4 id="1-3-6-渐进式rehash"><a href="#1-3-6-渐进式rehash" class="headerlink" title="1.3.6 渐进式rehash"></a>1.3.6 渐进式rehash</h4><p>rehash动作不是一次性、集中式的完成，而是分多次、渐进式的完成。<br>渐进式rehash步骤:</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash值ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作完成。</li></ol><p>在渐进式rehash期间，字典的删除、查找、更新等操作会在两个哈希表上进行。如果新加到字典的键值对一律被保存到ht[1]里面。</p><h3 id="1-4-跳跃表"><a href="#1-4-跳跃表" class="headerlink" title="1.4 跳跃表"></a>1.4 跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p><h4 id="1-4-1-结构"><a href="#1-4-1-结构" class="headerlink" title="1.4.1 结构"></a>1.4.1 结构</h4><p><img src="/media/article/skiplist.png" alt="skiplist"><br>上图展示了一个跳跃表示例，左边是zskiplist结构：</p><ul><li>header: 指向跳跃表的表头节点</li><li>tail: 指向跳跃表的结尾节点</li><li>level: 记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length: 记录跳跃表的长度，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>右侧是zskiplistNode结构：</p><ul><li>level: 节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，以此类推。每层两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，跨度则记录了前进指针所指向节点和当前节点的距离。</li><li>backward: 节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>score: 各个节点中的1.0、2.0、和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排序。</li><li>obj: 各个节点中的o1、o2和o3时节点所保存的成员对象。</li></ul><h3 id="1-5-整数集合"><a href="#1-5-整数集合" class="headerlink" title="1.5 整数集合"></a>1.5 整数集合</h3><p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。<br>整数集合是Redis用于保存整数值的集合抽象数据结构，他可以保存集合类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    // 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    // 集合包含的元素</span><br><span class="line">    uint32_t length;</span><br><span class="line">    // 保存元素的数据</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现:整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小从小打到有序的排列，并且数组中不包含任何重复项。</p><h4 id="1-5-1-整数集合升级"><a href="#1-5-1-整数集合升级" class="headerlink" title="1.5.1 整数集合升级"></a>1.5.1 整数集合升级</h4><p>每当我们将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合先进行升级，然后添加到整数集合里面。</p><p>升级步骤：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，放置元素过程中，需要维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><h3 id="1-6-压缩列表"><a href="#1-6-压缩列表" class="headerlink" title="1.6 压缩列表"></a>1.6 压缩列表</h3><p>当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><p>压缩列表是为了节约内存开发的，是由一系列特殊编码的连续内存块组织的顺序(sequential)数据结构。</p><p><img src="/media/article/ziplist.png" alt="ziplist"><br><img src="/media/article/ziplistintroduce.png" alt="ziplistintroduce"></p><p>节点content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><h4 id="1-6-1-连锁更新"><a href="#1-6-1-连锁更新" class="headerlink" title="1.6.1 连锁更新"></a>1.6.1 连锁更新</h4><p>连锁更新最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最快复杂度为O(N)，所以更新的最快复杂度为O(N^2)。</p><h3 id="1-7-快速列表-quicklist"><a href="#1-7-快速列表-quicklist" class="headerlink" title="1.7 快速列表(quicklist)"></a>1.7 快速列表(quicklist)</h3><p>quicklist是一个ziplist的双向链表（双向链表是由多个节点Node组成的）。也就是说quicklist的每个节点都是一个ziplist。ziplist本身也是一个能维持数据项先后顺序的列表（按插入位置），而且是一个各个数据项在内存上前后相邻的列表。<br>结构如下:</p><p><img src="/media/article/quicklist.png" alt="quicklist"><br>图片来自<a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a></p><p>quicklist基于空间和时间的考虑，结合双向链表和ziplist的优点。</p><blockquote><p>双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。<br>ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。<br>摘自<a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau Redis源码剖析–quicklist</a></p></blockquote><h4 id="快速列表存储效率"><a href="#快速列表存储效率" class="headerlink" title="快速列表存储效率"></a>快速列表存储效率</h4><p>本小节引用自《<a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a>》</p><blockquote><p>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。<br>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。</p></blockquote><p>实际上，Redis提供了一个配置参数<code>list-max-ziplist-size</code>，就是为了让使用者可以来根据自己的情况进行调整。</p><p>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。</p><p>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：</p><ul><li>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）</li><li>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</li><li>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。</li><li>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</li><li>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</li></ul><p>当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数list-compress-depth就是用来完成这个设置的。</p><p><code>list-compress-depth 0</code><br>这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。</p><p>参数list-compress-depth的取值含义如下：</p><ul><li>0: 是个特殊值，表示都不压缩。这是Redis的默认值。</li><li>1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。</li><li>2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。</li><li>3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</li></ul><p>依此类推…<br>由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p><p>Redis对于quicklist内部节点的压缩算法，采用的<a href="http://oldhome.schmorp.de/marc/liblzf.html" target="_blank" rel="noopener">LZF</a>——一种无损压缩算法。</p><h3 id="1-8-对象"><a href="#1-8-对象" class="headerlink" title="1.8 对象"></a>1.8 对象</h3><p>Redis并没有 直接使用SDS、双端链表、字典、压缩列表、整数集合这些数据结构实现键值对数据库，而是基于这些数据结构创建了一个对象系统。对象系统包含：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。<br>Redis的对象系统实现了基于引用计数计数的内存回收机制，当程序 不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外Redis还通过引用计数技术实现了对象共享机制，这种机制在适当情况下，通过让多个数据库键共享同一个对象来节约内存。<br>Redis对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能情况下，空转时长较大的那些键可能会优先被服务器删除。</p><h4 id="1-8-1-对象的类型与编码"><a href="#1-8-1-对象的类型与编码" class="headerlink" title="1.8.1 对象的类型与编码"></a>1.8.1 对象的类型与编码</h4><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，一个对象用作键值对的值。</p><p>Redis中的每个对象都由一个RedisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    </span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    </span><br><span class="line">    // 指向底层实现数据结构的指针</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>type记录了对象的类型：</p><ul><li>REDIS_STRING:字符串对象</li><li>REDIS_LIST:列表对象</li><li>REDIS_HASH:哈希对象</li><li>REDIS_SET:集合对象</li><li>REDIS_ZSET:有序集合对象</li></ul><blockquote><p>字符串键指的是这个数据库键所对应的值得字符串对象<br>列表键指的是数据库键所对应的值为列表对象</p></blockquote><p>ptr指针指向对象的底层实现数据结构，这些数据结构由对象的encoding属性决定。encoding记录对象使用的编码：</p><p><img src="/media/article/encoding-type.png" alt="encoding"><br>除上述列表外，还有一个是REDIS_ENCODING_QUICKLIST编码，快速列表。</p><p>每种类型的对象都至少使用了两种不同编码，下表列出了每种类型的对象可以使用的编码。</p><p><img src="/media/article/type-encoding.png" alt="type-encoding"></p><p>除上述列表外，还有一个是REDIS_LIST对应REDIS_ENCODING_QUICKLIST。</p><h4 id="1-8-2-字符串对象"><a href="#1-8-2-字符串对象" class="headerlink" title="1.8.2 字符串对象"></a>1.8.2 字符串对象</h4><p>字符串对象的编码可以是int、raw或者embstr。<br>如果字符串对象保存的是整数值，将字符串对象的编码设置为int。<br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度大于32字节，字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为raw。<br>raw结构：<br><img src="/media/article/raw.png" alt="raw"><br>如果字符串对象保存的是一个字符串值，并且这个字符串值长度小于32字节，字符串对象将使用embstr编码的方式保存这个字符串值。<br>embstr内存块结构：<br><img src="/media/article/embstr.png" alt="embstr"><br><strong>raw和embstr区别：</strong></p><ul><li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li><li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码字符串对象比起来raw编码的字符串能够更好地利用缓存带来的优势。</li></ul><p>字符串对象保存各类型值得编码方式:</p><p><img src="/media/article/string-type-value.png" alt="string"></p><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。<br>Redis没有为embstr编码的字符串对象编写任何响应的修改程序，所以embstr编码的字符串对象实际上是只读的。</p><p><img src="/media/article/string-order-implement.png" alt="string"></p><h4 id="1-8-3-列表对象"><a href="#1-8-3-列表对象" class="headerlink" title="1.8.3 列表对象"></a>1.8.3 列表对象</h4><p>3.2版本之前列表对象的编码可以使ziplist或者linkedlist。<br>ziplist结构如下：<br><img src="/media/article/ziplist-store.png" alt="ziplist"></p><p>linkedlist结构如下：</p><p><img src="/media/article/linkedlist-store.png" alt="linkedlist"></p><p>StringObject结构：</p><p><img src="/media/article/string-obj-store.png" alt="string-object"></p><p>当列表对象满足如下条件时，使用ziplist编码：<br>列表对象保存的所有字符串元素的长度都小于64字节；<br>列表对象保存的元素数量小于512个；</p><p><strong>列表命令的实现：</strong><br><img src="/media/article/list-order-implement.png" alt="list-order"></p><p>在3.2版本之后唯一的数据结构是快表（quicklist），它是一个双向链表，而且是一个ziplist的双向链表。</p><h4 id="1-8-4-哈希对象"><a href="#1-8-4-哈希对象" class="headerlink" title="1.8.4 哈希对象"></a>1.8.4 哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值得压缩列表节点推入到压缩列表表尾：</p><ul><li>因此保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;HSET profile name &quot;Tom&quot;</span><br><span class="line">&gt;HSET profile age 25</span><br><span class="line">&gt;HSET profile career &quot;Programmer&quot;</span><br></pre></td></tr></table></figure></p><p>哈希对象的压缩列表底层实现：</p><p><img src="/media/article/hash-ziplist-implement.png" alt="hash-ziplist-implement"></p><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><p>如果上述例子不是ziplist而是hashtable，则结构如下：</p><p><img src="/media/article/hashtable-implement.png" alt="hashtable-implement"></p><p>如果哈希对象满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值得字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；</li></ul><p><strong>hash命令：</strong></p><p><img src="/media/article/hash-order.png" alt="hash-order"></p><h4 id="1-8-5-集合对象"><a href="#1-8-5-集合对象" class="headerlink" title="1.8.5 集合对象"></a>1.8.5 集合对象</h4><p>集合对象编码可以是intset或者hashtable。</p><p><strong>集合命令：</strong></p><p><img src="/media/article/set-order.png" alt="set-order"><br><img src="/media/article/set-order1.png" alt="set-order"></p><h4 id="1-8-6-有序集合对象"><a href="#1-8-6-有序集合对象" class="headerlink" title="1.8.6 有序集合对象"></a>1.8.6 有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist。</p><p><strong>ziplist的的存储结构：</strong></p><p><img src="/media/article/sorted-set-ziplist.png" alt="sorted-set-ziplist"><br><img src="/media/article/sorted-set-ziplist1.png" alt="sorted-set-ziplist"></p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset&#123;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点保存了一个集合元素:跳跃表节点的Object属性保存了元素的成员，而跳跃表的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，如<code>ZRANK</code>、<code>ZRANGE</code>等命令就是基于跳跃表API来实现的。</p><p>除此之外，zset结构中的dict字典为有序集合创建了一个从成员的分值的映射，字典中的每个键值对都保存了一个集合元素:字典的键保存了元素的成员，而字典的值保存了元素的分值。通过这个字典，程序可以O(1)复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的。</p><p>虽然zset结构同时使用跳跃表和字典来保存有序集合元素，而这两种数据机构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或分值，也不会浪费额外内存。</p><blockquote><p><strong>为什么有序集合需要同时使用跳跃表和字典来实现？</strong><br>如果我们只是用字典来实现有序集合，那么虽然已O(1)复杂度查找成员的分值这一特性被保留，但是字典以无序的方式保存集合元素，所以每次在执行范围操作时，都需要对字典保存的所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。同样如果只是用跳跃表，根据成员查找分值操作复杂度将为O(logN)。</p></blockquote><p><strong>skiplist结构：</strong></p><p><img src="/media/article/sorted-set-skiplist.png" alt="sorted-set-skiplist"></p><p><strong><em>注意：字典和跳跃表会共享元素的成员和分值，并不会造成数据重复。</em></strong></p><p><strong>命令实现：</strong></p><p><img src="/media/article/sorted-set-order.png" alt="sorted-set-order"></p><h4 id="1-8-7-位数组（位图）"><a href="#1-8-7-位数组（位图）" class="headerlink" title="1.8.7 位数组（位图）"></a>1.8.7 位数组（位图）</h4><h4 id="1-8-8-HyperLogLogs"><a href="#1-8-8-HyperLogLogs" class="headerlink" title="1.8.8 HyperLogLogs"></a>1.8.8 HyperLogLogs</h4><h4 id="1-8-9-Streams"><a href="#1-8-9-Streams" class="headerlink" title="1.8.9 Streams"></a>1.8.9 Streams</h4><h4 id="1-8-7-类型检查与命令多态"><a href="#1-8-7-类型检查与命令多态" class="headerlink" title="1.8.7 类型检查与命令多态"></a>1.8.7 类型检查与命令多态</h4><p>Redis中用于操作键的命令基本上可以分为两种类型。<br>一种可以对任何类型键执行；另一种只能对特定类型的键执行。</p><p>Redis在执行一个类型特定的命令之前，会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。<br>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的:</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需类型，如果是的话执行。</li><li>否则，拒绝执行，返回类型错误。</li></ul><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。如llen：</p><p><img src="/media/article/llen-order.png" alt="llen-order"></p><h4 id="1-8-8-内存回收"><a href="#1-8-8-内存回收" class="headerlink" title="1.8.8 内存回收"></a>1.8.8 内存回收</h4><p>因为C不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数(reference counting)技术实现的内存回收机制。</p><h4 id="1-8-9-对象共享"><a href="#1-8-9-对象共享" class="headerlink" title="1.8.9 对象共享"></a>1.8.9 对象共享</h4><p>Redis对象的引用计数属性还带有对象共享的作用（多个键共享同一个值对象）。<br>这些共享对象不单单只有字符串键可以使用，那些数据结构中嵌套了字符串对象的对象都可以使用这些共享对象。</p><p>Redis只对包含整数值的字符串对象进行共享。</p><h4 id="1-8-10-对象的空转时长"><a href="#1-8-10-对象的空转时长" class="headerlink" title="1.8.10 对象的空转时长"></a>1.8.10 对象的空转时长</h4><p>除了type、encoding、ptr和refcount四个属性外，redisObject结构包含的最后一个属性为lru属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    unsigned lru:22;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>OBJECT IDLETIME命令可以打印出键的空转时长，计算方式：当前时间-lru。</p><h2 id="2-单机数据库实现"><a href="#2-单机数据库实现" class="headerlink" title="2. 单机数据库实现"></a>2. 单机数据库实现</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p><p><strong>数据库结构示例：</strong><br><img src="/media/article/redis-db.png" alt="db"></p><p>redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典成为键空间：</p><p><strong>数据库键空间示例：</strong><br><img src="/media/article/redis-db-keyspace.png" alt="db"></p><p>键空间的键也就是数据库的键，每个键都是一个字符串对象。<br>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。<br>数据库的键空间是一个字典。</p><p><strong> 读写空间时的维护操作</strong></p><ul><li>读取一个键后，服务器会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>读取一个键后，服务器会更新键的LRU时间，可以使用OBJECT idletime <key> 命令查看键key的闲置时间。</key></li><li>如果服务器在读取一个键时发现该键过期，服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果客户端使用watch命令监视了某个键，那么服务器在对被监视的键进行修改后，会将这个键标记为脏(dirty)。</li><li>服务器每次修改一个键后，都会对(dirty)键计数器的值增1，这个计数器会触发服务器的持久化及复制操作。</li><li>如果服务器开启了数据库通知功能，那么对键进行修改之后，服务器将按配置发送响应的数据库通知。</li></ul><h3 id="2-1-过期时间"><a href="#2-1-过期时间" class="headerlink" title="2.1 过期时间"></a>2.1 过期时间</h3><p>Redis有四种不同的命令可以用于设置键的生存时间或过期时间:</p><ul><li><code>EXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl秒。</li><li><code>PEXPIRE&lt;key&gt;&lt;ttl&gt;</code>命令用于将键key的生存时间设置为ttl毫秒。</li><li><code>EXPIREAT&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp秒数时间戳。</li><li><code>PEXPIRE&lt;key&gt;&lt;timestamp&gt;</code>命令用于将键key的生存时间设置为timestamp毫秒数时间戳。</li></ul><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典:</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><p>PERSIST命令可以移除一个键的过期时间。</p><p>TTL命令以秒级单位返回键的剩余生存时间，PTTL命令以毫秒为单位返回键的剩余生存时间。</p><h3 id="2-2-过期键删除策略"><a href="#2-2-过期键删除策略" class="headerlink" title="2.2 过期键删除策略"></a>2.2 过期键删除策略</h3><p>定时删除: 在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作。<br>惰性删除: 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。<br>定期删除: 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><h4 id="2-2-1-定时删除"><a href="#2-2-1-定时删除" class="headerlink" title="2.2.1 定时删除"></a>2.2.1 定时删除</h4><p>定时删除对内存友好，对CPU时间不友好，在过期键比较多的情况下，删除过期键这一行为可能会占用相同一部分CPU时间。</p><h4 id="2-2-2-惰性删除"><a href="#2-2-2-惰性删除" class="headerlink" title="2.2.2 惰性删除"></a>2.2.2 惰性删除</h4><p>惰性删除策略对CPU友好，对内存不友好。有内存泄漏的风险。</p><h4 id="2-2-3-定期删除"><a href="#2-2-3-定期删除" class="headerlink" title="2.2.3 定期删除"></a>2.2.3 定期删除</h4><p>定期删除操作的难点在于如果确定删除操作的时长和频率。</p><h4 id="2-2-4-Redis的过期删除策略"><a href="#2-2-4-Redis的过期删除策略" class="headerlink" title="2.2.4 Redis的过期删除策略"></a>2.2.4 Redis的过期删除策略</h4><p>Redis服务器实际使用的是惰性删除和定期删除两种策略。</p><h4 id="2-2-5-AOF、RDB和复制功能对过期键的处理"><a href="#2-2-5-AOF、RDB和复制功能对过期键的处理" class="headerlink" title="2.2.5 AOF、RDB和复制功能对过期键的处理"></a>2.2.5 AOF、RDB和复制功能对过期键的处理</h4><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件是，程序会对数据库中的键进行检查，已过期的键不会保存到新建的RDB文件中。</p><p><strong>RDB文件载入：</strong></p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模型运行，那么载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过主从服务器在进行数据同步时，从服务器的数据库会被清空。</li></ul><p>AOF重写的过程中，会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><p>当服务器在复制模式下时，从服务器的过期键删除动作有主服务器控制:</p><ul><li>主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告诉从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，及时碰到过期键也不会将过期键删除，而继续像处理未过期的键一样处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令后，才会删除过期键。</li></ul><h4 id="2-2-6-数据库通知"><a href="#2-2-6-数据库通知" class="headerlink" title="2.2.6 数据库通知"></a>2.2.6 数据库通知</h4><p>数据库通知时Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>监听索引为0的键空间key为message所有操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SUBSCRIBE __keyspace@0__:message</span><br></pre></td></tr></table></figure></p><h3 id="2-3-RDB持久化"><a href="#2-3-RDB持久化" class="headerlink" title="2.3 RDB持久化"></a>2.3 RDB持久化</h3><h4 id="2-3-1-RDB文件的创建与载入"><a href="#2-3-1-RDB文件的创建与载入" class="headerlink" title="2.3.1 RDB文件的创建与载入"></a>2.3.1 RDB文件的创建与载入</h4><p>Redis命令可用于生成RDB文件，一个是SAVE，另一个是BGSAVE。<br>SAVE会阻塞Redis服务进程，知道RDB文件创建完毕，阻塞期间，服务器不能处理任何命令请求。<br>BGSAVE命令会派生除一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理命令请求。<br>BGSAVE命令正在执行，客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕后执行。<br>BGREWRITEAOF正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</p><blockquote><p>如果开启了AOF持久化功能，服务器会优先使用AOF文件还原数据库状态。<br>只有AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</p></blockquote><h4 id="2-3-2-自动间隔性保存"><a href="#2-3-2-自动间隔性保存" class="headerlink" title="2.3.2 自动间隔性保存"></a>2.3.2 自动间隔性保存</h4><h4 id="2-3-3-RDB文件结构"><a href="#2-3-3-RDB文件结构" class="headerlink" title="2.3.3 RDB文件结构"></a>2.3.3 RDB文件结构</h4><p><img src="/media/article/rdb-structure.png" alt="rdb"></p><p>REDIS部分用来校验是否为RDB文件。<br>db_version长度为4字节，记录RDB文件的版本号。<br>databases部分包含着两个或者任意多个数据库，以及各个数据库中的键值对数据。<br>EOF标志着RDB文件的正文结束。<br>check_sum保存着一个校验和，由REDIS、db_version、databases、EOF计算得出。校验RDB文件是否出错或者损坏。</p><p>database部分保存任意多个非空数据库，如下图所示，每个非空数据库可以保存SELECTDB、db_number、key_value_pairs:</p><p><img src="/media/article/rdb-structure1.png" alt="rdb"><br><img src="/media/article/rdb-database.png" alt="rdb"></p><p>SELEECT表示数据库号码。<br>db_number保存一个数据库号码。<br>key_value_pairs保存数据库中的所有键值对数据。</p><p><img src="/media/article/rdb-file-structure.png" alt="rdb"></p><p>key_values_pairs保存了一个以上的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。<br>不过期时间的键值对由TYPE、key、value组成。<br>TYPE:</p><ul><li>REDIS_RDB_TYPE_STRING</li><li>REDIS_RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_ZIPLIST</li></ul><p>过期时间的键值对在RDB文件中结构:<br><img src="/media/article/rdb-expire-structure.png" alt="rdb"></p><h3 id="2-4-AOF持久化"><a href="#2-4-AOF持久化" class="headerlink" title="2.4 AOF持久化"></a>2.4 AOF持久化</h3><p>AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤。</p><h4 id="2-4-1-命令追加"><a href="#2-4-1-命令追加" class="headerlink" title="2.4.1 命令追加"></a>2.4.1 命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-2-文件写入与同步"><a href="#2-4-2-文件写入与同步" class="headerlink" title="2.4.2 文件写入与同步"></a>2.4.2 文件写入与同步</h4><p>写入：其实写入到OS的内存缓存区，还未写入到aof文件。<br>同步：将os的缓冲区刷入到aof文件，完成同步。<br>Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def eventLoop():</span><br><span class="line">    while True:</span><br><span class="line">        # 处理文件事件，接收命令请求以及发送命令回复</span><br><span class="line">        # 处理命令请求时可能会有新内容被追加到aof_buf缓冲区中</span><br><span class="line">        processFileEvents()</span><br><span class="line">        </span><br><span class="line">        # 处理时间事件</span><br><span class="line">        processTimeEvents()</span><br><span class="line">        </span><br><span class="line">        # 考虑是否将aof_buf中的内容写入和保存到AOF文件里面</span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure><p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定，各个不同值产生的行为如表:<br><img src="/media/article/appendfsycn.png" alt="appendfsync"></p><h4 id="2-4-3-AOF重写"><a href="#2-4-3-AOF重写" class="headerlink" title="2.4.3 AOF重写"></a>2.4.3 AOF重写</h4><p>因为AOF通过保存执行的写命令来记录数据库状态，所以可能造成AOF文件过大。为了解决这个问题，Redis提供了AOF文件重写功能。通过创建一个新的AOF文件替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF通常比旧AOF小得多。<br>重写功能通过读取服务器当前的数据状态来实现的。因为aof——rewirte函数生成的新的AOF只包含还原当前数据库状态所必需的的命令，所以新AOF文件不会浪费任何硬盘空间。</p><p><strong>注意:</strong><br>在实际中，为了避免执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查所包含的元素数量，如果元素数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值。</p><p>aof_rewrite会长时间阻塞，所以Redis将AOF重写程序放到子进程里执行:</p><ul><li>子进程进行AOF重写期间，服务器进程可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>AOF重写期间，客户端命令可能对现有数据库状态修改，造成当前数据库状态和AOF文件不一致的情况。</p><p>为了解决不一致的情况，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令后，它同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>AOF完成重写后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作:</p><ul><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子的覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ul><p>AOF后台重写过程中，只有信号处理函数执行时会对服务器进程造成阻塞，其他时候，AOF不会阻塞父进程。</p><h3 id="2-5-事件"><a href="#2-5-事件" class="headerlink" title="2.5 事件"></a>2.5 事件</h3><p>Redis服务器是一个事件驱动程序:</p><ul><li>文件事件: Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信产生响应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件: Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h4 id="2-5-1-文件事件"><a href="#2-5-1-文件事件" class="headerlink" title="2.5.1 文件事件"></a>2.5.1 文件事件</h4><p>Redis基于Reactor模式开发了自己的网络事件处理器: 这个处理器被称为文件事件处理器:</p><ul><li>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><h4 id="2-5-2-时间事件"><a href="#2-5-2-时间事件" class="headerlink" title="2.5.2 时间事件"></a>2.5.2 时间事件</h4><p>Redis的时间事件分为以下两类:</p><ul><li>定时事件: 让一段程序在指定的时间之后执行一次。</li><li>周期性时间: 让一段程序每隔指定时间执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成:</p><ul><li>id: 服务器为时间事件创建的全局唯一ID。从小到大递增。</li><li>when: 毫秒级精度的UNIX时间戳，记录了时间事件的到达时间。</li><li>timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件: 该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性事件: 当一个时间事件到达之后，服务器会根据事件处理器返回的值，对事件事件的when属性进行更新，这个事件在一段时间之后再次到达，并以这种方式一致更新并运行下去。</li></ul><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行，这些定期操作由redis.c/serverCron函数负责执行，主要工作包括:</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF和RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><h4 id="2-5-3-事件调度与执行"><a href="#2-5-3-事件调度与执行" class="headerlink" title="2.5.3 事件调度与执行"></a>2.5.3 事件调度与执行</h4><p>事件调度和执行由ae.c/aeProcessEvents函数负责。</p><blockquote><p>processFileEvent这个函数并不存在，在实际中，处理已产生文件事件的代码是直接写在aeProcessEvents函数里面。</p></blockquote><p>事件调度和执行规则:</p><ol><li>aeApiPoll函数的最大阻塞时间由到达时间最近当前时间的时间事件决定，这个方法既可以避免服务器对事件事件进行频繁的轮询，也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何事件事件到达，那么服务器将再次等待处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件。</li><li>对文件事件和时间事件的处理都是同步、有序、原子的执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此不管是文件事件的处理器，还是时间事件的处理器，也不会对事件进行抢占，一次不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可的减少程序阻塞时间，并在有需要时主动让出执行权，从而降低造成时间饥饿的可能性。另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li><li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间晚一些。</li></ol><h2 id="3-多机数据库实现"><a href="#3-多机数据库实现" class="headerlink" title="3. 多机数据库实现"></a>3. 多机数据库实现</h2><h3 id="3-1-复制"><a href="#3-1-复制" class="headerlink" title="3.1 复制"></a>3.1 复制</h3><p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制(replicate)另一个服务器。</p><p>Redis复制功能分为同步和命令传播两个操作：</p><ul><li>同步操作用于将服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致的状态。</li></ul><p>Redis复制实现：</p><ol><li>客户端发送命令(此命令是异步的)：<code>&gt;SLAVEOF master-ip master-port</code>。</li><li>1命令在从服务上完成masterhost和masterport属性的设置之后，从服务器返回OK。</li><li>从服务器根据masterhost和masterport建立socket连接。</li><li>发送PING命令，检查socket连接的读写状态，检查主服务器的命令处理，如果主服务器返回非PONG，则断开并重连主服务器。</li><li>从服务器发送身份验证信息。</li><li>发送从服务器的端口信息。</li><li>同步PSYNC。</li><li>最后命令传播。</li></ol><p>Redis复制流程图：</p><p><img src="/media/article/redis-replicate.png" alt="redis-replicate"></p><p>从Redis 2.8版本开始，Redis使用PSYNC代替SYNC命令执行复制操作。<br>PSYNC命令执行：</p><p><img src="/media/article/psync.png" alt="PSYNC"></p><p>PSYNC与SYNC最显著的区别是PSYNC支持部分重同步。</p><h3 id="3-2-Sentinel"><a href="#3-2-Sentinel" class="headerlink" title="3.2 Sentinel"></a>3.2 Sentinel</h3><p>Sentinel是Redis的高可用解决方案。</p><p>启动Sentinel时，执行<code>redis-server /path/sentinel.conf --sentinel</code>或者<code>redis-sentinel /path/sentinel.conf</code>命令即可。</p><p>Sentinel启动时，需要执行以下步骤：</p><ol><li>初始化服务器</li><li>将普通Redis服务器使用的代码替换成Sentinel专用代码</li><li>初始化Sentinel状态</li><li>根据给定配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连向主服务器的网络连接</li></ol><p>Sentinel状态图：<br><img src="/media/article/redis-sentinel-state.png" alt="redis-sentinel-state"></p><h4 id="3-2-1-获取主从、Sentinel的信息"><a href="#3-2-1-获取主从、Sentinel的信息" class="headerlink" title="3.2.1 获取主从、Sentinel的信息"></a>3.2.1 获取主从、Sentinel的信息</h4><p>初始化Sentinel最后一步是创建连向主服务器的网络连接，Sentinel将成为主服务器的客户端。</p><p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络：</p><ul><li>命令连接，这个连接专门向主服务器发送命令，并接收命令回复。</li><li>订阅连接，这个连接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道。 </li></ul><p>Sentinel默认以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，通过INFO获取主服务器的当前信息。<br>Sentinel通过主服务器发现从服务器时，也会建立上述的两个连接，每10秒发送INFO命令，获取从服务器的当前信息。<br>默认情况下，Sentinel每2秒通过命令连接向所有主从服务器发送如下命令：<br><code>PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_id&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;</code>“</p><p>s开头的是sentinel的信息，m开头的是主服务器的信息，如果发送的是从服务器，则m为从服务器正在复制的主服务器的信息。<br>Sentinel与一个主或从服务器建立订阅连接后，Sentinel就会通过订阅连接，向服务器发送以下命令:<br><code>SUBSCRIBE __sentinel__:hello</code></p><p>Sentinel通过频道信息发现一个新的Sentinel时，不仅会为新的Sentinel创建相应的实例结构，还会创建一个连向新Sentinel的命令连接。</p><h4 id="3-2-1-下线状态"><a href="#3-2-1-下线状态" class="headerlink" title="3.2.1 下线状态"></a>3.2.1 下线状态</h4><p>Sentinel每1秒一次的频率向所有与它建立命令连接的实例发送PING命令，判断是否在线。<br>实例在down-after-milliseconds内返回+PONG、-LOADING、-MASTERDOWN以外的回复，Sentinel将修改该实例的flags属性:SRI_S_DOWN标识，标识进入主观下线状态。<br>超时也会被置为主观下线状态。</p><p>当主服务器被判定为主观下线后，为确认是否真的下线了，Sentinel会询问监视此服务器的其他Sentinel，如果从其他Sentinel得到足够数量的已下线判断后，Sentinel将此服务器置为客观下线。</p><p>Redis下线状态及Sentinel领头选举：<br><img src="/media/article/redis-down.png" alt="redis-down"><br>上图中，1. master代表一个主服务器，2. 监视master的sentinel代表其中一个监视master的sentinel(所有监视master的sentinel都会这样去操作，这个地方只是列出来一个作为示例)，3. 监视master的sentinel代表监视master的sentinel的集合。</p><h4 id="3-2-2-故障转移"><a href="#3-2-2-故障转移" class="headerlink" title="3.2.2 故障转移"></a>3.2.2 故障转移</h4><p>故障转移步骤：</p><ul><li><ol><li>在已下线的主服务器的从服务器中，选一个作为主服务器。</li></ol></li><li><ol start="2"><li>让其他没有作为主服务器的从服务器复制新的主服务器。</li></ol></li><li><ol start="3"><li>将已下线的主服务器置为新主服务器的从服务器，当下线的主服务器再上线时，它就会成为新主服务器的从服务器。</li></ol></li></ul><h3 id="3-3-集群"><a href="#3-3-集群" class="headerlink" title="3.3 集群"></a>3.3 集群</h3><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。</p><h4 id="3-3-1-节点"><a href="#3-3-1-节点" class="headerlink" title="3.3.1 节点"></a>3.3.1 节点</h4><p>当一个节点node发送<code>CLUSTER MEET &lt;IP&gt; &lt;PORT&gt;</code>命令，可以让node节点与ip和port所指定的节点进行握手(handshake)，当握手成功后，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。<br>集群数据结构示例:<br><img src="/media/article/redis-cluster.png" alt="cluster"></p><h4 id="3-3-2-槽"><a href="#3-3-2-槽" class="headerlink" title="3.3.2 槽"></a>3.3.2 槽</h4><p>Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为16384个槽(slot)，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理0个或者最多16384个槽。</p><p>如果16384个槽都有节点在处理时，集群处于上线状态(ok)，相反如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态(fail)。</p><p>槽分配命令<code>CLUSTER ADSLOTS &lt;slot&gt; [slot ...]</code>，例如<code>127.0.0.1:6379&gt;cluster addslots 0 1 2 ... 1000</code>将0到1000的槽分配给本地的6379节点负责。</p><p>槽分配后节点的ClusterState结构:</p><p><img src="/media/article/redis-clusterstate.png" alt="clusterstate"></p><p>集群节点数据库存储结构:</p><p><img src="/media/article/redis-clusterstate1.png" alt="clusterstate"></p><p>集群节点保存key对应槽的跳跃表:</p><p><img src="/media/article/redis-slots-to-key.png" alt="clusterstate"></p><h4 id="3-3-3-分片"><a href="#3-3-3-分片" class="headerlink" title="3.3.3 分片"></a>3.3.3 分片</h4><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的减值对也会从源节点被移动到目标节点。</p><p>Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重分配分片所需要的所有命令。</p><p>Redis重分片迁移过程:</p><p><img src="/media/article/redis-migrate.png" alt="migrate"></p><p>迁移过程中，查询key的命令过程如下:</p><p><img src="/media/article/redis-ask.png" alt="redis-ask"></p><p><img src="/media/article/redis-asking.png" alt="redis-asking"></p><h4 id="3-3-4-故障检测"><a href="#3-3-4-故障检测" class="headerlink" title="3.3.4 故障检测"></a>3.3.4 故障检测</h4><p>集群中的每个节点都会定期的向集群中的其他节点发送PING消息，以此来检测对方是否在线。</p><h4 id="3-3-5-消息"><a href="#3-3-5-消息" class="headerlink" title="3.3.5 消息"></a>3.3.5 消息</h4><p>集群中的各个节点通过发送和接收消息(message)来进行通信。消息主要以下五种:</p><ul><li>MEET消息:当发送者接收客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</li><li>PING消息:集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对五个节点中最长时间没有发送过PING消息的节点发送PING消息。</li><li>PONG消息:当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。</li><li>FAIL消息:当一个主节点A判断另一个主节点B进入FAIL状态时，节点A会向集群广播一条关于B的FAIL消息，所有接收到这条消息的节点都会立即将B标记为已下线。</li><li>PUBLISH消息:当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收者都会执行相同的PUBLISH命令。</li></ul><p>Redis集群中的各个节点通过Gossip协议来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG是三种消息实现。三种消息使用相同的消息正文，通过消息头type区分消息。</p><h2 id="4-独立功能的实现"><a href="#4-独立功能的实现" class="headerlink" title="4. 独立功能的实现"></a>4. 独立功能的实现</h2><h3 id="4-1-事务"><a href="#4-1-事务" class="headerlink" title="4.1 事务"></a>4.1 事务</h3><p>Redis 通过MULTI、EXEC、WATCH等命令来说实现事务。<br>事务在执行期间，服务器不会中断事务处理其他请求。</p><h4 id="4-1-1-事务的实现"><a href="#4-1-1-事务的实现" class="headerlink" title="4.1.1 事务的实现"></a>4.1.1 事务的实现</h4><p>一个事务从开始时到结束通常经历3个阶段:</p><ol><li>事务开始: MULTI</li><li>命令入队: <command></li><li>事务执行: EXEC</li></ol><h4 id="4-1-2-WATCH-命令的实现"><a href="#4-1-2-WATCH-命令的实现" class="headerlink" title="4.1.2 WATCH 命令的实现"></a>4.1.2 WATCH 命令的实现</h4><p>WATCH命令是一个乐观锁(optimistic locking)，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少少有一个已经被修改过了，如果是，则拒绝执行事务，并向客户端返回代表事务执行失败的空回复。<br>每个Redis数据库都保存着一个watched_keys字典，这个字典的键时某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。<br>如果有修改命令对数据库键修改过，那么touchWatchKey函数将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，标识该客户端的事务安全性被破坏。</p><p><img src="/media/article/watch-transaction.png" alt="watch"></p><h4 id="4-1-3-事务的ACID性质"><a href="#4-1-3-事务的ACID性质" class="headerlink" title="4.1.3 事务的ACID性质"></a>4.1.3 事务的ACID性质</h4><p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕。</p><p>Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性，从而确保事务的一致性。以下介绍Redis事务可能出错的地方，并说明Redis是如何妥善处理这些错误。</p><ol><li>入队错误：服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被带有入队错误的事务影响。</li><li>执行错误：</li></ol><ul><li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时触发。</li><li>即使在事务的执行过程中发生错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令不会被出错的命令影响。</li></ul><ol start="3"><li>服务器停机：</li></ol><ul><li>如果Redis服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。</li><li>如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，空白的总是一致的。</li><li>如果服务器运行在AOF模式下，那么事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>BGSAVE 是否会存执行BGSAVE命令后客户端请求的命令？</li><li>假如说每秒执行一次AOF持久化，那么Redis从aof缓冲区写入AOF文件时，服务端处理的命令是否会存入缓冲区，是否会进入AOF文件？</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong><em>文中的列表和图片大都引用自<a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a></em></strong></p><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现（第二版）</a><br><a href="https://blog.csdn.net/harleylau/article/details/80534159" target="_blank" rel="noopener">harleylau-Redis源码解析-quicklist</a><br><a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">三石雨-Redis结构之quicklist</a><br><a href="http://www.hangdaowangluo.com/archives/613" target="_blank" rel="noopener">Redis中的列表对象(List)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>How to Write Doc Comments for the Javadoc Tool</title>
      <link href="/java/2019-05-19-javadoc-guide/"/>
      <url>/java/2019-05-19-javadoc-guide/</url>
      
        <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.oracle.com/technetwork/articles/javase/index-137868.html" target="_blank" rel="noopener">How to Write Doc Comments for the Javadoc Tool</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 泛型</title>
      <link href="/java/2019-05-06-java-generics/"/>
      <url>/java/2019-05-06-java-generics/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote><p><strong>其他参数术语：</strong><br>参数化的类型(parameterized type)：<code>List&lt;String&gt;</code><br>实际类型参数(type arguments)：<code>String</code><br>泛型(generic type)：<code>List&lt;E&gt;</code><br>形式类型参数(formal parameter types)：<code>E</code><br>无限制通配符类型(unbounded wildcards)：<code>List&lt;?&gt;</code><br>原生态类型(raw type)：<code>List</code><br>有限制类型参数(bounded type parameter)：<code>&lt;E extends Number&gt;</code><br>递归类型限制(recursive type restriction)：<code>&lt;T extends Comparable&lt;T&gt;&gt;</code><br>有限制通配符类型(bounded wildcards)：<code>List&lt;? extends Number&gt;</code><br>泛型方法(generic method)：<code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code><br>类型令牌(type token)：<code>String.class</code></p><p>– 摘自《Effective Java》</p></blockquote><p>Java集合有个缺点：集合对元素类型没有任何限制，这样就会引发一些问题，例如：创建一个只保存Dog对象的集合，但是程序也能将Cat对象放进去。由于把对象放进集合时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此去除集合元素后通常还需要进行强制类型转换。</p><p>为了解决上述问题，从JDK1.5之后，Java引入了“参数化类型（parameterized type）”的概念，Java的参数化类型被称为泛型（Generic）。</p><p>所谓泛型：就是允许在定义类、接口时指定类型形参（type parameters），这个类型形参将在声明变量、创建对象时确定。泛型的作用就是在编译时保证类型安全。</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>定义泛型接口、类示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义接口时指定一个类型形参</span><br><span class="line">public interface List&lt;E&gt;&#123;</span><br><span class="line">    //在接口里，E可以作为类型使用</span><br><span class="line">    void add(E x);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    E asList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>注意：</em></strong></p><ul><li>包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参(type arguments)，从而可以动态生成无数多个逻辑上的子类，但这种子类在物理上并不存在。</li><li>当创建泛型声明的自定义类，为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明。例如：为<code>Apple&lt;T&gt;</code>类定义构造器，其构造器名依然是<code>Apple</code>，而不是<code>Apple&lt;T&gt;</code>，但调用构造器时可以使用<code>Apple&lt;T&gt;</code>，此时T应该为实参类型。</li></ul><h3 id="2-1-从泛型类派生子类"><a href="#2-1-从泛型类派生子类" class="headerlink" title="2.1 从泛型类派生子类"></a>2.1 从泛型类派生子类</h3><p>当创建子类使用泛型接口或类时，不能再包含类型形参。如下代码时错误的：<br><code>public class A extends Apple&lt;T&gt;{}</code><br>正确方式如下：<br><code>public class A extends Apple&lt;String&gt;{}</code></p><p>类的静态变量和方法在所有的实例间共享，所以在静态方法、静态初始化或者静态变量的声明和初始化中不允许使用类型形参。原因见<a href="#4-3-不能声明静态字段的类型为类型参数">4.3 不能声明静态字段的类型为类型参数</a></p><p>由于系统对于泛型类或接口并不会生成真正的泛型类或接口（即逻辑上的子类，并不是生成真正的子类），所以instanceof运算符后不能使用泛型类。（具体原因见<a href="#4-4-不能使用参数化类型强制类型转换或者instanceof">4.4 不能使用参数化类型强制类型转换或者instanceof</a>）如下的代码时错误的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = new ArrayList&lt;String&gt;();</span><br><span class="line">if(cs instanceof List&lt;String&gt;)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-类型通配符"><a href="#2-2-类型通配符" class="headerlink" title="2.2 类型通配符"></a>2.2 类型通配符</h3><p>类型通配符既可以在方法签名中定义形参的类型，也可以用于定义变量的类型。使用通配符比显式声明通配符声明类型形参更加清晰准确，所以在可能的情况下，使用通配符更好。</p><h4 id="2-2-1-不受约束的通配符"><a href="#2-2-1-不受约束的通配符" class="headerlink" title="2.2.1 不受约束的通配符"></a>2.2.1 不受约束的通配符</h4><p>通配符可用于各种情况：作为参数，字段或局部变量的类型;有时作为返回类型（虽然更好的编程实践更具体）。通配符从不用作泛型方法调用，泛型类实例创建或超类型的类型参数。</p><p>如果满足下面的条件任意一个，就可以使用不受约束通配符：</p><ul><li>如果你正在编写可以<strong>使用Object类中提供的方法实现</strong>的方法。</li><li>当代码使用在泛型类中不依赖类型参数方法时。例如：List.size 或者 List.clear。 事实上，Class&lt;?&gt;经常被使用，因为Class<t>中的大多数方法不依赖T。</t></li></ul><p>使用通配符时，不能将元素放入未知类型的集合中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aaa&quot;);//这行代码引起编译时错误。因为不知道list的类型，所以不能往里面放任何元素，除了null。</span><br></pre></td></tr></table></figure><h4 id="2-2-2-上限通配符"><a href="#2-2-2-上限通配符" class="headerlink" title="2.2.2 上限通配符"></a>2.2.2 上限通配符</h4><p>使用<code>? extend type</code>表示所有type泛型类的子类（包含type本身）。</p><h4 id="2-2-3-下限通配符"><a href="#2-2-3-下限通配符" class="headerlink" title="2.2.3 下限通配符"></a>2.2.3 下限通配符</h4><p>使用<code>? super type</code>表示所有type泛型类的父类（包含type本身）。<del>只能用于泛型方法（有待验证）。</del></p><h4 id="2-2-4-通配符捕获和Helper方法"><a href="#2-2-4-通配符捕获和Helper方法" class="headerlink" title="2.2.4 通配符捕获和Helper方法"></a>2.2.4 通配符捕获和Helper方法</h4><p>在一些情况下，编译器会推断一个通配符的类型。例如，一个列表可以被定义为<code>List&lt;?&gt;</code>，当评估一个表达式时，编译器会从代码中推断一个特定类型。此方案称为通配符捕获。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardError &#123;</span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.set(0, i.get(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>i.set</code>方法编译异常，类型参数<code>List&lt;?&gt;</code>为不确定类型参数，所以<code>i.get(0)</code>获取的类型参数不确定，因此<code>i.set</code>方法不能将未知类型放入<code>i</code>中。（其中i.set默认是i.set(Integer,Object)，因为不确定i.get(0)的类型，所以产生编译问题）解决方案如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardFixed &#123;</span><br><span class="line"></span><br><span class="line">    void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // Helper method created so that the wildcard can be captured</span><br><span class="line">    // through type inference.</span><br><span class="line">    private &lt;T&gt; void fooHelper(List&lt;T&gt; l) &#123;</span><br><span class="line">        l.set(0, l.get(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-通配符和子类型"><a href="#2-2-5-通配符和子类型" class="headerlink" title="2.2.5 通配符和子类型"></a>2.2.5 通配符和子类型</h4><p>如泛型，继承和子类型中所述，泛型类或接口仅仅因为它们的类型不同而无关。但是，您可以使用通配符在泛型类或接口之间创建关系。下图是Number和Integer之间的继承关系：<br><img src="/media/article/15579245029350.jpg" alt=""></p><h3 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c)&#123;</span><br><span class="line">    for(T o:a)&#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面示例中，定义了一个泛型方法，该泛型方法中定义了一个T类型形参，这个T类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型形参不同的是，方法声明中定义的形参只能在该方法里使用，而接口、类声明中的定义的类型形参则可以在整个接口、类中使用。<br>与类、接口中使用泛型参数不同的是，方法中的泛型参数无需显式传入实际类型参数，根据实参推断类型形参的值。如果编译器不能推断你希望它拥有的类型，可以通过一个显示的类型参数（explicit type parameter）来告诉它要使用哪种类型。<br>泛型方法的用法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,S&gt; 返回值类型 方法名（形参列表）&#123;</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><em>提示：</em></strong><br>如果某个方法中一个形参（a）的类型或返回值类型依赖于另一个形参（b）的类型，则形参（b）的类型声明不应该使用通配符，因为形参（a）、或返回值与该形参（b）的类型，如果形参（b）的类型无法确定，程序无法定义形参（a）的类型。在这种情况下，<strong><em>只能考虑使用在方法签名中声明类型形参</em></strong>。</p></blockquote><p>类型通配符与显式声明类型形参区别：</p><ul><li>类型通配符即可在方法签名中定义形参的类型，也可以用于定义变量的类型。但泛型方法中类型形参必须在对应方法中显式声明。</li><li><strong><em>泛型方法允许类型形参用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的类型依赖关系。如果没有这样的依赖关系，不应该使用泛型方法。</em></strong></li></ul><h3 id="2-4-泛型使用准则"><a href="#2-4-泛型使用准则" class="headerlink" title="2.4 泛型使用准则"></a>2.4 泛型使用准则</h3><blockquote><p>“in”变量：in变量向代码提供数据。想象复制方法有两个参数：<code>copy(src, dest)</code>。<code>src</code>参数提供复制数据，因此时”in”参数。<br>“out”变量：out变量保存数据以供其他地方使用。在复制的例子中，<code>copy(src, dest)</code>，<code>dest</code>参数接受数据，因此时”out”参数。</p></blockquote><ul><li>使用<code>extends</code>关键字定义带有上限通配符的“in”变量。</li><li>使用<code>super</code>关键字定义带有下限通配符的“out”变量。</li><li>在可以使用Object类中定义的方法访问“in”变量的情况下，使用无界通配符。</li><li>在代码需要作为“in”和“out”变量访问的情况下，不要使用通配符。</li></ul><h2 id="3-泛型的擦除与转换"><a href="#3-泛型的擦除与转换" class="headerlink" title="3. 泛型的擦除与转换"></a>3. 泛型的擦除与转换</h2><p>泛型被引入Java语言，以便在编译时提供更严格的类型检查并支持通用编程（向上兼容）。为了实现泛型，Java编译器将类型擦除应用于：</p><ul><li>使用边界替换所有在泛型中的类型参数或者如果类型参数是无界的则使用<code>Object</code>替换。因此生成的字节码只包含通用的类，接口和方法。</li><li>如果必要，插入类型强制转换来保证类型安全。</li><li>生成桥接方法以保留扩展泛型类型中的多态性。</li></ul><p>对于以上3点，1和3可能在<a href="#3-1-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E6%93%A6%E9%99%A4">3.1</a>和<a href="#3-2-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E6%A1%A5%E6%96%B9%E6%B3%95">3.2</a>中会详细说明，但是第二点可能不是那么清楚，如果有必要，类型擦除时，会进行强制类型转换。一般这种情况包括：</p><ul><li>方法的返回类型是类型参数；</li><li>在访问数据域时，域的类型是一个类型参数。</li></ul><p>例如：<br>项目中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println(list1.get(0));</span><br></pre></td></tr></table></figure></p><p>编译后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list1 = new ArrayList();</span><br><span class="line">list1.add(&quot;Hell&quot;);</span><br><span class="line">System.out.println((String)list1.get(0));</span><br></pre></td></tr></table></figure></p><p>字节码，字节码命令请参阅<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Chapter 6. The Java Virtual Machine Instruction Set</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">       0: new           #3                  // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #4                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #5                  // String Hell</span><br><span class="line">      11: invokeinterface #6,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      16: pop</span><br><span class="line">      17: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: iconst_0</span><br><span class="line">      22: invokeinterface #8,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">      27: checkcast     #9                  // class java/lang/String 强制类型转换校验是否为String类型</span><br><span class="line">      30: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      33: return</span><br></pre></td></tr></table></figure></p><p>上面的例子说明，编译器在擦除泛型代码时，确实保留了List<string>的相关信息，但是你无法找到列表对象本身的T=String，参阅自<a href="https://stackoverflow.com/questions/339699/java-generics-type-erasure-when-and-what-happens/339708#339708" target="_blank" rel="noopener">Java generics type erasure: when and what happens?</a>Jon Skeet的answer。</string></p><p>详细了解请参阅<a href="https://stackoverflow.com/questions/55084504/insert-type-casts-if-necessary-to-preserve-type-safety" target="_blank" rel="noopener">Insert type casts if necessary to preserve type safety</a></p><h3 id="3-1-泛型方法的擦除"><a href="#3-1-泛型方法的擦除" class="headerlink" title="3.1 泛型方法的擦除"></a>3.1 泛型方法的擦除</h3><p>Java编译器也会擦除泛型方法中的类型参数。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static &lt;T&gt; int count(T[] anArray, T elem)&#123;</span><br><span class="line"></span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(T e : anArray)&#123;</span><br><span class="line">        if(e.equals(elem))&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为T是无限制的，所以Java编译器会使用Object代替它，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int count(Object[] anArray, Object elem) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (Object e : anArray)</span><br><span class="line">        if (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-类型擦除的影响和桥方法"><a href="#3-2-类型擦除的影响和桥方法" class="headerlink" title="3.2 类型擦除的影响和桥方法"></a>3.2 类型擦除的影响和桥方法</h3><p>在编译扩展参数化类或实现参数化接口的类或接口时，编译器可能需要创建一个称为桥接方法的合成方法，作为类型擦除过程的一部分。您通常不需要担心桥接方法，但如果出现在堆栈跟踪中，您可能会感到困惑。</p><p>生成桥接方法以保留扩展泛型类型中的多态性。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T data;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = mn;            // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);     </span><br><span class="line">Integer x = mn.data;    // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>类型擦除后, 代码变成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = new MyNode(5);</span><br><span class="line">Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;);</span><br><span class="line">Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.</span><br></pre></td></tr></table></figure></p><p>代码执行逻辑如下：</p><p><code>n.setData(&quot;Hello&quot;)</code>使得MyNode类对象中的<code>setData(Object)</code>被执行。<br>在<code>setData(Object)</code>方法体内，对象的数据字段引用被分配为String。<br>通过mn引用的相同对象数据字段，可以访问、且期望是Interger类型。<br>尝试分配String到Integer造成ClassCastException。</p><p>类型擦除后代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line"></span><br><span class="line">    public Object data;</span><br><span class="line"></span><br><span class="line">    public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类型擦除之后，方法签名不匹配。 Node方法变为setData（Object），MyNode方法变为setData（Integer）。因此，MyNode setData方法不会覆盖Node setData方法。 为了解决这个问题并在类型擦除后保留泛型类型的多态性，Java编译器会生成一个桥接方法，以确保子类型按预期工作。对于MyNode类，编译器为setData生成以下桥接方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    // Bridge method generated by the compiler</span><br><span class="line">    //</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>桥接方法与类型擦除后的Node类的setData方法具有相同的方法签名，委托给原始的setData方法(桥接方法在字节码中可见，<code>javap -c class</code>)。</p><h3 id="3-3-不可具体化类型"><a href="#3-3-不可具体化类型" class="headerlink" title="3.3 不可具体化类型"></a>3.3 不可具体化类型</h3><p>可具体化类型是在运行时类型信息完全可用的一种类型。包括基本类型，非泛型类型，原始类型，无界的通配符调用。唯一可具体化参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<br>不可具体化类型是类型信息在编译时通过类型擦除被删除————调用未定义为无界通配符的泛型类型。不可具体化的类型在运行时不是所有信息都可用。不可具体化类型的示例是<code>List &lt;String&gt;</code>和<code>List &lt;Number&gt;</code>; JVM无法在运行时区分这些类型。如<a href="#4-泛型的限制">4 泛型的限制</a>中所示，在某些情况下，不能使用不可具体化的类型：例如，在<code>instanceof</code>表达式的实例中，或作为数组中的元素。</p><h3 id="3-4-堆污染"><a href="#3-4-堆污染" class="headerlink" title="3.4 堆污染"></a>3.4 堆污染</h3><p>堆污染发生在当参数化类型的变量引用不是该参数化类型的对象时。如果程序执行某些操作，在编译时产生未经检查的警告，则会出现这种情况。如果在编译时（在编译时类型检查规则的限制内）或在运行时，一个包含参数化类型操作的正确性不能被验证，则会生成未经检查的警告。例如，在混合原始类型和参数化类型时，或者在执行未经检查的强制转换时，会发生堆污染。</p><p>在通常情况下，当所有代码在相同时间被编译，编译器为潜在的堆污染产生一个未经检查警告来引起你的注意。如果你分开编译代码的各个部分，很难检查出堆污染的潜在风险。如果你确保你的代码编译没有警告，则不会有堆污染可以发生。</p><h3 id="3-5-使用不可具体化形参的可变参数方法的潜在漏洞"><a href="#3-5-使用不可具体化形参的可变参数方法的潜在漏洞" class="headerlink" title="3.5 使用不可具体化形参的可变参数方法的潜在漏洞"></a>3.5 使用不可具体化形参的可变参数方法的潜在漏洞</h3><p>包含可变输入参数泛型方法可以造成堆污染。<br>考虑如下class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBuilder &#123;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) &#123;</span><br><span class="line">    for (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void faultyMethod(List&lt;String&gt;... l) &#123;</span><br><span class="line">    Object[] objectArray = l;     // Valid</span><br><span class="line">    objectArray[0] = Arrays.asList(42);</span><br><span class="line">    String s = l[0].get(0);       // ClassCastException thrown here</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下例子，<code>HeapPollutionExample</code>使用<code>ArrayBuilder</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HeapPollutionExample &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stringListA = new ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; stringListB = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.addToList(stringListA, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;);</span><br><span class="line">    ArrayBuilder.addToList(stringListB, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listOfStringLists =</span><br><span class="line">      new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    ArrayBuilder.addToList(listOfStringLists,</span><br><span class="line">      stringListA, stringListB);</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译时，如下<code>ArrayBuilder.addToList</code>方法的定义将产生warning：<br><code>warning: [varargs] Possible heap pollution from parameterized vararg type T</code><br>当编译器遇到一个可变参数方法，它转换可变形参为数组。然而，Java编程语言不允许参数化类型数组的创建。在<code>ArrrayBuilder.addToList</code>方法中，编译器转换可变形参<code>T...</code>要素为<code>T[]</code>要素。因为类型擦除，编译器转换可变形参为<code>Object[]</code>要素。所以，有堆污染的可能性。<br>如下声明分配可变形参给对象数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray = l;</span><br></pre></td></tr></table></figure></p><p>这种声明可能引起堆污染。可以将与可变形参<code>l</code>的参数化类型匹配的值分配给变量objectArray，因此可以分配给<code>l</code>。然而，在此声明中，编译器不能生成一个未经检查警告。编译器早已在转换可变形参<code>List&lt;String&gt;...l</code> 到形参<code>List[] l</code>时生成警告。这个声明是有效的；<code>l</code>变量的类型是<code>List[]</code>，是<code>Object[]</code>的子类型。</p><p>因此，如果将任何类型的List对象分配给objectArray数组的任何数组组件，编译器不会发出警告或错误，如下所示：<br><code>ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</code><br>在运行时，JVM在以下语句中抛出<code>ClassCastException</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ClassCastException thrown here</span><br><span class="line">String s = l[0].get(0);</span><br></pre></td></tr></table></figure></p><p>存储在变量<code>l</code>的第一个数组组件中的对象具有<code>List&lt;Integer&gt;</code>类型，但此语句需要一个<code>List &lt;String&gt;</code>类型的对象。</p><h3 id="3-6-使用不可具体化的形参防止可变参数方法发出警告"><a href="#3-6-使用不可具体化的形参防止可变参数方法发出警告" class="headerlink" title="3.6 使用不可具体化的形参防止可变参数方法发出警告"></a>3.6 使用不可具体化的形参防止可变参数方法发出警告</h3><p>如果声明具有参数化类型参数的可变参数方法，并确保方法体不会因可变参数形参处理不当而抛出<code>ClassCastException</code>或其他类似异常，你可以通过给静态和非构造方法声明添加如下的注解防止编译器给这些可变参数方法生成警告：<br><code>@SafeVarargs</code><br><code>@SafeVarargs</code>注解是方法约定的记录部分;这个注释断言该方法的实现不会不正确地处理可变形参。<br> 尽管不太可取，但通过在方法声明中添加以下内容来消除此类警告也是可以的：<br><code>@SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})</code><br>但是，此方法不会消除从方法的调用点生成的警告。如果您不熟悉<code>@SuppressWarnings</code>语法，请参阅注释。</p><h2 id="4-泛型的限制"><a href="#4-泛型的限制" class="headerlink" title="4 泛型的限制"></a>4 泛型的限制</h2><h3 id="4-1-不能使用基本类型实例化通用类型"><a href="#4-1-不能使用基本类型实例化通用类型" class="headerlink" title="4.1 不能使用基本类型实例化通用类型"></a>4.1 不能使用基本类型实例化通用类型</h3><p>考虑如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public Pair(K key, V value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当创建一个<code>Pair</code>对象，你不能为类型参数<code>K</code>或者<code>V</code>替换成基本类型：<br><code>Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);  // compile-time error</code><br>你仅可以为类型参数<code>K</code>或者<code>V</code>替换非基本类型：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &#39;a&#39;);</code><br>Java编译器自动装箱<code>8</code>为<code>Integer.valueOf(8)</code>和<code>a</code>为<code>Character(&#39;a&#39;)</code>：<br><code>Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character(&#39;a&#39;));</code></p><h3 id="4-2-不能创建类型参数实例"><a href="#4-2-不能创建类型参数实例" class="headerlink" title="4.2 不能创建类型参数实例"></a>4.2 不能创建类型参数实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">    E elem = new E();  // compile-time error</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种解决方案，你可以创建一个类型参数对象通过反射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">    E elem = cls.newInstance();   // OK</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以调用<code>append</code>方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = new ArrayList&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure></p><h3 id="4-3-不能声明静态字段的类型为类型参数"><a href="#4-3-不能声明静态字段的类型为类型参数" class="headerlink" title="4.3 不能声明静态字段的类型为类型参数"></a>4.3 不能声明静态字段的类型为类型参数</h3><p>类的静态字段是类等级变量，被当前类的所有非静态对象共享。因此，类型参数的静态字段是不允许的。考虑如下类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MobileDevice&lt;T&gt; &#123;</span><br><span class="line">    private static T os;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类型参数的静态字段被允许，如下的代码将会混乱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MobileDevice&lt;Smartphone&gt; phone = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;Pager&gt; pager = new MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;TabletPC&gt; pc = new MobileDevice&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>因为静态字段<code>os</code>被<code>phone</code>,<code>pager</code>和<code>pc</code>共享，什么是<code>os</code>的真实类型？在相同的时间它不可能是<code>Smartphone</code>，<code>Pager</code>，和<code>TablePc</code>。因此你不能创建类型参数静态字段。</p><h3 id="4-4-不能使用参数化类型强制类型转换或者instanceof"><a href="#4-4-不能使用参数化类型强制类型转换或者instanceof" class="headerlink" title="4.4 不能使用参数化类型强制类型转换或者instanceof"></a>4.4 不能使用参数化类型强制类型转换或者<code>instanceof</code></h3><p>因为Java编译器在泛型代码中擦除所有类型参数，您无法验证在运行时使用泛型类型的参数化类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>传递到<code>rtti</code>方法的参数化类型集合是：<br><code>S = { ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, ... }</code><br>运行时不保持对类型参数的跟踪，因此它不能告诉<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>之间的不同。你最多是使用无限通配符来验证列表是否为ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;?&gt;) &#123;  // OK; instanceof requires a reifiable type</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通常，你不能强制转换参数化类型，除非它通过无限制通配符参数化。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  // compile-time error</span><br></pre></td></tr></table></figure></p><p>但是，在一些情况下，编译器知道类型参数总是有效的，允许强制类型转换。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  // OK</span><br></pre></td></tr></table></figure></p><h3 id="4-5-不能创建参数化类型的数组"><a href="#4-5-不能创建参数化类型的数组" class="headerlink" title="4.5 不能创建参数化类型的数组"></a>4.5 不能创建参数化类型的数组</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  // compile-time error</span><br></pre></td></tr></table></figure></p><p>如下代码说明在不同类型插入列表是发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] strings = new String[2];</span><br><span class="line">strings[0] = &quot;hi&quot;;   // OK</span><br><span class="line">strings[1] = 100;    // An ArrayStoreException is thrown.</span><br></pre></td></tr></table></figure></p><p>如果你使用泛型列表尝试相同的事情，将会有如下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&apos;s allowed</span><br><span class="line">stringLists[0] = new ArrayList&lt;String&gt;();   // OK</span><br><span class="line">stringLists[1] = new ArrayList&lt;Integer&gt;();  // An ArrayStoreException should be thrown,</span><br><span class="line">                                            // but the runtime can&apos;t detect it.</span><br></pre></td></tr></table></figure></p><p> 如果参数化列表数组是允许的，之前的代码将失败抛出<code>ArrayStoreException</code>。</p><h3 id="4-6-不能创建、捕获或者抛出参数化类型对象"><a href="#4-6-不能创建、捕获或者抛出参数化类型对象" class="headerlink" title="4.6 不能创建、捕获或者抛出参数化类型对象"></a>4.6 不能创建、捕获或者抛出参数化类型对象</h3><p>泛型类也不能直接或间接继承自Throwable。原因是因为在编译期和运行时都必须知道异常的确切类型。例如如下类将不编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Extends Throwable indirectly</span><br><span class="line">class MathException&lt;T&gt; extends Exception &#123; /* ... */ &#125;    // compile-time error</span><br><span class="line"></span><br><span class="line">// Extends Throwable directly</span><br><span class="line">class QueueFullException&lt;T&gt; extends Throwable &#123; /* ... */ // compile-time error</span><br></pre></td></tr></table></figure></p><p>一个方法不能捕获一个类型参数的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (J job : jobs)</span><br><span class="line">            // ...</span><br><span class="line">    &#125; catch (T e) &#123;   // compile-time error</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，你可以在一个<code>throws</code>子句中使用类型参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parser&lt;T extends Exception&gt; &#123;</span><br><span class="line">    public void parse(File file) throws T &#123;     // OK</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出上述泛化的代码。</p><h3 id="4-7-不能重载形式类型参数擦除后相同原始类型的方法"><a href="#4-7-不能重载形式类型参数擦除后相同原始类型的方法" class="headerlink" title="4.7 不能重载形式类型参数擦除后相同原始类型的方法"></a>4.7 不能重载形式类型参数擦除后相同原始类型的方法</h3><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public void print(Set&lt;String&gt; strSet) &#123; &#125;</span><br><span class="line">    public void print(Set&lt;Integer&gt; intSet) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重载将共享相同的类文件表示，并将生成编译时错误。</p><h2 id="5-泛型与数组"><a href="#5-泛型与数组" class="headerlink" title="5. 泛型与数组"></a>5. 泛型与数组</h2><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型<code>Sub[]</code>就是<code>Super[]</code>的子类型。<br>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型是无限制通配符类型，如<code>List&lt;?&gt;</code>和<code>Map&lt;?,?&gt;</code>。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h2 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h2><p>如果以上都看完了，可以访问<a href="https://docs.oracle.com/javase/tutorial/java/generics/QandE/generics-questions.html" target="_blank" rel="noopener">Questions</a>试试自己是否真的懂了。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a><br><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">Effective Java</a><br><a href="https://docs.oracle.com/javase/tutorial/java/generics/" target="_blank" rel="noopener">Java Document Generic</a><br><a href="http://www.jiangjun.name/thinking-in-java/chapter15" target="_blank" rel="noopener">第十五章 泛型</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Effective Java</title>
      <link href="/java/2019-05-02-effective-java/"/>
      <url>/java/2019-05-02-effective-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘自《Effective Java》</p></blockquote><h1 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h1><h2 id="一、创建和销毁对象"><a href="#一、创建和销毁对象" class="headerlink" title="一、创建和销毁对象"></a>一、创建和销毁对象</h2><h3 id="1-考虑使用静态工厂方法替代构造器"><a href="#1-考虑使用静态工厂方法替代构造器" class="headerlink" title="1.考虑使用静态工厂方法替代构造器"></a>1.考虑使用静态工厂方法替代构造器</h3><ul><li>静态工厂方法与构造器不同的第一大优势在于，它们有名称，不必和类名相同。</li><li>静态工厂方法与构造器不同的第二大优势在于不必在每次调用他们的时候都创建一个新的对象。</li><li>静态工厂方法与构造器不同的第三大优势在于他们可以返回原类型的任何子类型对象。</li><li>静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们是代码变得更加简洁。</li><li>静态工厂方法的主要缺点在于类如果不含公有的活着受保护的构造器，就不能被子类化。</li><li>静态工厂方法第二个缺点在于它们与其他的静态方法实际上没有任何区别。</li></ul><h3 id="2-遇到多个构造器参数时要考虑用构建器"><a href="#2-遇到多个构造器参数时要考虑用构建器" class="headerlink" title="2.遇到多个构造器参数时要考虑用构建器"></a>2.遇到多个构造器参数时要考虑用构建器</h3><h3 id="3-用私有构造器或着枚举类强化Singleton属性"><a href="#3-用私有构造器或着枚举类强化Singleton属性" class="headerlink" title="3.用私有构造器或着枚举类强化Singleton属性"></a>3.用私有构造器或着枚举类强化Singleton属性</h3><h3 id="4-通过私有构造器强化不可实例化的能力"><a href="#4-通过私有构造器强化不可实例化的能力" class="headerlink" title="4.通过私有构造器强化不可实例化的能力"></a>4.通过私有构造器强化不可实例化的能力</h3><h3 id="5-避免创建不必要的对象"><a href="#5-避免创建不必要的对象" class="headerlink" title="5.避免创建不必要的对象"></a>5.避免创建不必要的对象</h3><h3 id="6-消除过期的对象引用"><a href="#6-消除过期的对象引用" class="headerlink" title="6.消除过期的对象引用"></a>6.消除过期的对象引用</h3><ul><li>只要类是自己管理内存，程序员就应该警惕内存泄露问题。</li><li>内存泄漏的另一个常见来源是缓存。</li><li>内存的第三个常见来源是监听器和其他回调。确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用。</li></ul><h3 id="7-避免使用终结方法"><a href="#7-避免使用终结方法" class="headerlink" title="7.避免使用终结方法"></a>7.避免使用终结方法</h3><ul><li>终结方法（finalizer）通常是不可预测的，也是危险的，一般情况下是不必要的。</li><li>使用终结方法有非常严重的（Severe）性能损失。</li></ul><h2 id="二、对于所有对象都通用的方法"><a href="#二、对于所有对象都通用的方法" class="headerlink" title="二、对于所有对象都通用的方法"></a>二、对于所有对象都通用的方法</h2><h3 id="8-覆盖equals时请遵守通用约定"><a href="#8-覆盖equals时请遵守通用约定" class="headerlink" title="8.覆盖equals时请遵守通用约定"></a>8.覆盖equals时请遵守通用约定</h3><ul><li>类的每个实例本质都是唯一的。</li><li>不关心类是否提供了“逻辑相等（logical equality）“的测试功能。</li><li>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。</li><li>类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用。</li><li>在覆盖equals方法时，必须遵守：<strong>自反性（reflexive）、对称性（symmetric）、传递性（transitive）、一致性（consistent）和对于任何非null的引用，equals(null)必须返回false</strong>。</li></ul><blockquote><p>里氏替换原则（Liskov substitution principle）认为，一个类型的任何重要属性也将适用它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行的很好。</p></blockquote><ul><li>覆盖equals时总要覆盖hashCode。</li><li>不要企图让equals方法过于智能。</li><li>不要将equals声明中的Object对象替换为其他的类型。</li></ul><h3 id="9-覆盖equals总要覆盖hashCode"><a href="#9-覆盖equals总要覆盖hashCode" class="headerlink" title="9.覆盖equals总要覆盖hashCode"></a>9.覆盖equals总要覆盖hashCode</h3><ul><li>在应用程序的执行期间，只要对象的equals方法比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li><li>如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。<strong>（违反第二条）</strong></li><li>如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定产生不同的整数结果。但是程序猿应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列（hash table）的性能。</li></ul><h3 id="10-始终要覆盖toString"><a href="#10-始终要覆盖toString" class="headerlink" title="10.始终要覆盖toString()"></a>10.始终要覆盖toString()</h3><h3 id="11-谨慎覆盖clone"><a href="#11-谨慎覆盖clone" class="headerlink" title="11.谨慎覆盖clone()"></a>11.谨慎覆盖clone()</h3><ul><li>如果专门为了继承而设计的类，覆盖了clone方法，覆盖版本的clone方法就应该模拟Object.clone的行为：他应该声明为protected、抛出CloneNotSupportedException异常，并且该类不应该实现Cloneable接口。</li><li>如果用线程安全的类实现Cloneable接口，要记得它的clone方法必须得到同步。</li><li>任何实现Cloneable接口的类都应该用一个公有的方法覆盖clone，首先调用super.clone，再修正任何需要修正的域。</li><li>另一种实现对象拷贝的好方法是提供一个拷贝构造器(copy constructor)或者拷贝工厂(copy factory)。</li></ul><h3 id="12-考虑实现Comparable接口"><a href="#12-考虑实现Comparable接口" class="headerlink" title="12.考虑实现Comparable接口"></a>12.考虑实现Comparable接口</h3><h2 id="三、类和接口"><a href="#三、类和接口" class="headerlink" title="三、类和接口"></a>三、类和接口</h2><h3 id="13-使类和成员的可访问性最小化"><a href="#13-使类和成员的可访问性最小化" class="headerlink" title="13.使类和成员的可访问性最小化"></a>13.使类和成员的可访问性最小化</h3><ul><li>尽可能的使每个类或者成员不被外界访问。</li><li>实例域绝不能使公有的。</li><li>类具有共有的静态final数组域，或者返回这种域的访问方法，这种几乎总是错误的。</li><li>公有类都不应该包含公有域，除了公有静态final域的特殊情形外。</li><li>确保公有静态final域所引用的对象都是不可变的。</li></ul><h3 id="14-在公有类中使用访问方法而非公有域"><a href="#14-在公有类中使用访问方法而非公有域" class="headerlink" title="14.在公有类中使用访问方法而非公有域"></a>14.在公有类中使用访问方法而非公有域</h3><ul><li>如果类可以在它所在的包的外部进行访问，就提供访问方法。</li><li>如果类是包级私有的，或者私有的嵌套类，直接暴露它的数据域并没有本质的错误。</li></ul><h3 id="15-使可变性最小化"><a href="#15-使可变性最小化" class="headerlink" title="15.使可变性最小化"></a>15.使可变性最小化</h3><p>不可变类只是实例不能被修改的类。每个实例中包含的信息都必须在创建该实例的时候提供，并在对象的整个生命周期固定不变。</p><ul><li>不要提供任何会修改对象状态的方法。</li><li>保证类不被扩展。</li><li>使所有的域都是final的。</li><li>使所有的域都成为私有的。</li><li>确保对于任何可变组件的互斥访问。</li></ul><h3 id="16-复合优先于继承"><a href="#16-复合优先于继承" class="headerlink" title="16.复合优先于继承"></a>16.复合优先于继承</h3><ul><li>与方法调用不同的是，继承打破了封装性。</li></ul><h3 id="17-要么为继承而设计，并提供文档说明，要么就禁止继承。"><a href="#17-要么为继承而设计，并提供文档说明，要么就禁止继承。" class="headerlink" title="17.要么为继承而设计，并提供文档说明，要么就禁止继承。"></a>17.要么为继承而设计，并提供文档说明，要么就禁止继承。</h3><ul><li>构造器绝不能调用可被覆盖的方法。</li><li>无论是clone还是readObject，都不可以调用可覆盖的方法，不管是以直接还是间接的方式。</li></ul><h3 id="18-接口优于抽象类"><a href="#18-接口优于抽象类" class="headerlink" title="18.接口优于抽象类"></a>18.接口优于抽象类</h3><ul><li>现有的类可以很容易被更新，以实现新的接口。</li><li>接口是定义mixin(混合类型)的理想选择。</li><li>接口允许构造非层次结构的类型框架。</li><li>接口使得安全的增强类的功能成为可能。</li><li>通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的优点结合起来。</li></ul><h3 id="19-接口只用于定义类型"><a href="#19-接口只用于定义类型" class="headerlink" title="19.接口只用于定义类型"></a>19.接口只用于定义类型</h3><ul><li>常量接口模式是对接口的不良使用。</li></ul><h3 id="20-类层级优于标签类"><a href="#20-类层级优于标签类" class="headerlink" title="20.类层级优于标签类"></a>20.类层级优于标签类</h3><h3 id="21-用函数对象表示策略"><a href="#21-用函数对象表示策略" class="headerlink" title="21.用函数对象表示策略"></a>21.用函数对象表示策略</h3><p>策略模式</p><h3 id="22-优先考虑静态成员类"><a href="#22-优先考虑静态成员类" class="headerlink" title="22.优先考虑静态成员类"></a>22.优先考虑静态成员类</h3><p>静态类成员：Map中的Entry<br>非静态类成员：Iterator<br>匿名类：无法实例化，无法声明实现接口，扩展类，无法调用任何成员除了从它的超类继承的，必须简洁，常用来作为函数对象，即函数表达式；另一种是创建过程对象（Runable）<br>局部类：声明局部变量的地方都可以声明局部类。</p><p>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中。</p><h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h3 id="23-请不要在新代码中使用原生态类型"><a href="#23-请不要在新代码中使用原生态类型" class="headerlink" title="23.请不要在新代码中使用原生态类型"></a>23.请不要在新代码中使用原生态类型</h3><ul><li>如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。</li><li>泛型有子类化的规则，虽然可以将List<string>传递给List的参数，但是不能将它传给类型List<object>的参数。</object></string></li><li>如果使用像List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<object>这样的参数化类型，则不会。</object></li><li>在类文字中必须使用原生态类型。</li><li>在参数化类型而非无限制通配符类型上使用instanceof操作法是非法的。</li></ul><h3 id="24-消除非受检警告"><a href="#24-消除非受检警告" class="headerlink" title="24.消除非受检警告"></a>24.消除非受检警告</h3><ul><li>尽可能消除每一个非受检警告</li><li>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，只有这种情况下可以用@SuppressWarnings(“unchecked”)注解来禁止这条警告。</li><li>应该在尽可能小的范围内使用SuppressWarnings注解。</li><li>每当使用SuppressWarnings注解，都要增加注释，说明为什么这么做是安全的。</li></ul><h3 id="25-列表优于数组"><a href="#25-列表优于数组" class="headerlink" title="25.列表优于数组"></a>25.列表优于数组</h3><p>JDK1.5的泛型有一个很重要的设计原则：如果一段代码在编译时系统没有产生：“[unchecked]未经检查的转换“警告，则程序在运行时不会引发”ClassCastException“异常。</p><p>数组是协变的（convariant）: 如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型。<br><strong>数组是具体化的（reified）: 数组在运行时才知道并检查他们的元素类型约束。</strong></p><p>泛型时不可变的（invariant）: 对于任意两个不同的类型Type1和Type2，<code>List&lt;Type1&gt;</code>既不是<code>List&lt;Type2&gt;</code>的子类型，也不是<code>List&lt;Type2&gt;</code>的超类型。</p><p><strong>泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</strong></p><p>从技术角度来说，像<code>E</code>、<code>List&lt;E&gt;</code>和<code>List&lt;String&gt;</code>这样的类型应称作不可具体化（non-reifiable）的类型。不可具体化类型是指其运行时表示法包含的信息比它编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型时无限制通配符类型，如List&lt;?&gt;和Map&lt;?,?&gt;。<strong>创建无限制通配类型的数组是合法的；不可具体化的类型的数组转换只能在特殊情况下使用。</strong></p><h3 id="26-优先考虑泛型"><a href="#26-优先考虑泛型" class="headerlink" title="26.优先考虑泛型"></a>26.优先考虑泛型</h3><ul><li>不能创建不可具体化的（non-reifiable）类型的数组。解决方案是新建Object数组强制转换为不可具体化类型，确保未受检的转换是安全的，就要尽可能小的范围中禁止警告。</li></ul><h3 id="27-优先考虑泛型方法"><a href="#27-优先考虑泛型方法" class="headerlink" title="27.优先考虑泛型方法"></a>27.优先考虑泛型方法</h3><h3 id="28-利用有限制通配符来提升API的灵活性"><a href="#28-利用有限制通配符来提升API的灵活性" class="headerlink" title="28.利用有限制通配符来提升API的灵活性"></a>28.利用有限制通配符来提升API的灵活性</h3><ul><li>为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。</li><li>如果类型参数只在方法声明中出现一次，就可以用通配符取代它，如果是无限制的类型参数，就用无限制的通配符取代它。</li><li>如果类的用户必须考虑通配符类型，类的API或许就会出错。</li><li>不要用通配符类型作为返回类型，除了为用户提供额外的灵活性之外，它还会强制用户在客户端代码中使用通配符类型。</li></ul><h3 id="29-优先考虑类型安全的异构容器"><a href="#29-优先考虑类型安全的异构容器" class="headerlink" title="29.优先考虑类型安全的异构容器"></a>29.优先考虑类型安全的异构容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Favorites&#123;</span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);</span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不像普通的map，它的<strong>所有键都是不同类型</strong>的，因此Favorites称作类型安全的异构容器（typesafe heterogeneous container）。</p><p>集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数，但是可以通过将类型参数放在键上而不是容器上来避开这一限制。</p><h2 id="五、枚举和注解"><a href="#五、枚举和注解" class="headerlink" title="五、枚举和注解"></a>五、枚举和注解</h2><h3 id="30-用enum代替int常量"><a href="#30-用enum代替int常量" class="headerlink" title="30.用enum代替int常量"></a>30.用enum代替int常量</h3><p>只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。</p><p>如果多个枚举常量同时共享相同的行为，则考虑策略枚举（strategy enum）。</p><h3 id="31-用实例代替序数索引"><a href="#31-用实例代替序数索引" class="headerlink" title="31.用实例代替序数索引"></a>31.用实例代替序数索引</h3><p>永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Ensemble&#123;</span><br><span class="line">    SOLO(1),DUET(2);</span><br><span class="line">    private final int numberOfMusicians;</span><br><span class="line">    Ensemble(int size)&#123;this.numberOfMusicians = size;&#125;</span><br><span class="line">    public int numberOfMusicians()&#123;return numberOfMusicians;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="32-用EnumSet代替位域"><a href="#32-用EnumSet代替位域" class="headerlink" title="32.用EnumSet代替位域"></a>32.用EnumSet代替位域</h3><h3 id="33-用EnumMap代替序数索引"><a href="#33-用EnumMap代替序数索引" class="headerlink" title="33.用EnumMap代替序数索引"></a>33.用EnumMap代替序数索引</h3><h3 id="34-用接口模拟可伸缩的枚举"><a href="#34-用接口模拟可伸缩的枚举" class="headerlink" title="34.用接口模拟可伸缩的枚举"></a>34.用接口模拟可伸缩的枚举</h3><h3 id="35-注解优先于命名模式"><a href="#35-注解优先于命名模式" class="headerlink" title="35.注解优先于命名模式"></a>35.注解优先于命名模式</h3><h3 id="36-坚持使用Override注解"><a href="#36-坚持使用Override注解" class="headerlink" title="36.坚持使用Override注解"></a>36.坚持使用Override注解</h3><h3 id="37-用标记接口定义类型"><a href="#37-用标记接口定义类型" class="headerlink" title="37.用标记接口定义类型"></a>37.用标记接口定义类型</h3><h2 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h2><h3 id="38-检查参数的有效性"><a href="#38-检查参数的有效性" class="headerlink" title="38.检查参数的有效性"></a>38.检查参数的有效性</h3><p>每当编写方法或者构造器时，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显示的检查来实施这些限制。<br>非公有的方法通常应该使用断言（assertion）来检查它们的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(long a[], int offset, int length)&#123;</span><br><span class="line">    assert a != null;</span><br><span class="line">    assert offset &gt;= 0 &amp;&amp; offset &lt;= a.length;</span><br><span class="line">    assert length &gt;= 0 &amp;&amp; length &lt;= a.length - offset;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="39-必要时进行保护性拷贝"><a href="#39-必要时进行保护性拷贝" class="headerlink" title="39.必要时进行保护性拷贝"></a>39.必要时进行保护性拷贝</h3><p>对于构造器的每个可变参数进行保护性拷贝（defensive copy）是必要的。<br>保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    this.start = start;</span><br><span class="line">    this.end = end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中虽然增加约束条件，但是Date在此对象外部还是可以被修改的，因为Date是引用传递，所以为避免这种问题，使用备份对象，而不是使用原始对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Period(Date start, Date end)&#123;</span><br><span class="line">    this.start = new Date(start.getTime);</span><br><span class="line">    this.end = new Date(end.getTime);</span><br><span class="line">    if(start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。<br>如果类中提供了对其可变内部成员的访问能力，则使它返回可变内部域的保护性拷贝即可。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date start = new Date();</span><br><span class="line">Date end = new Date();</span><br><span class="line">Period p = new Period(start, end);</span><br><span class="line">p.end().setYear(78);//end()方法返回Date对象，Period中提供setYear改变Date属性。</span><br></pre></td></tr></table></figure><p>为了保证传入Period中的start或者end不被改变，只需要修改Period中获取start和end的访问方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Date start()&#123;</span><br><span class="line">    return new Date(start.getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Date end()&#123;</span><br><span class="line"></span><br><span class="line">    return new Date(end.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数的保护性拷贝不仅仅针对不可变类。如果客户端提供的对象是可变的且该对象不允许在你的类对象中变化，就必须对该对象进行保护性拷贝。</p><p>如果拷贝成本受到限制，并且信任它的客户端不会不恰当的修改组件，就可以在文档中声明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。</p><h3 id="40-谨慎设计方法签名"><a href="#40-谨慎设计方法签名" class="headerlink" title="40.谨慎设计方法签名"></a>40.谨慎设计方法签名</h3><p>谨慎的选择方法的名称；<br>不要过于追求提供便利的方法。只有当一项操作被经常用到的时候，才考虑为它提供快捷方式（shorthand）。如果不确定还是不提供快捷为好；<br>避免过长的参数列表；</p><h3 id="41-慎用重载"><a href="#41-慎用重载" class="headerlink" title="41.慎用重载"></a>41.慎用重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionClassifier&#123;</span><br><span class="line"></span><br><span class="line">    public static String classify(Set&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;set&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(List&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;list&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String classify(Collection&lt;?&gt; s)&#123;</span><br><span class="line">        return &quot;unknow&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">            new HashSet&lt;String&gt;(),</span><br><span class="line">            new ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">            new HashMap&lt;String, String&gt;().value()</span><br><span class="line">        &#125;;</span><br><span class="line">        for(Collection&lt;?&gt; c : collections)</span><br><span class="line">            System.out.println(classify(c)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果是打印“unknow”三次。</p><h3 id="42-慎用可变参数"><a href="#42-慎用可变参数" class="headerlink" title="42.慎用可变参数"></a>42.慎用可变参数</h3><p>定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用，使用不当，将产生混乱的结果。</p><h3 id="43-返回零长度的数组或者集合，而不是null"><a href="#43-返回零长度的数组或者集合，而不是null" class="headerlink" title="43.返回零长度的数组或者集合，而不是null"></a>43.返回零长度的数组或者集合，而不是null</h3><h3 id="44-为所有导出的API元素编写文档注释"><a href="#44-为所有导出的API元素编写文档注释" class="headerlink" title="44.为所有导出的API元素编写文档注释"></a>44.为所有导出的API元素编写文档注释</h3><h2 id="七、通用程序设计"><a href="#七、通用程序设计" class="headerlink" title="七、通用程序设计"></a>七、通用程序设计</h2><h3 id="45-将局部变量的作用域最小化"><a href="#45-将局部变量的作用域最小化" class="headerlink" title="45.将局部变量的作用域最小化"></a>45.将局部变量的作用域最小化</h3><p>要使用局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。<br>几乎每个局部变量的声明都应该包含一个初始化表达式。</p><h3 id="46-for-each循环优先于传统的for循环"><a href="#46-for-each循环优先于传统的for循环" class="headerlink" title="46.for-each循环优先于传统的for循环"></a>46.for-each循环优先于传统的for循环</h3><p>虽然for-each循环在简洁性和预防bug方面比传统的for循环有优势，且没有性能损失。但是有三种常见情况无法使用for-each:</p><ul><li>过滤： 如果需要遍历集合，并且删除选定的元素，就需要使用显式的迭代器。</li><li>转换： 如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引。</li><li>平行迭代： 如果需要并行的遍历多个集合，就需要显式的控制迭代器或者索引变量。</li></ul><h3 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47.了解和使用类库"></a>47.了解和使用类库</h3><p>每个程序员都应该熟悉java.lang、java.util、java.io中的内容。</p><h3 id="48-如果需要精确的答案，请避免使用float和double"><a href="#48-如果需要精确的答案，请避免使用float和double" class="headerlink" title="48.如果需要精确的答案，请避免使用float和double"></a>48.如果需要精确的答案，请避免使用float和double</h3><p>使用BigDecimal、int或者long进行计算。如果数值防伪不超过9位十进制数字，就可以使用int；如果不超过18位就可以使用long；如果数值超过18位就必须使用BigDecimal。</p><p>BigDecimal缺点：不方便，慢。</p><h3 id="49-基本类型优先于装箱基本类型"><a href="#49-基本类型优先于装箱基本类型" class="headerlink" title="49.基本类型优先于装箱基本类型"></a>49.基本类型优先于装箱基本类型</h3><p>基本类型与装箱基本类型之间主要区别：</p><ul><li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。</li><li>基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值之外，还有非功能值：null。</li><li>基本类型通常比装箱基本类型更节省空间和时间。</li></ul><p>第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型（在代码中不用自己去装箱，如果把基本类型放入集合中，集合会自动把基本类型装箱）。不能放在集合中的原因是：基本类型存放在栈上，集合中的引用则存在堆或方法取上。</p><p>在参数化类型中，必须使用装箱基本类型作为参数，Java不允许使用基本类型，因为Java泛型要求使用的是对象类型，基本类型不是对象类型。</p><h3 id="50-如果其他类型更适合，则尽量避免使用字符串"><a href="#50-如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="50.如果其他类型更适合，则尽量避免使用字符串"></a>50.如果其他类型更适合，则尽量避免使用字符串</h3><p>字符串不适合代替其他的值类型。<br>字符串不适合代替枚举类型。<br>字符串不适合代替聚集类型。<br>字符串也不适合代替能力表。</p><h3 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51.当心字符串连接的性能"></a>51.当心字符串连接的性能</h3><h3 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52.通过接口引用对象"></a>52.通过接口引用对象</h3><p>如果有适合的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。</p><p>如果没有合适的接口存在，完全可以用类而不是接口来引用对象：</p><ul><li>如果具体类没有相关联的接口，不管它是否表示一个值，你都没有别的选择，只有通过它的类来引用它的对象。</li><li>对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架（class-based</li><li>framework），就应该用相关的积累（base class）来引用这个对象，而不是用它的实现类。</li></ul><h3 id="53-接口优先于反射机制"><a href="#53-接口优先于反射机制" class="headerlink" title="53.接口优先于反射机制"></a>53.接口优先于反射机制</h3><p>反射机制：</p><ul><li>丧失了编译时类型检查的好处，包括异常检查。如果程序企图用反射方式调用不存在的活不可访问的方法，在运行时它将会失败，除非采用了特别的预防措施。</li><li>执行反射访问所需的代码非常笨拙和冗长。编写这样的代码非常乏味，阅读起来也很困难。</li><li>性能损失。反射方法调用比普通方法调用慢了许多。</li></ul><p>通常普通应用程序在运行时不应该以反射方式访问对象。<br>对于有些程序，它们必须用到在编译时无法获取的类，但是在编译时存在适当的接口或者超类，通过它们可以引用这个类。如果是这种情况，就可以以反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例。如果适当的构造器不带参数，甚至根本不需要使用<code>java.lang.reflect</code>；<code>Class.newInstance</code>方法就已经提供了所需的功能。</p><h3 id="54-谨慎的使用本地方法"><a href="#54-谨慎的使用本地方法" class="headerlink" title="54.谨慎的使用本地方法"></a>54.谨慎的使用本地方法</h3><h3 id="55-谨慎的优化"><a href="#55-谨慎的优化" class="headerlink" title="55.谨慎的优化"></a>55.谨慎的优化</h3><blockquote><p>很多计算上的过失都被归咎于效率（没有必要达到的效率），而不是任何其他的原因—甚至包括盲目的做傻事。<br>不要取计较效率上的一些小小的得失，在97%的情况下，不成熟的优化才是一切问题的根源。<br>在优化方面，我们应该遵守两条规则：<br>规则1: 不要进行优化。<br>规则2: 还是不要进行优化—也就是说，在你还没有绝对清晰的未优化方案之前，请不要优化。</p></blockquote><p>不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。好的程序体现了信息隐藏的原则：只要有可能，它们就会把设计决策几种在单个模块中，因此，可以改变单个决策，而不会影响到系统的其他部分。</p><p>在设计的过程中考虑性能问题。努力避免限制性能的设计决策。</p><h3 id="56-遵守普遍接受的命名惯例"><a href="#56-遵守普遍接受的命名惯例" class="headerlink" title="56.遵守普遍接受的命名惯例"></a>56.遵守普遍接受的命名惯例</h3><h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><h3 id="57-只针对异常的情况才使用异常"><a href="#57-只针对异常的情况才使用异常" class="headerlink" title="57.只针对异常的情况才使用异常"></a>57.只针对异常的情况才使用异常</h3><p>异常机制的设计初衷是用于不正常的情形，所以很少会有JVM实现试图对它们进行优化，使得与显式的测试一样快速。</p><p>把代码放在try-catch块中反而阻止了现代JVM实现本来可能要执行的某些特定的优化。</p><p>对数组进行遍历的标准模式并不会导致冗余的检查。有些现代的JVM实现会将它们优化掉。</p><h3 id="58-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#58-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="58.对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>58.对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><h3 id="59-避免不必要的使用受检异常"><a href="#59-避免不必要的使用受检异常" class="headerlink" title="59.避免不必要的使用受检异常"></a>59.避免不必要的使用受检异常</h3><h3 id="60-优先使用标准异常"><a href="#60-优先使用标准异常" class="headerlink" title="60.优先使用标准异常"></a>60.优先使用标准异常</h3><p><img src="/media/article/15583547431411.jpg" alt=""></p><h3 id="61-抛出域抽象相对应的异常"><a href="#61-抛出域抽象相对应的异常" class="headerlink" title="61.抛出域抽象相对应的异常"></a>61.抛出域抽象相对应的异常</h3><p>更高层次的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。<br>如果不能阻止或者处理来自低层的异常，一般做法是使用异常转译，除非低层方法碰巧可以保证它抛出的所有异常对高层也合适才可以将异常从低层传播到高层。异常链对高层和低层异常都提供了最佳功能：它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析。</p><h3 id="62-每个方法抛出的异常都要有文档"><a href="#62-每个方法抛出的异常都要有文档" class="headerlink" title="62.每个方法抛出的异常都要有文档"></a>62.每个方法抛出的异常都要有文档</h3><p>始终要单独的声明受检异常，并且利用Javadoc的@throws标记，准确的记录下抛出的每个异常的条件。</p><p>使用Javadoc的@throws标签记录下一个方法可能抛出的每个受检异常，但是不要使用throws关键字将未受检异常包含在方法的声明中。</p><p>如果一个类中的许多方法处于同样的原因而抛出同一个异常，则该类的文档注释中对这个异常建立文档，是可以接受的。</p><h3 id="63-在细节消息中包含能捕获失败的信息"><a href="#63-在细节消息中包含能捕获失败的信息" class="headerlink" title="63.在细节消息中包含能捕获失败的信息"></a>63.在细节消息中包含能捕获失败的信息</h3><p>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。</p><h3 id="64-努力使失败保持原子性"><a href="#64-努力使失败保持原子性" class="headerlink" title="64.努力使失败保持原子性"></a>64.努力使失败保持原子性</h3><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p><h3 id="65-不要忽略异常"><a href="#65-不要忽略异常" class="headerlink" title="65.不要忽略异常"></a>65.不要忽略异常</h3><h2 id="九、并发"><a href="#九、并发" class="headerlink" title="九、并发"></a>九、并发</h2><h3 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66.同步访问共享的可变数据"></a>66.同步访问共享的可变数据</h3><p>Java语言规范保证读或写一个变量是原子的，除非这个变量的类型为long或者double[JLS，17.4.7]。对于这句话不要误解，虽然语言规范保证了线程在读取原子数据的时候，不会看到任意的数值，但是它并不保证一个线程写入的值对于另一个线程将是可见的。为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。</p><h3 id="67-避免过度同步"><a href="#67-避免过度同步" class="headerlink" title="67.避免过度同步"></a>67.避免过度同步</h3><p>为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法，要尽量限制同步区域内部的工作量。</p><h3 id="68-executor和task优先于线程"><a href="#68-executor和task优先于线程" class="headerlink" title="68.executor和task优先于线程"></a>68.executor和task优先于线程</h3><h3 id="69-并发工具优先于wait和notify"><a href="#69-并发工具优先于wait和notify" class="headerlink" title="69.并发工具优先于wait和notify"></a>69.并发工具优先于wait和notify</h3><p>java.util.concurrent中更高级的的工具分成三类：Execcutor Framework、并发集合（Concurrent Collection）以及同步器（Synchronizer）。</p><p>同步器是一些使线程能够等待另一个线程的对象，允许它们协调动作。常用的是CountDownLatch和Semaphore。不常用的是CyclicBarrier和Exchanger。</p><p>对于间歇式的定时，始终应该优先使用System.nanoTime，而不是使用System.currentTimeMills。System.nanoTime更加准确也更加精确，它不受系统的实时时钟的调整所影响。</p><p>如果你在维护使用wait和notify的代码，务必确保始终是利用标准的模式从while循环内部调用wait。一般情况下，你应该优先使用notifyAll，而不是使用notify。如果使用notify，请一定小心，以确保程序的活性。</p><h3 id="70-线程安全性的文档化"><a href="#70-线程安全性的文档化" class="headerlink" title="70.线程安全性的文档化"></a>70.线程安全性的文档化</h3><p>一个类为了可被多个线程安全的使用，必须在文档中清楚的说明它所支持的线程安全级别。</p><ul><li>不可变的（immutable）这个类是不可变的。所以不需要外部同步。例如：String、Long、BigInteger。</li><li>无条件的线程安全（unconditionally thread-safe）这个类的实例是可变的，但是这个类有着足够的内部同步，所以，它的实例可以被并发使用，无需任何外部同步。例如：Random、ConcurrentHashMap。</li><li>有条件的线程安全（conditionally thread-safe）除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。例如：Collections.synchronized包装返回的集合，它们的迭代器（iterator）要求外部同步。</li><li>非线程安全（not thread-safe）这个类的实例是可变的。为了并发地使用它们，客户端必须利用自己选择的外部同步包围每个方法调用。例如：ArrayList、HashMap。</li><li>线程对立（thread-hostile）这个类不能安全的被多个线程并发使用，即使所有的方法调用都被外部同步包围。</li></ul><h3 id="71-慎用延迟初始化"><a href="#71-慎用延迟初始化" class="headerlink" title="71.慎用延迟初始化"></a>71.慎用延迟初始化</h3><p>延迟初始化（lazy initialization）是延迟到需要域的值时才将它初始化的这种行为。<br>大多数的域应该正常地进行初始化，而不是延迟初始化。如果为了达到性能目的，或者为了破坏有害的初始化循环，必须延迟初始化一个域则：<br>对于实例域，就使用双重检查模式（double-check idiom）；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            result = field;</span><br><span class="line">            if(result == null)&#123;</span><br><span class="line">                field = result = computeFieldValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于静态域，则使用lazy initialization holder class idiom；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class FieldHolder&#123;</span><br><span class="line">    static final FieldType field = computeFieldValue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static FieldType getField()&#123;return FieldHolder.field;&#125;</span><br></pre></td></tr></table></figure></p><p>对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式（single-check idiom）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line"></span><br><span class="line">private FieldType getField()&#123;</span><br><span class="line"></span><br><span class="line">    FieldType result = field;</span><br><span class="line">    if(result == null)&#123;</span><br><span class="line">        field = result = computeFieldValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="72-不要依赖于线程调度器"><a href="#72-不要依赖于线程调度器" class="headerlink" title="72.不要依赖于线程调度器"></a>72.不要依赖于线程调度器</h3><h3 id="73-避免使用线程组"><a href="#73-避免使用线程组" class="headerlink" title="73.避免使用线程组"></a>73.避免使用线程组</h3><p>线程组的初衷是作为一种隔离applet的机制，当然是出于安全的考虑。线程组并没有提供太多有用的功能，而且它们提供的许多功能还都是有缺陷的。</p><h2 id="十、序列化"><a href="#十、序列化" class="headerlink" title="十、序列化"></a>十、序列化</h2><h3 id="74-谨慎的实现Serializable接口"><a href="#74-谨慎的实现Serializable接口" class="headerlink" title="74.谨慎的实现Serializable接口"></a>74.谨慎的实现Serializable接口</h3><p>实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。</p><p>如果接受了默认的序列化形式，并且以后要改变这个类的内部表示法，结果可能导致序列化形式的不兼容。</p><p>第二个代价是，它增加了出现Bug和安全漏洞的可能性。</p><p>实现Serializable第三个代价是，随着类发行新的版本，相关的测试负担也增加了。</p><p>为了继承而设计的类应该尽可能少的趋势线Serializable接口，用户的接口也应该尽可能少的继承Serializable接口。如果违反了这条规则，扩展这个类或者实现该接口的程序员就会背上沉重的负担。然而有些情况下，这条规则确实适合的。例如：如果一个类或者接口存在的目的主要是为了参加到某个框架中，该框架要求所有的参与者都必须实现Serializable接口，那么对于类或者接口来说实现扩展Serializable是有意义的。</p><p>如果一个专门为了继承而设计的类不是可序列化的，就不可能编写出可序列化的子类。特别是，如果超类没有提供可访问的无参构造器，子类也不可能做到序列化。对于未继承而设计的不可序列化的类，你应该提供一个无参构造器。</p><h3 id="75-考虑使用自定义的序列化形式"><a href="#75-考虑使用自定义的序列化形式" class="headerlink" title="75.考虑使用自定义的序列化形式"></a>75.考虑使用自定义的序列化形式</h3><p>如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Name implements Serializable&#123;</span><br><span class="line">    private final String lastName;</span><br><span class="line">    </span><br><span class="line">    private final String firstName;</span><br><span class="line">    </span><br><span class="line">    private final String middleName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使你确定了默认的序列化形式是合适的，通常还必须提供一个readObject方法保证约束关系和安全性。</p><p>当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下4个缺点：</p><ul><li>它使这个类的导出API永远地束缚在该类的内部表示法上。</li><li>它会消耗过多的时间。</li><li>它会消耗过多空间。</li><li>它会引起栈溢出。</li></ul><p>如果所有的实例域都是瞬时的（transient），从技术角度而言，不调用DefaultWriteObject和defaultReadObject也是允许的，但是不推荐这样做。<br>在决定将一个域做成非transient的之前，请一定要确信它的值将是该对象逻辑状态的一部分。<br>如果在读取整个对象状态的任何其他方法上强制任何同步，则也必须在对象序列化上强制这种同步。<br>不管你选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显式的序列版本UID（serial version UID）。</p><h3 id="76-保护性的编写readObject方法"><a href="#76-保护性的编写readObject方法" class="headerlink" title="76.保护性的编写readObject方法"></a>76.保护性的编写readObject方法</h3><p><strong><em>记得回来看反序列化代码</em></strong></p><p>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。保护性拷贝在有效性检查之前进行。</p><p>不要使用writeUnshared和readUnshared方法。</p><p>对于非final的可序列化类，readObject方法不可以调用可被覆盖的方法，无论是直接调用还是间接调用都不可以。如果违反了规则，并覆盖了该方法，被覆盖的方法将在子类的状态被序列化之前先运行，程序很可能失败。</p><p>readObject方法指导：</p><ul><li>对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别。</li><li>对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li><li>如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。</li><li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li></ul><h3 id="77-对于实例控制，枚举类型优先于readResolve"><a href="#77-对于实例控制，枚举类型优先于readResolve" class="headerlink" title="77.对于实例控制，枚举类型优先于readResolve"></a>77.对于实例控制，枚举类型优先于readResolve</h3><p>如果这个类的声明加上了“implements Serializable”的字样，它就不再是一个单例类。无论使用默认的序列化形式，还是自定义的序列化形式，都会返回一个新建的实例，这个新建实例不用于该类初始化时创建的实例。</p><p>readResolve特性允许你用readObject创建的实例代替另一个实例。对于一个正在被序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化后，新建对象上的readResolve方法就会被调用，该方法返回的对象引用将被返回，取代新建对象，指向新建对象的引用不需要再被保留，因此立即成为垃圾回收对象。</p><p>如果readResolve方法忽略被反序列化的对象，只返回该类初始化时创建的实例。如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient的。</p><p>readResolve的可访问性很重要。如果把readResolve方法放在一个final类上，它就应该是私有的。如果吧readResolve方法放在一个非final类上，就必须考虑它的可访问性。</p><p>尽可能的使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控（instance-controlled）的类，就必须提供一个readResolve方法，并确保该类的所有实例域都为基本类型，或者是transient的。</p><h3 id="78-考虑用序列化代理代替序列化实例"><a href="#78-考虑用序列化代理代替序列化实例" class="headerlink" title="78.考虑用序列化代理代替序列化实例"></a>78.考虑用序列化代理代替序列化实例</h3><p>每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。要想文件的带有重要约束条件的对象序列化，这种模式可能是最容易的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 枚举类</title>
      <link href="/java/2019-05-01-java-enum/"/>
      <url>/java/2019-05-01-java-enum/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java枚举类笔记，摘自《疯狂Java讲义》</p></blockquote><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在早期代码中，可能会直接使用简单的静态常量表示枚举，例如如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final int SEASON_SPRING = 1;</span><br><span class="line">public static final int SEASON_SUMMER = 2;</span><br><span class="line">public static final int SEASON_FALL = 3;</span><br><span class="line">public static final int SEASON_WINTER = 4;</span><br></pre></td></tr></table></figure><p>但是这种方式定义会存在如下问题：</p><ul><li>类型不安全：可能存在SEASON_SPRING + SEASON_FALL。</li><li>没有命名空间：当需要使用季节时，必须在SPRING钱使用SEASON_前缀，否则程序可能与其他类中的静态常量混淆。</li><li>打印输出的意义不明确：当输出某个季节时，实际的输出值时数字。</li></ul><p>JDK1.5 之后新增了enum关键字，用来定义枚举类。枚举类是一种特殊类，有自己的成员变量、方法，可以实现一个或者多个接口，可以定义自己的构造器。一个Java源文件中最多只能定一个public访问权限的枚举类，且该Java源文件必须和该枚举类的类名相同。和普通类区别如下：</p><ul><li>使用enum定义的默认枚举类默认继承了java.lang.Enum类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。</li><li>使用enum定义、<strong>非抽象</strong>的枚举类默认会使用final修饰，因此不能派生子类。</li><li>枚举类的构造器只能使用private访问控制符。</li><li>枚举类所有的实例必须在枚举类的第一行显示列出，否则这个枚举类永远都不能产生实例。</li></ul><p>Java枚举类型基本思想：通过公有的静态final域为每个枚举常量到处实例的类。因为没有可以访问的构造器，枚举类型是真正的final。</p><h3 id="1-枚举类的成员变量、方法和构造器"><a href="#1-枚举类的成员变量、方法和构造器" class="headerlink" title="1. 枚举类的成员变量、方法和构造器"></a>1. 枚举类的成员变量、方法和构造器</h3><p>枚举类也是一种比较特殊的类。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;),FEMALE(&quot;女&quot;);</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看出，枚举类中列出枚举值时，实际上就是调用构造器创建枚举类对象，只是这里不是使用new关键字，也无需显式调用构造器。</p><p>上面<code>MALE(&quot;男&quot;),FEMALE(&quot;女&quot;)</code>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void final Gender MALE = new Gender(&quot;男&quot;)；</span><br><span class="line">public static void final Gender FEMALE = new Gender(&quot;女&quot;)；</span><br></pre></td></tr></table></figure></p><h3 id="2-实现接口的枚举类"><a href="#2-实现接口的枚举类" class="headerlink" title="2. 实现接口的枚举类"></a>2. 实现接口的枚举类</h3><p>接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface GenderDesc&#123;</span><br><span class="line">    void info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum Gender&#123;</span><br><span class="line">    MALE(&quot;男&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;men&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,FEMALE(&quot;女&quot;)&#123;</span><br><span class="line">        public void info()&#123;</span><br><span class="line">            System.out.println(&quot;women&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private final String name;</span><br><span class="line">    private Gender(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong>并非所有的枚举类都使用final修饰，非抽象的枚举类才默认使用final修饰。对于一个抽象的枚举类，系统默认使用abstract修饰，而不是final。</p><h3 id="3-包含抽象方法的抽象类"><a href="#3-包含抽象方法的抽象类" class="headerlink" title="3. 包含抽象方法的抽象类"></a>3. 包含抽象方法的抽象类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public enum Operation&#123;</span><br><span class="line"></span><br><span class="line">    PLUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x-y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x*y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE&#123;</span><br><span class="line">        public double eval(double x, double y)&#123;</span><br><span class="line">            return x/y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    public abstract double eval(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Serializable</title>
      <link href="/java/2019-04-27-java-serializable/"/>
      <url>/java/2019-04-27-java-serializable/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java序列化笔记，摘自《疯狂Java讲义》</p></blockquote><h2 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h2><h3 id="1-序列化的含义和意义"><a href="#1-序列化的含义和意义" class="headerlink" title="1.序列化的含义和意义"></a>1.序列化的含义和意义</h3><p>对象序列化指将一个Java对象写入IO流中。<br>对象支持序列化则必须让它的类是可序列化的。该类必须实现如下两个接口之一</p><ul><li><code>Serializable</code></li><li><code>Externalizable</code></li></ul><p>建议：JavaBean类都实现Serializable。</p><h3 id="2-使用对象流实现序列化"><a href="#2-使用对象流实现序列化" class="headerlink" title="2.使用对象流实现序列化"></a>2.使用对象流实现序列化</h3><ul><li>反序列化读取的仅仅是Java对象的数据，而不是Java类，因此采用反序列化恢复Java对象时，必须提供该Java对象所属类的class文件，否则将会引发ClassNotFoundException异常。</li><li>反序列化无需通过构造器来初始化Java对象。</li><li>如果使用序列化机制向文件中写入了多个Java对象，使用反序列化机制恢复对象时必须按实际写入顺序读取。</li><li>当一个可序列化类有多个父类时，这些父类要么有无参数构造器，要么也是可序列化的，否则抛出InvalidClassException。</li><li>如果父类时不可序列化的，只带有无参数构造器，则该父类中定义的成员变量值不会序列化到二进制流中。（反序列化时会调用父类的无参构造器，重新实例化父类对象）</li></ul><h3 id="3-对象引用的序列化"><a href="#3-对象引用的序列化" class="headerlink" title="3.对象引用的序列化"></a>3.对象引用的序列化</h3><p>Java序列化机制算法：</p><ul><li>所有保存到磁盘中的对象都有一个序列化编号。</li><li>当程序试图序列化一个对象时，程序将先检查该对象是否已经被序列化过，只有该对象从未被序列化过，系统才会将该对象转换成字节序列并输出。</li><li>如果某个对象已经序列化过，程序将直接输出一个序列化编号，而不是再次重新序列化该对象。</li></ul><p>注：当程序序列化一个可变对象时，只有第一次writeObject()方法输出时才会将该对象转换成字节序列并输出，当再次调用writeObject()方法时，程序只是输出前面的序列化编号，即使后面该对象的实例变量值已被改变，改变的实例变量值也不会被输出。</p><h3 id="4-自定义序列化"><a href="#4-自定义序列化" class="headerlink" title="4.自定义序列化"></a>4.自定义序列化</h3><blockquote><p>当对某个对象进行序列化时，系统会自动把该对象的所有实例变量依次进行序列化，如果某个实例变量引用另一个对象，则被引用的对象也会被序列化；如果被引用的对象实例变量也引用了其他对象，则被引用的对象也会被序列化，这种情况被称为递归序列化。</p></blockquote><h4 id="4-1-transient关键字"><a href="#4-1-transient关键字" class="headerlink" title="4.1 transient关键字"></a>4.1 transient关键字</h4><p>在实例变量前使用transient关键字修饰，可以指定Java序列化时无需理会该实例变量。<br>transient关键字只能用于修饰实例变量，不能用于修饰Java程序中的其他成分。<br>transient关键字修饰实例变量将被完全隔离在序列化机制之外，这样导致在反序列化恢复Java对象时无法取得该实例的变量值。</p><h4 id="4-2-自定义序列化"><a href="#4-2-自定义序列化" class="headerlink" title="4.2 自定义序列化"></a>4.2 自定义序列化</h4><p>在类中提供如下方法，这些方法用以实现自定义序列化。</p><ul><li><code>private void writeObject(java.io.ObjectOutputStream out)throws IOException</code></li><li><code>private void readObject(java.io.ObjectInputStream in)throws IOException,ClassNotFoundException</code></li><li><code>private void readObjectNoData()throws ObjectStreamException</code></li></ul><p>注：writeObject的顺序与readObject的顺序一致，否则不能正常恢复Java对象。</p><p>writeReplace方法由序列化机制调用，只要该方法存在。在序列化某个对象前，先调用该对象writeReplace()方法，如果该方法返回另一个Java对象，则系统转化序列化另一个对象。<br>与writeReplace方法相对的是，readResolve()，这个方法在readObject()后被调用，该方法的返回值将代替原来反序列化的对象，原来的对象被丢弃。<br>readResolve()在序列化单例类和枚举类时尤其有用。所有的单例类和枚举类在实现序列化时都应该提供readResolve方法，这样才能保证反序列化的正常。</p><h3 id="5-自定义序列化机制"><a href="#5-自定义序列化机制" class="headerlink" title="5.自定义序列化机制"></a>5.自定义序列化机制</h3><p>Java除了Serializable，还提供了另一种序列化机制，这种序列化方式完全由程序员决定存储和恢复对象数据。要实现该目标，Java必须实现Externalizable接口，接口中方法如下：</p><ul><li><code>void readExternal(ObjectInput in)</code>：需要实现readExternal方法实现反序列化。</li><li><code>void writeExternal(ObjectOutput out)</code>：需要实现writeExternal方法来保存对象状态。</li></ul><p>两种序列化机制的对比：</p><p>Serializable</p><ul><li>系统自动保存必要信息</li><li>Java内建支持，易于实现，只需实现该接口即可，无需任何代码支持（也可以自定义）</li><li>性能略差</li></ul><p>Externalizable</p><ul><li>程序员决定存储哪些信息</li><li>仅仅提供空方法，必须自定义实现序列化</li><li>性能略高</li></ul><blockquote><p><strong>注意</strong></p><ul><li>对象的类名、属性（基本类型、数组、对其他对象的引用）都会被序列化；方法、static属性、transient属性都不会被序列化。</li><li>实现Serializable接口的类如果需要想让某个属性不被序列化，可在属性前加transient修饰符，而不是加static。</li><li>保证序列化对象的属性的类型也是可序列化的，否则需要使用transient关键字来修饰该属性，要不然，则该类是不可序列化的。</li><li>反序列化对象时必须有序列化对象的class文件。</li></ul></blockquote><h3 id="6-版本"><a href="#6-版本" class="headerlink" title="6.版本"></a>6.版本</h3><p>反序列化Java对象时必须提供该对象的class文件，如果项目升级，Java如何保证两个class文件的兼容性？</p><p>Java序列化机制允许为序列化类提供一个private static final的serialVersionUID属性值，该属性值用于表示该Java类的序列化版本。</p><ul><li>如果修改类时仅仅修改了方法，则反序列化完全不受任何影响，类定义无需修改serialVersionUID的属性值。</li><li>如果修饰类时仅仅修改了静态属性或瞬态属性，则反序化不受任何影响，类定义无需修改serialVersionUID属性值。</li><li>如果修改类时修饰了非静态、非瞬态属性，则可能导致序列化版本不兼容，如果对象流中的对象和新类中包含同名的属性，而属性类型不同，则反序列化失败，类定义应该更新serialVersionUID属性值。如果对象流中对象比新类中包含更多的属性，则多处的属性值被忽略，序列化版本可以兼容，类定义可以不更新serialVersionUID属性值；但反序列化得到的新对象中多处的属性值都是null（引用类型属性）或0（基本类型属性）。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂Java讲义</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Transaction Management</title>
      <link href="/transaction/2019-03-07-spring-transaction-management/"/>
      <url>/transaction/2019-03-07-spring-transaction-management/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-事务管理"><a href="#Spring-事务管理" class="headerlink" title="Spring 事务管理"></a>Spring 事务管理</h1><p>翻译自<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-motivation" target="_blank" rel="noopener">spring/docs/4.2.x</a></p><p>翻译过程中使用工具：google翻译，欧路词典</p><p>名词解释：<br>JTA：Java Transaction API<br>JPA：Java Persistence API<br>JDO：Java Data Object<br>CMT： Container Managed Transactions<br>JNDI：Java Naming and Directory Interface<br>JMS： Java Message Service<br>JCA： Java EE Connector Architecture</p><h2 id="1-事务管理"><a href="#1-事务管理" class="headerlink" title="1. 事务管理"></a>1. 事务管理</h2><h2 id="1-1-Spring框架事务管理介绍"><a href="#1-1-Spring框架事务管理介绍" class="headerlink" title="1.1 Spring框架事务管理介绍"></a>1.1 Spring框架事务管理介绍</h2><p>全方面的事务支持是使用Spring框架的最引人注目的原因之一。Spring框架为事务管理提供一致性抽象提供了如下好处：</p><ul><li>一致性编程模型横跨不同的事务APIs，例如 JTA，JPA，JDO。</li><li>支持声明式事务管理</li><li>和复杂编程事务APIs（例如JTA）相比，Spring提供更简单的编程事务管理的API。</li><li>与Spring的数据访问抽象有良好的集成。</li></ul><p>下面的部分描述Spring框架的事务value-adds和技术。(这部分也包含对于最好事务管理的实践，应用服务器集成和常见问题解决方案的讨论)</p><ul><li><a href="#1-2-Spring框架事务支持模型的优势">Spring框架事务支持模型的优势</a>描述你为什么会使用Spring框架的事务抽象，而不是选择EJB的容器管理事务或者通过专有的API（例如Hibernate）驱动本地事务。</li><li><a href="#1-3-理解Spring框架事务抽象">理解Spring框架的事务抽象</a>概述核心类和描述怎样配置和怎样从各种类型的数据源中获取数据源。</li><li><a href="#1-4-将资源与事务同步">将资源与事务同步</a>描述应用代码怎样确保资源的创建，复用和正确的清理。</li><li><a href="#1-5-声明式事务管理">声明式事务管理</a>描述支持声明式事务管理。</li><li><a href="#1-6-编程事务管理">编程事务管理</a>包含支持编程事务管理。</li><li><a href="#1-8-事务约束事件">事务约束事件</a>描述你可以怎样在事务中使用应用程序事件。</li></ul><h2 id="1-2-Spring框架事务支持模型的优势"><a href="#1-2-Spring框架事务支持模型的优势" class="headerlink" title="1.2 Spring框架事务支持模型的优势"></a>1.2 Spring框架事务支持模型的优势</h2><p>传统上，Java EE的开发者对于事务管理有两种选择：全局或者本地事务管理，这两种都有很大的局限性。全局和本地事务管理将在下面的两小节中回顾，接着是Spring框架管理支持解决全局和本地事务管理模型局限性的讨论。</p><h3 id="1-2-1-全局事务"><a href="#1-2-1-全局事务" class="headerlink" title="1.2.1 全局事务"></a>1.2.1 全局事务</h3><p>全部事务管理允许你和多个事务资源一块运行，事务资源一般是关系型数据库和消息队列。应用服务器通过JTA管理全局事务，JTA是一个用起来笨重的API（部分是由于它的异常模型决定的）。此外，JTA<code>UserTransaction</code>正常来说需要JNDI引入资源，意味着为了使用JTA你还需要使用JNDI。显然，全局事务的使用将会限制应用代码潜在的复用，同时JTA只能在应用服务器环境中可用。<br>先前，使用全局事务比较好的方式是通过EJB的容器管理事务：CMT是一张声明式事务管理表（对于编程事务管理也同样好用）。EJB CMT删除了关联事务JNDI的查找，尽管EJB自己必须要使用JNDI。它消除了编写Java代码以控制事务的大部分但不是全部的需要。CMT最大的缺陷是捆绑JTA和应用的服务器环境。同时，CMT只有在EJBs里实现业务逻辑才可用，或者至少在一个事务EJB facade之前。通常EJB的负面影响太大以致于这不是一个有吸引力的方案，尤其是面对声明式事务管理的引人注目的备选方案。</p><h3 id="1-2-2-本地事务"><a href="#1-2-2-本地事务" class="headerlink" title="1.2.2 本地事务"></a>1.2.2 本地事务</h3><p>本地事务是特定于资源的，比如一个事务关联一个JDBC连接。本地事务可能使用简单，但是有明显的缺陷：它们不能在多个事务资源上工作。举个例子，使用JDBC连接的管理事务代码不能在全局JTA事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个数据源的正确性。（值得注意的是，大多数应用使用单个事务资源）另一个缺陷是本地事务在编程模型中是侵入式的。</p><h3 id="1-2-3-Spring框架的一致性编程模型"><a href="#1-2-3-Spring框架的一致性编程模型" class="headerlink" title="1.2.3 Spring框架的一致性编程模型"></a>1.2.3 Spring框架的一致性编程模型</h3><p>Spring 解决了全局和本地事务的缺陷。它允许程序员在任何环境中使用一致性编程模型。你写一次代码，它可以在不同环境中的不同事务管理策略中受益。Spring框架提供声明和编程事务管理。大多数用户使用在大多数情况下被推荐使用的声明式事务模型。<br>对于编程式事务管理，开发者将使用Spring 框架的事务抽象，它可以在底层的事务基础设施上运行。对于声明式模型，开发经常写一点或者没有代码去关联事务管理，因此不依赖Spring框架的事务API或者其他的事务API。</p><blockquote><p><b>对于事务管理，你是否需要应用服务器？</b><br>Spring 框架事务管理支持当企业Java应用需要应用服务器时修改传统规则。<br>尤其，你只是需要通过EJBs声明事务而不是需要应用服务器。事实上，<strong>即使你的应用服务器有的JTA能</strong>力，对比EJB CMT，你可能决定使用Spring框架的声明式事务提供更多能力和一个富有成效的编程模型。<br>通常你需要使用应用服务器的JTA能力仅仅因为你的应用需要跨多个资源去处理事务，这种情况对于许多应用是不需要的，许多高端应用使用一个高扩展性的数据库（如：Oracle RAC）代替多个资源。独立事务管理如 Atomikos Transactions 和 JOTM是其他选择。当然，你可能需要其他应用服务器能力，如Java消息服务和JCA。<br>Spring框架给你当需要扩展你的应用去完整加载应用服务器的选择，替代使用EJB CMT或者JTA的唯一方式是使用本地事务（如：JDBC连接）写代码的日子一去不复返了，如果你需要在全局或者CMT中运行该本地事务代码将会面对大量的返工。使用Spring框架，你仅仅需要在配置文件中定义一些bean，而不是需要去修改代码。</p></blockquote><h2 id="1-3-理解Spring框架事务抽象"><a href="#1-3-理解Spring框架事务抽象" class="headerlink" title="1.3 理解Spring框架事务抽象"></a>1.3 理解Spring框架事务抽象</h2><p><strong>spring框架事务抽象的关键是事务策略的概念</strong>，通过<code>org.springframework.transaction.PlatformTransactionManager</code>接口定义事务策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager&#123;</span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition) throws TransactionException;</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个主要是Java的服务提供发现机制，尽管可以从应用代码中以编程方式使用。因为<code>PlatformTransactionManager</code>是一个接口，它可以在被需要是很容易的仿制或者存根。它和类似JNDI的查找策略无关。<br>定义<code>PlatformTransactionManager</code>的接口实现和spring IoC容器中的其他对象（或bean）相同。即使你使用JTA，仅此一项好处也使得Sping框架事务值得被抽象。相比于直接使用JTA，使用Spring事务抽象可以让测试事务代码更简单。<br>可以被任何<code>PlatformTransactionManager</code>接口的实现方法抛出的非检查（继承<code>java.lang.RuntimeException</code>的类）的<code>TransactionException</code>再次符合Spring的理念。事务基础设施的故障几乎总是致命的。应用代码在极少数情况下可以从事务失败中恢复，应用开发者可以选择捕获和处理<code>TransactionException</code>。重点是开发者不必强制去这样做。<br><code>getTransaction(..)</code>方法返回<code>TransactionStatus</code>对象，依赖一个<code>TransactionDefinition</code>参数。返回的<code>Transaction</code>可能代表一个新事务，或者可以代表一个已经存在的事务如果此事务在当前调用栈中存在匹配的事务。后者的意义是在Java EE事务上下文中，一个线程的执行和一个<code>TransactionStatus</code>相关联。<code>TransactionDefinition</code>接口指定：</p><ul><li>Isolation: 当前事务和其他事务在工作中的隔离程度。例如： 此事务是否可以看到来自其他事务的未提交的写入？</li><li>Propagation: 通常，在事务范围内运行的所有代码都将在此事务中运行。但是，你可以选择在事务上下文已经存在且执行事务方法的事件中指定行为。例如：代码可以在已存在的事务中继续运行（常见情况）;或者挂起已存在的事务，新建事务。Spring提供了EJB CMT中熟悉的所有事务传播选择。了解Spring中关于事务传播语义，<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#tx-propagation" target="_blank" rel="noopener">事务传播</a>。</li><li>Timeout: 在超时和底层事务基础设施自动回滚事务之前，事务可以运行多久？</li><li>Read-only status: 当你的代码读取但是不修改数据数据时可以使用只读事务。只读事务在某些情况下是有用的优化，例如当你使用Hibernate时。</li></ul><p>这些事务反映出了标准的事务概念，如果需要，请参阅讨论事务隔离等级和其他核心事务概念的资源。理解这些概念对使用Spring框架或者其他事务管理的解决方案是很必要的。</p><p><code>TransactionStatus</code>接口提供简单的事务代码去控制事务执行和查询事务状态。这些概念应该是熟悉的，它们对所有事务APIs都是通用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager&#123;</span><br><span class="line">    boolean isNewTransaction();</span><br><span class="line">    boolean hasSavepoint();</span><br><span class="line">    void setRollbackOnly();</span><br><span class="line">    boolean isRollbackOnly();</span><br><span class="line">    void flush();</span><br><span class="line">    boolean isCompleted();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论你在Spring中选择声明式事务还是编程式事务管理，定义正确的<code>PlatformTransactionManager</code>实现是绝对必要的。通常通过依赖注入定义这个实现。</p><p><code>PlatformTransactionManager</code>实现通常需要了解他们运行的环境：JDBC，JTA，Hibernate等等。下面的例子展示你怎样定义一个本地的<code>PlatformTransactionManager</code>实现。（这个例子适用普通的JDBC。）<br>定义一个JDBC<code>DataSource</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>相关<code>PlatformTransactionManager</code>的bean定义将有一个<code>DataSource</code>定义的引用。它看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>如果你在Java EE容器中使用JTA，你将使用通过容器从JNDI中获取的<code>DataSource</code>，和Spring的JtaTransactionManager相关联。这就是JTA和JNDI查找版本的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/jee</span><br><span class="line">        http://www.springframework.org/schema/jee/spring-jee.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;jdbc/jpetstore&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><code>JtaTransactionManager</code>不需要知道<code>DataSource</code>或者其他指定的资源，因为它使用容器的全局事务管理基础设施。</p><blockquote><p>以上定义的<code>dataSource</code>bean使用<code>jee</code>命名空间的<code>&lt;jdni-lookup/&gt;</code>标签。对于<code>schema-based</code>的更多配置信息，<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html" target="_blank" rel="noopener">Chapter40, XML Schema-based 配置</a>，对于<code>&lt;jee/&gt;</code>标签的更多信息，请看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html#xsd-config-body-schemas-jee" target="_blank" rel="noopener">Section 40.2.3</a></p></blockquote><p>你也可以使用轻松的使用Hibernate本地事务，正如在下面展示的例子。这种情况，你需要定义一个Hibernate<code>LocalSessionFactoryBean</code>，你的代码将使用它去获取Hibernate<code>Session</code>实例。</p><p><code>DataSource</code>bean定义和之前示例本地JDBC例子相似，所以下面不在展示。</p><blockquote><p>如果<code>DataSource</code>被任何非JTA事务管理使用，将通过JNDI查找，Java EE容器管理，然后它将是非事务性的，因为是使用Spring框架管理事务，而不是Java EE容器。</p></blockquote><p><code>txManager</code>bean 在这种情况下是属于<code>HibernateTransactionManager</code>类型。以相同的方式，正如<code>DataSourceTransactionManager</code>需要引用<code>DataSource</code>，<code>HiberanteTransactionManager</code>需要引用<code>SessionFactory</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;mappingResources&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;hibernateProperties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            hibernate.dialect=$&#123;hibernate.dialect&#125;</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果你使用Hibernate和Java EE容器管理JTA事务，你应该使用与之前JDBC的JTA例子相同的<code>JtaTransactionManager</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果你使用JTA，你的事务管理定义将看起来一样，而不管你用了什么数据访问技术，是JDBC，Hibernate JPA或者其他支持的技术。这个是确定的事实，JTA 事务是全局事务，可以加入任何的事务资源。</p></blockquote><p>对于以上所有情况，应用代码不需要 改变。你可以通过改变配置来改变如何管理事务，即使你从本地事务改为全局事务，反之亦然。</p><h2 id="1-4-将资源与事务同步"><a href="#1-4-将资源与事务同步" class="headerlink" title="1.4 将资源与事务同步"></a>1.4 将资源与事务同步</h2><p>现在你应该很清楚如何创建不同的事务管理，和它们怎样和需要被同步事务相关资源链接（例如：<code>DataSourceTransactionManager</code>链接JDBC<code>DataSource</code>，<code>HibernateTransactionManager</code>链接Hibernate<code>SessionFactory</code>，等等。）这个章节描述应用代码怎样直接或者非直接使用持久API，如JDBC，Hibernate，或者JDO，确保这些资源被创建，复用，和正确的清理。这个章节也讨论事务同步怎样通过相应的<code>PlatformTransactionManager</code>触发。</p><h3 id="1-4-1-高级同步方式"><a href="#1-4-1-高级同步方式" class="headerlink" title="1.4.1 高级同步方式"></a>1.4.1 高级同步方式</h3><p>首选方法是使用Spring基于高级模板的持久性集成APIs或者使用本地ORM APIs与transacton-aware工厂bean或者代理一起使用，来管理本地资源工厂。transaction-aware解决方案在内部处理资源的创建，复用，清理，资源的可选事务同步和异常映射。因此用户数据访问代码不必解决这些任务，但是可以完全关注于非样板持久逻辑。通常，你使用本地ORM API或者使用模版方式通过使用<code>JdbcTemplate</code>进行JDBC访问。这些解决方案在本参考文档的随后章节中有详细说明。</p><h3 id="1-4-2-低级同步方式"><a href="#1-4-2-低级同步方式" class="headerlink" title="1.4.2 低级同步方式"></a>1.4.2 低级同步方式</h3><p>类例如：<code>DataSourceUtils</code>（JDBC），<code>EntityManagerFactoryUtils</code>(JPA)，<code>SessionFactoryUtils</code>（Hibernate），<code>PersistenceManagerFactoryUtils</code>(JDO)，等类存在于较低级别。<br>本地持久化APIs，你使用这些类去确保Spring框架管理的实例被正确获取，事务被同步（可选），在进程中发生的异常正确的被映射到一致的API。<br>例如，在JDBC的情况下，而不是在<code>DataSource</code>调用<code>getConnection()</code>方法的传统的JDBC方式,你替换使用Spring的<code>org.springframework.jdbc.datasource.DataSourceUtils</code>类，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DataSourceUtils.getConnection(dataSource);</span><br></pre></td></tr></table></figure></p><p>如果一个已经存在的事务有一个链接和它同步，这个实例将被返回。否则，这个方法调用出方法新链接的创建，这个链接（可选）被同步到已经任何已存在的事务上，使得在随后的同一事务中重复调用。 如上所述，任何<code>SQLException</code>在Spring框架<code>CannotGetJdbcConnectionException</code>中是被包括的，是Spring框架非校验数据访问异常之一。这个方式提供了比你从<code>SQLException</code>中轻松获的更多的信息，确保跨数据库的可移植性，设置跨不同的持久化技术。</p><p>这种方式运行也没有Spring事务管理（事务同步时可选的），所以无论你是否使用Spring事务管理，你都可以使用它。</p><p>当然，一旦你使用了Spring的JDBC支持，JPA支持或者Hibernate支持，你通常更喜欢不使用<code>DataSourceUtils</code>或者其他的类，因为相比于直接使用相关的APIs，通过Spring抽象你将工作的更快乐。例如：你使用Spring<code>JdbcTemplate</code>或者<code>jdbc.object</code>包去简化你使用的JDBC，在幕后发生的链接恢复，你将不在需要写任何特定代码。</p><h3 id="1-4-3-TransactionAwareDataSourceProxy"><a href="#1-4-3-TransactionAwareDataSourceProxy" class="headerlink" title="1.4.3 TransactionAwareDataSourceProxy"></a>1.4.3 TransactionAwareDataSourceProxy</h3><p><code>TransactionAwareDataSourceProxy</code>类作为一个低级存在。这是一个<code>DataSource</code>的代理，它包装目标DataSource以增加对Spring管理的事务的认识。在这个方面，它类似于通过Java EE服务器提供的事务JNDI<code>DataSource</code>。</p><p>使用这个累根本不需要或者不可取，除非当已存在的代码必须被调用和传递了一个标准JDBC<code>DataSource</code>接口实现。在这种情况下，代码可能有用，但是参与Spring的事务管理。最好是通过使用上面提到的高级抽象去写新代码。</p><h2 id="1-5-声明式事务管理"><a href="#1-5-声明式事务管理" class="headerlink" title="1.5 声明式事务管理"></a>1.5 声明式事务管理</h2><blockquote><p>大多数Spring框架用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。</p></blockquote><p>使用Spring切面编程的Spring 框架的声明式事务管理成为可能。但是，由于事务切面代码随Spring Framework发行版一起提供并且可能以样板方式使用，因此通常没必要理解AOP概念来有效地使用此代码。</p><p>Spring 框架的声明式事务管理和 EJB CMT在给单个方法级别指定（缺少）事务的行为是相似的。在需要的情况下，不使用事务上下文调用<code>setRollbackOnly()</code>是可能的。两种事务管理类型的不同点是：</p><ul><li>和 EJB CMT不一样，绑定JTA，Spring框架的声明式事务管理可以在任何环境中运行。也可以通过调整配置文件使用JTA事务或者使用JDBC，JPA，Hibernate或者JDO本地事务。</li><li>你可以对任意类用Spring框架声明式事务管理，不仅仅是对于像EJBs的特殊类。</li><li>Spring框架提供声明式回滚规则，没有和EJB等效的功能。提供编程式和声明式两种回滚规则支持。</li><li>Spring框架允许通过使用AOP自定义事务行为。例如，你可以在事务回滚的情况下插入自定义行为。你随着事务advice也可以添加任意advice。使用EJB CMT，除了<code>setRollbackOnly</code>你无法影响容器的事务管理。</li><li>Spring框架和高端服务器一样不支持跨远程调用事务上下文传播特性。如果你需要使用这种特性，我们建议你使用EJB。但是，使用这种特性之前考略清楚，因为一般来说，不想支持事务的跨远程调用。</li></ul><blockquote><p><b>TransactionProxyFactoryBean在哪？</b><br>   在Sping的2.0版本及以上版本的声明事务配置和以前的Spring版本有很大的区别。主要的不同是不在需要配置<code>TransactionProxyFactoryBean</code>beans。<br>   Spring2.0版本之前的配置依然是100%有效的配置；将新<code>&lt;tx:tags/&gt;</code>视为代表你简单的定义<code>TransactionProxyFactoryBean</code> beans。   </p></blockquote><p>回滚规则的概念是重要的：它们允许你头指定哪种异常（或者抛出）应该造成自动的回滚。你以声明的方式指定它，在配置中，不在Java代码中。因此，尽管你可以始终在<code>TransactionStatus</code>对象上调用<code>setRollbackOnly</code>方法去回滚当前事务，但是大多数你常常可以指定<code>MyApplicationException</code>必须总是造成回滚的规则。这个选择对的重大优势是业务对象不依赖事务基础设施。例如，它们通常需要导入Spring 事务APIs或者其他Spring APIs。</p><p>尽管EJB容器默认行为在系统异常（通常是运行时异常）中自动回滚事务，EJB CMT在应用异常（除<code>java.rmi.RemoteException</code>外的检查时异常）中不自动回滚事务。虽然Spring声明式事务管理的默认行为遵循EJB约定（仅仅在非检查异常时自动回滚），但是，自定义这个行为是经常有用的。</p><h3 id="1-5-1-理解声明式事务管理实现"><a href="#1-5-1-理解声明式事务管理实现" class="headerlink" title="1.5.1 理解声明式事务管理实现"></a>1.5.1 理解声明式事务管理实现</h3><p>简单的告诉你去使用<code>@Transactional</code>注解去注解你的类，在配置中添加<code>@EnableTransactionMangement</code>，然后期待你理解它全部怎样运行的是不足够的。这个章节解释在发生与事务相关的问题时Spring的声明式事务基础设施内部工作原理。<br>关于Spring框架的说明书事务支持最重要的概念是通过AOP代理启用这个支持，事务advice由元数据（目前基于XML或者注解）驱动。事务元数据和AOP的组合生成一个代理，这个代理使用<code>TransactionInterceptor</code>和适当的<code>PlatfromTransactionManager</code>实现来驱动围绕方法调用的事务。</p><blockquote><p>Spring AOP 包含在<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring.</a></p></blockquote><p>从概念上讲，调用在一个事务代理上的一个方法像这样：</p><p><img src="media/15528176890745.png" alt=""></p><h3 id="1-5-2-声明式事务实现的例子"><a href="#1-5-2-声明式事务实现的例子" class="headerlink" title="1.5.2 声明式事务实现的例子"></a>1.5.2 声明式事务实现的例子</h3><p>考虑下面的接口，和随后的实现。这个例子使用<code>Foo</code>和<code>Bar</code>类作为标志符，以便于你可以不用管不住特殊域模型，只集中关注事务的使用。对于这个例子的目的，在每一个实现方法体内，<code>DefaultFooService</code>类抛出<code>UnsupportedOperationException</code>实例的事实是好的；它允许你查看创建的事务和然后回滚来响应<code>UnsupportedOperationException</code>实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public interface FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName, String barName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<code>FooService</code>接口的前面两个方法，<code>getFoo(String)</code>和<code>getFoo(String, String)</code>，必须在一个带有只读语义事务的上下文中执行，和其他的方法，<code>insertFoo(Foo)</code>和<code>updateFoo(Foo)</code>，必须在带有只读语义事务上下文中执行。如下配置在下面的几段中被详细解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the transactional advice (what &apos;happens&apos;; see the &lt;aop:advisor/&gt; bean below) --&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;!-- the transactional semantics... --&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!-- all methods starting with &apos;get&apos; are read-only --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;!-- other methods use the default transaction settings (see below) --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ensure that the above transactional advice runs for any execution</span><br><span class="line">        of an operation defined by the FooService interface --&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;fooServiceOperation&quot; expression=&quot;execution(* x.y.service.FooService.*(..))&quot;/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;fooServiceOperation&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- don&apos;t forget the DataSource --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;scott&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;tiger&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- similarly, don&apos;t forget the PlatformTransactionManager --&gt;</span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>检查前面的配置。你想创建一个服务对象，<code>fooService</code>bean。要应用的事务语义被封装在<code>&lt;tx:advice/&gt;</code>定义中。<code>&lt;tx:advice/&gt;</code>定义读作“在只读事务上下文中所有要执行的方法以<code>get</code>开头，所有其他要执行的方法带有默认事务语义。“<code>&lt;tx:advice/&gt;</code>标签的<code>transaction-manager</code>属性被设置为将要驱动事务的<code>PlatformTransactionManager</code>bean 的name，在当前的配置文件中，是<code>txManager</code>bean。</p><blockquote><p>如果你想设置<code>PlatformTransactionManager</code>bean的name为<code>transactionManager</code>，你可以忽略事务advice的<code>transaction-manager</code>属性。如果你想使用任何其他的name给<code>PlatformTransactionManager</code>bean，正如在之前的例子中，你之后必须明确的使用<code>transaction-manager</code>属性。</p></blockquote><p><code>&lt;aop:config/&gt;</code>的定义确保在程序中适当的点执行通过<code>txAdvice</code>bean定义的事务advice。首先你定义一个切入点，切入点与在<code>FooService</code>接口（<code>fooServiceOperation</code>）中定义的任何操作执行的相匹配。然后使用advisor关联切入点和txAdvice。结果表明在执行<code>fooServiceOperation</code>时，通过<code>txAdvice</code>定义的advice将会运行。</p><p>在<code>&lt;aop:pointcut/&gt;</code>元素中定义的表达式，是一个AspectJ切入点表达式；查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring</a>了解更多有关Spring中的切入点表达式的详细信息。</p><p>一个常见的需求时创建一个全部服务层的事务。实现这种需求的最好方式是只修改切入点表达式去匹配在你服务层的所有操作。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;fooServiceMethods&quot; expression=&quot;execution(* x.y.service.*.*(..))&quot;/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;fooServiceMethods&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中：它假设你所有服务接口在<code>x.y.service</code>包中定义；查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring </a>了解更多信息。</p></blockquote><p>现在，我们已经分析了配置，你可能会问你自己，“这所有的配置实际上做了什么？”。</p><p>以上配置将被用来去创建一个事务代理围绕从<code>fooService</code>bean 定义创建的对象。这个代理将使用事务advice配置，以便于在代理上调用一个适当的方法时，一个事务开始，挂起，被标记为只读等等，取决于与该方法关联的事务配置。考虑一下测试驱动以上配置的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Boot &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;context.xml&quot;, Boot.class);</span><br><span class="line">        FooService fooService = (FooService) ctx.getBean(&quot;fooService&quot;);</span><br><span class="line">        fooService.insertFoo (new Foo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码的输出将类似下面的。（为清楚起见，Log4J输出和DefaultFooService类的insertFoo（..）方法抛出的UnsupportedOperationException的堆栈跟踪已被截断。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- the Spring container is starting up... --&gt;</span><br><span class="line">[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean &apos;fooService&apos; with 0 common interceptors and 1 specific interceptors</span><br><span class="line"></span><br><span class="line">&lt;!-- the DefaultFooService is actually proxied --&gt;</span><br><span class="line">[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]</span><br><span class="line"></span><br><span class="line">&lt;!-- ... the insertFoo(..) method is now being invoked on the proxy --&gt;</span><br><span class="line">[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo</span><br><span class="line"></span><br><span class="line">&lt;!-- the transactional advice kicks in here... --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]</span><br><span class="line">[DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction</span><br><span class="line"></span><br><span class="line">&lt;!-- the insertFoo(..) method from DefaultFooService throws an exception... --&gt;</span><br><span class="line">[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException</span><br><span class="line">[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]</span><br><span class="line"></span><br><span class="line">&lt;!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp.PoolableConnection@a53de4]</span><br><span class="line">[DataSourceTransactionManager] - Releasing JDBC Connection after transaction</span><br><span class="line">[DataSourceUtils] - Returning JDBC Connection to DataSource</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)</span><br><span class="line">&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;</span><br><span class="line">at $Proxy0.insertFoo(Unknown Source)</span><br><span class="line">at Boot.main(Boot.java:11)</span><br></pre></td></tr></table></figure><h3 id="1-5-3-回滚一个声明式事务"><a href="#1-5-3-回滚一个声明式事务" class="headerlink" title="1.5.3 回滚一个声明式事务"></a>1.5.3 回滚一个声明式事务</h3><p>上面的章节概述了如何在你的应用中给类（通常是服务层类）声明式的指定事务设置。这个章节描述如果以一种简单的声明式方式控制事务回滚。<br>向Spring框架的事务基础设施表明回滚一个事务的推荐的方式是在当前一个事务上下文从执行的代码中抛出<code>Exception</code>。Spring框架事务基础设施代码将捕获所有未处理异常，因为它会调用堆栈，做出判定是否标记回滚事务标识。</p><p>在它的默认配置中，Spring框架的事务基础设施代码仅仅在runtime，unchecked异常时标记回滚事务；也就是说，当抛出的异常是一个实例或者RuntimeException的子类。（Errors在默认配置下也会回滚）。在一个事务方法中抛出的已检查异常在默认配置下不会造成回滚。</p><p>你可以准确的配置哪些类型的异常标记事务回滚，包括已检查的异常。下面的XML片段演示你怎样给已检查和应用指定异常类型配置回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; rollback-for=&quot;NoProductInStockException&quot;/&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>如果当抛出一个异常的时候，你不想事务回滚，你也可以指定‘不回滚规则’。下面的列子告诉你Spring框架的事务基础设施即使面对未处理的InstrumentNotFoundException也要提交<strong>伴随</strong>事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;updateStock&quot; no-rollback-for=&quot;InstrumentNotFoundException&quot;/&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>当Spring框架的事务基础设施缓存一个异常，参考回滚配置规则来决定是否标记回滚事务时，强匹配规则胜利。因此，在下面配置的这种情况，除<code>InstrumentNotFoundException</code>以外的所有异常都会造成伴随事务的回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Throwable&quot; no-rollback-for=&quot;InstrumentNotFoundException&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure><p>你可以表示一个需要编程式回滚。尽管非常简单，这个进程时侵入式的，Spring框架的事务基础设施将紧紧侵入你的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void resolvePosition() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // some business logic...</span><br><span class="line">    &#125; catch (NoProductInStockException ex) &#123;</span><br><span class="line">        // trigger rollback programmatically</span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有可能强烈推荐使用声明式途径回滚事务。编程式事务回滚应该在你绝对需要时使用，但是它的用法在实现基于POJO的清洁框架时很明显。</p><h3 id="1-5-4-给不同的bean配置不同的事务语义"><a href="#1-5-4-给不同的bean配置不同的事务语义" class="headerlink" title="1.5.4 给不同的bean配置不同的事务语义"></a>1.5.4 给不同的bean配置不同的事务语义</h3><p>考虑具有多个服务层对象的情况，并且您希望对每个对象应用完全不同的事务配置。使用不同的切入点和advice-ref属性值定义不同的&lt;aop：advisor /&gt;元素。作为比较，首先假设您的所有服务层类都在根x.y.service包中定义。要使所有作为在该包（或子包中）中定义的类的实例的bean以及以Service结尾的名称具有默认的事务配置，您将编写以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;serviceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service..*Service.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;serviceOperation&quot; advice-ref=&quot;txAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- these two beans will be transactional... --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;barService&quot; class=&quot;x.y.service.extras.SimpleBarService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ... and these two beans won&apos;t --&gt;</span><br><span class="line">    &lt;bean id=&quot;anotherService&quot; class=&quot;org.xyz.SomeService&quot;/&gt; &lt;!-- (not in the right package) --&gt;</span><br><span class="line">    &lt;bean id=&quot;barManager&quot; class=&quot;x.y.service.SimpleBarManager&quot;/&gt; &lt;!-- (doesn&apos;t end in &apos;Service&apos;) --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>下面的例子展示怎样使用两种完全不同的事务设置配置两种不同的bean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;defaultServiceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service.*Service.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id=&quot;noTxServiceOperation&quot;</span><br><span class="line">                expression=&quot;execution(* x.y.service.ddl.DefaultDdlManager.*(..))&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;defaultServiceOperation&quot; advice-ref=&quot;defaultTxAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;noTxServiceOperation&quot; advice-ref=&quot;noTxAdvice&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will be transactional (see the &apos;defaultServiceOperation&apos; pointcut) --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;</span><br><span class="line">    &lt;bean id=&quot;anotherFooService&quot; class=&quot;x.y.service.ddl.DefaultDdlManager&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;defaultTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;noTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot; propagation=&quot;NEVER&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-lt-tx-advice-gt-设置"><a href="#1-5-5-lt-tx-advice-gt-设置" class="headerlink" title="1.5.5 &lt;tx:advice/&gt;设置"></a>1.5.5 <code>&lt;tx:advice/&gt;</code>设置</h3><p>这个章节总结可以指定使用<code>&lt;tx:advice/&gt;标签的各种事务配置。默认的</code><a href="tx:advice/" target="_blank" rel="noopener">tx:advice/</a>`设置：</p><ul><li>传播特性是 <code>REQUIRED</code></li><li>隔离等级是 <code>DEFAULT</code></li><li>事务是读/写</li><li>事务超时默认为底层事务系统的默认超时，如果不支持超时则为none</li><li>任意<code>RuntimeException</code>触发回滚，任意的检查时异常不回滚。</li></ul><p>你可以改变这些默认设置；嵌套在<code>&lt;tx:advice/&gt;</code>和<code>&lt;tx:attributes/&gt;</code>标签中的<code>&lt;tx:method/&gt;</code>标签的各种属性总结如下：<br><a href="tx:method/" target="_blank" rel="noopener">tx:method/</a> 设置:<br><img src="media/15531331224039.jpg" alt=""></p><h3 id="1-5-6-使用-Transactional"><a href="#1-5-6-使用-Transactional" class="headerlink" title="1.5.6 使用@Transactional"></a>1.5.6 使用@Transactional</h3><p>除了基于XML的方式声明事务配置，你也可以使用基于注解的方式。直接在Java源代码中声明事务语义使声明更接近被作用的代码。没有太多过度耦合的危险，因为无论如何，以事务方式使用的代码几乎总是以这种方式部署。</p><blockquote><p>标准<code>javax.transaction.Transactional</code>注解支持使用Spring自己的注解直接替换。请参考JTA 1.2 文档了解更多详细资料。</p></blockquote><p>使用@Transactional注释所提供的易用性最好通过一个示例来说明，该示例将在后面的文本中进行说明。考虑以下类定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// the service class that we want to make transactional</span><br><span class="line">@Transactional</span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当上面的POJO被定义为Spring IoC容器中的bean时，可以通过仅添加一行XML配置来使bean实例成为事务性的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- from the file &apos;context.xml&apos; --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;&lt;!-- a PlatformTransactionManager is still required --&gt;</span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;!-- (this dependency is defined somewhere else) --&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果要连接的<code>PlatformTransactionManager</code>的bean的名字是<code>transactionManager</code>，你可以忽略<code>&lt;tx:annotation-driven</code>/&gt;的<code>transaction-manager</code>属性。如果你要依赖注入的<code>PlatformTransactionManager</code>bean有任何其他的名字，你必须和上面的例子一样明确的使用<code>transaction-manager</code>。<br>如果你基于Java配置，<code>@EnableTransactionManagement</code>注解提供有效的支持。只需添加<code>@Configuration</code>注解类。查看全部详细内容请看javadocs。</p></blockquote><blockquote><p><b>方法可见性和@Transaction</b><br>当使用代理时，仅仅对于public可见性的方法应用<code>@Transactional</code>注解。如果你对protected，private或者包内可见的方法使用<code>@Transactional</code>注解，虽然没有错误，但是这个已经注解的方法不展示已配置的事务配置。如果你需要直接非public的方法，可以考虑使用AspectJ（见下文）。</p></blockquote><p>你可以在一个接口定义，接口上的方法，类定义或者类上的public方法前面设置<code>@Transactional</code>。但是，只有<code>@Transactional</code>注解是不足以激活事务行为的。<code>@Transactional</code>注解是一个简单的元数据，它可以被一些运行时的基础设施消费，这个基础设施是<code>@Transactional</code>-aware和可以使用元数据配置具有事务行为的适当的bean。在上面的例子中，<code>&lt;tx:annotation-driven/&gt;</code>元素打开事务行为。</p><blockquote><p>Spring 推荐你只使用<code>@Transactional</code>注解具体类（和具体类的方法），而不是注解接口。你通常可以在一个接口（或者一个接口的方法）上配置<code>@Transactional</code>注解，但是，仅仅在你使用基于接口代理的方式时才能获得你期望的运行。Java注解不从接口继承Java注解的事实意味着如果你使用基于类的代理（<code>proxy-target-class=&quot;true&quot;</code>）或者基于切面织入（<code>mode=&quot;&quot;aspectj</code>），然后代理和织入的基础设施将不识别事务设置，并且这个对象不被包裹在事务代理中，这将是非常糟糕的。</p></blockquote><blockquote><p>在代理模式（默认）中，仅外部的方法通过代理调用进入会被拦截。这意味着自我调用，实际上，在目标对象的方法调用目标对象的其他方法将不会在运行时引起一个实际的事务，即使被调用的方法使用<code>@Transactional</code>标记。这个代理也必须完整的初始化去提供你期望的行为，因此，你不应该在你的初始化代码中依赖这个特性，即<code>@PostConstruct</code>。</p></blockquote><p>如果你希望自我调用也被包裹在事务中，可以考虑切面模式（在下面的表格中查看模式的属性）的使用。在这种情况下，首先不会有一个代理；相反，为了将<code>@Transactional</code>转换为任何类型方法上的运行时行为，目标类将被织入（它的字节码将被修改）。</p><p><table><tr><td>XML Attribute</td><td>Annotation Attribute</td><td>Default</td><td>Description</td></tr><tr><td><code>transaction-manger</code></td><td>N/A(查看<code>TransactionManagementConfigurer</code> javadocs)</td><td>transactionManager</td><td>要使用的事务管理器的名称。仅在如果事务管理器的名称不是<code>transactionManager</code>时需要，如上面的例子所示</td></tr><tr><td><code>mode</code></td><td><code>mode</code></td><td>proxy</td><td>默认模式“代理”进程使用Spring的AOP框架（以下代理语义，正如上面讨论的，仅适用于通过代理进入的方法调用）代理被注解的bean。替代模式“aspectj”代替使用Spring的AspectJ事务切面织入受影响的类，修改目标类字节码以应用任何类型的方法调用。AspectJ 织入需要spring-aspects.jar在classpath中，同时加载时织入（编译时织入）开启。（查看怎样设置加载时织入的详细内容，请访问<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-aj-ltw-spring" target="_blank" rel="noopener">Spring配置</a>）</td></tr><tr><td><code>proxy-target-class</code></td><td><code>proxyTargetClass</code></td><td>false</td><td>仅适用代理模式。控制给带有<code>@Transactional</code>注解的注解类创建什么类型的事务代理。如果<code>proxy-target-class</code>属性设置为<code>true</code>，基于类的代理将被创建。如果<code>proxy-target-class</code>为false或者这个属性被忽略，标准JDK基于接口的代理将被创建。（详细检查不同类型代理请查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-proxying）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;`order`&lt;/td&gt;&lt;td&gt;`order`&lt;/td&gt;&lt;td&gt;Ordered.LOWEST_PRECEDENCE&lt;/td&gt;&lt;td&gt;定义事务advice的order适用于带有`@Transaction`注解的bean。（关于有关AOP advice的规则的更多信息，查看[Advice ordering](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">10.6 代理机制</a>。）不指定ordering意味着AOP子系统决定advice的order</td></tr></table></p><blockquote><p><code>@EnableTransactionManagement</code>和<code>&lt;tx:annotation-driven/&gt;</code>只查找它们定义在相同应用上下文bean上的<code>@Transactional</code>。这意味着，如果你在一个<code>WebApplicationContext</code>中给一个<code>DispatcherServlet</code>添加注解驱动配置，它仅仅检查你controller带有<code>@Transactional</code>的bean，而不是你的service。了解更多信息查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/mvc.html#mvc-servlet" target="_blank" rel="noopener">The DispatcherServlet</a>。</p></blockquote><p>在评估方法的事务设置时，派生最多的位置优先。下面列子的这种情况，<code>DefaultFooService</code>类在类级别中使用只读事务设置注解，但是，在相同的类中，在<code>updateFoo(Foo)</code>方法上的<code>@Transactional</code>注解优先于类级别定义的事务设置。</p><blockquote><p><b>@Transactional 设置</b><br><code>@Transactional</code>注解是一个元数据，这个元数据指定一个接口，类或者方法必须有事务语义；例如，“当方法被调用时，开始一个全新的只读事务，中止任何已存在的事务“。默认的<code>@Transactional</code>设置如下：</p></blockquote><ul><li>传播特性设置是<code>PROPAGATION_REQUIRED</code>。</li><li>隔离等级是<code>ISOLATION_DEFAULT</code>。</li><li>事务是读/写。</li><li>事务超时默认是底层事务系统的默认超时，或者如果不支持超时为none。</li><li>任何<code>RuntimeException</code>触发回滚，任何已校验异常不会。</li></ul><p>这些默认设置可以改变；在下表中总结了<code>@Transactional</code>注解的各种属性：</p><p><table><tr><td>Property</td><td>Type</td><td>Description</td></tr><tr><td>value</td><td>String</td><td>可选限定符，指定要使用的事务管理器</td></tr><tr><td>propagation</td><td>enum:<code>Propagation</code></td><td>可选传播特性设置</td></tr><tr><td><code>isolation</code></td><td>enum:<code>Isolation</code></td><td>可选隔离级别</td></tr><tr><td><code>readOnly</code></td><td>boolean</td><td>读/写 vs 只读</td></tr><tr><td><code>timeout</code></td><td>int(秒粒度)</td><td>事务超时</td></tr><tr><td><code>rollbackFor</code></td><td>类的对象数组，必须从<code>Throwable</code>派生</td><td>可选异常类数组，这些异常必须造成回滚</td></tr><tr><td><code>rollbackForClassName</code></td><td>类的名称数组，类必须从<code>Throwable</code>派生</td><td>可选异常类名称数组，必须造成回滚</td></tr><tr><td><code>noRollbackFor</code></td><td>类的对象数组，必须从<code>Throwable</code>派生</td><td>可选异常类数组，这些异常必须不造成回滚</td></tr><tr><td><code>noRollbackForClassName</code></td><td>类的名称数组，类必须从<code>Throwable</code>派生</td><td>可选异常类名称数组，必须不造成回滚</td></tr></table><br>目前，你无法明确的掌控事务的名称，如果适用，其中<code>name</code>表示将在事务监视器中显示的事务名称，以及日志记录输出。对于声明式事务，事务名总是全量类名+“.”+事务的advised类的方法名。例如，如果<code>BusinessService</code>类的<code>handlePayment(...)</code>方法开始一个事务，事务名称将会是<code>com.foo.BusinessService.handlePayment</code>。</p><h4 id="使用-Transactional的多个事务管理"><a href="#使用-Transactional的多个事务管理" class="headerlink" title="使用@Transactional的多个事务管理"></a>使用@Transactional的多个事务管理</h4><p>大多数Spring应用仅仅需要单个事务管理，但是可能也会有在单个应用中你想多个独立事务管理的情况。<code>@Transactional</code>注解的属性值可以被用来选择性指定要使用的<code>PlatformTransactionManager</code>。这可以是bean的名称或者事务管理bean的值。例如，如下Java代码使用的限定符值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TransactionalService&#123;</span><br><span class="line"></span><br><span class="line">    @Transactional(&quot;order&quot;)</span><br><span class="line">    public void setSomething(String name)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    @Transactional(&quot;account&quot;)</span><br><span class="line">    public void doSomething()&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在应用上下文中和如下的事务管理bean声明组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;tx:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;transactionManager1&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value=&quot;order&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;transactionManager2&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value=&quot;account&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>TransactionalService</code>的两个方法将在单独事务管理器下运行，通过“order”和“account”区分。如果没有找到指定限定符的<code>PlatformTransactionManager</code>的bean，将一直使用<code>&lt;tx:annotation-driven&gt;</code>默认的目标bean名称<code>transactionManager</code>。</p><h4 id="自定义快捷方式注解"><a href="#自定义快捷方式注解" class="headerlink" title="自定义快捷方式注解"></a>自定义快捷方式注解</h4><p>如果你发现你在许多不同方法上重复使用<code>@Transactional</code>的相同属性值，[Spring’s meta-annotaion support]允许你在你的指定使用情况下定义自定义快捷方式的注解。例如，如下注解的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;order&quot;)</span><br><span class="line">public @interface OrderTx &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;account&quot;)</span><br><span class="line">public @interface AccountTx &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许我们将上一小节的例子写为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TransactionalService&#123;</span><br><span class="line">    </span><br><span class="line">    @OrderTx</span><br><span class="line">    public void setSomething(String name)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    @AccountTx</span><br><span class="line">    public void doSomething()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了定义事务管理器的限定符语法，但是我们也可以包含传播特性行为，回滚规则，超时等等。</p><h3 id="1-5-7-事务传播特性"><a href="#1-5-7-事务传播特性" class="headerlink" title="1.5.7 事务传播特性"></a>1.5.7 事务传播特性</h3><p>这个章节描述在Spring中的事务传统特性的一些语义。请注意这个章节不是适当的一个事务传播特性介绍；二是详细描述在Spring中关于事务传播特性的一些语义。</p><p>在Spring管理的事务中，注意物理和逻辑事务的区别，和事务传播特性设置如何应用此差异。<br><img src="media/15534834588483.jpg" alt=""></p><p><code>PROPAGATION_REQUIRES_NEW</code>，与<code>PROPAGATION_REQUIRED</code>相比，为每一个事务作用域使用一个独立的事务。在那种情况下，底层的物理事务是不同的，因此可以独立的提交或者回滚，外部事务不受内部事务回滚状态的影响。</p><h4 id="Nested"><a href="#Nested" class="headerlink" title="Nested"></a>Nested</h4><p><code>PROPAGATION_NESTED</code>使用具有多个保存点的单个物理事务，它可以回滚到该事务。一些局部是回滚允许内部事务域在它的作用域触发回滚，使用外部事务可以继续物理事务而不用管一些已经回滚的操作。这个设置常用来映射JDBC的保存点。因此仅仅和JDBC资源事务一起工作。查看Spring的<code>DataSourceTransactionManager</code>。</p><h3 id="1-5-8-Advising-事务操作"><a href="#1-5-8-Advising-事务操作" class="headerlink" title="1.5.8 Advising 事务操作"></a>1.5.8 Advising 事务操作</h3><p>假如你想同时执行事务和一些基础剖析advice。你怎样在<code>&lt;tx:annotaion-driven/&gt;</code>的上下文中实现这点？</p><p>当你调用<code>updateFoo(Foo)</code>方法，你想看到如下动作：</p><ul><li>配置的剖析切面启动</li><li>事务advice执行</li><li>advised对象上的方法执行</li><li>事务提交</li><li>剖析切面精确报告整个事务方法调用期间</li></ul><blockquote><p>这个章节不关心详细介绍AOP（除非AOP适用于事务）。有关以下AOP配置和AOP的详细介绍，请参见<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10,Aspect Oriented Programming with Spring</a>。</p></blockquote><p>这是上面讨论简单剖析切面的代码。advice的排序由<code>Ordered</code>接口控制。了解advice 排序的全部详细内容，查看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">the section called “Advice ordering”</a>..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package x.y;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.springframework.util.StopWatch;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line"></span><br><span class="line">public class SimpleProfiler implements Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private int order;</span><br><span class="line"></span><br><span class="line">    // allows us to control the ordering of advice</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return this.order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrder(int order) &#123;</span><br><span class="line">        this.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this method is the around advice</span><br><span class="line">    public Object profile(ProceedingJoinPoint call) throws Throwable &#123;</span><br><span class="line">        Object returnValue;</span><br><span class="line">        StopWatch clock = new StopWatch(getClass().getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            clock.start(call.toShortString());</span><br><span class="line">            returnValue = call.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            clock.stop();</span><br><span class="line">            System.out.println(clock.prettyPrint());</span><br><span class="line">        &#125;</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the aspect --&gt;</span><br><span class="line">    &lt;bean id=&quot;profiler&quot; class=&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        &lt;property name=&quot;order&quot; __value=&quot;1&quot;__/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; __order=&quot;200&quot;__/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">            &lt;!-- this advice will execute around the transactional advice --&gt;</span><br><span class="line">            &lt;aop:aspect id=&quot;profilingAspect&quot; ref=&quot;profiler&quot;&gt;</span><br><span class="line">                &lt;aop:pointcut id=&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                        expression=&quot;execution(!void x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">                &lt;aop:around method=&quot;profile&quot; pointcut-ref=&quot;serviceMethodWithReturnValue&quot;/&gt;</span><br><span class="line">            &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;scott&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;tiger&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>上述配置的结果是一个fooService bean，它具有按所需顺序应用于它的分析和事务切面。你可以以类似的方式配置任意数量的其他切面。</p><p>以下示例实现与上述相同的配置，但是使用纯粹的XML声明式途径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the profiling advice --&gt;</span><br><span class="line">    &lt;bean id=&quot;profiler&quot; class=&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        __&lt;property name=&quot;order&quot; value=&quot;1__&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;entryPointMethod&quot; expression=&quot;execution(* x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">        &lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;entryPointMethod&quot; __order=&quot;2__&quot;/&gt;</span><br><span class="line">        &lt;!-- order value is higher than the profiling aspect --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:aspect id=&quot;profilingAspect&quot; ref=&quot;profiler&quot;&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                    expression=&quot;execution(!void x.y..*Service.*(..))&quot;/&gt;</span><br><span class="line">            &lt;aop:around method=&quot;profile&quot; pointcut-ref=&quot;serviceMethodWithReturnValue&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean/&gt; definitions such as a DataSource and a PlatformTransactionManager here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>以上配置的结果是一个<code>fooService</code>bean，它具有适用于它的所需排序的剖析和事务切面。如果你想要在事务advice在进入之后，事务advice出去之前，执行的剖析advice，你只需简单的更换剖析切面bean的order属性值，使得它比事务advice的顺序值更高。</p><p>你使用类似的方式配置其他的切面。</p><h3 id="1-5-9-使用带有切面的-Transactional"><a href="#1-5-9-使用带有切面的-Transactional" class="headerlink" title="1.5.9 使用带有切面的@Transactional"></a>1.5.9 使用带有切面的@Transactional</h3><p>在一个Spring容器之外，通过AspectJ切面，也可能使用Spring框架的<code>@Transactional</code>的支持。如果这样做，你首先使用<code>@Transactional</code>注解你的类（和可选择的你的类方法），然后你使用定义在<code>spring-aspects.jar</code>的<code>org.springframework.transaction.aspectj.AnnotationTransactionAspect</code>连接（织入）你的应用。还必须使用事务管理器配置你的切面。你当然可以使用Spring框架的IoC容器去管理依赖注入切面。配置事务管理器切面的最简单方式是使用<code>&lt;tx:annotation-driven/&gt;</code>元素和给<code>aspectj</code>指定<code>mode</code>属性，正如在<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-annotations" target="_blank" rel="noopener">Section 16.5.6 Using @Transactional</a>。因为我们关注在一个Spring容器之外程序的运行，我们将会向你展示如何以编程的方式实现它。</p><blockquote><p> 在继续之前，你可能想要分别去读<a href="">Section 16.5.6 Using @Transactional</a>和<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Chapter 10, Aspect Oriented Programming with Spring</a>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// construct an appropriate transaction manager</span><br><span class="line">DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());</span><br><span class="line"></span><br><span class="line">// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods</span><br><span class="line">AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);</span><br></pre></td></tr></table></figure><blockquote><p>当使用切面，你必须注解实现类（和/或 类里的方法），不是类实现的接口。<br>AspectJ 遵守Java的规则，不继承接口上的注解。</p></blockquote><p>在类上的<code>@Transactional</code>注解给在类里的任何方法的执行指定默认事务语义。<br>在在类里的方法上的<code>@Transactional</code>注解覆盖类提供注解（如果存在）的默认事务语义。不管是否可见，任何的方法可能被注解。</p><p>使用<code>AnnotationTransactionAspect</code>织入你的应用，你要么使用AspectJ（<a href="https://www.eclipse.org/aspectj/doc/released/devguide/index.html" target="_blank" rel="noopener">AspectJ Development Guide</a>）构建你的应用，要么使用加载时织入。使用AspectJ加载时织入的讨论请看<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-aj-ltw" target="_blank" rel="noopener">Load-time weaving with AspectJ in the Spring Framework</a></p><h2 id="1-6-编程事务管理"><a href="#1-6-编程事务管理" class="headerlink" title="1.6 编程事务管理"></a>1.6 编程事务管理</h2><p>Spring框架提供两种编程事务管理工具：</p><ul><li>使用<code>TransactionTemplate</code>。</li><li>直接使用<code>PlatformTransactionManager</code>实现。</li></ul><p>对于编程式事务管理Spring团队通常建议使用<code>TransactionTemplate</code>。第二种相似途径是使用JTA<code>UserTransaction</code>API，虽然异常处理不是那么笨重。</p><h3 id="1-6-1-使用TransactionTemplate"><a href="#1-6-1-使用TransactionTemplate" class="headerlink" title="1.6.1 使用TransactionTemplate"></a>1.6.1 使用TransactionTemplate</h3><p><code>TransactionTemplate</code> 采用与其他Spring模版（例如<code>JdbcTemplate</code>）一样的方式。它使用一个回调的方法，使应用代码不必执行样板获取和释放事务资源，并产生驱动程序的代码，以便于被编写的代码仅关注开发人员想要做的事情。</p><blockquote><p>正如你将在如下的例子中看到的，使用<code>TransactionTemplate</code>绝对将你和Spring的事务基础架构和API结合在一起。</p></blockquote><p>应用代码必须在事务上下文中执行，明确的使用<code>TransactionTemplate</code>，看起来和如下的相似。你作为一个应用开发者，写一个<code>TransactionCallback</code>实现（通常表现为一个匿名内部类），这个实现包含在一个事务上下文中执行的代码。然后将自定义<code>TransactionCallback</code>的实例，传递给<code>TransactionTemplate</code>上公开的<code>execute(...)</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    // single TransactionTemplate shared amongst all methods in this instance</span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    // use constructor-injection to supply the PlatformTransactionManager</span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        Assert.notNull(transactionManager, &quot;The &apos;transactionManager&apos; argument must not be null.&quot;);</span><br><span class="line">        this.transactionTemplate = new TransactionTemplate(transactionManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object someServiceMethod() &#123;</span><br><span class="line">        return transactionTemplate.execute(new TransactionCallback() &#123;</span><br><span class="line">            // the code in this method executes in a transactional context</span><br><span class="line">            public Object doInTransaction(TransactionStatus status) &#123;</span><br><span class="line">                updateOperation1();</span><br><span class="line">                return resultOfUpdateOperation2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有返回值，方便的使用<code>TransactionCallbackWithoutResult</code>类和一个匿名内部类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        updateOperation1();</span><br><span class="line">        updateOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在回调中的代码可以通过提供的<code>TransactionStatus</code>对象上调用<code>setRollbackOnly()</code>方法回滚这个事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line"></span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            updateOperation1();</span><br><span class="line">            updateOperation2();</span><br><span class="line">        &#125; catch (SomeBusinessExeption ex) &#123;</span><br><span class="line">            status.setRollbackOnly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="指定事务设置"><a href="#指定事务设置" class="headerlink" title="指定事务设置"></a>指定事务设置</h4><p>你可以以编程方式或配置方式在TransactionTemplate上指定例如传播特性模式，隔离等级，超时等等的事务设置。默认的<code>TransactionTemplate</code>实例有<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-txadvice-settings" target="_blank" rel="noopener">默认事务设置</a>。如下的例子展示对于一个指定<code>TransactionTemplate</code>事务设置的编程式定制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        Assert.notNull(transactionManager, &quot;The &apos;transactionManager&apos; argument must not be null.&quot;);</span><br><span class="line">        this.transactionTemplate = new TransactionTemplate(transactionManager);</span><br><span class="line"></span><br><span class="line">        // the transaction settings can be set here explicitly if so desired</span><br><span class="line">        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);</span><br><span class="line">        this.transactionTemplate.setTimeout(30); // 30 seconds</span><br><span class="line">        // and so forth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下的例子定义了一个使用一些自定义事务设置的<code>TransactionTemplate</code>，使用Spring XML配置。然后可以将<code>sharedTransactionTemplate</code>注入到尽可能多的需要的服务中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sharedTransactionTemplate&quot;</span><br><span class="line">        class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;isolationLevelName&quot; value=&quot;ISOLATION_READ_UNCOMMITTED&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;timeout&quot; value=&quot;30&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>最后，<code>TransactionTemplate</code>类的实例是线程安全的，因为实力不保持任何会话状态。但是，<code>TransactionTemplate</code>实例会保持配置状态，因此当许多类可能共享一个<code>TransactionTemplate</code>的一个单例时，如果一个类需要使用一个带有不同设置（例如，不同隔离等级）的<code>TransactionTemplate</code>，你就需要去创建一个两个不同的<code>TransactionTemplate</code>实例。</p><h3 id="1-6-2-使用PlatformTransactionManager"><a href="#1-6-2-使用PlatformTransactionManager" class="headerlink" title="1.6.2 使用PlatformTransactionManager"></a>1.6.2 使用PlatformTransactionManager</h3><p>你也可以直接使用<code>org.springframework.transaction.PlatformTransactionManager</code>管理你的事务。简单的通过一个bean引用传递你正在用的<code>PlatformTransactionManager</code>的实现给你的bean。然后，使用<code>TransactionDefinition</code>和<code>TransactionStatus</code>对象你可以发起，回滚和提交事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultTransactionDefinition def = new DefaultTransactionDefinition();</span><br><span class="line">// explicitly setting the transaction name is something that can only be done programmatically</span><br><span class="line">def.setName(&quot;SomeTxName&quot;);</span><br><span class="line">def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">TransactionStatus status = txManager.getTransaction(def);</span><br><span class="line">try &#123;</span><br><span class="line">    // execute your business logic here</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex) &#123;</span><br><span class="line">    txManager.rollback(status);</span><br><span class="line">    throw ex;</span><br><span class="line">&#125;</span><br><span class="line">txManager.commit(status);</span><br></pre></td></tr></table></figure><h2 id="1-7-编程式和声明式事务管理器的选择"><a href="#1-7-编程式和声明式事务管理器的选择" class="headerlink" title="1.7 编程式和声明式事务管理器的选择"></a>1.7 编程式和声明式事务管理器的选择</h2><p>编程式事务管理仅仅在你如果有一个小数量的事务操作情况下才是一个好想法。例如，如果你有一个web应用需要仅仅主要是update操作的事务，你不可能想去使用Spring或者其他任何技术去设置事务代理。在这种情况下，使用<code>transactionTemplate</code>可能是一个好方法。可能明确的设置事务名称可以仅在使用编程式途径进行事务管理的情况下去做。</p><p>从另一方面，如果你的应用有很多事务操作，声明式事务管理通常是合算的。它保持事务管理摆脱业务逻辑，配置不困难。当使用Spring框架，而不是EJB CMT时，声明式事务配置的成本将大大降低。</p><h2 id="1-8-事务约束事件"><a href="#1-8-事务约束事件" class="headerlink" title="1.8 事务约束事件"></a>1.8 事务约束事件</h2><p>作为Spring 4.2，一个事件的监听可以被约束为事务的一个阶段。常用的例子是当事务已经成功的完成时去处理事件：当当前事务的结果对于监听器实际上很重要时，这允许事件被更灵活地使用。<br>注册一个常规的监听事件可以通过<code>@EventListener</code>注解。如果你需要和事务绑定它使用<code>@TransactionEventListener</code>。当你这样做时，监听器将默认约束事务提交阶段。<br>我们举个例子说明这个概念。</p><p>假设一个组件发布了一个订单创建的事件，我们想要定义一个监听器，该监听器只应该在事件成功提交时才处理该事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyComponent &#123;</span><br><span class="line"></span><br><span class="line">    @TransactionalEventListener</span><br><span class="line">    public void handleOrderCreatedEvent(CreationEvent&lt;Order&gt; creationEvent) &#123;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>TransactionalEventListener</code>注解暴露一个<code>phase</code>属性，这个属性允许自定义监听器应该约束事务的哪个phase。这个有效的phases是<code>BEFORE_COMMIT</code>，<code>AFTER_COMMIT</code>(default)，<code>AFTER_ROLLBACK</code>和<code>AFTER_COMPLETION</code>，它们聚合事务的完整性（是一个提交或者一个回滚）。</p><p>如果没有正在运行的事务，由于我们无法遵守所需的语义，监听器根本不会被调用。但是，它可能通过设置注解的<code>fallbackExecution</code>属性为true去覆盖该行为。</p><h2 id="1-9-指定应用服务器的集成"><a href="#1-9-指定应用服务器的集成" class="headerlink" title="1.9 指定应用服务器的集成"></a>1.9 指定应用服务器的集成</h2><p>Spring的事务抽象通常是应用服务器不可知。此外，Spring的<code>JtaTransactionManager</code>类，可以可选执行对于JTA<code>UserTransaction</code>和<code>TransactionManager</code>对象的JNDI查找，对于后者对象，自动检查地址，该地址因应用服务器而变化。访问JTA TransactionManager允许增强的事务语义，特别是支持事务暂停。了解详细请查看<code>JtaTransactionManager</code>javadocs。</p><p>Spring的<code>JtaTransactionManager</code>在Java EE应用服务器上运行的标准选择，并已知可以在所有常用的服务器上运行。高级功能（事务暂停）在很多服务器上运行很好，包括GlassFish，JBoss和Geronimo，不需要任何特殊配置。但是，对于完整的支持事务暂停和进一步的高级集成，Spring ship对于WebLogic服务器和WebSphere特殊适配。这些适配在如下章节讨论。</p><p>对于标准场景，包括Weblogic Server和WebSphere，考虑使用定制<code>&lt;tx:jta-trasaction-manager/&gt;</code>配置元素。当已配置时，这元素自动检查底层服务器和选择适用于该平台的最好的事务管理器。这意味着你将不需要必须显式的配置指定服务器适配类（在如下章节讨论）；相反，它们是自动选择的，标准的<code>JtaTransactionManager</code>是默认的后备。</p><h3 id="1-9-1-IBM-WebSphere"><a href="#1-9-1-IBM-WebSphere" class="headerlink" title="1.9.1 IBM WebSphere"></a>1.9.1 IBM WebSphere</h3><p>在WebSphere6.1.0.9及以上版本，建议Spring JTA事务管理器使用<code>WebSphereUowTransactionManager</code>。这个特殊的适配器利用了IBM’s <code>UOWManager</code> API，在WebSphere应用服务器6.0.2.19和以后版本，6.1.0.9和以后版本是适用的。使用这个适配器，驱动Spring事务暂停（暂停/恢复 由<code>PROPAGATION_REQUIRES_NEW</code>发起）是由IBM官方支持的。</p><h3 id="1-9-2-Oracle-WebLogic-Server"><a href="#1-9-2-Oracle-WebLogic-Server" class="headerlink" title="1.9.2 Oracle WebLogic Server"></a>1.9.2 Oracle WebLogic Server</h3><p>在Weblogic Server及以后版本中，你通常将使用<code>WebLogicJtaTransactionManager</code>而不是存<code>JtaTransactionManager</code>类。普通<code>JtaTransactionManager</code>的这个特殊的Weblogic特定的子类在Weblogic管理的事务环境中支持Spring的事务全部功能，超出标准的JTA语义：特性包括事务名称，每个事务的隔离等级，以及在所有的情况下正确的恢复事务。</p><h2 id="1-10-常见问题解决"><a href="#1-10-常见问题解决" class="headerlink" title="1.10 常见问题解决"></a>1.10 常见问题解决</h2><h3 id="1-10-1-对于特定数据源错误的事务管理器的使用"><a href="#1-10-1-对于特定数据源错误的事务管理器的使用" class="headerlink" title="1.10.1 对于特定数据源错误的事务管理器的使用"></a>1.10.1 对于特定数据源错误的事务管理器的使用</h3><p>正确的使用<code>PlatformTransactionManager</code>实现基于你事务技术和需求的选择。正确的使用，Spring框架仅提供一个简单直接和轻便的抽象。如果你正在使用全局事务，你必须使用<code>org.springframework.transaction.jta.JtaTransactionManager</code>类（或者一个指定的应用服务器子类）进行你所有的事务操作。否则事务基础设施在资源（例如容器的<code>DataSource</code>实例）上尝试使用本地事务。这样的本地事务没有意义，一个好的应用服务器把它们当作错误。</p><h2 id="1-11-集成资源"><a href="#1-11-集成资源" class="headerlink" title="1.11 集成资源"></a>1.11 集成资源</h2><p>了解更多关于Spring框架的事务支持信息：</p><ul><li><a href="http://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html" target="_blank" rel="noopener">Distributed transaction in Spring，with and without XA</a>是一个JavaWorld演示文稿，其中Spring的David Syer引导您在Spring应用程序中通过分布式事务的七种模式，其中三种模式使用XA，另外四种没有。</li><li><a href="http://www.infoq.com/minibooks/JTDS" target="_blank" rel="noopener">Java 事务设计策略</a>是一本从<a href="http://www.infoq.com/" target="_blank" rel="noopener">InfoQ</a>得到的书，InfoQ提供一个Java事务快速介绍。它还包括如何使用Spring Framework和EJB3配置和使用事务的并排示例。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sychronized锁优化</title>
      <link href="/concurrency/2018-12-17-java-lock-performence-optImize/"/>
      <url>/concurrency/2018-12-17-java-lock-performence-optImize/</url>
      
        <content type="html"><![CDATA[<p>自旋(Spinning)、适应性自旋(Adaptive Spinning)、锁消除(Lock Elimination)、锁粗化(Lock Coarsening)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)等。</p><h3 id="1-1-自旋锁与自适应性自旋"><a href="#1-1-自旋锁与自适应性自旋" class="headerlink" title="1.1 自旋锁与自适应性自旋"></a>1.1 自旋锁与自适应性自旋</h3><p>互斥同步对性能最大的影响是阻塞的实现，挂起和恢复线程的操作都需要转入内核态完成，这些操作给并发性能带来很大的压力。如果获取共享数据锁时仅需要等待很短的时间，为了很短的时间去挂起和恢复线程并不值得。如果处理器有一个以上的处理器，我们可以线程让请求锁的线程忙循环，不放弃处理器的执行时间，这项技术就是所谓的自旋锁。<br>自适应自旋锁意味着自旋的时间不再固定，根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><h3 id="1-2-锁消除"><a href="#1-2-锁消除" class="headerlink" title="1.2 锁消除"></a>1.2 锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为是线程私有的，同步加锁自然无需执行。</p><h3 id="1-3-锁粗化"><a href="#1-3-锁粗化" class="headerlink" title="1.3 锁粗化"></a>1.3 锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环体中。如果虚拟机探测到有这样一串零碎的操作都对一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只加锁一次就可以。</p><h3 id="1-4-偏向锁"><a href="#1-4-偏向锁" class="headerlink" title="1.4 偏向锁"></a>1.4 偏向锁</h3><p>偏向锁目的是消除数据在无竞争情况下的同步原语。<br>使用场景：锁不仅不存在多线程竞争，而且总是由同一线程多次获得。</p><h4 id="1-4-1-偏向锁原理"><a href="#1-4-1-偏向锁原理" class="headerlink" title="1.4.1 偏向锁原理"></a>1.4.1 偏向锁原理</h4><p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步时，虚拟机都可以不再进行任何同步操作，只需简单测试对象头的Mark Word是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁。如果测试失败，则需要在测试一下Mark Word中偏向锁的标识是否设置成”01”；如果没有设置，则使用CAS竞争锁，如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，继续执行同步块；如果竞争失败，则进行偏向锁撤销。如果设置了则尝试使用CAS将对象头的偏向锁指向当前线程。</p><h4 id="1-4-2-偏向锁撤销（Revoke-Bias）"><a href="#1-4-2-偏向锁撤销（Revoke-Bias）" class="headerlink" title="1.4.2 偏向锁撤销（Revoke Bias）"></a>1.4.2 偏向锁撤销（Revoke Bias）</h4><p>当有另外一个线程尝试去获取这个锁时，偏向模式结束。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。在安全点时它首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置成无锁状态；如果线程还活着，拥有偏向锁的栈会被执行，在栈中创建锁记录，遍历偏向对象头（MarkWord）中的锁记录，将对象头中的锁记录拷贝到栈的锁记录中，修改锁标识为轻量级锁，唤醒持有原持有偏向锁的线程，从安全点继续执行。</p><p>偏向锁初始化及撤销流程图：<br><img src="/media/article/bias-expand.png" alt="bias-expand"><br>图摘自<a href="#偏向锁">Java并发编程艺术 2.2小节</a></p><p>上图只说明了一种情况，即安全点时检测线程是否存活，上图是线程已经执行完同步块，线程已经处于未活动状态（执行完了），所以撤销偏向锁是将锁置为无锁状态。如果代码未执行完成处于活动状态，则升级为轻量级所。</p><h3 id="1-5-轻量级锁"><a href="#1-5-轻量级锁" class="headerlink" title="1.5 轻量级锁"></a>1.5 轻量级锁</h3><p>轻量级锁是JDK1.6 中加入的新型锁机制，轻量级是相对于使用操作系统互斥量来实现传统锁而言，因此传统锁机制被称为重量级锁。轻量级锁本意指在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>HotSpot虚拟机的对象头(Object Header)分为两部分，第一用于存储自身的运行时数据，这部分数据的长度在32位和64位的虚拟机分别是32个和64个bits，官网称它为”Mark Word”。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还有一个额外的部分用于存储数组长度。<br><img src="/media/article/object-header.png" alt="mark word"><br>表摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，根据对象的状态复用自己的存储空间。<br>HotSpot 虚拟机对象头Mark Word不同状态下存储内容表：<br><img src="/media/article/markword.png" alt="mark word"><br>表摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>上表中存储内容列是Mark Word中除标志位外，其他的30bit空间的存储内容，状态列是指不同的锁状态，如：轻量级锁，重量级锁等等。具体内容存储占位如下图所示<br><img src="/media/article/markword-status.png" alt="mark word status"><br>表摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>轻量级锁的执行过程：在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word拷贝，如图：<br><img src="/media/article/markword-cas-before.png" alt="markword-cas-before"><br>图摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新成功了，那么该线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转为“00”，即表示该对象处于轻量级锁定状态。<br><img src="/media/article/markword-cas-after.png" alt="markword-cas-after"><br>图摘自<a href="#轻量级锁">深入理解Java虚拟机-JVM高级特性与实践 13.3小节</a><br>如果更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了该对象的锁，可直接进入同步代码块继续执行，否则说明这个锁对象被其他线程抢占了；如果否，则当前线程进入自旋，等待锁。如果此时有两条以上（包括两条）的线程（一条处于自旋，一条又来竞争）争用同一个锁，轻量级锁不再有效要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁的指针，后面等待的线程也要进入阻塞状态。<br>轻量级锁初始化及膨胀流程图：<br><img src="/media/article/lightweight-expand.png" alt="lightweight"><br>图摘自<a href="#轻量级锁">Java并发编程艺术 2.2小节</a><br>解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍指向线程的锁记录，就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，同步完成。替换失败，有其他线程尝试获取该锁，此时锁已经膨胀，就要在释放锁的同时，唤醒被挂起的线程。</p><h3 id="1-6-重量级锁"><a href="#1-6-重量级锁" class="headerlink" title="1.6 重量级锁"></a>1.6 重量级锁</h3><h4 id="1-6-1-原理"><a href="#1-6-1-原理" class="headerlink" title="1.6.1 原理"></a>1.6.1 原理</h4><p>重量级锁的实现和JVM的对象监视器相关（Object-Monitor）。在Java虚拟机中每一个对象都和一个Monitor相关。ObjectMonitor的相关数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = 0; // 记录个数</span><br><span class="line">    _waiters      = 0,</span><br><span class="line">    _recursions   = 0;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL; // 处于wait状态的线程，会被加入到_WaitSet</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; // 处于等待锁block状态的线程，会被加入到该列表</span><br><span class="line">    _SpinFreq     = 0 ;</span><br><span class="line">    _SpinClock    = 0 ;</span><br><span class="line">    OwnerIsThread = 0 ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>轻量级锁升级为重量级锁时，会修改MarkWord中的锁标志为11，在MarkWord中存储指向Monitor的指针。多个线程访问同一个对象时，只有一个线程会进入_owner，其他的都在_EntryList等待，如果线程在持有_owner时，选择wait，则线程进入_WaitSet。_EntryList、_WaitSet中的线程在持有_owner的线程释放后，都会竞争_owner。</p><p><img src="/media/article/heavylock.png" alt=""></p><h3 id="1-7-轻量级锁、偏向锁、重量级锁对比"><a href="#1-7-轻量级锁、偏向锁、重量级锁对比" class="headerlink" title="1.7 轻量级锁、偏向锁、重量级锁对比"></a>1.7 轻量级锁、偏向锁、重量级锁对比</h3><p>偏向锁初始化及膨胀流程图：<br><img src="/media/article/lock-advantage-disadvantage.png" alt="lock"><br>图摘自<a href="#轻量级锁、偏向锁、重量级锁对比">Java并发编程艺术 2.2小节</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与实践</a><br><a href="">Java并发编程实践</a><br><a href="">Java并发编程的艺术</a><br><a href="https://juejin.im/post/5b4eec7df265da0fa00a118f" target="_blank" rel="noopener">啃碎并发（七）：深入分析Synchronized原理-掘金</a><br><a href="https://www.zhihu.com/question/57774162/answer/154298044" target="_blank" rel="noopener">Java偏向锁是如何撤销的？</a><br><a href="https://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf" target="_blank" rel="noopener">Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing</a><br><a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf" target="_blank" rel="noopener">biasedlocking</a><br><a href="http://www.diva-portal.org/smash/get/diva2:754541/FULLTEXT01.pdf" target="_blank" rel="noopener">Evaluating and improving biased locking in the HotSpot virtual machine</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程安全</title>
      <link href="/concurrency/2018-12-06-thread-security/"/>
      <url>/concurrency/2018-12-06-thread-security/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全-读书笔记"><a href="#线程安全-读书笔记" class="headerlink" title="线程安全-读书笔记"></a>线程安全-读<a href="#引用">书</a>笔记</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>线程安全定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调动作，调用这个对象的行为都可以获得正确的结果，那这个<strong>对象就是线程安全的</strong>。摘至<a href="https://github.com/zhongyp/mybook/blob/master/java/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5.pdf" target="_blank" rel="noopener">《Java并发编程实践》</a><br>编写的线程安全的代码，本质上就是管理对状态（state）的访问，而且通常都是共享的、可变的状态。共享指一个变量可以被多个线程访问；可变变量的值在生命周期内可以改变。<br>无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问。<br>保证对象线程安全的三种措施：</p><ul><li>不跨线程共享变量</li><li>使状态变量不可变</li><li>在任何访问状态变量的时候使用同步</li></ul><h2 id="2-Java线程安全"><a href="#2-Java线程安全" class="headerlink" title="2. Java线程安全"></a>2. Java线程安全</h2><h3 id="2-1-线程安全强弱等级"><a href="#2-1-线程安全强弱等级" class="headerlink" title="2.1 线程安全强弱等级"></a>2.1 线程安全强弱等级</h3><p>Java语言中操作各种共享的数据可根据安全程度分为以下5类：</p><h4 id="2-1-1-不可变"><a href="#2-1-1-不可变" class="headerlink" title="2.1.1 不可变"></a>2.1.1 不可变</h4><p>在Java线程里面，不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何的线程安全保障措施。</p><p>Java语言中，如果共享数据是一个基本数据类型，只要在定义时使用final关键字修饰它就可以保证它是不可变的；如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。只要一个不可变的对象被正确构建出来（没有发生<a href="https://www.cnblogs.com/straybirds/p/8640748.html" target="_blank" rel="noopener">this引用逃逸</a>的情况），那么其外部的可见状态也不会改变。保证对象的行为不影响自己状态的途径有很多种，最简单的就是把对象中带有状态的变量都声明为final。</p><h4 id="2-1-2-绝对线程安全"><a href="#2-1-2-绝对线程安全" class="headerlink" title="2.1.2 绝对线程安全"></a>2.1.2 绝对线程安全</h4><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p><h4 id="2-1-3-相对线程安全"><a href="#2-1-3-相对线程安全" class="headerlink" title="2.1.3 相对线程安全"></a>2.1.3 相对线程安全</h4><p>对象单独的操作时线程安全的，我们在调用的时候不需要做额外的保障措施，对于特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。例如：Vector、ConcurrentHashMap等。</p><h4 id="2-1-4-线程兼容"><a href="#2-1-4-线程兼容" class="headerlink" title="2.1.4 线程兼容"></a>2.1.4 线程兼容</h4><p>线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中安全地使用。例如：HashMap等。</p><h4 id="2-1-5-线程对立"><a href="#2-1-5-线程对立" class="headerlink" title="2.1.5 线程对立"></a>2.1.5 线程对立</h4><p>线程对立指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。例如：Thread类中的suspend(),resume()方法。</p><h3 id="2-2-Java线程安全实现"><a href="#2-2-Java线程安全实现" class="headerlink" title="2.2 Java线程安全实现"></a>2.2 Java线程安全实现</h3><h4 id="2-2-1-互斥同步"><a href="#2-2-1-互斥同步" class="headerlink" title="2.2.1 互斥同步"></a>2.2.1 互斥同步</h4><p>互斥同步(Mutual Exclusion &amp; Synchronization)是最常见的一种并发正确性保障手段，同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。是一种悲观的并发策略，无论是否并发都需要加锁。<br>手段：synchronized、ReentrantLock。<br>缺点：线程阻塞和唤醒带来的性能问题，因此互斥同步也称为阻塞同步(Blocking Synchronization)。</p><h4 id="2-2-2-非阻塞同步"><a href="#2-2-2-非阻塞同步" class="headerlink" title="2.2.2 非阻塞同步"></a>2.2.2 非阻塞同步</h4><p>非阻塞同步(Non-Blocking Synchronization)是基于冲突检测的乐观并发策略，通俗的讲就是先进行操作，如果没有其他线程争用共享数据，则操作成功，否则产生冲突，然后进行补偿措施（最常见的就是不断的重试，知道试成功为止）。<br>要求：硬件指令集的发展，需要操作和检测两个步骤具备原子性。<br>常见指令：测试并设置(Test-and-Set)、获取并增加(Fetch-and-Increment)、交换(Swap)、比较并交换(Compare-and-Swap,CAS)、加载链接/条件存储(Load-linked/Store-Conditional,LL/SC)。</p><h4 id="2-2-3-无同步方案"><a href="#2-2-3-无同步方案" class="headerlink" title="2.2.3 无同步方案"></a>2.2.3 无同步方案</h4><p>要保证线程同步，不一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时正确性的手段，如果有些代码不涉及共享数据，自然无需同步保证共享数据争用时的正确性。</p><ul><li>可重入代码（Reentrant Code）：这种代码也叫纯代码（Pure Code），可以在代码执行的任何时刻中断它，转去执行另外一段代码，而控制权回来后继续执行代码，程序不会出现任何错误。</li><li>线程本地存储（Thread Local Storage）：如果一段代码所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，无需同步也能实现线程之间不出现数据争用的问题。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与实践</a><br><a href="">Java并发编程实践</a><br><a href="">Java并发编程艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多线程通信</title>
      <link href="/concurrency/2018-12-06-thread-communication/"/>
      <url>/concurrency/2018-12-06-thread-communication/</url>
      
        <content type="html"><![CDATA[<h2 id="1-共享变量的可见性"><a href="#1-共享变量的可见性" class="headerlink" title="1. 共享变量的可见性"></a>1. 共享变量的可见性</h2><p>线程通信主要是通过对共享变量的读写来进行的，一般共享变量，我们会采用使共享变量不可变或者在任何访问状态变量的时候使用同步两种措施进行变量共享。</p><h2 id="2-使用锁同步共享变量状态"><a href="#2-使用锁同步共享变量状态" class="headerlink" title="2. 使用锁同步共享变量状态"></a>2. 使用锁同步共享变量状态</h2><h3 id="2-1-synchronized（内置锁）"><a href="#2-1-synchronized（内置锁）" class="headerlink" title="2.1 synchronized（内置锁）"></a>2.1 synchronized（内置锁）</h3><p>synchronized我们知道常常用来临界区互斥执行，但是除此之外，它还有最重要的功能：锁的内存语义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MonitorExample&#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    public synchronized void writer()&#123;// 1</span><br><span class="line">        a++; // 2</span><br><span class="line">    &#125; // 3</span><br><span class="line">    public synchronized void reader()&#123; // 4</span><br><span class="line">        int i=a; // 5</span><br><span class="line">    &#125; // 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A<strong>先</strong>执行writer()方法，<strong>随后</strong>线程B执行reader()方法。根据JMM的happens-before规则，这段代码包含的happens-before关系可以分为3类。</p><p>1）根据程序次序规则，1 happens-before2, 2 happens-before 3; 4 happens-before 5, 5 happens-before 6。</p><p>2) 根据监视器锁规则，3 happens-before 4。<br>3) 根据happens-before的传递性，2 happens-before 5。</p><p><strong>注：</strong>happens-before规则保证了线程A执行后的结果对B可见，但是线程A的代码不一定在线程B之前执行。上面A与B线程是有先后顺序的，主要是为了方便解释锁的内存语义。 </p><p><img src="/media/article/happens-before-relation.jpg" alt="happens-beofre"><br>图片来自<a href="">Java并发编程艺术图3-24</a></p><p>锁释放和锁获取的内存语义：</p><p><strong>线程A释放一个锁，实质上是线程A向接下来将要获取的这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</strong></p><p><strong>线程B释放一个锁，实质上是线程B接收了之前某个线程发出的（释放这个锁之前对共享变量所做的修改的）消息。</strong></p><p><strong>线程A释放锁，线程B获取锁，这个过程实质上是线程A通过主内存向线程B发送消息。</strong></p><p><img src="/media/article/lock-acquire-state.png" alt="lock-acquire-state"><br>图片来自<a href="">Java并发编程艺术图3-26</a></p><h2 id="3-使用同步原语"><a href="#3-使用同步原语" class="headerlink" title="3. 使用同步原语"></a>3. 使用同步原语</h2><h3 id="3-1-volatile"><a href="#3-1-volatile" class="headerlink" title="3.1 volatile"></a>3.1 volatile</h3><p>volatile我们熟知的特性是：</p><p>1.可见性</p><p>对一个volatile变量的读，总能看到任意线程对这个volatile变量最后的写入。</p><p>2.有序性</p><p>如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀。lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p><h3 id="3-2-final"><a href="#3-2-final" class="headerlink" title="3.2 final"></a>3.2 final</h3><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="">Java并发编程实践</a><br><a href="">Java并发编程艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程启动与终止</title>
      <link href="/concurrency/2018-12-04-thread-start-end/"/>
      <url>/concurrency/2018-12-04-thread-start-end/</url>
      
        <content type="html"><![CDATA[<h3 id="1-构造线程"><a href="#1-构造线程" class="headerlink" title="1. 构造线程"></a>1. 构造线程</h3><h4 id="1-1-构造线程的方式"><a href="#1-1-构造线程的方式" class="headerlink" title="1.1 构造线程的方式"></a>1.1 构造线程的方式</h4><p>Java构造一个线程有两种方式：</p><p>一种是声明子类继承Thread父类并重写父类的run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeThread extends Thread &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeThread(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeThread p = new PrimeThread(143);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure></p><p>另一种方式是声明子类实现Runnable接口，并实现run方法。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 线程类</span><br><span class="line">class PrimeRun implements Runnable &#123;</span><br><span class="line">    long minPrime;</span><br><span class="line">    PrimeRun(long minPrime) &#123;</span><br><span class="line">        this.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // compute primes larger than minPrime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//启动线程实例</span><br><span class="line">PrimeRun p = new PrimeRun(143);</span><br><span class="line">new Thread(p).start();</span><br></pre></td></tr></table></figure></p><p>两者其实在本质上是一致的，因为Thread类也继承了Runable接口，所以都实现/重写Runable中的run方法。Java将线程的执行和执行对象抽象开来，JDK中执行的是Thread类，Executor框架，可执行目标有Runable，Callable。对于构造线程的方式第一种方式并不推荐，因为继承Thread类限定了其基本行为，在设计上违反多用组合 少用继承的原则，所以一般构造线程使用第二种方式，实现Runable接口。</p><h4 id="1-2-构造线程的属性"><a href="#1-2-构造线程的属性" class="headerlink" title="1.2 构造线程的属性"></a>1.2 构造线程的属性</h4><p>构造线程时需要提供线程所需要的属性。一个新的（child）线程对象是由parent线程进行空间分配的，而child线程继承了parent是否为Daemon、优先级、和加载资源的contextClassLoader以及可继承的ThreadLocal等属性，同时分配唯一的ID来表示这个child线程。如果创建线程实例后需要修改线程属性，则可以通过Thread提供的一些修改属性的方法进行修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setPriority() // 优先级</span><br><span class="line">getPriority()</span><br><span class="line">setName()。// 线程名</span><br><span class="line">getName()</span><br><span class="line">setDaemon() // 守护线程</span><br><span class="line">isDaemon()</span><br><span class="line">getContextClassLoader()。// 资源加载</span><br><span class="line">setContextClassLoader()</span><br><span class="line">getStackTrace() </span><br><span class="line">getAllStackTraces()</span><br><span class="line">checkAccess()</span><br><span class="line">isCCLOverridden()</span><br><span class="line">auditSubclass() </span><br><span class="line">dumpThreads()</span><br><span class="line">getThreads()</span><br><span class="line">getId()</span><br><span class="line">getState()</span><br><span class="line">setDefaultUncaughtExceptionHandler()</span><br><span class="line">getDefaultUncaughtExceptionHandler()</span><br><span class="line">getUncaughtExceptionHandler()</span><br><span class="line">setUncaughtExceptionHandler()</span><br><span class="line">dispatchUncaughtException()</span><br><span class="line">processQueue()</span><br></pre></td></tr></table></figure></p><p>当然构造线程时有些属性还可以在创建线程实例时就设置，如线程组，栈大小，栈名称，权限控制上下文，可继承的ThreadLocal，下面是JDK初始化一个线程实例时的代码，摘至<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK8</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @param g</span><br><span class="line"> * @param target</span><br><span class="line"> * @param name</span><br><span class="line"> * @param stackSize 线程的栈大小 根据参数传递过程可以看出默认大小为零，即使用默认的线程栈大小</span><br><span class="line"> * @param acc 访问控制权限</span><br><span class="line"> * @param inheritThreadLocals // 可继承的ThreadLocal</span><br><span class="line"> *</span><br><span class="line"> * ThreadGroup 线程组（ThreadGroup）就是由线程组成的管理线程的类，</span><br><span class="line"> *     这个类是java.lang.ThreadGroup类。</span><br><span class="line"> *     定义一个线程组，通过以下代码可以实现。</span><br><span class="line"> *     ThreadGroup group=new ThreadGroup(&quot;group&quot;);</span><br><span class="line"> *     Thread thread=new Thread(group,&quot;the first thread of group&quot;);</span><br><span class="line"> *     ThreadGroup类中的某些方法，可以对线程组中的线程产生作用。例如，setMaxPriority()方法可以设定线程组中的所有线程拥有最大的优先权。</span><br><span class="line"> */</span><br><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                  long stackSize, AccessControlContext acc,</span><br><span class="line">                  boolean inheritThreadLocals) &#123;</span><br><span class="line">    if (name == null) &#123;// 线程名，可相同</span><br><span class="line">        throw new NullPointerException(&quot;name cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();// 获取当前线程，并作为父线程。</span><br><span class="line">    SecurityManager security = System.getSecurityManager();// 获取安全策略</span><br><span class="line">    if (g == null) &#123;</span><br><span class="line">        /* Determine if it&apos;s an applet or not */</span><br><span class="line"></span><br><span class="line">        /* If there is a security manager, ask the security manager</span><br><span class="line">           what to do. */</span><br><span class="line">        if (security != null) &#123;//如果存在安全管理器，则获取它重写的线程组</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If the security doesn&apos;t have a strong opinion of the matter</span><br><span class="line">           use the parent thread group. */</span><br><span class="line">        if (g == null) &#123;</span><br><span class="line">            g = parent.getThreadGroup();//使用父线程组</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* checkAccess regardless of whether or not threadgroup is</span><br><span class="line">       explicitly passed in. */</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Do we have the required permissions?</span><br><span class="line">     */</span><br><span class="line">    if (security != null) &#123;</span><br><span class="line">        if (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    this.group = g;</span><br><span class="line">    this.daemon = parent.isDaemon();//继承父线程的守护属性</span><br><span class="line">    this.priority = parent.getPriority();//继承父线程的优先级</span><br><span class="line">    //继承父线程加载资源的contextClassLoader</span><br><span class="line">    if (security == null || isCCLOverridden(parent.getClass()))</span><br><span class="line">        this.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    else</span><br><span class="line">        this.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    this.inheritedAccessControlContext =</span><br><span class="line">            acc != null ? acc : AccessController.getContext();</span><br><span class="line">    this.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    // 继承父线程可继承的ThreadLocal</span><br><span class="line">    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">        this.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    /* Stash the specified stack size in case the VM cares */</span><br><span class="line">    this.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    /* Set thread ID */</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-启动线程"><a href="#1-3-启动线程" class="headerlink" title="1.3 启动线程"></a>1.3 启动线程</h4><p>线程对象在初始化完成后，调用start方法就可以启动线程。<br><strong><em>注意：启动一个线程，最好为这个线程设置线程名称，这行有助于分析或者排查问题</em></strong></p><h3 id="2-中断线程"><a href="#2-中断线程" class="headerlink" title="2. 中断线程"></a>2. 中断线程</h3><h4 id="2-1-中断的原理"><a href="#2-1-中断的原理" class="headerlink" title="2.1 中断的原理"></a>2.1 中断的原理</h4><p>中断，可以理解为运行中的线程，是否被其他线程进行了中断操作。中断操作包含三个方法。interrupt(),interrupted(),isInterrupted()。下面我们将对这个方法进行详细了解。</p><h5 id="2-1-1-interrupt"><a href="#2-1-1-interrupt" class="headerlink" title="2.1.1 interrupt()"></a>2.1.1 interrupt()</h5><p>中断操作通过调用线程的interrupt()方法进行。例如线程A中断线程B，在线程A的代码中调用ThreadB.interrupt() 即可。</p><p>interrupt()方法不是直接将线程终止，而是针对于不同情况进行不同处理。</p><ol><li>除非终止的是当前线程（始终被允许），否则调用checkAccess方法，可能会导致抛出SecurityException异常。</li><li>如果调用Object类的wait(),wait(long)或者wait(long, int)等方法，或者调用此线程的join(),join(long),join(long, int), sleep(long), sleep(long, int)方法，<strong><em>此线程的中断状态将被清除，同时将抛出InterruptedException异常</em></strong>。</li><li>如果此线程在可中断通道的IO操作上，通道将被关闭，线程被设置中断状态，同时将抛出ClosedByInterruptException异常。</li><li>如果线程在选择器(Selector)阻塞，线程将被设置中断状态，立即从选择操作中返回，可能带有非零值，就像选择器唤醒方法被调用一样。</li><li>如果以上的条件都不满足，此线程将被设置中断状态。</li><li>中断不存活的线程不会有任何影响。</li></ol><p>翻译自<a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Java se7docs</a></p><p>注：Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。<br><strong><em>注意：</em></strong><br>对于会抛出异常的情况，异常一定要处理，一般子线程异常不能抛出非运行时异常，所以子线程我们需要抛出运行时异常，用于给父线程捕获。或者在catch块中使用 Thread.currentThread().interrupt() 重新抛出中断来保证调用栈的高层的代码知道当前线程的中断。</p><h5 id="2-1-2-interrupted"><a href="#2-1-2-interrupted" class="headerlink" title="2.1.2 interrupted()"></a>2.1.2 interrupted()</h5><p>interrupted()主要有以下两个功能：</p><ol><li>测试<strong><em>当前线程</em></strong>是否被中断,清除线程中断状态。换句话说就是，如果当前方法被成功调用两次，则返回false（除非当前线程在第一次调用此方法后第二次调用此方法前被再次中断）。</li><li>线程中断被忽略，在中断时线程处于不活动的状态将被此方法反映返回false。</li></ol><p>interrupted()不同于interrupt(),此方法用于测试当前线程是否被中断，并清除中断状态。代码示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread thread = new InterruptThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    SleepUtils.sleep(1);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">static class InterruptThread extends Thread&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       int count = 0;</span><br><span class="line">       while(true)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           if(Thread.currentThread().interrupted())&#123;//此处仅仅是为了示例</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-1-3-isInterrupted"><a href="#2-1-3-isInterrupted" class="headerlink" title="2.1.3 isInterrupted()"></a>2.1.3 isInterrupted()</h5><ol><li>isInterrupted虽然也是测试线程是否被中断，但是此方法不会更改线程的中断状态。</li><li>线程中断被忽略，在中断时线程处于不活动的状态将被此方法反映返回false。</li></ol><h3 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3. 终止线程"></a>3. 终止线程</h3><h4 id="3-1-过期的suspend-、resume-和stop"><a href="#3-1-过期的suspend-、resume-和stop" class="headerlink" title="3.1 过期的suspend()、resume()和stop()"></a>3.1 过期的suspend()、resume()和stop()</h4><p>在Java API中，suspend()、resume()和stop()三个方法是过期的，不建议使用的。<br>主要原因是：suspend()在调用后，线程不是放已经占有的资源比如说锁，而是占有着资源进入睡眠，这样容易引发死锁状态。stop()方法在终结一个线程时不会保证线程资源的释放，因此导致线程处于不确定的状态下。</p><p><strong><em>sleep和suspend区别：</em></strong><br>相同点：sleep和suspend都会持有占有的资源不释放。<br>不同点：sleep阻塞（TIMED_WAITING）后，经过一段时间自行恢复运行。而suspend必须使用resume()显示的恢复，如果不使用resume()或者resume()失败，很容易引起资源占用导致的死锁。</p><h4 id="3-2-安全的终止线程"><a href="#3-2-安全的终止线程" class="headerlink" title="3.2 安全的终止线程"></a>3.2 安全的终止线程</h4><p>在第2小节提到的中断是线程的一个标示位，中断操作是一种简便的线程间交互方式，这种交互方式适合用来取消和停止任务。除了中断，还可以使用同步变量来控制是否停止并终止该线程。<br><strong><em>线程的终止不是直接强制线程停止，而是引导线程运行结束。</em></strong></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" target="_blank" rel="noopener">Java 安全模型介绍</a><br><a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Class Thread</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程(1)-Thread类源码</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Class文件结构</title>
      <link href="/jvm/2018-11-22-class-structure/"/>
      <url>/jvm/2018-11-22-class-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="class结构"><a href="#class结构" class="headerlink" title="class结构"></a>class结构</h2><blockquote><p>翻译自<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">Chapter 4.The class File Format</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h3><p>用来识别class文件，固定值：0xCAFEBABE。关于0xCAFEBABE还有一个故事<a href="https://leokongwq.github.io/2016/12/31/java-magic-0xCAFEBABE.html" target="_blank" rel="noopener">java魔法之0xCAFEBABE</a></p><h3 id="minor-version-major-version"><a href="#minor-version-major-version" class="headerlink" title="minor_version, major_version"></a>minor_version, major_version</h3><p>minor_version和major_version项的值是此类文件的次要版本号和主要版本号。主要版本号和次要版本号一起确定类文件格式的版本。如果类文件具有主版本号M和次版本号m，则我们将其类文件格式的版本表示为M.m.因此，类文件格式版本可以按字典顺序排序，例如，1.5 &lt;2.0 &lt;2.1。</p><p>当且仅当v位于某个连续范围Mi.0≤v≤Mj.m时，Java虚拟机实现可以支持版本v的类文件格式。 Java SE平台的发行版级负责确定Java虚拟机实现符合的范围。</p><p>JDK 1.0.2版中的Oracle Java虚拟机实现支持包含45.0到45.3类的类文件格式。 JDK发布的1.1.*支持类文件格式版本范围为45.0到45.65535（含）。对于k≥2，JDK版本1.k支持45.0到44 + k.0范围内的类文件格式版本。</p><h3 id="constant-pool-count"><a href="#constant-pool-count" class="headerlink" title="constant_pool_count"></a>constant_pool_count</h3><p>constant_pool_count项的值等于constant_pool表中的条目数加1。如果constant_pool索引大于零且小于constant_pool_count，则认为它是有效的，§4.4.5中注明了long和double类型的常量。</p><h3 id="constant-pool"><a href="#constant-pool" class="headerlink" title="constant_pool[]"></a>constant_pool[]</h3><p>constant_pool是一个存储各种字符串常量、类和接口名称、字段名称以及在Class文件结构和子结构中引用的其他常量的结构表。每个constant_pool表的条目的格式由它的第一个‘tag’字节指出。<br>constant_pool表的索引从1到constant_pool_count-1。</p><h3 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h3><p>access_flags项的值是用来表示访问权限和类或者接口的属性的标志的掩码。设置时，每个标志的解释如表4.1所示。</p><p>Table 4.1. 类访问和属性修饰符</p><p>Flag Name    Value    Interpretation</p><p>ACC_PUBLIC    0x0001    Declared public; 可以被外部包访问。<br>ACC_FINAL    0x0010    Declared final; 不允许有子类。<br>ACC_SUPER    0x0020    在invokespecial指令调用时特别处理超类方法。<br>ACC_INTERFACE    0x0200    标识接口类。<br>ACC_ABSTRACT    0x0400    Declared abstract; 不能被实例化。<br>ACC_SYNTHETIC    0x1000    Declared synthetic; 不再源代码中体现。<br>ACC_ANNOTATION    0x2000    Declared as an annotation type.<br>ACC_ENUM    0x4000    Declared as an enum type.</p><p>可以用ACC_SYNTHETIC标志标记类，以指示它是由编译器生成的，并且不出现在源代码中。</p><p>ACC_ENUM 标志指示这个类或者它的父类是被定义为枚举类型。</p><p>一个接口的特征是被设置ACC_INTERFACE标志。如果没有设置ACC_INTERFACE标志，这个类文件定义的是一个类而不是一个接口。</p><p>如果这个类设置了ACC_INTERFACE标志，它的ACC_ABSTRACT也一定被设置了(JLS §9.1.1.1)。这样的类文件不能设置其ACC_FINAL，ACC_SUPER或ACC_ENUM标志。</p><p>注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，则也必须设置ACC_INTERFACE标志。如果这个类文件没有设置ACC_INTERFACE标志，它可以设置Table 4.1中除ACC_ANNOTATION之外的任何其他标志。但是，这个类不能同时设置ACC_FINAL和ACC_ABSTRACT标志(JLS §8.1.1.2)。</p><p>ACC_SUPER标志指示如果它出现在此类中，则由invokespecial指令（§invokespecial）表示两个备用语义中的哪一个。 Java虚拟机指令集的编译器应设置ACC_SUPER标志。</p><p>ACC_SUPER标志的存在是为了与旧编译器为Java编程语言编译的代码向后兼容。在版本1.0.2之前的Oracle JDK中，编译器生成了ClassFile access_flags，其中现在表示ACC_SUPER的标志没有指定含义，并且Oracle的Java虚拟机实现忽略了该标志（如果已设置）。</p><p>表4.1中未分配的access_flags项的所有位都保留供将来使用。它们应该在生成的类文件中设置为零，并且应该被Java虚拟机的实现忽略。</p><h3 id="this-class"><a href="#this-class" class="headerlink" title="this_class"></a>this_class</h3><p>this_class项的值必须是一个在constant_pool表中的有效索引。constant_pool索引index处的条目必须是一个在此类文件中定义的类或者接口的CONSTANT_Class_info结构。</p><h3 id="super-class"><a href="#super-class" class="headerlink" title="super_class"></a>super_class</h3><p>对于一个类，父类项的值要么是0，要么是一个在常量池表中的有效索引。如果父类项的值非0，则在常量池表索引index位置上的条目一定是CONSTANT_Class_info结构(§4.4.1)，指示class文件中定义的类的直接父类。直接父类或者任何其他父类都不会在它的Class文件结构的access_flags项上设置ACC_FINAL标志。</p><p>如果父类项的值是0，则这个类文件必须是Object类，唯一个没有直接父类的类或者接口。</p><p>对于一个接口，父类项的值必须总是一个在常量池表中的有效索引。在此索引上的常量池条目必须是一个CONSTANT_Class_info结构指示Object类。</p><h3 id="interfaces-count"><a href="#interfaces-count" class="headerlink" title="interfaces_count"></a>interfaces_count</h3><p>interfaces_count项的值是这个类或者接口类型的直接父接口的数量。</p><h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces[]"></a>interfaces[]</h3><p>接口数组中的每个值都必须是一个在常量池表中的有效索引。在常量池表中索引是interfaces[i]（0&lt;=i&lt;interfaces_count）的值上的每个条目必须是表示一个接口的CONSTANT_Class_info 结构 (§4.4.1)，这个接口是这个类或者这个接口类型的父接口，在类型的来源中给出的从左到右的顺序。</p><h3 id="fields-count"><a href="#fields-count" class="headerlink" title="fields_count"></a>fields_count</h3><p>fields_count项的值是字段表中field_info结构的数量。field_info结构指示所有字段，包括在这个类或者接口类型中的类变量和实例变量。</p><h3 id="fields"><a href="#fields" class="headerlink" title="fields[]"></a>fields[]</h3><p>字段表中的每个值都必须是一个给出在这个类或者接口中的字段的完整描述的field_info(§4.5)结构。字段表仅仅包含在这个类或者接口中定义的那些字段。不包含从父类或者父接口中继承的字段。</p><h3 id="methods-count"><a href="#methods-count" class="headerlink" title="methods_count"></a>methods_count</h3><p>methods_count的值给出了方法表中的methods_info结构的数量。</p><h3 id="methods"><a href="#methods" class="headerlink" title="methods[]"></a>methods[]</h3><p>方法表中的每个值都必须是一个给出一个在这个类或者接口中方法的完整描述的method_info结构。如果一个method_info结构的access_flags项未设置ACC_NATIVE和ACC_ABSTRACT标志，Java虚拟机也提供了实现这个方法的指令。</p><p>method_info结构指示了所有在这个类或者接口类型中定义的方法，包括实例方法，类方法，实力初始化方法以及任何类或者接口初始化方法(§2.9)。方法表不包含继承自父类或者父接口的方法。</p><h3 id="attributes-count"><a href="#attributes-count" class="headerlink" title="attributes_count"></a>attributes_count</h3><p>attributes_count项的值给出了在这个类的属性表中的属性数量。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes[]"></a>attributes[]</h3><p>属性表的每个值都必须是一个attribute_info(§4.7)结构。</p><p>本规范定义的属性出现在ClassFile结构的属性表中的是InnerClasses（§4.7.6），EnclosingMethod（§4.7.7），Synthetic（§4.7.8），Signature（§4.7.9）， SourceFile（§4.7.10），SourceDebugExtension（§4.7.11），不推荐使用（§4.7.15），RuntimeVisibleAnnotations（§4.7.16），RuntimeInvisibleAnnotations（§4.7.17）和BootstrapMethods（§4.7.21）属性。</p><p>如果一个Java虚拟机的实现实现识别出class文件的版本在49.0版本以上，它必须识别和正确的读取在49.0或者更高版本class文件的文件结构的属性表中找到的签名(§4.7.9)，RuntimeVisibleAnnotations (§4.7.16)和 RuntimeInvisibleAnnotations (§4.7.17) 属性。</p><p>如果Java虚拟机实现识别出51.0或更高版本的class文件，它必须识别和正确的读取在51.0或更高版本的class文件的文件结构的属性表中找到的BootstrapMethods (§4.7.21) 属性。</p><p>一个Java虚拟机的实现需要静默忽略它无法识别的ClassFile结构的属性表中的任何或所有属性。不允许在本规范中定义的属性影响类文件的语义，但仅允许提供其他描述性信息（第4.7.1节）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发知识架构</title>
      <link href="/concurrency/2018-11-27-concurrency-structure/"/>
      <url>/concurrency/2018-11-27-concurrency-structure/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/article/concurrency.png" alt="Java并发架构图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git常用命令总结</title>
      <link href="/utils/2018-10-23-git/"/>
      <url>/utils/2018-10-23-git/</url>
      
        <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>系统系统性的学习Git，请移步<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Git中文学习文档</a>，这篇文章只是分类记录一下git的常用命令。<br><img src="/media/article/15403035072735.png" alt="Git版本控制系统VCS基本操作流程图"></p><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><h3 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h3><p><code>git init</code> 将当前目录变为本地仓库（.git）<br><code>git clone</code> 克隆一个远程仓库到本地<br><code>git clone -b branch url</code> 克隆远程仓库指定branch分支到本地<br><code>git config user.name</code> 查看用户名<br><code>git config user.email</code> 查看邮箱</p><h3 id="设置与配置"><a href="#设置与配置" class="headerlink" title="设置与配置"></a>设置与配置</h3><p><code>git config -global user.name/email &quot;参数&quot;</code> git是分布式版本控制，所以添加用户名和邮箱作为一个标识<br><code>ssh -keygen -t rsa -C &quot;email&quot;</code> 生成本地ssh key</p><h3 id="本地版本库"><a href="#本地版本库" class="headerlink" title="本地版本库"></a>本地版本库</h3><p><code>git add &quot;filename.*&quot;</code> 添加到暂存区<br><code>git commit -m &quot;filename.*&quot;</code> 提交到本地仓库<br><code>git commit --amend</code> 尝试重新提交，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add file1 // 将file1 添加至缓存区</span><br><span class="line">git commmit -m &quot;update files&quot; //提交file1到本地仓库,提交完发现忘记file2没有提交，则你可以使用如下命令，提交file2并覆盖之前的提交信息。</span><br><span class="line">git add file2 // 添加file2</span><br><span class="line">git commit -amend // 尝试重新提交commit信息，并覆盖掉之前的提交信息</span><br></pre></td></tr></table></figure><p><code>git status</code> 查看本地仓库状态<br><code>git diff filename.*</code> 查看尚未暂存的文件修改的部分<br><code>git diff --cached</code>或<code>git diff --staged</code>查看已暂存的文件修改的部分<br><code>git log</code> commit的日志<br><code>git log --pretty=oneline</code> 日志显示为缩略版<br>注：<code>git reset</code> 不加<code>--hard</code>参数对当前工作区文件不会有任何修改，只是对缓存区进行操作。一旦加了参数，操作一定要慎重，否则你当前工作区中的修改将会全部被清除。<br><code>git reset HEAD file</code> 将file退回到当前版本（仅仅是对缓存区进行操作）<br><code>git reset --hard HEAD^</code> 退回到上一版本<br><code>git reset --hard HEAD^^</code> 退回到前二的版本<br><code>git reset --hard HEAD~100</code> 退回到前100版本<br><code>git reset --hard 版本号</code> 退回到一个特定的版本<br><code>git reflog</code> 查看所有操作日志，包括分支和删除的commit<br><code>git reset --mixed</code> 将当前文件撤出缓存区，保留文件修改<br><code>git rm --cached file</code> 删除缓存区file<br><code>git checkout -- file</code> 恢复工作区file（取消工作区文件的修改）</p><h3 id="远程版本库"><a href="#远程版本库" class="headerlink" title="远程版本库"></a>远程版本库</h3><p><code>git remote add origin 远程git地址</code> 连接<br><code>git push -u origin master</code> 把本地库分支master内容推送到远程库（-u 命令在第一次关联本地库和远程库时使用）<br><code>git clone url</code> 克隆远程(url)库</p><h3 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h3><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p><code>git branch</code> 查看分支<br><code>git checkout</code> 切换分支<br><code>git checkout -b</code>  创建并切换分支<br><code>git merge</code> 合并到当前分支<br><code>git branch -d</code>删除某分支<br><code>git merge --no-ff -m &quot;注释&quot;</code>分支合并分支禁用fast forward<br><code>git stash</code> 将当前分支的工作现场保留下来<br><code>git stash list</code> 查看工作现场<br><code>git stash apply</code> 恢复内容但是你需要git stash drop删除stash<br><code>git stash pop</code> 恢复的同时把stash内容也删除<br><code>git remote</code> 查看远程库的信息<br><code>git remote -v</code> 查看远程库的详细信息<br><code>git push origin master</code> master为本地的分支名推送分支<br><code>git checkout -b dev origin/dev</code> dev为分支名，做完开发后<br><code>git push origin dev</code> 推送到远程库<br><code>git pull</code> 抓取最新的提交,并尝试自动合并到本地当前所在的分支<br><code>git fetch</code> 抓取最新的提交，不会自动合并，必须手动。<br><code>git rebase</code> 变基,将提交到某一分支上的所有修改都移至另一分支上<br><code>git rebase --continue</code> <strong><em>继续变基操作，一般用于第一次变基失败后，解决冲突文件，将冲突文件添加到缓存区，不要提交，然后再执行此命令。如果提交了，执行<code>git rebase --skip</code>命令取消rebase状态。</em></strong><br><code>git branch --set-upstream dev origin/dev</code> 指定本地dev分支（已经创建的）与远程origin/dev分支的连接<br><code>git branch -u origin/dev</code> 指定当前所在连接远程origin/dev分支的连接<br><code>git checkout --track origin/dev</code> 创建新的dev分支，制定远程连接origin/dev</p><blockquote><p>如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p></blockquote><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ol><li>每开发一个新特性可以新建一个本地特性分支，开发完成后合并到本地主线。</li><li>如果不使用特性分支开发可以使用<code>git stash</code>保存当前的工作空间。</li><li>远程代码和本地代码合并有两种方式，<code>git pull</code>和<code>git fetch</code>，<code>git pull</code>命令会自动合并远程代码，冲突后需要解决冲突后提交。<code>git fetch</code>不自动和本地代码合并，需要手动merge。</li><li>在合并时，根据项目情况使用<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">变基</a>，<code>git pull --rebase</code>可以保持自动合并的情况下进行变基。一般情况下，远程库不保留本地操作历史，所以本地与远程代码合并时最好使用变基。</li><li><strong><em>使用变基原则</em></strong>：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Utils </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么不能在foreach中执行remove/add操作</title>
      <link href="/faq/2018-07-30-foreach/"/>
      <url>/faq/2018-07-30-foreach/</url>
      
        <content type="html"><![CDATA[<p>测试代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = new Vector&lt;&gt;();</span><br><span class="line">    list.add(&quot;1&quot;);</span><br><span class="line">    list.add(&quot;2&quot;);</span><br><span class="line">    for(String it:list)&#123;</span><br><span class="line">        // 如果it==2，删除it</span><br><span class="line">        if(&quot;2&quot;.equals(it))&#123;</span><br><span class="line">            list.remove(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行上述代码，会抛出ConcurrentModificationException异常。</p><p>为什么会报错呢？</p><p><code>javap -c</code>命令查看编译后代码，了解下上述代码运行过程:</p><p><img src="/media/article/java-foreach.png" alt="foreach"></p><p>上图代码A处，可以看到foreach循环是使用的是Iterator迭代器，代码B处使用Iterator迭代器中的next方法获取集合中的值，代码C处使用list.remove()删除集合中的值。</p><p>Itr迭代器类的next方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">  synchronized (Vector.this) &#123;</span><br><span class="line">      if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">      int i = cursor;</span><br><span class="line">      if (i &gt;= elementCount)</span><br><span class="line">          throw new NoSuchElementException();</span><br><span class="line">      cursor = i + 1;</span><br><span class="line">      return elementData(lastRet = i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list.remove方法代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean removeElement(Object obj) &#123;</span><br><span class="line">   // 修改了modCount</span><br><span class="line">   modCount++;</span><br><span class="line">   int i = indexOf(obj);</span><br><span class="line">   if (i &gt;= 0) &#123;</span><br><span class="line">       removeElementAt(i);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先next方法中，首先判断modCount的值，如果modCount的值和expectedModCount值不一致，就会抛出ConcurrentModificationException异常。而恰恰remove方法中就修改了modCount的值，而未修改expectedModCount的值，从而导致我们的测试代码抛出ConcurrentModificationException异常。</p><p>抛错的源头找到了，可是为什么会出现这种问题呢？</p><p>我们看下导致抛出源头的两个参数modCount和expectedModCount。modCount是类Vector的成员变量，主要记录Vector的修改次数；expectedModCount是内部迭代器类Itr的成员变量，初始化时等于modCount。我们使用foreach去remove集合内的值时，调用的是Vector类的remove方法，不是迭代器Itr的remove方法，所以只会修改modCount的值，而不更新expectedModCount的值。所以在测试代码中报错是因为在第一次删除后，modCount值+1，而expectedModCount的值未变化，所以在迭代器再次调用next方法获取集合内的值时就会抛出ConcurrentModificationException异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> FAQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机问题排查工具</title>
      <link href="/jvm/2018-04-07-jvm-tools/"/>
      <url>/jvm/2018-04-07-jvm-tools/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JDK命令行工具"><a href="#1-JDK命令行工具" class="headerlink" title="1. JDK命令行工具"></a>1. JDK命令行工具</h2><p>JDK命令行工具主要用于JVM性能监控和故障处理。</p><h3 id="1-1-jps"><a href="#1-1-jps" class="headerlink" title="1.1 jps"></a>1.1 jps</h3><p>虚拟机进程状况工具。 显示当前所有java进程pid的命令。</p><p>-l 输出主类的全名，如果进程执行的是Jar包，输出Jar路径</p><p>-v 输出虚拟机进程启动时JVM参数</p><p>-q 只输出LVMID，省略主类的名称</p><p>-m 输出虚拟机进程启动时传递给主类main()函数的参数</p><h3 id="1-2-jstat"><a href="#1-2-jstat" class="headerlink" title="1.2 jstat"></a>1.2 jstat</h3><p> 虚拟机统计信息监视工具，用于监视虚拟机各种运行状态信息的命令。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾回收、JIT编译等运行数据。运行期定位虚拟机性能问题的首选工具。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-class：监视类装载、卸载数量、总空间以及类装载所耗时间。</span><br><span class="line"></span><br><span class="line">-gc：监视JAVA堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间，GC已用时间合计等信息；</span><br><span class="line"></span><br><span class="line">-gccapacity：监视内容与-gc基本相同，但输出主要关注 java堆各个区域使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcutil：监视内容与-gc基本相同，便输出主要关注已使用空间占总空间的百分比；</span><br><span class="line"></span><br><span class="line">-gccause：与-gcutil功能一样，但是会额外输出导致 一次GC产生的原因；</span><br><span class="line"></span><br><span class="line">-gcnew：监视新生代GC状态；</span><br><span class="line"></span><br><span class="line">-gcnewcapacity：监视内容与-gcnew基本相同，输出最要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcold：监视老年代GC状况；</span><br><span class="line"></span><br><span class="line">-gcoldcapacity：监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-gcpermcapacity：监视永久代使用到的最大、最小空间；</span><br><span class="line"></span><br><span class="line">-compiler：输入JIT编译器编译过的方法，耗时等信息；</span><br><span class="line"></span><br><span class="line">-printcompilation：输出已经被JIT编译的方法；</span><br></pre></td></tr></table></figure><h3 id="1-3-jinfo"><a href="#1-3-jinfo" class="headerlink" title="1.3 jinfo"></a>1.3 jinfo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-flag &lt;name&gt; ：可查看虚拟机启动时显式指定的参数列表。</span><br><span class="line">-flag [+|-]&lt;name&gt;：设置或取消VM参数</span><br><span class="line">-flag &lt;name&gt;=&lt;value&gt;：给VM参数设置新值</span><br><span class="line">-flags：可查看所有VM参数；</span><br><span class="line">-sysprops：查看java系统参数;</span><br><span class="line">&lt;no option&gt;：表示在不给定任何选项时，打印出以上所有的VM参数</span><br></pre></td></tr></table></figure><p> 实时的查看和调整虚拟机的各项参数。</p><h3 id="1-4-jmap"><a href="#1-4-jmap" class="headerlink" title="1.4 jmap"></a>1.4 jmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-dump：生成java堆转储快照，格式为：-dump[live, ] format=b, file=&lt;filename&gt;,其中live子参数说明是否只dump出存活对象；</span><br><span class="line"></span><br><span class="line">-finalizerinfo：显示在F-QueuiK 等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-heap：显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效；</span><br><span class="line"></span><br><span class="line">-histo：显示堆中对象统计信息，包括类、实例数量、合计容量；</span><br><span class="line"></span><br><span class="line">-permstat：以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台有效；</span><br><span class="line"></span><br><span class="line">-F：当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，只在Linux/Solaris平台有效</span><br></pre></td></tr></table></figure><p> Java内存映像工具。用于生成堆转储快照，还可以查询finalize()执行队列，Java堆和永久代的详细信息，如空间使用率、当前使用的哪种收集器等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jmap -dump:format=b,file=D:\test.bin 2768</span><br><span class="line">Dumping heap to D:\test.bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h3 id="1-5-jhat"><a href="#1-5-jhat" class="headerlink" title="1.5 jhat"></a>1.5 jhat</h3><p><code>jhat D:\test.bin</code></p><p> 分析jmap生成的堆转储快照，在浏览器查看。</p><h3 id="1-6-jstack"><a href="#1-6-jstack" class="headerlink" title="1.6 jstack"></a>1.6 jstack</h3><p> 用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合，生成快照的目的是定位线程出现长时间停顿的原因。</p><p>-F    当正常输出的请求不被响应时，强制输出线程堆栈</p><p>-l    除堆栈外，显示关于锁的附加信息</p><p>-m    如果调用到本地方法的话，可以显示c/c++的堆栈</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">//        Thread t1 = new Worker(1);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        t1.start();</span><br><span class="line">        final A a = new A();</span><br><span class="line">        final B b = new B();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                a.getBLock(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                b.getALock(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getBLock(B b)&#123;</span><br><span class="line"></span><br><span class="line">        b.getALock(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void getALock(A a)&#123;</span><br><span class="line">        a.getBLock(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会产生死锁，使用jstack命令可以打印出线程死锁信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jps -m</span><br><span class="line">1904 AppMain com.zhongyp.Test</span><br><span class="line">944 RemoteMavenServer</span><br><span class="line">11540 Jps -m</span><br><span class="line">13204 Launcher F:/Program Files/intellij IDEA/lib/log4j.jar;F:/Program Files/intellij IDEA/lib/jps-builders.jar;F:/Program Files/intellij IDEA/lib/netty-all-4.1.1.Final.jar;F:/Program Files/intellij IDEA/lib/annotations.jar;F:/Program Files/intellij IDEA/lib/rt/jps-plugin-system.jar;F:/Program Files/inte</span><br><span class="line">llij IDEA/lib/jgoodies-forms.jar;F:/Program Files/intellij IDEA/lib/util.jar;F:/Program Files/intellij IDEA/lib/trove4j.jar;F:/Program Files/intellij IDEA/lib/jna.jar;F:/Program Files/intellij IDEA/lib/resources_en.jar;F:/Program Files/intellij IDEA/lib/oromatcher.jar;F:/Program Files/intellij IDEA/lib/i</span><br><span class="line">dea_rt.jar;F:/Program Files/intellij IDEA/lib/openapi.jar;F:/Program Files/intellij IDEA/lib/javac2.jar;F:/Program Files/intellij IDEA/lib/snappy-in-java-0.5.1.jar;F:/Program Files/intellij IDEA/lib/jna-platform.jar;F:/Program Files/intellij IDEA/lib/forms_rt.jar;F:/Program Files/intellij IDEA/lib/jdom.j</span><br><span class="line">ar;F:/Program Files/intellij IDEA/lib/asm-all.jar;F:/Program Files/intellij IDEA/lib/jps-</span><br><span class="line">4488</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Program Files\Java\jdk1.8.0_161\bin&gt;jstack -F 1904</span><br><span class="line">Attaching to process ID 1904, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.161-b12</span><br><span class="line">Deadlock Detection:</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193ce108 (Object@0x00000000d6129700, a com/zhongyp/B),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000193cb878 (Object@0x00000000d6127d20, a com/zhongyp/A),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line"></span><br><span class="line">Found a total of 1 deadlock.</span><br><span class="line"></span><br><span class="line">Thread 1: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 18: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=0, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=2, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$2.run() @bci=18, line=38 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 17: (state = BLOCKED)</span><br><span class="line"> - com.zhongyp.B.getALock(com.zhongyp.A) @bci=0, line=59 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.A.getBLock(com.zhongyp.B) @bci=2, line=51 (Interpreted frame)</span><br><span class="line"> - com.zhongyp.Test$1.run() @bci=18, line=26 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 16: (state = IN_NATIVE)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.accept0(int, java.net.InetSocketAddress[]) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.net.DualStackPlainSocketImpl.socketAccept(java.net.SocketImpl) @bci=37, line=131 (Interpreted frame)</span><br><span class="line"> - java.net.AbstractPlainSocketImpl.accept(java.net.SocketImpl) @bci=7, line=409 (Interpreted frame)</span><br><span class="line"> - java.net.PlainSocketImpl.accept(java.net.SocketImpl) @bci=42, line=199 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.implAccept(java.net.Socket) @bci=60, line=545 (Interpreted frame)</span><br><span class="line"> - java.net.ServerSocket.accept() @bci=48, line=513 (Interpreted frame)</span><br><span class="line"> - com.intellij.rt.execution.application.AppMain$1.run() @bci=13, line=79 (Interpreted frame)</span><br><span class="line"> - java.lang.Thread.run() @bci=11, line=748 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 10: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 9: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 8: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 7: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.Object.wait() @bci=2, line=502 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference.tryHandlePending(boolean) @bci=54, line=191 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference$ReferenceHandler.run() @bci=1, line=153 (Interpreted frame)</span><br></pre></td></tr></table></figure><h2 id="2-JDK可视化工具"><a href="#2-JDK可视化工具" class="headerlink" title="2. JDK可视化工具"></a>2. JDK可视化工具</h2><p>JConsole: Java监视与管理控制台。基于JMX的可视化监视和管理工具。监视Java堆和永久代的的变化趋势。</p><p>VisualVM: 多合一故障处理工具。</p><h3 id="2-1-MAT-堆dump文件分析工具"><a href="#2-1-MAT-堆dump文件分析工具" class="headerlink" title="2.1 MAT: 堆dump文件分析工具"></a>2.1 MAT: 堆dump文件分析工具</h3><h4 id="2-1-1-Histogram可以列出内存中的对象，对象的个数以及大"><a href="#2-1-1-Histogram可以列出内存中的对象，对象的个数以及大" class="headerlink" title="2.1.1 Histogram可以列出内存中的对象，对象的个数以及大"></a>2.1.1 Histogram可以列出内存中的对象，对象的个数以及大</h4><p>Class Name:类名称，java类名</p><p>Objects:类的对象的数量，这个对象被创建了多少个</p><p>Shallow Heap:一个对象内存的消耗大小，不包含对其他对象的引用，Shallow Heap堆中的对象是它的大小和保留内存大小相同的对象是堆内存的数量时,将释放对象被垃圾收集。<br>对象自身占用的内存大小，不包括它引用的对象。<br>针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。<br>针对数组类型的对象，它的大小是数组元素对象的大小总和。</p><p>Retained Heap:是shallow Heap的总和，也就是该对象被GC之后所能回收到内存的总和。<br>Retained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)<br>换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。<br>不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被被当做Garbage。</p><h4 id="2-1-2-Dominator-Tree可以列出那个线程，以及线程下面的那些对象占用的空间"><a href="#2-1-2-Dominator-Tree可以列出那个线程，以及线程下面的那些对象占用的空间" class="headerlink" title="2.1.2 Dominator Tree可以列出那个线程，以及线程下面的那些对象占用的空间"></a>2.1.2 Dominator Tree可以列出那个线程，以及线程下面的那些对象占用的空间</h4><h4 id="2-1-3-Top-consumers通过图形列出最大的object"><a href="#2-1-3-Top-consumers通过图形列出最大的object" class="headerlink" title="2.1.3 Top consumers通过图形列出最大的object"></a>2.1.3 Top consumers通过图形列出最大的object</h4><h4 id="2-1-4-Leak-Suspects通过MA自动分析泄漏的原因"><a href="#2-1-4-Leak-Suspects通过MA自动分析泄漏的原因" class="headerlink" title="2.1.4 Leak Suspects通过MA自动分析泄漏的原因"></a>2.1.4 Leak Suspects通过MA自动分析泄漏的原因</h4><h2 id="3-内存问题分析"><a href="#3-内存问题分析" class="headerlink" title="3. 内存问题分析"></a>3. 内存问题分析</h2><p><a href="https://www.javatang.com/archives/2017/10/19/33151873.html" target="_blank" rel="noopener">JVM故障分析系列</a></p><p><a href="https://wensong.iteye.com/blog/1986449" target="_blank" rel="noopener">Memory Analyzer Tool 使用手记</a></p><p><a href="http://blog.csdn.net/jackesy/article/details/47039865" target="_blank" rel="noopener">使用Eclipse Memory Analyzer分析内存</a></p><p><a href="http://www.blogjava.net/rosen/archive/2010/05/21/321575.html" target="_blank" rel="noopener">使用Memory Analyzer tool(MAT)分析内存泄漏（一）</a></p><p><a href="https://www.yourkit.com/docs/java/help/sizes.jsp" target="_blank" rel="noopener">Shallow and retained sizes</a></p><p><a href="http://www.infoq.com/cn/articles/jvm-memory-collection" target="_blank" rel="noopener">JVM内存回收理论与实现</a></p><p><a href="https://www.yourkit.com/docs/java/help/gc_roots.jsp" target="_blank" rel="noopener">GC roots</a></p><p><a href="http://tivan.iteye.com/blog/1487855" target="_blank" rel="noopener">一次使用Eclipse Memory Analyzer分析Tomcat内存溢出</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.iteye.com/blog/bjyzxxds-1532937" target="_blank" rel="noopener">Shallow heap &amp; Retained heap</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高性能MySQL -- 摘自《高性能MySQL第三版》</title>
      <link href="/mysql/2018-04-02-mysql/"/>
      <url>/mysql/2018-04-02-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MySQL的逻辑架构：</p><p><img src="/media/article/mysql-logic-structure.png" alt=""></p><p>–摘自《高性能MySQL 第3版》1.1 小节</p><h3 id="优化与执行"><a href="#优化与执行" class="headerlink" title="优化与执行"></a>优化与执行</h3><ul><li>MySQL会解析查询，并创建内部数据结构，然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引。</li><li>用户可以通过特殊的关键字提示(hint)优化器，影响它的决策过程。</li><li>也可以请求优化器解释(explain)优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的。</li><li>对于SELECT语句，在解析查询之前，服务器会先检查查询缓存(Query Cache)，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</li></ul><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>共享锁、排他锁。</p><h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p>表锁是最基本的锁策略，并且是开销最小的策略。</p><p>行级锁可以最大程度的支持并发处理。行级锁仅在存储引擎中实现，如InnoDB和XtraDB。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>原子性、一致性、隔离性、持久性。</p><p>事务的隔离级别又分为：未提交读、提交读、可重复读、可串行化。</p><h4 id="未提交读（脏读）"><a href="#未提交读（脏读）" class="headerlink" title="未提交读（脏读）"></a>未提交读（脏读）</h4><h4 id="提交读（不可重复读）"><a href="#提交读（不可重复读）" class="headerlink" title="提交读（不可重复读）"></a>提交读（不可重复读）</h4><p>大多数数据库默认是提交读，MySQL不是。同一个事务中执行两次相同的查询可能得到不一样的结果。</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>解决了脏读问题，同一事务中多次读取相同的记录结果是一致的。但是存在幻读问题，当前某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取范围的记录时，读取不到新事务插入的新值，会产生幻行。</p><p>当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。</p><p>MySQL的默认数据库隔离级别。</p><h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><p>最高的隔离级别。通过强制事务串行执行，避免了前面说的幻读问题。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>InnoDB中的死锁：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html" target="_blank" rel="noopener">Deadlocks in InnoDB</a></p><p>InnoDB有两种处理死锁的方式：</p><ul><li>When deadlock detection is enabled (the default), InnoDB automatically detects transaction deadlocks and rolls back a transaction or transactions to break the deadlock. InnoDB tries to pick small transactions to roll back, where the size of a transaction is determined by the number of rows inserted, updated, or deleted.</li><li>On high concurrency systems, deadlock detection can cause a slowdown when numerous threads wait for the same lock. At times, it may be more efficient to disable deadlock detection and rely on the innodb_lock_wait_timeout setting for transaction rollback when a deadlock occurs. Deadlock detection can be disabled using the innodb_deadlock_detect configuration option.</li></ul><p>死锁检测：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-detection.html" target="_blank" rel="noopener">Deadlock Detection and Rollback</a></p><h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久化到磁盘。这种方式通常称为预写式日志(Write-Ahead Logging)。这种方式通常修改数据需要写两次磁盘。</p><h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，他们一般都同时实现了多版本并发控制(MVCC)。<br>MVCC是行级锁的一个变种，但是他在很多情况下避免了加锁操作，因此开销更低。非阻塞读和行锁。</p><p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p>InnoDB的MVCC是通过每行记录后面保存两个隐藏的列来实现的。这两个列一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是实际的时间值，而是系统版本号（system version number）。没开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录进行比较。例如：</p><p>select:</p><ul><li>InnoDB只查找版本早于当前事务版本的数据行。</li><li>行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行，在事务开始之前未被删除。</li></ul><p>insert:</p><ul><li>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li></ul><p>delete：</p><ul><li>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</li></ul><p>update：</p><ul><li>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</li></ul><p>目前MVCC模式支持提交读和可重复读。未提交读每次读取最新的全表数据，</p><p>缺点: MVCC对于并发修改由良好的性能支持，但是由于使用多版本控制行记录，如果进行回滚，则可能会影响其他其他事物的提交。</p><p>比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html" target="_blank" rel="noopener">innodb-multi-version</a></p><h4 id="多版本并发控制和二级索引"><a href="#多版本并发控制和二级索引" class="headerlink" title="多版本并发控制和二级索引"></a>多版本并发控制和二级索引</h4><p>MVCC对二级索引和聚簇索引的处理方式是不同的。聚簇索引的记录会立马更新，聚簇索引的隐藏系统列指向可以被重构记录的更早版本的undo log条目，不像聚簇索引记录，二级索引记录不包含隐藏系统列，也不会立即更新。</p><p>当二级索引列被更新时，老的二级索引记录被标记删除，新纪录被插入，被标记删除记录最终被清除。<strong><em>当二级索引记录被删除标记或者二级索引页被新事务更新，InnoDB在聚簇索引中查找数据库记录。（此时覆盖索引失效）</em></strong>在聚簇索引中，记录的DB_TRX_ID被检查，如果在启动读取事务后修改了记录，则会从undu log中检索记录的正确版本。</p><p>但是，如果启用了索引条件下推（ICP）优化，并且仅可以使用索引中的字段来评估WHERE条件的部分，则MySQL服务器仍会将WHERE条件的这部分下推到存储引擎中进行评估使用索引。如果找不到匹配的记录，则避免聚集索引查找。如果找到匹配的记录，即使在删除标记的记录中，InnoDB也会在聚集索引中查找记录。</p><h2 id="引擎篇"><a href="#引擎篇" class="headerlink" title="引擎篇"></a>引擎篇</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li><p>Myisam是Mysql的默认存储引擎，当create创建新表时，未指定新表的存储引擎时，默认使用Myisam。</p></li><li><p>每个MyISAM在磁盘上存储成三个文件。文件名都和表名相同，扩展名分别是.frm（存储表定义）、.MYD (MYData，存储数据)、.MYI (MYIndex，存储索引)。数据文件和索引文件可以放置在不同的目录，平均分布io，获得更快的速度。</p></li><li><p>它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一 。</p></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期事务。短期事务大部分情况是正常提交的，很少会回滚。<br>InnoDB的数据存储在表空间中。</p><ul><li><p>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比Myisam的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</p></li><li><p>用于事务处理应用程序，具有众多特性，包括ACID 事务支持。</p></li><li>InnoDB可通过Sphinx实现全文索引。</li><li>InnoDB表基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引必须包含主键列。</li><li>InnoDB根据主键引用被索引的行。</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>将所有数据保存在RAM 中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。</p><table><tr></tr><tr></tr><tr><td>特点</td><td>Myisam</td><td> BDB</td><td> Memory</td><td>InnoDB</td><td> Archive</td></tr><tr><td>存储限制</td><td>没有</td><td>没有</td><td>有</td><td>64TB</td><td>没有</td></tr><tr><td>事务安全</td><td></td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>锁机制</td><td>表锁</td><td>页锁</td><td>表锁</td><td>行锁</td><td>行锁</td></tr><tr><td>B 树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr><td>数据缓存</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>空间使用</td><td>低</td><td>低</td><td>N/A</td><td> 高</td><td>非常低</td></tr><tr><td>内存使用</td><td>低</td><td>低</td><td>中等</td><td>高</td><td>低</td></tr><tr><td>批量插入的速度</td><td>高</td><td>高</td><td>高</td><td>低</td><td>非常高</td></tr><tr><td>支持外键</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr></tr></table><h2 id="Schema与数据类型优化"><a href="#Schema与数据类型优化" class="headerlink" title="Schema与数据类型优化"></a>Schema与数据类型优化</h2><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li><p>一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p></li><li><p>简单的数据类型通常需要更少的CPU周期。</p></li><li><p>尽量避免使用NULL，原因是由于NULL可能需要单独的位（bit）去存储或者NULL使得索引、索引统计、值比较都更为复杂。InnoDB使用单独的位(bit)存储NULL之，所以对于稀疏数据有很好的空间效率。</p></li></ul><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>有两种类型的数字：整数(whole number)和实数(real number)。如果存储整数，可以使用这几种整数类型：TYNYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8，16，24，32，64位存储空间。它们可以存储的值的范围从-2^(N-1)到-2^(N-1)-1，其中N是存储空间位数。</p><p>整数类型可选UNSIGNED属性，表示不允许为负值。</p><p>有符号和无符号类型使用相同的存储空间，并具有相同的性能。<br>整数计算一般使用64位的BIGINT整数，及时在32位环境也是如此。</p><h4 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h4><p>实数是带有小数部分的数字。 它不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数。及支持精确类型，也支持不精确类型。<br>Float和double类型支持使用标准的浮点运算进行近似计算。<br>DECIMAL类型用于存储精确的小数。</p><h3 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h3><ul><li><p>范式化的更新操作会比反范式化的快。</p></li><li><p>当数据较好范式化的时候，只有很少或者没有重复数据，所以只需要修改更少的数据。</p></li><li><p>范式化的表通常更小。</p></li><li><p>很少有冗余数据意味着检索列表数据更少需要distinct或者group by语句。</p></li></ul><h3 id="反范式的优点和缺点"><a href="#反范式的优点和缺点" class="headerlink" title="反范式的优点和缺点"></a>反范式的优点和缺点</h3><ul><li>反范式的schema所有数据都在一张表中，可以很好的避免关联，还可以避免随机IO(和存储引擎有关)。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>尽可能避免过度设计，例如会导致复杂查询的schema设计，或者有很多列的表的设计。</p></li><li><p>使用小而简单的合适数据类型，除非真实数据模型中确切的需要，否则应尽可能的避免NULL值。</p></li><li><p>尽量使用相同的数据类型存储相似或者相关的值，尤其是在关联条件中要使用的列。</p></li><li><p>避免使用MySQL已经遗弃的特性，例如浮点数的精度，或者整数的显示宽度。</p></li><li><p>小心使用ENUM和SET。避免使用BIT。</p></li></ul><h2 id="MySQL查询性能优化"><a href="#MySQL查询性能优化" class="headerlink" title="MySQL查询性能优化"></a>MySQL查询性能优化</h2><h3 id="捕获SQL查询日志"><a href="#捕获SQL查询日志" class="headerlink" title="捕获SQL查询日志"></a>捕获SQL查询日志</h3><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志是开销最低，精度最高的测量查询时间的工具。不需要考虑性能消耗，但是需要注意日志量太大导致占用太多磁盘空间。<br>慢查询日志中V/M列提供了方差均值比的详细数据，方差均值比也就是常说的离差指数。离差指数高的查询对应的执行时间的变化较大。</p><h4 id="抓取TCP包"><a href="#抓取TCP包" class="headerlink" title="抓取TCP包"></a>抓取TCP包</h4><p>通过tcpdump将网络包数据保存到磁盘，然后使用pt-query-digest的–type=tcpdump解析查询。</p><h3 id="分析查询日志"><a href="#分析查询日志" class="headerlink" title="分析查询日志"></a>分析查询日志</h3><p>工具：pt-query-digest。</p><h4 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h4><p><code>set profiling = 1</code><br><code>show profiles</code><br><code>show prifle for query 1</code><br>输出结果根据执行顺序排序，不使用show profile也可以直接查询infomation_schema中对应的表。</p><h4 id="show-status"><a href="#show-status" class="headerlink" title="show status"></a>show status</h4><p>这是一个计数器，可以清楚的知道句柄、临时文件和表的次数。是否是磁盘表。</p><h3 id="诊断问题工具"><a href="#诊断问题工具" class="headerlink" title="诊断问题工具"></a>诊断问题工具</h3><p>show Global status，可以将这个命令的数据绘制成图像。</p><p>show processlist， 观察是否存在大量线程处于不正常的状态或者有其他不正常的特征。</p><p>上面两个工具性能消耗很低，可以交叉或者频繁多次调用获取数据分析问题。</p><h3 id="捕获诊断数据"><a href="#捕获诊断数据" class="headerlink" title="捕获诊断数据"></a>捕获诊断数据</h3><p>监控工具：pt-stalk、pt-collect<br>监控变量：系统的状态、CPU利用率、磁盘使用率和可用空间、ps的输出采样、内存利用率，show status、show processlist和show innodb status。</p><h2 id="高性能索引创建"><a href="#高性能索引创建" class="headerlink" title="高性能索引创建"></a>高性能索引创建</h2><p>系统从磁盘读取数据到内存是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页（page）的概念，页是其磁盘管理的最小单位。</p><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><p>索引是存储引擎用于快速找到记录的一种数据结构。</p><h4 id="B-Tree索引（平衡多路查找树）"><a href="#B-Tree索引（平衡多路查找树）" class="headerlink" title="B-Tree索引（平衡多路查找树）"></a>B-Tree索引（平衡多路查找树）</h4><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree.png?raw=true" alt="b-tree"></p><p>B-Tree 通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。B-Tree索引能够加快访问数据的速度，存储引擎不需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放指向<strong><em>子节点的指针</em></strong>，存储引擎根据这些指针向下层查找。指针中定义了子节点页中值的上限和下限。最终找到该值或者不存在。</p><p>叶子节点比较特殊，他们指向的是被索引的数据，而不是其他的节点页。</p><p>索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</p><p>B-Tree索引的查询类型适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于根据最左前缀查找。</p><p>树的深度和表的大小直接相关。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/b-tree1.png?raw=true" alt="b-tree"></p><p>可以使用B-Tree索引的查询类型：</p><p>全值匹配：全值匹配指的是和索引的所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen 1960-01-01。</p><p>匹配最左前缀：可用于查找索引的第一列。</p><p>匹配列前缀：也可以匹配某一列的值的开头部分。</p><p>匹配范围值：遵循最左前缀的前提下，范围查找。</p><p>精确匹配某一列并范围匹配另外一列：可用于查找所有姓为Allen,并且名字是字母K开头的人。</p><p>只访问索引的查询：B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。</p><p>B-Tree使用限制：</p><ul><li>必须遵循最左原则。</li><li>不能跳过索引中的列。</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li><li>如果查询中某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li></ul><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>在B-tree的基础上，为叶子节点增加链表指针，而且所有的关键字都在叶子节点中出现，且数据只存储在叶子节点中。非叶子节点的关键字仅作为叶子节点的索引。</p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><p>在MySQL中，只有Memory引擎显式支持哈希索引且支持非唯一哈希索引的。</p><p>哈希索引每个槽点编号是有序的。</p><p>哈希索引使用限制：</p><p>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</p><p>哈希索引并不是按照索引值顺序存储的，所以无法用于排序。</p><p>哈希索引也不支持部分索引列的匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</p><p>哈希索引支持等值比较查询，包括=、in()、&lt;=&gt;也不支持任何范围查询，例如WHERE price &gt; 100。</p><p>访问哈希索引的数据非常快，除非有很多哈希冲突。</p><p>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。</p><p>除了Memory引擎外，NDB集群引擎也支持唯一哈希索引，且在NDB集群引擎中作用非常特殊。</p><p>InnoDB引擎有一个特殊的功能叫“自适应哈希索引”。当InnoDB引擎注意到某些索引值被使用的非常频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型索引，它查找的是文本中的关键词，而不是直接比较索引中的值。适用于MATCH AGINST操作，而不是普通的WHERE条件操作。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li><p>索引大大减少了服务器需要扫描的数据量。</p></li><li><p>索引可以帮助服务器避免排序和临时表。</p></li><li><p>索引可以将随机IO变为顺序IO。</p></li></ul><h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>索引不能是表达式的一部分，也不能是函数的参数。</p><h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>使用前缀作为索引。</p><p>前缀的选择性应接近于索引整个列。</p><p>完整列的选择性： select count(distinct city)/Count(<em>) from sakila.city_demo 。<br>前缀索引的选择性：select count(city,3)/count(</em>) from sakila.city_demo。</p><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。</p><ul><li>当服务器对多个索引做相交操作时（通常多个and），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。</li><li>当服务器对多个索引做联合操作时（通常多个or），通常需要耗费大量CPU和内存资源在算法的缓存、排序、合并操作上。</li><li>优化器不会把这些计算到查询成本中，优化器只关心随机页面读取，这会是的查询的成本被低估，到时该执行计划还不如直接走全表扫描。</li></ul><h4 id="选择合适的索引顺序"><a href="#选择合适的索引顺序" class="headerlink" title="选择合适的索引顺序"></a>选择合适的索引顺序</h4><p>当不考虑排序和分组时，选择性最高的列放到索引最前列。这时候索引的作用只是用于优化where条件的查找。</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p><p>优点：</p><ul><li>可以把相关的数据保存在一起。</li><li>数据访问更快。</li><li>使用覆盖索引扫描的查询可以直接使用叶节点中的主键值。</li></ul><p>缺点：</p><ul><li>聚簇索引最大限度的提高了I/O密集型应用的性能，但是如果数据全部放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没有什么优势了。</li><li>插入速度依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。如果不是按照主键顺序加载数据，那么在加载完成后最好使用optimize table重新组织一下表。</li><li>更新聚簇索引代价很高，因为会强制InnoDB将每个更新的行移动到新的位上。</li><li>聚簇索引的表插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li><li>二级索引可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li><li>二级索引访问需要两次索引查找，而不是一次。</li></ul><p>聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。</p><p>写入目标页可能已经刷到磁盘上并从缓存中移除，护着还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机I/O。</p><p>因为写入是乱序的，InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间。也分类会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。<br>由于频繁的页分裂，也会变的稀疏并被不规则的填充，最终数据会有分片。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果查询只需要扫描索引而无需回表：</p><ul><li>索引条目通常远小于数据行大小，所以只需要读取索引，极大减少数据访问量。</li><li>因为索引是按照列支顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少的多。</li><li>由于InnoDB是聚簇索引，覆盖索引对InnoDB特别有用。</li></ul><p>覆盖索引无法优化的问题：</p><ul><li>没有任何索引能够覆盖这个查询。</li><li>MySQL不能在索引中执行like操作，这是底层API的限制。</li></ul><p>解决方式：</p><p>延迟关联：</p><p><code>select * from test join (select id from test where id = 1 and title like &#39;%%&#39;) as t1 on t1.id = id</code></p><p>这种优化取决于where条件返回的数据条数。</p><p>如果返回一个很大的结果集（第一、二个条件过滤后还是很大），则优化效果不太明显。<br>如果返回一个小结果集（第一个条件过滤后还是很大，第二个过滤后很小），则优化效果明显。<br>如果返回一个小结果集（第一个条件过滤后还是很小，第二个过滤后也很小），则优化效果不明显。</p><p> <strong><em>注意</em></strong>，一定要看下5.6版本中存储引擎API上的重大改进。索引条件推送。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p> 索引条件下推（ICP）是针对MySQL使用索引从表中检索行的情况的一种优化。如果不使用ICP，则存储引擎将遍历索引以在基表中定位行，并将其返回给MySQL服务器，后者将评估这些行的WHERE条件。启用ICP后，如果仅可以使用索引中的列来评估WHERE条件的一部分，则MySQL服务器会将WHERE条件的这一部分下推到存储引擎。然后，存储引擎通过使用索引条目来评估推送的索引条件，并且只有在满足此条件的情况下，才从表中读取行。 ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。</p><p> 索引条件下推优化的适用性取决于这些条件:</p><ul><li>当需要访问整个表行时，ICP用于范围，ref，eq_ref和ref_or_null访问方法。</li><li>ICP适用于InnoDB和MyISAM表</li><li>对于InnoDB表，ICP仅用于二级索引。 ICP的目标是减少全行读取的次数，从而减少I / O操作。对于InnoDB聚集索引，完整的记录已被读入InnoDB缓冲区。在这种情况下使用ICP不会减少I / O。</li><li>不能将引用子查询的条件下推。</li><li>涉及存储功能的条件不能下推。存储引擎无法调用存储的功能。</li><li>触发条件不能下推。</li></ul><p>不使用ICP索引的扫描</p><ul><li>获取下一行，首先读取索引元组，然后使用索引元组查找并读取整个表行。</li><li><p>测试适用于此表的WHERE条件部分。根据测试结果接受或拒绝该行。</p><p>使用索引条件下推</p><ul><li>获取下一行的索引元组（而不是整个表行）。</li><li>测试适用于此表的WHERE条件部分，仅可使用索引列进行检查。</li><li>如果不满足条件，请转到下一行的索引元组。如果满足条件，请使用索引元组来定位和读取整个表行。</li><li>测试适用于此表的WHERE条件的其余部分。根据测试结果接受或拒绝该行。</li></ul></li></ul><h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p> MySQL有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描；如果explain出来的type列的值为“index”，则说明使用了索引扫描来做排序。按索引顺序读取数据的速度通常比顺序的全表扫描慢，尤其是在I/O密集型的工作负载时。</p><p> MySQL设计索引时，如果有可能，既满足排序，又用于查找行。</p><p> 只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当order by子句引用的字段你全部为第一个表时，才能使用索引做排序。</p><p> 一般情况下，order by子句可以不满足索引的最左前缀的要求，就是前导列为常量时，如果where子句或者join子句对这些列指定了常量，就可以弥补索引的不足。</p><p> 以下是不能使用索引做排序的查询：</p><ul><li>查询使用了两种不同的排序方向，索引列都是正序排序的</li><li>order by子句中引用了一个不再索引中的列</li><li>where和order by中的列无法组合成索引的最左前缀</li><li>索引列的第一列不是常量查询，而是范围查询</li><li>inventory_id列上有多个等于条件，这也是一种范围查询</li></ul><h4 id="压缩（前缀压缩）索引-和-未使用的索引"><a href="#压缩（前缀压缩）索引-和-未使用的索引" class="headerlink" title="压缩（前缀压缩）索引 和 未使用的索引"></a>压缩（前缀压缩）索引 和 未使用的索引</h4><h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><p> 重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。</p><p> 冗余索引通常发生在为表添加新索引的时候。<br> information_schema也可以查询哪些是冗余的索引。</p><p> 可以通过查询information_schema.index_statistics可以查询到每个索引的使用频率。</p><p>SCHEMATA表：提供了关于数据库的信息。</p><p>TABLES表：给出了关于数据库中的表的信息。</p><p>COLUMNS表：给出了表中的列信息。</p><p>STATISTICS表：给出了关于表索引的信息。</p><p>USER_PRIVILEGES表：给出了关于全程权限的信息。该信息源自mysql.user授权表。</p><p>SCHEMA_PRIVILEGES表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。</p><p>TABLE_PRIVILEGES表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。</p><p>COLUMN_PRIVILEGES表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。</p><p>CHARACTER_SETS表：提供了关于可用字符集的信息。</p><p>COLLATIONS表：提供了关于各字符集的对照信息。</p><p>COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。</p><p>TABLE_CONSTRAINTS表：描述了存在约束的表。</p><p>KEY_COLUMN_USAGE表：描述了具有约束的键列。</p><p>ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。</p><p>VIEWS表：给出了关于数据库中的视图的信息。</p><p>TRIGGERS表：提供了关于触发程序的信息。</p><h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p> InnoDB在二级索引上使用共享锁，但访问主键索引需要排他锁。这消除了使用覆盖索引的可能性，并且使得select for update比lock in share mode或非锁定查询要慢很多。</p><h3 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h3><h4 id="支持多种过滤条件"><a href="#支持多种过滤条件" class="headerlink" title="支持多种过滤条件"></a>支持多种过滤条件</h4><h4 id="避免多个范围条件"><a href="#避免多个范围条件" class="headerlink" title="避免多个范围条件"></a>避免多个范围条件</h4><h4 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h4><h3 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h3><p>维护表有3个目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。</p><h4 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h4><p>表损坏（corruption）是件很糟糕的事情。对于MyISAM，表损坏通常是系统崩溃导致的。</p><p>损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时甚至还会导致数据库的崩溃。</p><p>修复：</p><ul><li><p>check table，能找出大多数表和索引错误。有些存储引擎不支持该命令。</p></li><li><p>repair table，和check类似。</p></li><li><p>alter table innodb_tbl engine=innodb，修改表的存储引擎为当前引擎重建表。</p></li><li><p>离线工具myisamchk</p></li><li><p>将数据导出在重新导入。</p></li><li><p>如果损坏的是行数据或者系统区域，以上办法无效。</p></li><li><p>如果损坏系统区域或者行数据，可以从备份中恢复表，或者尝试从损坏的数据文件中尽可能的恢复数据。</p></li></ul><p>如果InnoDB引擎的表出现损坏，那么一定是发生了严重的错误，需要立刻调查原因。具体细节可以查看MySQL手册。</p><h4 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h4><p>查询优化器会通过两个API了解存储引擎的索引值的分布信息<br>record_in_range()通过传入两个边界值获取这个范围大概有多少条纪律<br>info()返回各种类型的数据，包括索引的基数（每个键值有多少纪律）</p><h4 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h4><ul><li>行碎片</li><li>行间碎片</li><li>剩余空间碎片</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三个原则：</p><ul><li><p>单行访问时很慢的。最好读取块中能包含尽可能多的所需要的行。使用索引可以创建位置引用以提升效率。</p></li><li><p>按顺序访问范围数据是很快的，这有两个原因。第一、顺序IO不需要多次磁盘寻道，所以比随机IO快很多。第二、如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且group by查询也无需再做排序和将行按组进行聚合计算了。</p></li><li><p>索引覆盖查询是很快的。</p></li></ul><p>一般来说，我们建议按响应时间来对查询进行分析。</p><p>如果一个查询无法从所有可能的索引中获益，则应该看看是否可以创建一个更合适的索引来提升性能。</p><h2 id="剖析MySQL查询"><a href="#剖析MySQL查询" class="headerlink" title="剖析MySQL查询"></a>剖析MySQL查询</h2><p>对查询进行性能剖析有两种方式，每种方式都有各自的问题。</p><h3 id="剖析服务器负载"><a href="#剖析服务器负载" class="headerlink" title="剖析服务器负载"></a>剖析服务器负载</h3><p>服务器端可以有效的审计效率低下的查询。</p><h4 id="捕获MySQL的查询到日志文件中"><a href="#捕获MySQL的查询到日志文件中" class="headerlink" title="捕获MySQL的查询到日志文件中"></a>捕获MySQL的查询到日志文件中</h4><p>慢查询日志是一种轻量而且功能全面的性能剖析工具，是优化服务器查询的利器。可以通过修改针对每个链接的long_query_time的阈值来捕获所以的查询。</p><p>通用日志在查询请求到服务器时进行记录，所以不包含响应时间和执行计划等重要信息。日志信息记录到数据库表中。</p><h4 id="分析查询日志-1"><a href="#分析查询日志-1" class="headerlink" title="分析查询日志"></a>分析查询日志</h4><p>工具：pt-query-digest</p><p>剖析报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest1.png?raw=true" alt="查询日志"></p><p>详细报告：<br><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/digest2.png?raw=true" alt="详细查询日志"></p><h3 id="剖析单条查询"><a href="#剖析单条查询" class="headerlink" title="剖析单条查询"></a>剖析单条查询</h3><h4 id="show-profile-1"><a href="#show-profile-1" class="headerlink" title="show profile"></a>show profile</h4><p>show profile命令是在5.1版本之后引入的，默认是禁用的，可以通过<code>set profiling=1</code>动态的修改。这个功能有一定的作用，将来能会被Performance Schema所取代。</p><p>下面是对一个视图的剖析结果：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling1.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling2.png?raw=true" alt="详细查询日志"></p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/profiling3.png?raw=true" alt="详细查询日志"></p><p>剖析报告给出查询执行每个步骤花费的时间，看结果无法快速确定哪个步骤花费时间最多，因为输出是按照执行顺序排序，而不是花费的时间排序的。如果不使用show profile命令。还可以直接查询information_schema中对应的表，按照格式化输出。</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/information_schema.png?raw=true" alt="详细查询日志"></p><p>效果比看show profile输出的结果好很多，可以很直观的看到哪些步骤花费时长较长。</p><h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="查询慢的原因"><a href="#查询慢的原因" class="headerlink" title="查询慢的原因"></a>查询慢的原因</h3><p>查询最重要的是响应时间，如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行更快。</p><p>MySQL执行查询的时候，查询需要在不同的地方花费时间，如网络、cpu、生成统计信息和执行计划、锁等待等。在每一个消耗大量时间的查询案例中，我们都能看到一些不必要的额外操作、某些操作被额外的执行了很多次、某些操作执行的太慢等。</p><p>优化查询的目的就是减少和消除这些操作所花费的时间。</p><h3 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h3><p>查询性能低下最基本的原因是访问的数据太多。某些查询不可避免的需要筛选大量数据，大部分查询都可以通过减少访问的数据量的方式进行优化。对于低效查询可以分为两个步骤分析：</p><ul><li><ol><li>确认应用程序是否检索大量超过需要的数据。如访问过多的行或者列。</li></ol></li><li><ol start="2"><li>确定MySQL服务器层是否在分析大量超过需要的数据行。</li></ol></li></ul><h4 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h4><ul><li><p>查询不需要的记录</p></li><li><p>多表关联返回全部的列</p></li><li><p>总是取出全部的列</p></li><li><p>重复查询相同的数据</p></li></ul><h4 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h4><p>在确定查询只返回需要的数据以后，最简单的衡量查询开销的三个指标如下：</p><ul><li><p>响应时间</p></li><li><p>扫描的行数</p></li><li><p>返回的行数</p></li></ul><p>响应时间：响应时间只是一个表面上的值。响应时间是服务时间和排队时间。服务时间指数据库处理这个时间花费的时间。排队时间指服务器因为等待某些资源而没有真正执行查询的时间。</p><p>快速上限估计：了解查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以在具体硬件条件下一次IO的消耗时间。</p><p>扫描的行数和返回的行数： 分析查询时，查看扫描的行数一定程度上可以反映出该查询找到需要的数据的效率高不高。</p><p>扫描的行数和访问类型：在explain语句中的type列反映了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。从慢到快，扫描的行数从小到大。</p><p>如果查询没有找到合适的访问类型，那么解决的最好办法通常是增加一个合适的索引。</p><p>例如：</p><p><code>select * from sakila.film_actor where film_id = 1;</code></p><p>这个查询返回10行数据，从explain的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/ref.png?raw=true" alt="详细查询日志"></p><p>explain的结果也显示MySQL预估需要访问10行数据。查询优化器认为这种访问类型可以高效的完成查询。如果我们删除索引再来运行：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/where.png?raw=true" alt="详细查询日志"></p><p>正如我们预料的，查询变成全表扫描，MySQL预估会扫描5073条记录来完成查询。</p><p>一般MySQL使用如下三种方式应用WHERE条件，从好到坏依次是：</p><ul><li><p>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</p></li><li><p>使用索引覆盖扫描（Extra:using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需再回表查询记录。</p></li><li><p>从数据表中返回数据（Extra:using where），然后过滤不满足条件的记录。这是在服务器层完成的，MySQL需要从数据表中读出来然后再进行过滤。</p></li></ul><p>虽然例子说明了好的索引多么重要，但是也不是说增加了索引就能让扫描的行数等于返回的行数。例如使用聚合函数的查询：</p><p><code>select actor_id,count(*) from sakila.film_actor group by actor_id</code></p><p>这个例子没有什么索引能够让这样的查询减少需要扫描的行数。</p><p>通常如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试使用下面的技巧去优化：</p><ul><li><p>使用覆盖索引扫描，把所有需要的列放到索引中，这样存储引擎无需回表获取对应行就可以返回结果了。</p></li><li><p>改变库表结构。例如使用单独的汇总表。</p></li><li><p>重写复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</p></li></ul><h3 id="重构查询的方式非锁"><a href="#重构查询的方式非锁" class="headerlink" title="重构查询的方式非锁"></a>重构查询的方式非锁</h3><h4 id="一个复杂的查询还是多个简单的查询"><a href="#一个复杂的查询还是多个简单的查询" class="headerlink" title="一个复杂的查询还是多个简单的查询"></a>一个复杂的查询还是多个简单的查询</h4><p>衡量一下一个复杂查询和多个简单查询的优劣。</p><h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><p>将大查询分为小查询，每个查询功能完全一样，只完成一小部分，每次返回一小部分查询结果。删除旧数据就是一个很好的例子</p><h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><p>对每一个表进行一次单表查询，然后将结果在应用程序中关联。</p><p>分解关联查询的优点：</p><ul><li><p>让缓存效率更高。</p></li><li><p>执行单个查询可以减少锁的竞争。</p></li><li><p>做应用层关联，可以更好的对数据库拆分，更容易做到，高性能可扩展。</p></li><li><p>查询效率本身效率也可能会有所提升。</p></li><li><p>可以减少冗余记录的查询。</p></li><li><p>这样做相当于在应用中实现了哈希关联而不是MySQL的嵌套循环关联。</p></li></ul><h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><p>查询执行路径：</p><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/process.png?raw=true" alt="查询执行路径"></p><h4 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h4><p>MySQL客户端与服务器之间的通信协议是“半双工”的，这意味着，要么服务器项客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。</p><h5 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h5><p><code>show full processlist</code>命令返回结果中的Command列就表示当前的状态。</p><p><code>Sleep</code>: 线程正等待客户端发送新的数据。<br><code>Query</code>: 线程正在执行查询或者正在将结果发送给客户端。<br><code>Locked</code>: 该线程正在 等待表锁。<br><code>Analyzing and statistics</code>: 线程正在收集存储引擎的统计信息，并生成查询的执行计划。<br><code>Copying to tmp table [on disk]</code>: 线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是group by操作，要么是文件排序操作，或者union操作。如果这个状态后面还有“on disk”标记，那表示MySQL正在将一个内存临时存放在磁盘上。<br><code>Sorting result</code>: 线程正在对结果集进行排序。<br><code>Sending data</code>: 线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</p><h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><p>如果SQL命中缓存，则直接从缓存中获取数据，返回客户端。</p><h5 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h5><p>解析SQL、预处理、优化SQL执行计划。</p><h6 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h6><p>MySQL通过关键字将SQL语句进行解析，并生成一个对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。</p><p>预处理则根据一些MySQL规则进一步检查解析树是否合法，验证权限。</p><h6 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h6><p>一条查询可以有很多执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。</p><p><code>show status like &#39;last_query_host&#39;</code></p><p>每个表或者索引的页面个数，索引的基数、索引和数据行的长度、索引分布情况。</p><p>有很多原因会导致MySQL优化器选择错误的执行计划：</p><ul><li>统计信息不准确。MySQL依赖存储引擎提供的统计信息来评估成本，但是有的存储引擎提供的信息是准确的，有的偏差可能非常大。例如，InnoDB因为其MVCC的架构，并不能维护一个数据表的行数的精确统计信息。</li><li>执行计划中的成本估算不等同与实际执行的成本。所以即使统计信息精准，优化器给出的执行计划也可能不是最优的。例如有时候某个执行计划虽然需要读取更多的页面，但是它的成本却更小。因为如果这些页面都是顺序读或者这些页面都已经在内存中的话，那么它的访问成本将很小。MySQL层面并不知道哪些页面在内存中、哪些在磁盘上，所以查询实际执行过程中到底需要多少次物理I/O是无法得知的。</li><li>MySQL只是基于成本模型选择最优的执行计划，而有些时候这并不是最快的执行方式。</li><li>MySQL从不考虑其他并发执行的查询，这可能会影响到当前查询的速度。</li><li>MySQL也并不是任何时候都是基于成本优化。如果存在全文搜索的match 子句，则在存在全文索引的时候就是用全文索引。即使有时候使用别的索引和where条件可以远比这种方式要快。</li><li>MySQL不会考虑不受其控制的操作的成本，例如执行存储过程或者用户自定义函数的成本。</li><li>优化器有时候无法去估算所有可能的执行计划，所以他可能错过实际上最优的执行计划。</li></ul><p>优化策略可以分为两类：</p><ul><li>静态优化：可以直接对解析树进行分析，并完成优化。</li><li>动态优化： 动态优化则和查询的上下文有关，也可能和很多其他因素有关，例如where条件中的取值、索引中条目对应数据行数等。</li></ul><p>MySQL对查询静态优化只做一次，但对查询的动态优化则在每次执行时都需要重新评估。有时候甚至在查询的执行过程中也会重新优化。</p><p>优化类型：</p><ul><li>重新定义关联表的顺序：数据表的关联并不总是按照在查询中指定的顺序进行。决定关联的顺序是优化器 很重要的一部分功能。</li><li>将外连接转化为内连接：并不是所有的outer join语句都必须以外连接的方式执行。例如where条件、库表结构都可以能会让外连接等价于一个内连接。</li><li>使用等价变换规则：MySQL可以使用一些等价变换来简化并规范表达式。</li><li>优化count()、min()、max()：索引和列是否可为空通常可以帮助MySQL优化这类表达式。例如，需要找到某一列的最小值，则需要查询对应B-Tree索引最左端的记录，MySQL可以直接获取索引的第一行记录。</li><li>预估并转化为常数表达式：当MySQL检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。例如，一个用户自定义变量在查询中没有发生变化时就可以转为一个常数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select film.film_id, film_actor.actor_id from sakila.film</span><br><span class="line">inner join sakila.film_actor usring(film_id) where film.film_id = 1;</span><br></pre></td></tr></table></figure><p>MySQL分两步来执行这个查询，也就是上面执行计划的两行输出。第一步先从film表找到需要的行。因为在film_id字段上有主键索引，所以MySQL优化器知道这会返回一行数据，优化器在生成执行计划的时候，就已经通过索引信息知道将返回多少行数据。</p><p>在执行计划的第二部，MySQL将第一步中返回的film_id列当做一个已知取值的列来处理。</p><h6 id="覆盖索引扫描"><a href="#覆盖索引扫描" class="headerlink" title="覆盖索引扫描"></a>覆盖索引扫描</h6><p>之前说过</p><h6 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h6><p>MySQL在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询对数据进行访问。</p><h6 id="提前终止查询"><a href="#提前终止查询" class="headerlink" title="提前终止查询"></a>提前终止查询</h6><p>在发现已经满足查询需求的时候，MySQL总是能够立刻终止查询。</p><h6 id="等值传播"><a href="#等值传播" class="headerlink" title="等值传播"></a>等值传播</h6><p>如果两个列的值通过等式关联，那么MySQL能够把其中一个列的where条件传递到另一列上。</p><h6 id="列表in-的比较"><a href="#列表in-的比较" class="headerlink" title="列表in()的比较"></a>列表in()的比较</h6><p>MySQL将in()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这个一个O(logn)复杂度的操作，等价转换成OR查询的复杂度为O(n)，对于in()列表中有大量取值的时候，MySQL的处理速度将会更快。</p><h5 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h5><p>因为服务器层没有任何统计信息，所以MySQL查询优化器在生成查询计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对应的统计信息：每个表或者索引有多少个页面、每个表的每个索引的基数是多少、数据行和索引长度、索引的分布信息等。</p><h5 id="MySQL如何执行关联查询"><a href="#MySQL如何执行关联查询" class="headerlink" title="MySQL如何执行关联查询"></a>MySQL如何执行关联查询</h5><p>在MySQL中并不仅仅是查询需要到两个表匹配才叫关联，所以在MySQL中，每一个查询，每一个片段（子查询、甚至于单表的select）都可能是关联。</p><p>对于union查询，MySQL先将一系列的单个查询结果放到一个临时表中，然后再重新读取初临时表数据来完成union查询。读取临时表也是一种关联。</p><p>MySQL关联执行的策略：MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，知道找到素有表中匹配的行为止。</p><p>从本质上说，MySQL对所有的类型的查询都以同样的方式运行。例如，MySQL在from子句中遇到子查询时，限制性子查询并将其结果放到一个临时表中，然后将这个临时表当做一个普通表对待。简而言之，当前版本的MySQL都会讲所有的查询类型都转换成类似的执行计划。</p><p>全外连接就无法通过嵌套循环和回溯的方式完成，当发现关联表中没有找到任何匹配行的时候，则可能是因为关联是恰好从一个没有任何匹配的表开始。</p><p>内连接：<code>select tbl1.col1,tbl2,col2 from tbl1 inner join tbl2 using(col3) where tbl1.col1 in(5,6)</code></p><p>外连接：<code>select tbl1.clo1, tbl2.col2 from tbl1 left outer join tbl2 using(col3) where tbl1.col1 in(5,6)</code></p><p><img src="/media/article/mysql-inner.png" alt=""></p><h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h5><p>MySQL并不会生成查询字节码来执行查询。MySQL生成的查询的一颗指令树，然后通过存储引擎执行完成这棵树并返回结果。</p><p>MySQL总是从一个表开始一直嵌套循环、回溯完成所有表关联。所以MySQL的执行计划是一棵左侧深度优先的树。<br><img src="/media/article/mysql-plan-tree.png" alt=""></p><h5 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h5><p>MySQL优化器最重要的一部分就是关联查询优化，它决定了多个表关联查询时的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select film.film_id,film.title,film.release_year,actor.actor_id,actor.first_name,actor.last_name from sakila.film inner join sakila.film_actor using(film_id) inner join sakila.actor using(actor_id);</span><br></pre></td></tr></table></figure><p>可以使用Straight_join关键字重写查询（不会重新排序）。</p><p>当需要关联的表超过optimizer_search_depth的限制的时候，就会选择“贪婪”搜索模式了。</p><h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><p>排序是一个成本很高的操作，所以尽可能避免对大量数据进行排序。</p><p>MySQL有如下两种排序算法：</p><ul><li>两次传输排序：读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。这需要两次数据传输，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这会产生大量的随机I/O，所以这两次数据传输成本非常高。</li><li>单次传输排序：先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。缺点是如果需要返回的列非常多、非常大、会额外占用大量的空间，这些列堆排序操作本身来说是没有任何作用的。因为单条排序记录很大，所以可能会有更多的排序块需要合并。</li></ul><p><strong><em> 5.6版本以后，对排序进行了重大改进，只对最后结果进行排序。</em></strong></p><h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><p>MySQL只是简单的根据执行计划给出的指令逐步执行。MySQL在优化阶段为每个表创建了一个handler实例，优化器根据这些实例的接口可以获取表的相关信息，包括标的所有列名、索引统计信息。</p><h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><p>查询执行的最后一个阶段是将结果返回给客户端。<br>MySQL将结果集返回客户端是一个增量、逐步返回的过程。<br>结果集中每一行数据都会以一个满足MySQL客户端/服务器通信协议的封包发送，再通过TCP协议进行传输，传输过程中，可能对MySQL的封包进行缓存然后批量传输。</p><h3 id="MySQL查询优化器的局限性"><a href="#MySQL查询优化器的局限性" class="headerlink" title="MySQL查询优化器的局限性"></a>MySQL查询优化器的局限性</h3><h4 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h4><p>MySQL的子查询实现非常糟糕，最糟糕的一类查询是where条件中包含in()的子查询语句。<br>一般建议使用左外连接重写该查询。</p><h4 id="union-的限制"><a href="#union-的限制" class="headerlink" title="union 的限制"></a>union 的限制</h4><p>MySQL无法将限制条件从外层下推到内层，这使得原本能够限制部分返回结果的条件无法应用到内层查询的优化上。如果希望union能根据limit只取部分结果集，则需要在每个union中使用limit。</p><h4 id="索引合并优化"><a href="#索引合并优化" class="headerlink" title="索引合并优化"></a>索引合并优化</h4><p>MySQL能够访问单个表的多个索引以合并和交叉过滤的方式定位需要查找的行。</p><h4 id="等值传递"><a href="#等值传递" class="headerlink" title="等值传递"></a>等值传递</h4><p>如果MySQL优化器发现存在Where、ON或者using子句，将这个列表的值和另一个表的某个列相关联。<br>优化器会将in()列表都复制应用到关联的各个表中。通常因为各个表增加了过滤条件，优化器可以更高效的从存储引擎过滤记录。但是如果这个列表非常大，则导致优化和执行变得非常慢。</p><h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>MySQL无法利用多核特性来并行执行查询。</p><h4 id="哈希关联"><a href="#哈希关联" class="headerlink" title="哈希关联"></a>哈希关联</h4><p>MySQL的所有关联都是嵌套循环关联。</p><h4 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h4><p>MySQL不支持松散索引扫描，无法按照不连续的方式扫描索引。</p><h4 id="最大值和最小值优化"><a href="#最大值和最小值优化" class="headerlink" title="最大值和最小值优化"></a>最大值和最小值优化</h4><p>对于min()和max()查询支持并不好。</p><p><code>select min(actor_id) from sakila.actor where first_name == &#39;PENELOPE&#39;;</code></p><p>因为first_name上没有索引，因此MySQL会进行一次全表扫描。</p><p><code>select actor_id from sakila.actor use index(primary) where first_name = &#39;Penelope limit 1&#39;</code></p><h4 id="在同一个表上查询和更新"><a href="#在同一个表上查询和更新" class="headerlink" title="在同一个表上查询和更新"></a>在同一个表上查询和更新</h4><p>MySQL不允许对同一张表同时进行查询和更新。</p><p><code>update tb1 as outer_tb1 set cnt  = (select count(*) from tb1 as innner_tb1 where innner_tb1.type = outer_tb1.type )</code></p><p>解决方式:<code>update tb1 inner join(select type,count(*) as cnt from tb1 group by type) as der using (type) set tb1.cnt = der.cnt</code></p><h4 id="查询优化器的提示-hint"><a href="#查询优化器的提示-hint" class="headerlink" title="查询优化器的提示(hint)"></a>查询优化器的提示(hint)</h4><p>HIGH_PRIORITY和LOWPRIORITY</p><p>HIGH_PRIORITY用于SELECT语句的时候，MySQL会将此SELECT语句重新 调度到所有正在等待表锁以便修改数据的语句之前。 HIGH_PRIORITY还可以用于INSERT语句，其效果只是简单的抵消了全局LOW_PRIORITY设置对该语句的影响。</p><p>LOW_PRIORITY则会让该语句一致处于等待状态，只要队列中海油需要访问同一个表的语句。LOW_PRIORITY提示在SELECT、INSERT、UPDATE和DELETE语句中都可以使用。</p><p>这两个提示针对表锁的存储引擎有效，千万不要在InnoDB或者其他有细粒度锁机制的并发控制引擎中使用。</p><p>DELAYED</p><p>这个提示对INSERT和REPLACE有效。MySQL会将使用该提示的语句立即返回给客户端，并插入的行数据放入到缓冲区，然后在表空闲的时候批量将数据写入。</p><p>这个用法有一些限制: 并不是所有的存储引擎都支持这样的做法，并且该提示会导致函数LAST_INSERT_ID()无法正常工作。</p><p>STRAIGHT_JOIN</p><p>这个提示可以放置在SELECT语句的SELECT关键字之后，也可以放置在任何两个关联表的名字之间。第一个用法是让查询中所有表按照在语句中出现的顺序进行关联。第二个用法则是固定其前后两个表的关联顺序。</p><p>SQL_SMALL_RESULT和SQL_BIG_RESULT</p><p>这两个提示对SELECT语句有效。它告诉优化器对GROUP BY或者DISTINCT查询如何使用临时表及排序。SQL_SMALL_RESULT告诉优化器结果集会很小，可以将结果集放在内存中的索引临时表，以避免排序操作。SQL_BIG_RESULT，则告诉优化器结果集可能非常大，建议使用磁盘临时表做排序操作。</p><p>SQL_BUFFER_RESULT</p><p>这个提示告诉优化器将查询结果放入到一个临时表，尽可能快的释放表。缺点就是服务器端会占用很多内存。</p><p>SQL_CACHE和SQL_NO_CACHE</p><p>这个提示告诉MySQL这个结果集是否应该缓存在查询缓存中。</p><p>SQL_CALC_FOUND_ROWS</p><p>查询中加上该提示MySQL会计算出去LIMIT子句后这个查询要返回的结果集的总数，而实际上只返回limit要求的结果集，可以通过found_row()获得这个值。</p><p>FOR UPDATE和LOCK IN SHARE MODE</p><p>这两个提示控制SELECT语句的锁机制，只针对实现行级锁的存储引擎有效。唯一内置支持这两个提示的引擎就是InnoDB。通常避免使用这两个提示。</p><p>USE INDEX、IGNORE INDEX和FORCE INDEX</p><p>这个提示会告诉优化器使用或者不使用哪些索引来查询记录。</p><p>新增一些参数来控制优化器的行为：</p><p>optimizer_search_depth 这个参数控制优化器在穷举执行计划时的限度。如果查询时间处于“Statistics”状态，那么可以考虑调低此参数。<br>optimizer_prune_level 该参数默认是打开的，这让优化器会根据需要扫描的行数来决定是否跳过某些执行计划。<br>optimizer_switch 这个变量包含了开启、关闭优化器特性的标志位。</p><p>开启和关闭索引下推<br>SET optimizer_switch = ‘index_condition_pushdown=off’;<br>SET optimizer_switch = ‘index_condition_pushdown=on’;</p><h4 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h4><h5 id="优化count-查询"><a href="#优化count-查询" class="headerlink" title="优化count()查询"></a>优化count()查询</h5><p>count()是一个特殊函数。<br>它可以统计某个列值的数量，也可以统计行数。在统计列值时要求列值是非空的。如果在count()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。<br>count()另一个作用是统计结果集的行数。当MySQL确认括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是当我们使用count(*)的时候，这种情况下通配符并不会扩展成所有的列，它会忽略所有的列而直接统计所有的行数。</p><h5 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h5><ul><li>确保ON或者using子句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。一般来说说，除非有其他理由，否则只需要在关联顺序中的第二个表的响应列上创建索引。</li><li>确保任何的group by和order by中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li><li>当升级MySQL的时候需要注意: 关联语法、运算符优先级等其他可能会发生变化的地方。</li></ul><h5 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h5><p>尽量使用关联查询代替。5.6版本后，可以忽略关于优化子查询的建议。</p><h5 id="优化GROUP-BY-和DISTINCT"><a href="#优化GROUP-BY-和DISTINCT" class="headerlink" title="优化GROUP BY 和DISTINCT"></a>优化GROUP BY 和DISTINCT</h5><p>MySQL优化器会在内部处理的时候相互转化这两类查询。他们都可以使用索引来优化，这也是最有效的优化办法。</p><p>当无法使用索引的时候，group by使用两种策略来完成: 使用临时表或者文件排序来做分组。</p><p>如果需要对关联查询做分组(group by)，并且是按照查找表中的某个列进行分组，那么通常采用查找表的标识列分组的效率会比其他列更高。</p><p><code>select actor.first_name, actor.last_name, count(*) from sakila.film_actor inner join sakila.actor using(actor_id) group by actor.first_name, actor.last_name</code></p><p>优化后：<br><code>select actor.first_name,actor.last_name,count(*) from sakila.film_actor inner join sakila.actor using(actor_id) group by film_actor.actor_id</code></p><p>事实上，我们建议将MySQL的SQL_MODE设置为包含ONLY_FULL_GROUP_BY，这时MySQL会对这个类查询直接返回一个错误，提醒你重写这个查询。</p><p>如果没有通过ORDER BY子句显式的指定排序列，当查询使用GROUP BY子句的时候 ，结果集会自动按照分组的字段进行排序。不需要排序可以使用ORDER BY NULL不再排序。</p><p>分组查询的一个变种就是要求MySQL对返回的数组结果再做一次超级聚合。可以使用WITH ROLLUP子句来实现这种逻辑，但可能会不够优化。建议尽可能将WITH ROLLUP功能转移到应用程序中处理。</p><h5 id="优化limit分页"><a href="#优化limit分页" class="headerlink" title="优化limit分页"></a>优化limit分页</h5><p>优化偏移量大的查询分页最简单的办法就是尽可能的使用索引覆盖扫描，而不是查询所有的列。</p><p><code>select film_id, description from sakila.film order by title limit 50,5</code></p><p>优化后：<br><code>select film.film_id,film.description from sakila.film inner join(select film_id from sakila.film order  by title limit 50, 5) as lim using(film_id)</code><br>limit和offset的问题，其实是offset的问题，我们可以使用相关列的排序规避offset。<br>例如：<code>select * from sakila.rental order by rental_id sesc limit 20</code></p><h5 id="优化SQL-CALC-FOUND-ROWS"><a href="#优化SQL-CALC-FOUND-ROWS" class="headerlink" title="优化SQL_CALC_FOUND_ROWS"></a>优化SQL_CALC_FOUND_ROWS</h5><p>分页的时候，另一个常用的技巧是在limit语句中加上SQL_CALC_FOUND_ROWS提示，可以获得去掉limit以后满足条件的行数，可以用作为分页的总数。该提示代价可能会很高。</p><h5 id="优化union查询"><a href="#优化union查询" class="headerlink" title="优化union查询"></a>优化union查询</h5><p>MySQL总是通过创建并填充临时表的方式来执行union查询。一次很多优化策略在union查询中都没法很好的使用，经常需要手动的将where、limit、order by等子句下推到union各个子查询中，以便优化器可以充分利用这些条件进行优化。</p><p>除非确实需要服务器消除重复的行，否则就一定要使用Union all。如果没有all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性检查。</p><h5 id="静态查询分析"><a href="#静态查询分析" class="headerlink" title="静态查询分析"></a>静态查询分析</h5><p>Percona Toolkit中的pt-query-advisor能够解析查询日志、分析查询模式，然后给出所有可能存在潜在问题的查询。</p><h5 id="使用用户自定义变量"><a href="#使用用户自定义变量" class="headerlink" title="使用用户自定义变量"></a>使用用户自定义变量</h5><p>以下情况不能使用自定义变量：</p><ul><li>使用自定义变量的查询，无法使用查询缓存。</li><li>不能在使用常量或者标识符的地方使用自定义变量，例如表名，limit子句。</li><li>生命周期在一个连接中有效，所以不能用他们来做连接间的通信。</li><li>MySQL在某些场景下可能会将这些变量优化掉，这可能导致代码不按照预想的方式运行。</li><li>赋值的顺序和赋值的时间并不总是固定的。</li><li>赋值符号:=的优先级非常低，赋值表达式应该使用明确的括号。</li><li>使用未定义变量不会产生任何语法错误，如果没有意思到这一点，非常容易犯错。</li></ul><p>使用用户自定义变量的一个重要特性是你可以再给一个变量复制的同时使用这个变量。</p><ul><li>优化排名语句</li><li>避免重复查询刚刚更新的数据</li><li>统计更新和插入的数量</li><li>确定取值的顺序</li><li>编写偷懒的union</li><li>查询运行时计算总数和平均值</li><li>模拟group语句中的first和last</li><li>对大量数据做一些数据计算</li><li>计算一个大表的md5散列值</li><li>编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变成0</li><li>模拟读/写游标</li><li>在show语句的where子句中加入变量值</li></ul><h3 id="查询优化器的提示"><a href="#查询优化器的提示" class="headerlink" title="查询优化器的提示"></a>查询优化器的提示</h3><h3 id="优化特定类型的查询-1"><a href="#优化特定类型的查询-1" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h3><h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><h2 id="MySQL的高级特性"><a href="#MySQL的高级特性" class="headerlink" title="MySQL的高级特性"></a>MySQL的高级特性</h2><ul><li><p>分区表</p></li><li><p>视图</p></li><li><p>外键约束</p></li><li><p>MySQL内部存储代码</p></li><li><p>游标</p></li><li><p>绑定变量</p></li><li><p>用户自定义函数</p></li><li><p>插件</p></li><li><p>字符集和校对</p></li><li><p>全文索引</p></li><li><p>分布式（XA）事务</p></li><li><p>查询缓存</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">高性能MySQL 第3版 中文 宁海元，周振兴，彭立勋，翟卫祥，刘辉译.</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/what-is-mysql.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL优化</title>
      <link href="/mysql/2018-04-02-sql/"/>
      <url>/mysql/2018-04-02-sql/</url>
      
        <content type="html"><![CDATA[<h2 id="常用SQL技巧"><a href="#常用SQL技巧" class="headerlink" title="常用SQL技巧"></a>常用SQL技巧</h2><h3 id="1-1-检索包含最大和最小值的行"><a href="#1-1-检索包含最大和最小值的行" class="headerlink" title="1.1 检索包含最大和最小值的行"></a>1.1 检索包含最大和最小值的行</h3><p><code>select max(test_score),min(test_score) from student</code></p><h3 id="1-2-巧用rand-rand-n-提取随机行"><a href="#1-2-巧用rand-rand-n-提取随机行" class="headerlink" title="1.2 巧用rand()/rand(n)提取随机行"></a>1.2 巧用rand()/rand(n)提取随机行</h3><p><code>select * from table order by rand()</code></p><h3 id="1-3-group-by的with-rollup子句做统计"><a href="#1-3-group-by的with-rollup子句做统计" class="headerlink" title="1.3 group by的with rollup子句做统计"></a>1.3 group by的with rollup子句做统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table sales(</span><br><span class="line"></span><br><span class="line">year int not null,</span><br><span class="line">country varchar(20) not null,</span><br><span class="line">product varchar(32) not null,</span><br><span class="line">profit int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2001);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2002);</span><br><span class="line">insert into sales values(2004,&apos;china&apos;,&apos;tnt2004&apos;,2003);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2004);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2005);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2006);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2007);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2008);</span><br><span class="line">insert into sales values(2005,&apos;china&apos;,&apos;tnt2005&apos;,2009);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2010);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2011);</span><br><span class="line">insert into sales values(2006,&apos;china&apos;,&apos;tnt2006&apos;,2012);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year;</span><br><span class="line"></span><br><span class="line">select year,sum(profit) from sales group by year with rollup;</span><br></pre></td></tr></table></figure><p>当你使用ROLLUP时, 你不能同时使用ORDER BY子句进行结果排序。换言之， ROLLUP和ORDER BY 是互相排斥的LIMIT 用在ROLLUP 后面。</p><h3 id="1-4-bit-group-functions做统计"><a href="#1-4-bit-group-functions做统计" class="headerlink" title="1.4 bit group functions做统计"></a>1.4 bit group functions做统计</h3><p>bit_count:用来计算二进制数中包含1的个数</p><p>bit_or:就是对两个二进制数进行或运算</p><p>bit_and:就是对两个二进制数进行并运算</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="通过show-status和应用特点了解各种SQL的执行频率。"><a href="#通过show-status和应用特点了解各种SQL的执行频率。" class="headerlink" title="通过show status和应用特点了解各种SQL的执行频率。"></a>通过show status和应用特点了解各种SQL的执行频率。</h3><p>首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)</p><p>show status</p><p>常用的:</p><p>show status like ‘uptime’ ; </p><p>show stauts like ‘com_select’  show status like ‘com_insert’ …类推 update  delete</p><p>show session或global status like …. 如果你不写session或global,默认是session 会话，指取出当前窗口的执行，如果你想看所有session,从mysql 启动到现在，则应该 global。</p><p>show status like ‘connections’; </p><p>//显示慢查询次数</p><p>show status like ‘slow_queries’;</p><p>以下几个参数对Myisam 和Innodb 存储引擎都计数：</p><ol><li><p>Com_select 执行select 操作的次数，一次查询只累加1；</p></li><li><p>Com_insert 执行insert 操作的次数，对于批量插入的insert 操作，只累加一次；</p></li><li><p>Com_update 执行update 操作的次数；</p></li><li><p>Com_delete 执行delete 操作的次数；</p></li></ol><p>以下几个参数是针对Innodb 存储引擎计数的，累加的算法也略有不同：</p><ol><li><p>Innodb_rows_read select 查询返回的行数；</p></li><li><p>Innodb_rows_inserted 执行Insert 操作插入的行数；</p></li><li><p>Innodb_rows_updated 执行update 操作更新的行数；</p></li><li><p>Innodb_rows_deleted 执行delete 操作删除的行数；</p></li></ol><p>对于事务型的应用，通过Com_commit 和Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。</p><p>此外，以下几个参数便于我们了解数据库的基本情况：</p><ol><li><p>Connections 试图连接Mysql 服务器的次数</p></li><li><p>Uptime 服务器工作时间</p></li><li><p>Slow_queries 慢查询的次数</p></li></ol><h3 id="定位执行效率较低的SQL"><a href="#定位执行效率较低的SQL" class="headerlink" title="定位执行效率较低的SQL"></a>定位执行效率较低的SQL</h3><p>可以通过以下两种方式定位执行效率较低的SQL 语句：</p><ol><li><p>可以通过慢查询日志定位那些执行效率较低的sql 语句，用–log-slowqueries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过long_query_time 秒的SQL语句的日志文件。可以链接到管理维护中的相关章节。</p></li><li><p>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist 命令查看当前MySQL 在进行的线程，包括线程的状态，是否锁表等等，可以实时的查看SQL 执行情况，同时对一些锁表操作进行优化。</p></li></ol><h3 id="通过explain分析低效SQL的执行计划"><a href="#通过explain分析低效SQL的执行计划" class="headerlink" title="通过explain分析低效SQL的执行计划"></a>通过explain分析低效SQL的执行计划</h3><h4 id="select-type：-select-类型"><a href="#select-type：-select-类型" class="headerlink" title="select_type： select 类型"></a>select_type： select 类型</h4><p>A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个</p><p>B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</p><p>C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union</p><p>D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响</p><p>E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</p><p>F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</p><p>G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</p><p>H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</p><h4 id="table：-输出结果集的表"><a href="#table：-输出结果集的表" class="headerlink" title="table： 输出结果集的表"></a>table： 输出结果集的表</h4><p>显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的<derived n="">就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的<union m,n="">，与<derived n="">类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</derived></union></derived></p><h4 id="type：-表示表的连接类型"><a href="#type：-表示表的连接类型" class="headerlink" title="type： 表示表的连接类型"></a>type： 表示表的连接类型</h4><p>当表中仅有一行是type的值为system是最佳的连接类型；</p><p>当select操作中使用索引进行表连接时type的值为ref；</p><p>当select的表连接没有使用索引时，经常会看到type的值为ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。</p><p>依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</p><p>A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p><p>B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</p><p>C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</p><p>D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</p><p>E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p><p>F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</p><p>G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</p><p>H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p><p>I：range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</p><p>J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</p><p>K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p><p>L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p><h4 id="possible-keys：-表示查询时-可以使用的索引列"><a href="#possible-keys：-表示查询时-可以使用的索引列" class="headerlink" title="possible_keys： 表示查询时,可以使用的索引列."></a>possible_keys： 表示查询时,可以使用的索引列.</h4><h4 id="key：-表示使用的索引"><a href="#key：-表示使用的索引" class="headerlink" title="key： 表示使用的索引"></a>key： 表示使用的索引</h4><h4 id="key-len：-索引长度"><a href="#key-len：-索引长度" class="headerlink" title="key_len： 索引长度"></a>key_len： 索引长度</h4><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p><h4 id="rows：-扫描范围"><a href="#rows：-扫描范围" class="headerlink" title="rows： 扫描范围"></a>rows： 扫描范围</h4><h4 id="Extra：-执行情况的说明和描述"><a href="#Extra：-执行情况的说明和描述" class="headerlink" title="Extra： 执行情况的说明和描述"></a>Extra： 执行情况的说明和描述</h4><p>A：distinct：在select部分使用了distinc关键字</p><p>B：no tables used：不带from字句的查询或者From dual查询</p><p>C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</p><p>D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</p><p>E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p><p>F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。</p><p>G：using sort_union，using_union，using intersect，using sort_intersection：</p><p>using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集</p><p>using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集</p><p>using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。</p><p>H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</p><p>I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition</p><p>J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个</p><p>K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p><p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息</p><h3 id="确定问题并采取响应的优化措施"><a href="#确定问题并采取响应的优化措施" class="headerlink" title="确定问题并采取响应的优化措施"></a>确定问题并采取响应的优化措施</h3><h3 id="索引的存储分类"><a href="#索引的存储分类" class="headerlink" title="索引的存储分类"></a>索引的存储分类</h3><p>myisam 表的数据文件和索引文件是自动分开的；innodb 的数据和索引是存储在<br>同一个表空间里面，但可以有多个文件组成。<br>创建索引语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</span><br><span class="line">[USING index_type]</span><br><span class="line">ON tbl_name (index_col_name,...)</span><br><span class="line">index_col_name:</span><br><span class="line">col_name [(length)] [ASC | DESC]</span><br></pre></td></tr></table></figure><p>索引的存储类型目前只有两种（btree 和hash），具体和表的模式相关：</p><p>myisam btree</p><p>innodb btree</p><p>memory/heap hash，btree</p><p>mysql 目前不支持函数索引，只能对列的前一部分（length）进行索引，例：</p><p><code>create index ind_test on table1(name(5))</code></p><p>对于char 和varchar 列，使用前缀索引将大大节省空间。</p><h3 id="MySQL如何使用索引"><a href="#MySQL如何使用索引" class="headerlink" title="MySQL如何使用索引"></a>MySQL如何使用索引</h3><p>索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高SELECT 操作性能的最佳途径。</p><p>查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。</p><p>下列情况下，Mysql 不会使用已有的索引：</p><p>1.如果mysql 估计使用索引比全表扫描更慢，则不使用索引。例如：如果key_part1均匀分布在1 和100 之间，下列查询中使用索引就不是很好：</p><p><code>SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90</code></p><p>2.如果使用heap 表并且where 条件中不用＝索引列，其他&gt; 、&lt;、&gt;=、&lt;=均不使用索引；</p><p>3.如果不是索引列的第一部分；</p><p>4.如果like 是以％开始；</p><p>5.对where 后边条件为字符串的一定要加引号，字符串如果为数字mysql 会自动转为字符串，但是不使用索引。</p><h3 id="查看索引的使用情况"><a href="#查看索引的使用情况" class="headerlink" title="查看索引的使用情况"></a>查看索引的使用情况</h3><p>如果索引正在工作，Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。</p><p>Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明表索引不正确或写入的查询没有利用索引。</p><p><code>show status like &#39;Handler_read%&#39;;</code></p><h3 id="定期分析表"><a href="#定期分析表" class="headerlink" title="定期分析表"></a>定期分析表</h3><h4 id="ANALYZE-TABLE"><a href="#ANALYZE-TABLE" class="headerlink" title="ANALYZE TABLE"></a>ANALYZE TABLE</h4><p>语法：</p><p><code>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM, BDB 和InnoDB 表有作用。对于MyISAM 表，本语句与使用myisamchk -a 相当。</p><h4 id="CHECK-TABLE"><a href="#CHECK-TABLE" class="headerlink" title="CHECK TABLE"></a>CHECK TABLE</h4><p>语法：</p><p><code>CHECK TABLE tbl_name [, tbl_name] ... [option] ...</code></p><p><code>option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}</code></p><p>检查一个或多个表是否有错误。CHECK TABLE 对MyISAM 和InnoDB 表有作用。对于MyISAM 表，关键字统计数据被更新。</p><p>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。</p><h4 id="CHECKSUM-TABLE"><a href="#CHECKSUM-TABLE" class="headerlink" title="CHECKSUM TABLE"></a>CHECKSUM TABLE</h4><p>语法：</p><p><code>CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]</code></p><p>报告一个表校验和。</p><h3 id="使用optimize-table"><a href="#使用optimize-table" class="headerlink" title="使用optimize table"></a>使用optimize table</h3><h4 id="OPTIMIZE-TABLE"><a href="#OPTIMIZE-TABLE" class="headerlink" title="OPTIMIZE TABLE"></a>OPTIMIZE TABLE</h4><p>语法：</p><p><code>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></p><p>如果已经删除了表的一大部分，或者如果您已经对含有可变长度行的表（含有VARCHAR, BLOB 或TEXT 列的表）进行了很多更改，则应使用OPTIMIZE TABLE。被删除的记录被保持在链接清单中，后续的INSERT 操作会重新使用旧的记录位置。您可以使用OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。</p><p>OPTIMIZE TABLE 只对MyISAM, BDB 和InnoDB 表起作用。</p><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><h4 id="对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。"><a href="#对于Myisam-类型的表，可以通过以下方式快速的导入大量的数据。" class="headerlink" title="对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。"></a>对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tblname DISABLE KEYS;</span><br><span class="line">loading the data</span><br><span class="line">ALTER TABLE tblname ENABLE KEYS;</span><br></pre></td></tr></table></figure><p>这两个命令用来打开或者关闭Myisam 表非唯一索引的更新。在导入大量的数据到一个非空的Myisam 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的Myisam 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。</p><h4 id="而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率："><a href="#而对于Innodb-类型的表，这种方式并不能提高导入数据的效率。对于Innodb-类型的表，我们有以下几种方式可以提高导入的效率：" class="headerlink" title="而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率："></a>而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率：</h4><p>a. 因为Innodb 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果Innodb 表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。</p><p>b. 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SETUNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p><p>c. 如果应用使用自动提交的方式，建议在导入前执行SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p><h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><p>如果你同时从同一客户插入很多行，使用多个值表的INSERT 语句。这比使用分开INSERT 语句快(在一些情况中几倍)。</p><p><code>Insert into test values(1,2),(1,3),(1,4)…</code></p><p>如果你从不同客户插入很多行，能通过使用INSERT DELAYED 语句得到更高的速度。Delayed 的含义是让insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘；这比每条语句分别插入要快的多；LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完后才进行插入。</p><p><code>Insert delayed into test values(1,2),(1,3),(1,4)…</code></p><p><code>Insert low_priority into test values(1,2),(1,3),(1,4)…</code></p><p>将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）。</p><p>如果进行批量插入，可以增加bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对myisam 表使用。</p><p>在my.cnf中添加如下语句，将insert语句的长度设为最大。</p><p><code>Max_allowed_packet=1M</code></p><p><code>Net_buffer_length=2k</code></p><p>当从一个文本文件装载一个表时，使用LOAD DATA INFILE。这通常比使用很多INSERT 语句快20 倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//数据</span><br><span class="line"></span><br><span class="line">1669,Jim,Smith</span><br><span class="line">337,Mary,Jones</span><br><span class="line">2005,Linda,Black</span><br><span class="line"></span><br><span class="line">示例语句：</span><br><span class="line"></span><br><span class="line">load data infile &quot;/data/mysql/e.sql&quot; into table tablename fields terminated by &apos;,&apos;;</span><br></pre></td></tr></table></figure><p>根据应用情况使用replace 语句代替insert。<code>replace low_priority into ta values(1,2);</code><br>replace具备替换拥有唯一索引或者主键索引重复数据的能力，也就是如果使用replaceinto插入的数据的唯一索引或者主键索引与之前的数据有重复的情况，将会删除原先的数据，然后再进行添加。</p><p>根据应用情况使用ignore 关键字忽略重复记录。<br><code>insert ignore into</code><br>当插入数据时，如出现错误时，如重复数据，将不返回错误，只以警告形式返回。所以使用ignore请确保语句本身没有问题，否则也会被忽略掉。例如：<code>INSERT IGNORE INTO books (name) VALUES (&#39;MySQL Manual&#39;)</code></p><h3 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h3><p>默认情况下，MySQL 排序所有GROUP BY col1，col2，….。查询的方法如同在查询中指定ORDER BY col1，col2，…。如果显式包括一个包含相同的列的ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。</p><p>如果查询包括GROUP BY 但你想要避免排序结果的消耗，你可以指定ORDER BY NULL禁止排序。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO foo</span><br><span class="line">SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;</span><br></pre></td></tr></table></figure><h3 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h3><p>在某些情况中，MySQL 可以使用一个索引来满足ORDER BY 子句，而不需要额外的排序。where 条件和order by 使用相同的索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或者都是降序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如：下列sql 可以使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1,key_part2,... ;</span><br><span class="line">SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2</span><br><span class="line">DESC;</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</span><br><span class="line">但是以下情况不使用索引：</span><br><span class="line">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;</span><br><span class="line">--order by 的字段混合ASC 和DESC</span><br><span class="line">SELECT * FROM t1 WHERE key2=constant ORDER BY key1;</span><br><span class="line">--用于查询行的关键字与ORDER BY 中所使用的不相同</span><br><span class="line">SELECT * FROM t1 ORDER BY key1, key2;</span><br><span class="line">--对不同的关键字使用ORDER BY。</span><br></pre></td></tr></table></figure><h3 id="优化join语句"><a href="#优化join语句" class="headerlink" title="优化join语句"></a>优化join语句</h3><p>Mysql4.1 开始支持SQL 的子查询。这个技术可以使用SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。</p><p>假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><p><code>SELECT * FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerIDFROM salesinfo)</code></p><p>如果使用连接(JOIN).. 来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID 建有索引的话，性能将会更好，查询如下：</p><p><code>SELECT * FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL</code></p><p>连接(JOIN).. 之所以更有效率一些，是因为MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h3 id="mysql如何优化or条件"><a href="#mysql如何优化or条件" class="headerlink" title="mysql如何优化or条件"></a>mysql如何优化or条件</h3><p>对于or 子句，如果要利用索引，则or 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。</p><h3 id="查询优先还是更新优先"><a href="#查询优先还是更新优先" class="headerlink" title="查询优先还是更新优先"></a>查询优先还是更新优先</h3><p>MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。</p><p>我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。</p><p>下面我们提到的改变调度策略的方法主要是针对Myisam 存储引擎的，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。</p><p>MySQL 的默认的调度策略可用总结如下：</p><ol><li><p>写入操作优先于读取操作。</p></li><li><p>对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。</p></li><li><p>对某张数据表的多个读取操作可以同时地进行。</p></li></ol><p>MySQL 提供了几个语句调节符，允许你修改它的调度策略：</p><ol><li><p>LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE。</p></li><li><p>HIGH_PRIORITY关键字应用于SELECT和INSERT语句。</p></li><li><p>DELAYED关键字应用于INSERT和REPLACE语句。</p></li></ol><p>如果写入操作是一个LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在LOW_PRIORITY 写入操作永远被阻塞的情况。</p><p>SELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的SELECT 在正常的SELECT 语句之前执行，因为这些语句会被写入操作阻塞。</p><p>如果你希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么请使用–low-priority-updates 选项来启动服务器。通过使用INSERT HIGH_PRIORITY 来把INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT 语句的影响。</p><h3 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h3><p><code>SELECT SQL_BUFFER_RESULTS ...</code></p><p>将强制MySQL 生成一个临时结果集。只要所有临时结果集生成后，所有表上的锁定均被释放。这能在遇到表锁定问题时或要花很长时间将结果传给客户端时有所帮助。</p><p>当处理一个会让客户端耗费点时间才能处理的大结果集时， 可以考虑使用SQL_BUFFER_RESULT 提示字。这样可以告诉MySQL 将结果集保存在一个临时表中，这样可以尽早的释放各种锁。</p><h4 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h4><p>在你查询语句中表名的后面，添加USE INDEX 来提供你希望MySQ 去参考的索引列表，就可以让MySQL 不再考虑其他可用的索引。</p><p><code>Eg:SELECT * FROM mytable USE INDEX (mod_time, name) ...</code></p><h4 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h4><p>如果你只是单纯的想让MySQL 忽略一个或者多个索引，可以使用IGNORE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytale IGNORE INDEX (priority) ...</code></p><h4 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h4><p>为强制MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。</p><p><code>Eg:SELECT * FROM mytable FORCE INDEX (mod_time) ...</code></p><h3 id="其他优化措施"><a href="#其他优化措施" class="headerlink" title="其他优化措施"></a>其他优化措施</h3><ol><li><p>使用持久的连接数据库以避免连接开销。</p></li><li><p>经常检查所有查询确实使用了必要的索引。</p></li><li><p>避免在频繁更新的表上执行复杂的SELECT 查询，以避免与锁定表有关的由于读、写冲突发生的问题。</p></li><li><p>对于没有删除的行操作的MyISAM 表，插入操作和查询操作可以并行进行，因为没有删除操作的表查询期间不会阻塞插入操作．对于确实需要执行删除操作的表，尽量在空闲时间进行批量删除操作，避免阻塞其他操作。</p></li><li><p>充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少MySQL 需要做的语法分析从而提高插入速度。</p></li><li><p>对经常访问的可以重构的数据使用内存表，可以显著提高访问的效率。</p></li><li><p>通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份期间对应用的影响，可以在复制服务器上执行备份操作。</p></li><li><p>表的字段尽量不使用自增长变量，在高并发情况下该字段的自增可能对效率有比较大的影响，推荐通过应用来实现字段的自增长。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM垃圾收集器</title>
      <link href="/jvm/2018-03-27-jvm-memory/"/>
      <url>/jvm/2018-03-27-jvm-memory/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JVM的自动内存管理机制"><a href="#1-JVM的自动内存管理机制" class="headerlink" title="1. JVM的自动内存管理机制"></a>1. JVM的自动内存管理机制</h2><h3 id="1-1-对象状态算法"><a href="#1-1-对象状态算法" class="headerlink" title="1.1 对象状态算法"></a>1.1 对象状态算法</h3><ul><li><p>引用计数算法： 很难解决对象之间相互引用的问题，内存泄露。</p></li><li><p>跟搜索算法：通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索的路径成为引用链，当一个对象到GC Root没有一个引用时，则证明此对象是不可用的。</p></li></ul><p>注：1. GC对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI。2. 跟搜索算法中，没有引用的对象并非非死不可，还有经历两次标记，第一次发现没有引用，则进行标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或finalize()已经被调用过，虚拟机将这两种情况都视为没有必要执行。</p><h3 id="1-2-回收方法区"><a href="#1-2-回收方法区" class="headerlink" title="1.2 回收方法区"></a>1.2 回收方法区</h3><p>方法区主要回收废弃变量和无用的类。无用的类：该类所有实例都已被回收，加载该类的ClassLoader被回收，该类对应的java.lang.Class对象没有在任何地方被引用。只有同时满足无用的类的三个条件，才<strong><em>可以</em></strong>被回收。反射、动态代理、CGLib等bytecode框架场景以及频繁定义ClassLoader的场景都需要具备卸载功能，以保证永久代不会溢出。</p><p>在JDK7中</p><pre><code>使用永久代（Permanent Generation）实现方法区，这样就可以不用专门实现方法区的内存管理，但这容易引起内存溢出问题；有规划放弃永久代而改用Native Memory来实现方法区；不再在Java堆的永久代中生成中分配字符串常量池，而是在Java堆其他的主要部分（年轻代和老年代）中分配；更多请参考：docs.oracle.com/javase/8/do…</code></pre><p>2、在JDK8中</p><pre><code>永久代已被删除，类元数据（Class Metadata）存储空间在本地内存中分配，并用显式管理元数据的空间： 从OS请求空间，然后分成块； 类加载器从它的块中分配元数据的空间（一个块被绑定到一个特定的类加载器）； 当为类加载器卸载类时，它的块被回收再使用或返回到操作系统； 元数据使用由mmap分配的空间，而不是由malloc分配的空间；</code></pre><h3 id="1-3-垃圾收集算法"><a href="#1-3-垃圾收集算法" class="headerlink" title="1.3 垃圾收集算法"></a>1.3 垃圾收集算法</h3><ul><li><p>标记清除算法： 标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。效率问题，空间问题（内存碎片）。</p></li><li><p>复制算法： 新生代使用复制算法回收，由于新生代98%的对象都是朝生夕死的，所以不需要1:1的比例划分内存空间（Hotspot默认8:1），而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一个Survivor。当回收时，将Eden和Survivor中还存活的对象一次性的拷贝到另一块的Survivor上。最后清理掉Eden和刚才使用过的Survivor。当Survivor空间不够用时，需要依赖其他的老年代进行分配担保（Handle Promotion）。分配担保：如果Survivor空间没有足够的空间存放上次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p></li><li><p>标记-整理算法：让所有存活的对象向一端移动，然后清理掉端边界以外的内存。老年代常用的算法。</p></li><li><p>分代收集算法： 根据对象的存活周期不同，将内存划分为几块，根据各个年代的特点进行垃圾回收。</p></li></ul><h3 id="1-4-垃圾收集器"><a href="#1-4-垃圾收集器" class="headerlink" title="1.4 垃圾收集器"></a>1.4 垃圾收集器</h3><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/files/gc.jpg?raw=true" alt="垃圾回收器"><br><a href="#垃圾收集器">图片来自《深入理解Java虚拟机》</a><br>如果两个收集器之间存在连线，就说明他们可以搭配使用。</p><ol><li><p>Serial</p><p> 复制算法，新生代的单线程收集器，简单高效，stop the world。</p></li><li><p>ParNew</p><p> 复制算法，Serial的多线程版本，stop the world。首选的新生代收集器。</p></li><li><p>Parallel Scavenge</p><p> 新生代收集器，使用复制算法，多线程并行, stop the world。目标达到可控制的吞吐量。运行用户代码时间/CPU消耗总时常=吞吐量。该收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMills参数及直接设置吞吐量大小的-XX:GCTimeRatio参数。MaxGCPauseMills参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。GCTimeRatio参数的值应该是一个大于0的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。除了这两个参数，还有一个-XX:+UseAdaptiveSizePolicy值得关注。打开这个参数后，不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大吞吐量这种方式称为GC自适应的调节策略（GC Ergonomics）</p></li><li><p>Serial Old</p><p> Serial收集器的老年代版本，单线程收集器，使用标记-整理算法，stop the world。主要有两个用途：1. 在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候用。</p></li><li><p>Parallel Old</p><p> Parallel Scavenge的老年代版本，标记-整理算法，stop the world。</p></li><li><p>CMS（Concurrent Mark Sweep）收集器</p></li></ol><p>最短回收停顿时间为目标的收集器，重视服务响应速度，标记-清除算法实现。第一款并发收集器，可与用户线程并发执行。执行过程分为4个步骤：初始标记(CMS initial mark)、并发标记(CMS concurrent mark)、重新标记(CMS remark)、并发清除(CMS concurrent sweep)。初始和重新stop the world。初始标记只是标记GCRoots能直接关联的对象，速度很快，并发标记进行GCROOTs Tracing的过程。重新标记为了修复并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。<br>优点：并发收集、低停顿。<br>缺点：1. 对CPU资源非常敏感，解决方案，减少GC线程的独占时间。2. 无法处理浮动垃圾。CMS运行期间，用户线程产生的垃圾为浮动垃圾，CMS无法在本次收集中个清理这些浮动垃圾。如果CMS运行期间，内存无法满足用户线程要求，就会出现Concurrent Mode Failure失败，可能导致另一个FullGC产生，启动预备方案 Serial Old。3. 产生大量的空间碎片。</p><ol start="7"><li><p>G1收集器</p><p> 标记整理算法实现，精确的控制停顿，指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。G1将整个Java堆（老年代，新生代）划分多个大小固定的独立区域（Region），并且追踪这些区域里面的垃圾堆积程度。在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ol><h3 id="1-5-内存分配与回收"><a href="#1-5-内存分配与回收" class="headerlink" title="1.5 内存分配与回收"></a>1.5 内存分配与回收</h3><p>对象在Eden中分配内存，没有足够的空间进行垃圾回收。MinorGC。</p><pre><code>MinorGC: 新生代垃圾回收的动作，频繁且速度快。MajorGC（FullGC）: 指发生在老年代的GC，慢，清理新生代和老年代，CMS</code></pre><p>大对象指需要大量连续空间的Java对象。典型就是很长的字符串和数组。直接进入老年代分配，避免在Eden及Survivor中大量复制拷贝。</p><p>长期生活的对象进入老年代。对象年龄计数器，每一次MinorGC增长1岁。默认15岁进入老年代。</p><p>动态对象年龄判断，如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄段的对象直接进入老年代。</p><p>空间担保分配，每次MinorGC,检测升级到老年代的大小是否大于老年代的空间，如果大于，则进行FullGC。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a><br><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a><br><a href="https://www.jianshu.com/p/aef0f4765098" target="_blank" rel="noopener">G1垃圾回收器详解  </a><br><a href="https://cloud.tencent.com/developer/article/1459638" target="_blank" rel="noopener">详解 JVM Garbage First(G1) 垃圾收集器</a><br><a href="">Charlie H, Monica B, Poonam P, Bengt R. Java Performance Companion</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/enhancements-7.html" target="_blank" rel="noopener">Java Virtual Machine Enhancements in JDK 7</a><br><a href="https://blog.csdn.net/tjiyu/article/details/53915869" target="_blank" rel="noopener">Java内存管理：Java内存区域 JVM运行时数据区</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机运行时数据区域</title>
      <link href="/jvm/2018-03-27-jvm-runtime-data-area/"/>
      <url>/jvm/2018-03-27-jvm-runtime-data-area/</url>
      
        <content type="html"><![CDATA[<h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1 运行时数据区域"></a>1 运行时数据区域</h2><p><img src="/media/article/jvm-1.7-later.png" alt="jvm 1.7"></p><h3 id="1-1-程序计数器（Program-Counter-Register）"><a href="#1-1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.1 程序计数器（Program Counter Register）"></a>1.1 程序计数器（Program Counter Register）</h3><ul><li>线程私有的。</li><li>当前线程所执行字节码的行号指示器，字节码解释器的作用是通过改变计数器的值来选取下一条需要执行的字节码指令。</li><li>如果执行的方法不是native的，计数器包含当前正在执行的Java虚拟机指令的地址。</li><li>如果当前执行的是native方法，则这个计数器为<code>undefined</code>。</li><li>Java虚拟机中<strong><em>唯一</em></strong>没有OOM的区域。</li></ul><h3 id="1-2-Java虚拟机栈-（Java-Virtual-Machine-Stacks）"><a href="#1-2-Java虚拟机栈-（Java-Virtual-Machine-Stacks）" class="headerlink" title="1.2 Java虚拟机栈 （Java Virtual Machine Stacks）"></a>1.2 Java虚拟机栈 （Java Virtual Machine Stacks）</h3><ul><li>线程私有的。</li><li>虚拟机栈描述的是Java方法执行的内存模型，生命周期与线程相同。</li><li><strong><em>每个方法运行都会创建一个栈帧</em></strong>，存储局部变量表(Local Variable Table)，局部结果集等信息。</li><li><strong><em>在编译期分配</em></strong>局部变量表存放各种基本数据类型、对象引用类型和returnAddress(指向一条字节码指令的地址)。</li><li>如果请求的栈深度大于最大可用栈深度时，系统就会抛出StackOverflowError错误。</li><li>如果虚拟机动态扩展无法申请到足够的的内存时会抛出OOM异常。大部分虚拟机都可以动态扩展，当然也允许固定长度虚拟机栈。</li></ul><blockquote><p>returnAddress类型的值是指向Java虚拟机指令的操作码的指针。与数字基本类型不同，returnAddress类型不对应任何Java编程语言类型，并且不能由正在运行的程序修改。</p></blockquote><h3 id="1-3-本地方法栈（Native-Method-Stack）"><a href="#1-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="1.3 本地方法栈（Native Method Stack）"></a>1.3 本地方法栈（Native Method Stack）</h3><ul><li>线程私有的。</li><li>虚拟机栈为执行Java方法服务，本地方法栈为Native方法服务。</li><li>会出现OOM或者StackOverflowError，原因和虚拟机栈类似。</li></ul><h3 id="1-4-Java堆（Heap）"><a href="#1-4-Java堆（Heap）" class="headerlink" title="1.4 Java堆（Heap）"></a>1.4 Java堆（Heap）</h3><ul><li>虚拟机启动时创建被所有线程共享的内存区域，为了存储所有对象实例和数组。垃圾回收的主要区域。</li></ul><h3 id="1-5-方法区（Method-Area）"><a href="#1-5-方法区（Method-Area）" class="headerlink" title="1.5 方法区（Method Area）"></a>1.5 方法区（Method Area）</h3><ul><li>别名：“永久代“、”非堆，各个线程共享的内存区域，<strong><em>存储虚拟机已加载的类信息，静态变量、常量、即时编译器编译后的代码数据</em></strong>。默认最小为16MB，最大为64MB，可以通过-XX:PermSize和-XX:MaxPermSize 参数限制方法区大小。</li><li>Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做元空间。</li></ul><h3 id="1-6-运行时常量池（Runtime-Constant-Pool）"><a href="#1-6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="1.6 运行时常量池（Runtime Constant Pool）"></a>1.6 运行时常量池（Runtime Constant Pool）</h3><ul><li>运行时常量池：jdk1.6及之前是方法区的一部分，其中的主要内容来自于JVM对Class的加载。Java7中已经将运行时常量池从方法区（永久代）移除，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。</li><li><strong><em>类加载后</em></strong>存储编译器生成的常量（各种字面量和符号引用）。符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：<a href="https://blog.csdn.net/zhangjg_blog/article/details/21487287" target="_blank" rel="noopener">类和接口的全限定名、字段名称和描述符、方法名称和描述符</a>。</li><li>由于运行时常量池从方法区移动到堆，所以jdk1.6和jdk1.7及之后的版本对于常量池的使用还是有些区别的，<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern</a></li><li>运行时常量池是类文件中constant_pool表的每类或每接口运行时表示。它包含几种常量，从编译时已知的数字值到必须在运行时解析的方法和字段引用。运行时常量池提供类似于传统编程语言的符号表的功能，尽管它包含比典型符号表更宽范围的数据。</li></ul><h3 id="1-7-直接内存-Direct-Memory"><a href="#1-7-直接内存-Direct-Memory" class="headerlink" title="1.7 直接内存(Direct Memory)"></a>1.7 直接内存(Direct Memory)</h3><ul><li>堆外内存，JVM虚拟机各个区域内存总和大于机器物理内存可能会导致OOM。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a><br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.1" target="_blank" rel="noopener">Chapter 2. The Structure of the Java Virtual Machine</a><br><a href="https://www.jianshu.com/p/cf78e68e3a99" target="_blank" rel="noopener">JVM常量池浅析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据存储-Spring事务</title>
      <link href="/spring/2018-03-17-spring-transaction/"/>
      <url>/spring/2018-03-17-spring-transaction/</url>
      
        <content type="html"><![CDATA[<h2 id="事务传播特性"><a href="#事务传播特性" class="headerlink" title="事务传播特性"></a>事务传播特性</h2><p>待续…</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>待续…</p><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><p>事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。  </p><p>在 Spring 中通常可以通过以下三种方式来实现对事务的管理： </p><ol><li>使用 Spring 的事务代理工厂管理事务</li></ol><ol start="2"><li><p>使用 Spring 的事务注解管理事务<br> a) DataSourceManager<br> b) HibernateManager</p></li><li><p>使用 AspectJ 的 AOP 配置管理事务 </p></li></ol><p>Spring 的事务管理，主要用到两个事务相关的接口。</p><p> <img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/transaction.jpg?raw=true" alt="Spring事务接口"></p><h2 id="事务管理器接口"><a href="#事务管理器接口" class="headerlink" title="事务管理器接口"></a>事务管理器接口</h2><p>事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Public interface PlatformTransactionManager()...&#123;  </span><br><span class="line">// 由TransactionDefinition得到TransactionStatus对象</span><br><span class="line">TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; </span><br><span class="line">// 提交</span><br><span class="line">Void commit(TransactionStatus status) throws TransactionException;  </span><br><span class="line">// 回滚</span><br><span class="line">Void rollback(TransactionStatus status) throws TransactionException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A) 常用的两个实现类，PlatformTransactionManager 接口有两个常用的实现类：  　　　　　　　　　　</p><ul><li>DataSourceTransactionManager：使用 JDBC 或 iBatis  进行持久化数据时使用。  </li></ul><p>如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p><p>　　</p><ul><li>HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。 </li></ul><p>如果应用程序的持久化是通过Hibernate实现的，那么你需要使用HibernateTransactionManager。对于Hibernate3，需要在Spring上下文定义中添加如下的<bean>声明：</bean></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p><p>B) PlatformTransactionManager其他实现类</p><p>Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA(事务)、JPA(持久化)。下面分别介绍各个平台框架实现事务管理的机制。</p><ul><li>Java持久化API事务（JPA）</li></ul><p>Hibernate多年来一直是事实上的Java持久化标准，但是现在Java持久化API作为真正的Java持久化标准进入大家的视野。如果你计划使用JPA的话，那你需要使用Spring的JpaTransactionManager来处理事务。你需要在Spring中这样配置JpaTransactionManager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>JpaTransactionManager只需要装配一个JPA实体管理工厂（javax.persistence.EntityManagerFactory接口的任意实现）。JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务。</p><ul><li>Java原生API事务(JTA)</li></ul><p>如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;transactionManagerName&quot; value=&quot;java:/TransactionManager&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象，其中事务成功完成通过UserTransaction.commit()方法提交，事务失败通过UserTransaction.rollback()方法回滚。</p><p>C) Spring 的回滚方式 　　</p><ul><li>Spring 事务的默认回滚方式是：发生运行时异常时回滚，发生受查异常时提交。不过，对于受查异常，程序员也可以手工设置其回滚方式。</li></ul><h2 id="事务定义接口"><a href="#事务定义接口" class="headerlink" title="事务定义接口"></a>事务定义接口</h2><p>事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限，及对它们的操作。</p><p>A) 定义了五个事务隔离级别常量,这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX： 　　　　　　　　 </p><ul><li>DEFAULT：采用DB默认的事务隔离级别。MySql的默认为REPEATABLE_READ；  Oracle默认为 READ_COMMITTED。 　　</li><li>READ_UNCOMMITTED：读未提交。未解决任何并发问题。 　　</li><li>READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。  　　</li><li>REPEATABLE_READ：可重复读。解决脏读、不可重复读，存在幻读  　　</li><li>SERIALIZABLE：串行化。不存在并发问题。</li></ul><p>B) 定义了七个事务传播行为常量，所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如，A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。事务传播行为常量都是以 PROPAGATION_  开头，形如 PROPAGATION_XXX。  　　</p><ul><li>REQUIRED：指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是Spring 默认的事务传播行为。如该传播行为加在 doOther()方法上。若 doSome()方法在执行时就是在事务内的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法没有在事务内执行，则 doOther()方法会创建一个事务，并在其中执行。　　</li><li><p>SUPPORTS：指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。 </p></li><li><p>MANDATORY：指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。</p></li><li><p>REQUIRES_NEW：总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。</p></li><li><p>NOT_SUPPORTED：指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。</p></li><li><p>NEVER：指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。</p></li><li><p>NESTED：指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。嵌套事务在外部事务提交后，才真正的提交。</p></li></ul><p>C) 定义了默认事务超时时限 </p><ul><li><p>常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。 </p></li><li><p>注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。</p></li></ul><h2 id="Spring-的事务代理工厂管理事务"><a href="#Spring-的事务代理工厂管理事务" class="headerlink" title="Spring 的事务代理工厂管理事务"></a>Spring 的事务代理工厂管理事务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册数据源：C3P0数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册JDBC属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册Dao --&gt;</span><br><span class="line">    &lt;bean id=&quot;accountDao&quot; class=&quot;com.tongji.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;stockDao&quot; class=&quot;com.tongji.dao.StockDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册Service --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockService&quot; class=&quot;com.tongji.service.StockProcessServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;stockDao&quot; ref=&quot;stockDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;!-- 注册事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 生成事务代理 --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockServiceProxy&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;transactionManager&quot; ref=&quot;myTxManager&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot; ref=&quot;stockService&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;transactionAttributes&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;open*&quot;&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;buyStock&quot;&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED,-StockException&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="Spring-的事务注解管理事务"><a href="#Spring-的事务注解管理事务" class="headerlink" title="Spring 的事务注解管理事务"></a>Spring 的事务注解管理事务</h2><p>注：需要注意的是，@Transactional 若用在方法上，只能用于 public 方法上。对于其他非public 方法，如果加上了注解@Transactional，虽然 Spring 不会报错，但不会将指定事务织入到该方法中。因为 Spring 会忽略掉所有非 public 方法上的@Transaction 注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; </span><br><span class="line">        xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx </span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop </span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册数据源：C3P0数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册JDBC属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册Dao --&gt;</span><br><span class="line">    &lt;bean id=&quot;accountDao&quot; class=&quot;com.tongji.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;stockDao&quot; class=&quot;com.tongji.dao.StockDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册Service --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockService&quot; class=&quot;com.tongji.service.StockProcessServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;stockDao&quot; ref=&quot;stockDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;!-- 注册事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 开启注解驱动 --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;myTxManager&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED)</span><br><span class="line">public void openAccount(String aname, double money) &#123;</span><br><span class="line">    accountDao.insertAccount(aname, money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED)</span><br><span class="line">public void openStock(String sname, int amount) &#123;</span><br><span class="line">    stockDao.insertStock(sname, amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED, rollbackFor=StockException.class)</span><br><span class="line">public void buyStock(String aname, double money, String sname, int amount) throws StockException &#123;</span><br><span class="line">    boolean isBuy = true;</span><br><span class="line">    accountDao.updateAccount(aname, money, isBuy);</span><br><span class="line">    if (true) &#123;</span><br><span class="line">        throw new StockException(&quot;购买股票异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    stockDao.updateStock(sname, amount, isBuy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-使用AspectJ的AOP配置管理事务"><a href="#Spring-使用AspectJ的AOP配置管理事务" class="headerlink" title="Spring 使用AspectJ的AOP配置管理事务"></a>Spring 使用AspectJ的AOP配置管理事务</h2><p><img src="https://github.com/zhongyp/jekyll.github.io/blob/master/styles/images/article/aop-3.jpg?raw=true" alt="aop3"></p><p>AOP术语：</p><ul><li><p>连接点（joinpoint）你可以切入的方法（注意是可以）。</p></li><li><p>切点（pointcut）是你切入的方法。</p></li><li><p>增强（advice）往切点里面增加其他特殊的东西，比如事务传播。</p></li><li><p>目标对象（target）引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p></li><li><p>引介（introduction）允许我们向现有的类添加新方法属性。</p></li><li><p>织入（weaving） 把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。</p></li><li><p>代理（proxy）实现整套aop机制的，都是通过代理。</p></li><li><p>切面（aspect）切面是通知和切入点的结合,就是定义了通知的类。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; </span><br><span class="line">        xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx </span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop </span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册数据源：C3P0数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册JDBC属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 注册Dao --&gt;</span><br><span class="line">    &lt;bean id=&quot;accountDao&quot; class=&quot;com.tongji.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;stockDao&quot; class=&quot;com.tongji.dao.StockDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册Service --&gt;</span><br><span class="line">    &lt;bean id=&quot;stockService&quot; class=&quot;com.tongji.service.StockProcessServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;stockDao&quot; ref=&quot;stockDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;    </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;!-- 注册事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- 注册事务通知 --&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;myTxManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!-- 指定在切入点方法上应用的事务属性 --&gt;</span><br><span class="line">            &lt;tx:method name=&quot;open*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;buyStock&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;StockException&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- AOP配置 --&gt;</span><br><span class="line">    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;//表示使用CGLib动态代理技术织入增强。设置为false时，表示使用jdk动态代理织入增强，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br><span class="line">        &lt;!-- 指定切入点 --&gt;</span><br><span class="line">        &lt;aop:pointcut expression=&quot;execution(* *..service.*.*(..))&quot; id=&quot;stockPointCut&quot;/&gt;//这里设置切入点，expression设置切面植入的切入点的方法地址</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;stockPointCut&quot;/&gt;// 加入事务传播特性</span><br><span class="line">        &lt;aop:aspect ref=&quot;stockService&quot;&gt;//定义一个切面</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/qjjazry/p/6366204.html" target="_blank" rel="noopener">Spring4笔记9–Spring的事务管理（AOP应用的例子）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程简介</title>
      <link href="/concurrency/2017-03-16-thread-brief/"/>
      <url>/concurrency/2017-03-16-thread-brief/</url>
      
        <content type="html"><![CDATA[<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h3><p>现代操作系统在运行程序时，会为其创建一个进程。比如你现在用的浏览器，系统就会为其创建一个甚至多个进程。<strong><em>引入进程的目的是为了更好的使操作系统并发执行程序。来提高资源利用率和系统吞吐量，增加并发程度。</em></strong><br>线程是现代操作系统调度的基本单元，是运行在进程上下文中的逻辑流，是程序执行流的最小单元，也叫轻量级进程（Light Weight Process），也可以称之为CPU的执行单元。一个程序作为一个进程来运行，程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行一个处理器核心上。<strong><em>引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。线程不拥有系统资源（代码，数据、堆、共享库、文件），只拥有运行中必不可少的资源（线程ID, 栈，栈指针，程序计数器、通用目的寄存器和条件码）。</em></strong><br>线程是调度的抽象。<strong><em>Java中将线程的执行和执行对象抽象开来，JDK包中执行的有Thread类，Executor框架，可执行目标有Runaable，Callable。</em></strong></p><h4 id="1-1-线程的优点"><a href="#1-1-线程的优点" class="headerlink" title="1.1 线程的优点"></a>1.1 线程的优点</h4><ol><li>多处理器使用： 提高资源利用率和系统吞吐量。</li></ol><h4 id="1-2-线程的风险"><a href="#1-2-线程的风险" class="headerlink" title="1.2 线程的风险"></a>1.2 线程的风险</h4><ol><li>安全风险：对于共享变量的访问、操作容易造成安全风险。</li><li>活跃度风险：死锁引发活动度失败。</li><li>性能风险：线程之间频繁调度导致上下文切换导致巨大的系统开销。</li></ol><h3 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2. 线程的状态"></a>2. 线程的状态</h3><p><img src="/media/article/ThreadStatus.png" alt="ThreadStatus"><br><a href="#线程简介">图片来自：Java并发编程的艺术-</a></p><ul><li>新建(NEW)：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（READY）。</li></ul><p><strong><em>注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</em></strong></p><ul><li><p>运行状态(RUNNABLE)：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行中”。</p></li><li><p>就绪(READY)：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。</p></li><li><p>运行(RUNNING)：处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>等待状态(WAITING)：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程作出一些特定动作（通知或中断）。</p></li><li><p>超时等待状态(TIME_WAITING)：该状态不同于WAITING，它是可以在指定的时间自行返回的。</p></li><li><p>阻塞(BLOCKED)：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a>关于BLOCKED的描述：Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.翻译：阻塞线程是等待获取同步监视器锁的线程。线程等待获取同步监视器锁进入同步代码块/方法,或者调用Object.wait方法后,被唤醒后等待获取同步监视器锁,<strong><em>重入</em></strong>同步代码块/方法。</p></li><li><p>死亡(DEAD)：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ul><h3 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3. 线程优先级"></a>3. 线程优先级</h3><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。</p><p><strong><em>注：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</em></strong></p><h3 id="4-Daemon线程"><a href="#4-Daemon线程" class="headerlink" title="4. Daemon线程"></a>4. Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用做程序中后台调度及支持性工作。<br><strong><em> 注意：构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</em></strong></p><p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</span><br><span class="line">• Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">    * 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line">    * 该方法必须在启动线程前调用。</span><br><span class="line">    * 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。</span><br><span class="line">    * 这可能抛出 SecurityException（在当前线程中）。   </span><br><span class="line">    *   参数：</span><br><span class="line">    *      on - 如果为 true，则将该线程标记为守护线程。    </span><br><span class="line">    *   抛出：    </span><br><span class="line">    *     IllegalThreadStateException - 如果该线程处于活动状态。    </span><br><span class="line">    *     SecurityException - 如果当前线程无法修改该线程。</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">public final void setDaemon(boolean on)</span><br></pre></td></tr></table></figure><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p><a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">Java多线程详解</a><br><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程艺术</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">javase7 docs</a><br><a href="https://my.oschina.net/u/2500836/blog/1538667" target="_blank" rel="noopener">Java线程（1）-读Thread类源码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap（1.8版本）</title>
      <link href="/java/2018-03-30-hashmap/"/>
      <url>/java/2018-03-30-hashmap/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap的存储结构"><a href="#HashMap的存储结构" class="headerlink" title="HashMap的存储结构"></a>HashMap的存储结构</h2><p>HashMap存储默认初始化一个16大小的Node数组，如果存在冲突，则在以链表的方式存储，如果链表长度达到临界值，则使用红黑树存储。如下：</p><p><img src="/media/article/hashmap.png" alt="hashmap结构"></p><h2 id="HashMap-扩容"><a href="#HashMap-扩容" class="headerlink" title="HashMap 扩容"></a>HashMap 扩容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">   // 如果为空则重新创建一个Node数组，数组即HashMap</span><br><span class="line">   if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">       n = (tab = resize()).length;</span><br><span class="line">   // 如果hash值对应的Node数组中的Node为空，则直接将key，value放入Node </span><br><span class="line">   if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">       tab[i] = newNode(hash, key, value, null);</span><br><span class="line">   else &#123;</span><br><span class="line">       Node&lt;K,V&gt; e; K k;</span><br><span class="line">       // 判断下key是否相同，如果相同获取此Node</span><br><span class="line">       if (p.hash == hash &amp;&amp;</span><br><span class="line">           ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">           e = p;</span><br><span class="line">       // 如果key不相同，判断下Node数组中的对应Node是否是树结构，树结构直接新增树节点</span><br><span class="line">       else if (p instanceof TreeNode)</span><br><span class="line">           e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">       else &#123;</span><br><span class="line">           // 遍历Node数组对应位置Node的链表，将新增一个节点放入链表末尾。</span><br><span class="line">           for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">               if ((e = p.next) == null) &#123;</span><br><span class="line">                   p.next = newNode(hash, key, value, null);</span><br><span class="line">                   // 如果增加后链表到达临界值，则转为树结构。</span><br><span class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                       treeifyBin(tab, hash);</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               // 如果链表中存在相同的key，则获取此节点，返回Node</span><br><span class="line">               if (e.hash == hash &amp;&amp;</span><br><span class="line">                   ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                   break;</span><br><span class="line">               p = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 如果存在key相同的Node，则获取旧值，</span><br><span class="line">       if (e != null) &#123; // existing mapping for key</span><br><span class="line">           V oldValue = e.value;</span><br><span class="line">           // 只有允许修改标识为true或者旧值为null时可以替换旧值</span><br><span class="line">           if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">               e.value = value;</span><br><span class="line">           // 移动node至尾部</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">           return oldValue;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ++modCount;</span><br><span class="line">   // 超过了阀值，重新扩展HashMap Node数组的大小</span><br><span class="line">   if (++size &gt; threshold)</span><br><span class="line">       resize();</span><br><span class="line">   afterNodeInsertion(evict);</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">   // 未扩展前 HashMap Node数组大小（容量）</span><br><span class="line">   int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">   // 旧阀值</span><br><span class="line">   int oldThr = threshold;</span><br><span class="line">   int newCap, newThr = 0;</span><br><span class="line">   // 如果未扩展前 HashMap Node数组大小大于0且大小大于等于最大容量值，则调整阀值到整数上线，然后返回旧Node数组，即HashMap，否则将旧阀值扩大一倍。</span><br><span class="line">   if (oldCap &gt; 0) &#123;</span><br><span class="line">       if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return oldTab;</span><br><span class="line">       &#125;</span><br><span class="line">       else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">   &#125;</span><br><span class="line">   // 旧容量为0，且旧阀值大于0，则将新容量设置为旧阀值</span><br><span class="line">   else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">       newCap = oldThr;</span><br><span class="line">   // 如果旧阀值且旧容量为0，则使用默认的容量大小和阀值因子</span><br><span class="line">   else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">       newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line">   // 新阀值如果为0，则使用新的容量和阀值因子计算。</span><br><span class="line">   if (newThr == 0) &#123;</span><br><span class="line">       float ft = (float)newCap * loadFactor;</span><br><span class="line">       newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                 (int)ft : Integer.MAX_VALUE);</span><br><span class="line">   &#125;</span><br><span class="line">   threshold = newThr;</span><br><span class="line">   @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">   table = newTab;</span><br><span class="line">   if (oldTab != null) &#123;</span><br><span class="line">       // 遍历旧Node数组</span><br><span class="line">       for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">           Node&lt;K,V&gt; e;</span><br><span class="line">           if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">               oldTab[j] = null;</span><br><span class="line">               if (e.next == null)</span><br><span class="line">                   newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">               else if (e instanceof TreeNode)</span><br><span class="line">                   ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">               else &#123; // preserve order</span><br><span class="line">                   Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                   Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                   Node&lt;K,V&gt; next;</span><br><span class="line">                   do &#123;</span><br><span class="line">                       //遍历旧的链表</span><br><span class="line">                       next = e.next;</span><br><span class="line">                       // 这里的意思说，例如原来容量为16，现在扩展到32</span><br><span class="line">                       // 容量为16时，使用15&amp;hash获取key在Node数组中的位置，即1111&amp;hash</span><br><span class="line">                       // 容量为32时，使用31&amp;hash获取key在Node数组中的位置，即11111&amp;hash</span><br><span class="line">                       // 看出来区别没有，如果hash值得第5位不为1，则位置不变，否则的话，位置为 16+原来的位置。</span><br><span class="line">                       if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                           if (loTail == null)</span><br><span class="line">                               loHead = e;</span><br><span class="line">                           else</span><br><span class="line">                               loTail.next = e;</span><br><span class="line">                           loTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                       else &#123;</span><br><span class="line">                           if (hiTail == null)</span><br><span class="line">                               hiHead = e;</span><br><span class="line">                           else</span><br><span class="line">                               hiTail.next = e;</span><br><span class="line">                           hiTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; while ((e = next) != null);</span><br><span class="line">                   if (loTail != null) &#123;</span><br><span class="line">                       loTail.next = null;</span><br><span class="line">                       newTab[j] = loHead;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (hiTail != null) &#123;</span><br><span class="line">                       hiTail.next = null;</span><br><span class="line">                       newTab[j + oldCap] = hiHead;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>HashMap并发下死循环问题？</li></ol><p>该问题在JDK1.8中已经修复了。不过还是不推荐并发情况下使用，容易造成数据丢失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ArrayList</title>
      <link href="/java/2018-01-11-arraylist/"/>
      <url>/java/2018-01-11-arraylist/</url>
      
        <content type="html"><![CDATA[<h2 id="1-接口实现"><a href="#1-接口实现" class="headerlink" title="1. 接口实现"></a>1. 接口实现</h2><p><img src="/media/article/collection-arraylist.png" alt="arraylist"></p><p>ArrayList继承AbstractList类，实现List，RandomAccess，Cloneable，Serializable接口。AbstractList提供 List 接口的骨干实现，从而最大限度地减少了实现由“随机访问”数据存储（如数组）支持的接口所需的工作。对于连续的访问数据（如链表），应优先使用AbstractSequentialList，而非此类。<br>AbstractCollection是集合类的抽象类，主要提供集合层面的一些操作。<br>RandomAccess是随机访问的接口标志，如果继承RandomAccess则说明当前类是支持随机访问的。</p><h2 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h2><p>ArrayList默认构造方式有三种:</p><p>第一种: 给定初始化大小；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">   if (initialCapacity &gt; 0) &#123;</span><br><span class="line">       this.elementData = new Object[initialCapacity];</span><br><span class="line">   &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">       this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                          initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种: 默认初始化大小，默认初始化为10；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">   this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三种: 集合大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   elementData = c.toArray();</span><br><span class="line">   if ((size = elementData.length) != 0) &#123;</span><br><span class="line">       // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">       if (elementData.getClass() != Object[].class)</span><br><span class="line">           elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       // replace with empty array.</span><br><span class="line">       this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们看下add方法的扩容流程:</p><p><strong>注意：为了方便看源码，我会将一些方法的源码组合到add方法中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    // 首先判断是否是默认初始化大小，如果是，比较默认的数组大小和当前数组大小size+1，相比，取较大的那个</span><br><span class="line">   int minCapacity = size + 1;</span><br><span class="line">   if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">       minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   // 记录数组的修改次数（这个参数可以在常见变量解释小结中说明）</span><br><span class="line">   modCount++;</span><br><span class="line">   // overflow-conscious code</span><br><span class="line">   // 判断当前的minCapacity是否大于当前数组的容量，进行扩容操作</span><br><span class="line">   if (minCapacity - elementData.length &gt; 0)&#123;</span><br><span class="line">       // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        // 新的数组大小为oldCapacity+1/2 * oldCapacity</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        // 判断下新数组大小是否小于minCapacity</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        // 判断新的数组大小是否大于Integer.MAX - 8</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)&#123;</span><br><span class="line">            if (minCapacity &lt; 0) // overflow</span><br><span class="line">                throw new OutOfMemoryError();</span><br><span class="line">            // 如果新容量大于Integer.MAX - 8，则新容量为Integer.MAX</span><br><span class="line">            newCapacity = (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;   </span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   elementData[size++] = e;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList所有方法涉及扩容的原理都差不多，可以参考上述的代码注释了解。</p><h2 id="3-参数"><a href="#3-参数" class="headerlink" title="3. 参数"></a>3. 参数</h2><p>modCount: modCount是一个AbstractList的一个成员变量，主要的作用是，子类的迭代器用于判断fail-fast的参数。具体可以详见<a href="https://zhongyp.me/faq/2018-07-30-foreach/">为什么不能在foreach中执行remove/add操作？</a>，虽然这篇博客只讲了一个问题，但是可以管中窥豹。</p><p>size: size是ArrayList的元素数量，元素可以为null。</p><p>MAX_ARRAY_SIZE: 为什么ArrayList数组的最大大小为Integer.MAX-8，原因是Some VMs reserve some header words in an array.Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><a href="https://zhongyp.me/faq/2018-07-30-foreach/">为什么不能在foreach中执行remove/add操作？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式原理及应用场景</title>
      <link href="/java/2018-01-10-pattern/"/>
      <url>/java/2018-01-10-pattern/</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p></blockquote><p><a href="https://github.com/zhongyp/Demo/tree/master/src/main/java/com/zhongyp/advanced/pattern" target="_blank" rel="noopener">设计模式相关源码</a></p><h2 id="1-深入浅出设计模式原则："><a href="#1-深入浅出设计模式原则：" class="headerlink" title="1. 深入浅出设计模式原则："></a>1. 深入浅出设计模式原则：</h2><p>目标就是：高内聚，低耦合。<br><strong><em>在设计模式中，所谓的“实现一个接口”，并不一定标识写一个类，实现一个interface。实现一个接口泛指实现某个超类型（可以是类或接口）</em></strong></p><h3 id="1-1-单一职责原则（SRP，Single-Responsibility-Principle）"><a href="#1-1-单一职责原则（SRP，Single-Responsibility-Principle）" class="headerlink" title="1.1 单一职责原则（SRP，Single Responsibility Principle）"></a>1.1 单一职责原则（SRP，Single Responsibility Principle）</h3><p>系统中的每一个对象都应该只有一个单独的原则。</p><h3 id="1-2-开闭原则（OCP，Open-For-Extension-Close-For-Modification-Principle）"><a href="#1-2-开闭原则（OCP，Open-For-Extension-Close-For-Modification-Principle）" class="headerlink" title="1.2 开闭原则（OCP，Open For Extension, Close For Modification Principle）"></a>1.2 开闭原则（OCP，Open For Extension, Close For Modification Principle）</h3><p>类应该对扩展开放，对修改关闭。对类的改动通过增加代码来进行，而不是修改现有的代码。</p><h3 id="1-3-依赖注入原则（DIP，Dependence-Inversion-Principle）"><a href="#1-3-依赖注入原则（DIP，Dependence-Inversion-Principle）" class="headerlink" title="1.3 依赖注入原则（DIP，Dependence Inversion Principle）"></a>1.3 依赖注入原则（DIP，Dependence Inversion Principle）</h3><p>针对接口编程，不针对实现编程，程序利用多态针对超类型（supertype）编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上。依赖抽象，不要依赖具体类。</p><h3 id="1-4-里式代换原则（LSP，Liskov-Substitution-Principle）"><a href="#1-4-里式代换原则（LSP，Liskov-Substitution-Principle）" class="headerlink" title="1.4 里式代换原则（LSP，Liskov Substitution Principle）"></a>1.4 里式代换原则（LSP，Liskov Substitution Principle）</h3><p>任何基类可以出现的地方，子类一定可以出现。反之则不行。</p><h3 id="1-5-迪米特法则（LoD，Law-of-Demeter）"><a href="#1-5-迪米特法则（LoD，Law-of-Demeter）" class="headerlink" title="1.5 迪米特法则（LoD，Law of Demeter）"></a>1.5 迪米特法则（LoD，Law of Demeter）</h3><p>最少知道原则：只和朋友交谈。 就是只调用接口方法，没必要去了解接口内部的实现。</p><h3 id="1-6-接口隔离原则（ISP，Interface-Segregation-Principle）"><a href="#1-6-接口隔离原则（ISP，Interface-Segregation-Principle）" class="headerlink" title="1.6 接口隔离原则（ISP，Interface Segregation Principle）"></a>1.6 接口隔离原则（ISP，Interface Segregation Principle）</h3><p>为交互对象之间的松耦合设计而努力。接口尽量小，但是要有限度。</p><h3 id="1-7-多用组合，少用继承（CARP，Composite-Aggregate-Reuse-Principle）"><a href="#1-7-多用组合，少用继承（CARP，Composite-Aggregate-Reuse-Principle）" class="headerlink" title="1.7 多用组合，少用继承（CARP，Composite/Aggregate Reuse Principle）"></a>1.7 多用组合，少用继承（CARP，Composite/Aggregate Reuse Principle）</h3><p>组合使系统具有弹性，不仅可以将算法封装成类，还可以在运行时动态的改变行为。继承时，如果父类修改，则子类都要进行修改。所以在最初设计时，应尽量降低这种依赖关系。</p><h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h2><h3 id="2-1-创建型模式"><a href="#2-1-创建型模式" class="headerlink" title="2.1 创建型模式"></a>2.1 创建型模式</h3><h4 id="2-1-1-单例模式（Singleton）"><a href="#2-1-1-单例模式（Singleton）" class="headerlink" title="2.1.1 单例模式（Singleton）"></a>2.1.1 单例模式（Singleton）</h4><p>单例模式就是：确保一个类只有一个实例，并提供全局访问点。</p><p>单例模式的实现有多种方式，如下：</p><ul><li><ol><li>懒汉式，线程不安全</li></ol></li></ul><p>是否 Lazy 初始化：是</p><p>是否多线程安全：否</p><p>实现难度：易</p><p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p><p>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</p><ul><li><ol start="2"><li>懒汉式，线程安全</li></ol></li></ul><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p><p>优点：第一次调用才初始化，避免内存浪费。</p><p>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</p><p>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>饿汉式</li></ol></li></ul><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式比较常用，但容易产生垃圾对象。</p><p>优点：没有加锁，执行效率会提高。</p><p>缺点：类加载时就初始化，浪费内存。</p><p>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li>双检锁/双重校验锁（DCL，即 double-checked locking）</li></ol></li></ul><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：较复杂</p><p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><p>getInstance() 的性能对应用程序很关键。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getSingleton() &#123;  </span><br><span class="line">        if (singleton == null) &#123;  </span><br><span class="line">            synchronized (Singleton.class) &#123;  </span><br><span class="line">                if (singleton == null) &#123;  </span><br><span class="line">                    singleton = new Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>登记式/静态内部类</li></ol></li></ul><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：一般</p><p>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p><p>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">        return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="6"><li>枚举</li></ol></li></ul><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</p><p>不能通过 reflection attack 来调用私有构造方法。</p><p>代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumTest &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    private Test test;</span><br><span class="line"></span><br><span class="line">    private EnumTest()&#123;</span><br><span class="line">        test = new Test();</span><br><span class="line">    &#125;</span><br><span class="line">    public Test getInstance()&#123;</span><br><span class="line">        return test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>了解<a href="/java/2019-05-01-java-enum/">枚举</a></p></blockquote><p>经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p><h4 id="2-1-2-工厂模式（Factory）"><a href="#2-1-2-工厂模式（Factory）" class="headerlink" title="2.1.2 工厂模式（Factory）"></a>2.1.2 工厂模式（Factory）</h4><p>在技术上，new一个对象总是没错的，但是如果你new的这个对象时不确定的，可变的，那就需要我们将变化的部分从不变的部分抽离出来。<br>工厂处理创建对象的细节。所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。<br>关于工厂模式，我觉得最好还是看下《Head First设计模式》这本书比较好，其他人讲的真不咋的。</p><h5 id="2-1-2-1-简单工厂方法模式（Factory-Method）"><a href="#2-1-2-1-简单工厂方法模式（Factory-Method）" class="headerlink" title="2.1.2.1 简单工厂方法模式（Factory Method）"></a>2.1.2.1 简单工厂方法模式（Factory Method）</h5><p>简单工厂其实不是一个设计模式，而是比较像是一种编程习惯。屏蔽创建对象的细节。<br><img src="/media/article/simple-factory.png" alt=""></p><h5 id="2-1-2-2-工厂方法模式（Factory-Method）"><a href="#2-1-2-2-工厂方法模式（Factory-Method）" class="headerlink" title="2.1.2.2 工厂方法模式（Factory Method）"></a>2.1.2.2 工厂方法模式（Factory Method）</h5><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。<br><img src="/media/article/factory-method.png" alt=""></p><h5 id="2-1-2-3-抽象工厂模式（Abstract-Factory）"><a href="#2-1-2-3-抽象工厂模式（Abstract-Factory）" class="headerlink" title="2.1.2.3 抽象工厂模式（Abstract Factory）"></a>2.1.2.3 抽象工厂模式（Abstract Factory）</h5><p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。对象创建被实现在工厂接口所暴露出来的方法中。<br><img src="/media/article/abstract-factory.png" alt=""></p><h4 id="2-1-3-原型模式（Prototype）"><a href="#2-1-3-原型模式（Prototype）" class="headerlink" title="2.1.3 原型模式（Prototype）"></a>2.1.3 原型模式（Prototype）</h4><p>原型模式是创建模式的一种，顾名思义，就是创建一个和原来对象一模一样的新对象。<br>当创建给定类的实例的过程很昂贵或很复杂是，就是用原型模式。<br>Clone接口。<br>优点：</p><ul><li>向客户隐藏制造新实例的复杂性。</li><li>提供让客户能够产生位置类型对象的选项。</li><li>在某些环境下，复制对象比创建新对象更有效。</li></ul><p>缺点：</p><ul><li>在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型。</li><li>对象有时复制相当复杂。</li></ul><h4 id="2-1-4-创建者模式（Builder）"><a href="#2-1-4-创建者模式（Builder）" class="headerlink" title="2.1.4 创建者模式（Builder）"></a>2.1.4 创建者模式（Builder）</h4><p>创建者(生成器)模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，而且客户端不知道对象的构建细节。<br>优点：</p><ul><li>将一个复杂对象的创建过程封装起来。</li><li>允许对象通过多个步骤来创建，并且可以改变过程。</li><li>向客户隐藏产品内部的表现。</li><li>产品的实现可以被替换，因为客户只看到一个抽象接口。</li></ul><p>缺点：</p><ul><li>经常被用来创建组合结构。</li><li>与工厂模式相比，采用生成器模式创建对象的客户，需要具备更多的领域知识。</li></ul><h3 id="2-2-结构型模式"><a href="#2-2-结构型模式" class="headerlink" title="2.2 结构型模式"></a>2.2 结构型模式</h3><h4 id="2-2-1-适配器模式（Adapter）"><a href="#2-2-1-适配器模式（Adapter）" class="headerlink" title="2.2.1 适配器模式（Adapter）"></a>2.2.1 适配器模式（Adapter）</h4><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。</p><h4 id="2-2-2-门面（外观）模式-Facade"><a href="#2-2-2-门面（外观）模式-Facade" class="headerlink" title="2.2.2 门面（外观）模式 (Facade)"></a>2.2.2 门面（外观）模式 (Facade)</h4><p>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p><p>优点</p><ul><li><p>松散耦合</p></li><li><p>使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；</p></li><li><p>简单易用</p></li><li><p>客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟Facade类交互即可。</p></li><li><p>更好的划分访问层次</p></li><li><p>有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。</p></li><li><h4 id="2-2-3-代理模式-Proxy"><a href="#2-2-3-代理模式-Proxy" class="headerlink" title="2.2.3 代理模式 (Proxy)"></a>2.2.3 代理模式 (Proxy)</h4></li></ul><p>为另一个对象提供一个替身或者占位符以控制对这个对象的访问。</p><p>优点：</p><ul><li>只有真正去调用的时候才会创建实例。有些情况下，程序不会真正的调用被调用对象的某个方法时，这种情况无需去创建被调用这对象的实例。在这种情况下，代理模式可以调程序的性能。宏观上减少了系统开销。</li></ul><p>应用：hibernate延时加载</p><h4 id="2-2-4-合成-组合-模式-Composite"><a href="#2-2-4-合成-组合-模式-Composite" class="headerlink" title="2.2.4 合成(组合)模式 (Composite)"></a>2.2.4 合成(组合)模式 (Composite)</h4><p>允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象及对象组合。</p><p>应用实例： </p><ul><li><p>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 </p></li><li><p>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p></li></ul><p>优点：</p><ul><li><p>高层模块调用简单。</p></li><li><p>节点自由增加。</p></li></ul><p>缺点：</p><ul><li>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</li></ul><p>使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。</p><p>注意事项：定义时为具体类。</p><h4 id="2-2-5-享元（蝇量）模式-FlyWeight"><a href="#2-2-5-享元（蝇量）模式-FlyWeight" class="headerlink" title="2.2.5 享元（蝇量）模式 (FlyWeight)"></a>2.2.5 享元（蝇量）模式 (FlyWeight)</h4><p>优点：</p><ul><li>减少运行时对象实例的个数，节省内存。</li><li>将许多“虚拟”对象的状态集中管理。</li></ul><p>缺点：</p><ul><li>当一个类有许多的实例，而这些实例能被同一方法控制的时候，我们就可以使用蝇量模式。</li><li>蝇量模式的缺点在于，一旦你实现了它，那么单个的逻辑实例将无法拥有独立而不同的行为。</li></ul><h4 id="2-2-6-装饰模式-Decorator"><a href="#2-2-6-装饰模式-Decorator" class="headerlink" title="2.2.6 装饰模式 (Decorator)"></a>2.2.6 装饰模式 (Decorator)</h4><p>动态的将责任附加到对象上，若要扩展功能，装饰者提供了比集成更具有弹性的替代方案。</p><p><img src="/media/article/decorator.png" alt=""></p><h4 id="2-2-7-桥接模式-Bridge"><a href="#2-2-7-桥接模式-Bridge" class="headerlink" title="2.2.7 桥接模式 (Bridge)"></a>2.2.7 桥接模式 (Bridge)</h4><p>抽象变化，封装各自变化。</p><p><a href="http://www.jasongj.com/design_pattern/bridge/" target="_blank" rel="noopener">Java设计模式（九） 桥接模式</a><br>优点：</p><ul><li>将实现予以解耦，让它和界面之间不再永久绑定。</li><li>抽象和实现可以独立扩展。</li><li>对于具体的抽象类所做的改变，不会影响到客户。</li></ul><p>缺点：</p><ul><li>适合使用在需要跨越多个平台的图形和窗口系统上。</li><li>当需要用不同的方式改变接口和实现时，你会发现桥接模式很好用。</li></ul><h3 id="2-3-行为模式"><a href="#2-3-行为模式" class="headerlink" title="2.3 行为模式"></a>2.3 行为模式</h3><h4 id="2-3-1-策略模式（Stategy）"><a href="#2-3-1-策略模式（Stategy）" class="headerlink" title="2.3.1 策略模式（Stategy）"></a>2.3.1 策略模式（Stategy）</h4><p>定义了算法簇，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。体现封装变化、多用组合少用继承、针对接口编程，不针对实现编程。 </p><h4 id="2-3-2-迭代器模式（Iterator）"><a href="#2-3-2-迭代器模式（Iterator）" class="headerlink" title="2.3.2 迭代器模式（Iterator）"></a>2.3.2 迭代器模式（Iterator）</h4><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><p>应用实例：JAVA 中的 iterator。</p><p>优点：</p><ul><li><p>它支持以不同的方式遍历一个聚合对象。</p></li><li><p>迭代器简化了聚合类。 </p></li><li><p>在同一个聚合上可以有多个遍历。 </p></li><li><p>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p></li></ul><p>缺点：</p><ul><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li></ul><p>使用场景： </p><ul><li><p>访问一个聚合对象的内容而无须暴露它的内部表示。 </p></li><li><p>需要为聚合对象提供多种遍历方式。 </p></li><li><p>为遍历不同的聚合结构提供一个统一的接口。</p></li></ul><p>注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h4 id="2-3-3-模板方法模式（Template-Method）"><a href="#2-3-3-模板方法模式（Template-Method）" class="headerlink" title="2.3.3 模板方法模式（Template Method）"></a>2.3.3 模板方法模式（Template Method）</h4><p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使用子类可以在不改变算法结构的情况下，重新定义算法中的步骤。</p><p>优点</p><ul><li><p>封装不变部分，扩展可变部分。把认为不变部分的算法封装到父类中实现，而可变部分的则可以通过继承来继续扩展。</p></li><li><p>提取公共部分代码，便于维护。</p></li><li><p>行为由父类控制，子类实现。</p></li></ul><p>缺点</p><ul><li>按照设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类负责完成具体的事务属性和方法，但是模板方式正好相反，子类执行的结果影响了父类的结果，会增加代码阅读的难度。</li></ul><p>模板方法模式是通过父类建立框架，子类在重写了父类部分方法之后，在调用从父类继承的方法，产生不同的效果，通过修改子类，影响父类行为的结果，模板方法在一些开源框架中应用非常多，它提供了一个抽象类，然后开源框架写了一堆子类，如果需要扩展功能，可以继承此抽象类，然后覆写protected基本方法，然后在调用一个类似TemplateMethod()的模板方法，完成扩展开发。</p><h4 id="2-3-4-中介者模式（Mediator）"><a href="#2-3-4-中介者模式（Mediator）" class="headerlink" title="2.3.4 中介者模式（Mediator）"></a>2.3.4 中介者模式（Mediator）</h4><p>使用中介者模式来集中相关对象之间复杂的沟通和控制方式。</p><p>优点：</p><ul><li>通过将对象彼此解耦，可以增加对象的复用。</li><li>通过将控制逻辑集中，可以简化系统的维护。</li><li>可以让对象之间所传递的消息变得简单而且大幅减少。</li></ul><p>缺点：</p><p>中介者常常被用来协调相关的GUI组件。<br>中介者模式的缺点是，如果设计不当，中介者对象本身会变得过于复杂。</p><h4 id="2-3-5-访问者模式（Visitor）"><a href="#2-3-5-访问者模式（Visitor）" class="headerlink" title="2.3.5 访问者模式（Visitor）"></a>2.3.5 访问者模式（Visitor）</h4><p>当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式。</p><p><img src="/media/article/visitor.png" alt=""></p><p>优点：</p><ul><li>允许你对组合结构加入新的操作，而无需改变结构本身。</li><li>想要加入新的操作，相对容易。</li><li>访问者所进行的操作，其代码是集中在一起的。</li></ul><p>缺点：</p><ul><li>当采用访问者模式的时候，就会打破组合类的封装。</li><li>因为游走的功能牵涉其中，所以对组合结构的改变就更加困难。</li></ul><h4 id="2-3-6-职责链模式（Chain-of-Responsibility）"><a href="#2-3-6-职责链模式（Chain-of-Responsibility）" class="headerlink" title="2.3.6 职责链模式（Chain of Responsibility）"></a>2.3.6 职责链模式（Chain of Responsibility）</h4><p>当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责任链。</p><p>优点：</p><ul><li>将请求的发送者和接收者解耦。</li><li>可以简化你的对象，因为它不需要知道链的结构。</li><li>通过改变链内的成员或调动它们的次序，允许你动态的新增或者删除责任。</li></ul><p>缺点：</p><ul><li>经常被使用的窗口系统中，处理鼠标和键盘之类的事件。</li><li>并不保证请求一定会被执行；如果没有任何对象处理它的话，他可能回落到链尾之外。</li><li>可能不容易观察运行时的特征，有碍于除错。</li></ul><h4 id="2-3-7-状态模式（State）"><a href="#2-3-7-状态模式（State）" class="headerlink" title="2.3.7 状态模式（State）"></a>2.3.7 状态模式（State）</h4><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p><p>State模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中, 所以通过定义新的子类可以很容易的增加新的状态和转换。另一个方法是使用数据值定义内部状态并且让 Context操作来显式地检查这些数据。但这样将会使整个Context的实现中遍布看起来很相似的条件if else语句或switch case语句。增加一个新的状态可能需要改变若干个操作, 这就使得维护变得复杂了。State模式避免了这个问题, 但可能会引入另一个问题, 因为该模式将不同状态的行为分布在多个State子类中。这就增加了子类的数目，相对于单个类的实现来说不够紧凑。但是如果有许多状态时这样的分布实际上更好一些, 否则需要使用巨大的条件语句。正如很长的过程一样，巨大的条件语句是不受欢迎的。它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。 State模式提供了一个更好的方法来组织与特定状态相关的代码。决定状态转移的逻辑不在单块的 i f或s w i t c h语句中, 而是分布在State子类之间。将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。</p><p>优点：</p><ul><li><p>它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p></li><li><p>它使得状态转换显式化: 当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且, State对象可保证Context不会发生内部状态不一致的情况，因为从 Context的角度看，状态转换是原子的—只需重新绑定一个变量(即Context的State对象变量)，而无需为多个变量赋值</p></li><li><p>State对象可被共享 如果State对象没有实例变量—即它们表示的状态完全以它们的类型来编码—那么各Context对象可以共享一个State对象。当状态以这种方式被共享时, 它们必然是没有内部状态, 只有行为的轻量级对象。</p></li></ul><p>缺点:</p><ul><li><p>状态模式的使用必然会增加系统类和对象的个数。</p></li><li><p>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</p></li></ul><h4 id="2-3-8-解释器模式（Interpreter）"><a href="#2-3-8-解释器模式（Interpreter）" class="headerlink" title="2.3.8 解释器模式（Interpreter）"></a>2.3.8 解释器模式（Interpreter）</h4><p>使用解释器模式为语言创建解释器。</p><p><img src="/media/article/interpreter.png" alt=""></p><p>优点：</p><ul><li>将每一个语法规则表示成一个类，方便与实现语言。</li><li>因为语法有许多类表示，所以你可以轻易地改变或扩展语言。</li><li>通过在类结构中加入新的方法，可以在解释的同时增加新的行为，例如打印格式的美化或者进行复杂的程序验证。</li></ul><p>用途和缺点：</p><ul><li>当你需要实现一个简单的语言时，使用解释器。</li><li>当你有一个简单的语法，而且简单比效率更重要时，使用解释器。</li><li>可以处理脚本语言和编程语言。</li><li>当语法规则的数目太大时，这个模式可能会变得非常复杂。</li></ul><h4 id="2-3-9-观察者模式（Observer）"><a href="#2-3-9-观察者模式（Observer）" class="headerlink" title="2.3.9 观察者模式（Observer）"></a>2.3.9 观察者模式（Observer）</h4><p>在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖他的对象都会收到通知并自动更新。体现封装变化、针对接口编程、多用组合，少用继承、交互对象之间的松耦合设计。 </p><h4 id="2-3-10-命令模式（Command）"><a href="#2-3-10-命令模式（Command）" class="headerlink" title="2.3.10 命令模式（Command）"></a>2.3.10 命令模式（Command）</h4><p>将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p><p><img src="/media/article/command" alt=""></p><p>优点</p><ul><li>类间解耦：调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command 抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。</li><li>可扩展性：Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严 重的代码耦合。</li><li>命令模式结合其他模式会更优秀：命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少 Command子类的膨胀问题。</li></ul><p>缺点</p><ul><li>命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来 了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项 目中慎重考虑使用。</li></ul><h4 id="2-3-11-备忘录模式（Memento）"><a href="#2-3-11-备忘录模式（Memento）" class="headerlink" title="2.3.11 备忘录模式（Memento）"></a>2.3.11 备忘录模式（Memento）</h4><p>备忘录有两个目标：</p><ul><li>存储系统关键对象的重要状态。</li><li>维护关键对象的封装。</li></ul><p>优点：</p><ul><li>将被存储的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚。</li><li>保持关键对象的数据封装。</li><li>提供了容易实现的恢复能力。</li></ul><p>缺点：</p><ul><li>备忘录用于存储状态。</li><li>使用备忘录的缺点：存储和回复状态的过程可能相当耗时。</li><li>在Java系统中，其实可以考虑使用序列化机制存储系统的状态。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/20370434/comments/" target="_blank" rel="noopener">深入浅出设计模式 郭峰著，中国铁道出版社</a><br><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">Head First 设计模式</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存模型</title>
      <link href="/concurrency/2018-03-04-java-memory-model/"/>
      <url>/concurrency/2018-03-04-java-memory-model/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型（Java Memory Model，简称：JMM），下文中如果没有特殊说明，JMM即代表“Java内存模型”。<br>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p><p>注： 这里说的变量包括了实例变量、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有，不会被共享，自然就不存在竞争问题。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-缓存一致性"><a href="#1-1-缓存一致性" class="headerlink" title="1.1 缓存一致性"></a>1.1 缓存一致性</h3><p>在并发编程模型中，需要处理两个关键的问题：<strong>线程之间以何种机制交换信息（通信）及如何控制不同线程之间操作发生相对顺序的机制（同步）</strong>。<br>线程之间的通信机制有两种：共享内存和消息传递，每种通信机制对应不同的内存模型。<br>共享内存模型：线程之间通过读-写内存中的公共状态进行隐式通信。<br>消息传递模型：线程之间没有公共状态，线程之间必须通过发送消息来显示的进行通信。<br><strong><em>Java并发采用的是共享内存模型</em></strong>。<br>在共享的内存模型，多处理器体系架构中，每个<a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2" target="_blank" rel="noopener">处理器</a>都有自己的缓存，并且周期性的与主内存协调一致。处理器架构提供了不同级别的缓存一致性（cache coherence），有些仅提供最小的保证，几乎在任何时间内，都允许不同的处理器在相同位置上看到不同的值。<br>举个简单的例子：在java中，执行下面这个语句：</p><p><code>i  = 10++;</code></p><p>1) 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p><p>2) 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p><p>3) 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</p><p>4) 最终结果i的值是11，而不是12。这就是缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p><p><strong>注：</strong><br>同步：<strong>指程序中用于控制不同线程间操作发生相对顺序的机制</strong>，意味着某种形式的原子性或者互斥。<br>共享内存的并发模型中，同步是显式，程序员必须显示的指定某个方法或某段代码需要在线程之间互斥执行。消息传递的并发模型中，消息的发送必须在消息的接收之前，因此同步是隐式的。</p><p>想要保证每个处理器能在任意时间内获知其他处理器正在处理的工作，代价很高而且很多时候这些信息都是不必要的，所以就牺牲掉存储的一致性来保证性能。为了共享数据时能得到存储协调的保证，Java提供了自己的JMM解决与底层平台存储模型的差异化。</p><h3 id="1-2-重排序"><a href="#1-2-重排序" class="headerlink" title="1.2 重排序"></a>1.2 重排序</h3><p>除了上述的缓存一致性问题外，在执行程序时，为了提高程序的性能，使得处理器内部的运算单元被充分利用，编译器和处理器常常会对指令做重排序。<br>从Java源代码到最终执行的指令序列，会分别经历下面的三种重排序：<br><img src="/media/article/java-resort.png" alt="resort"><br>图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><ol><li>编译器重排序。编译器不改变单线程语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级重排序。现代处理器采用指令级并行技术将多条指令重叠执行。<strong><em>如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</em></strong></li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>编译器和处理器重排序时会遵守数据依赖性，编译器、运行时和处理器都必须遵守as-if-serial语义。<br><strong>注：</strong><br>数据依赖性：编译器和处理器不会改变存在数据以来关系的两个操作的执行顺序。<strong>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</strong><br>as-if-serial：内部线程类似顺序化语义。不管如何的重排序，单线程程序的执行结果不能被改变。</p><h4 id="1-2-1-重排序的影响"><a href="#1-2-1-重排序的影响" class="headerlink" title="1.2.1 重排序的影响"></a>1.2.1 重排序的影响</h4><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public void writer()&#123;</span><br><span class="line">        a = 1; // 1</span><br><span class="line">        flag = true; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    public void reader()&#123;</span><br><span class="line">        if (flag)&#123; // 3</span><br><span class="line">            int i = a * a; // 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设线程A先执行writrer方法，随后线程B执行reader方法，线程执行操作4时，不一定能看到1处的赋值。原因如下图：<br><img src="/media/article/resort.png" alt="resort"><br>图片来自<a href="#2-4-happens-before">Java并发编程艺术</a><br>由于操作1和2没有依赖关系，所以编译器和处理器可以对这两个操作重排序，线程A首先标记了flag，随后线程B读取flag。由于flag=true，线程B可以读取a，但是此时的a并为被线程A赋值。所以这里的多线程程序的语义被破坏了。JMM提供同步机制来抑制编译器、运行时和硬件对存储操作的各种方式的重排序，保证内存的可见性。                                              </p><h2 id="2-JMM设计"><a href="#2-JMM设计" class="headerlink" title="2. JMM设计"></a>2. JMM设计</h2><p><img src="/media/article/jmm-abs.png" alt="JMM的抽象结构"><br>JMM在内存中的抽象结构，图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><p>JMM属于语言级别的内存模型，确保在不同的编译和不同处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，决定一个线程对共享变量的写入何时对另一个线程可见，提供内存可见性保证。<br>从JDK5开始，Java使用JSR-133内存模型。JSR-133使用<strong>happens-before概念保证内存的可见性</strong>。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ol><li><p><strong><em>程序次序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</em></strong></p></li><li><p><strong><em>监视器锁规则：一个unLock操作先行发生于后面对同一个锁的lock操作。</em></strong></p></li><li><p><strong><em>volatile变量规则：对一个volatile变量的写操作，happens-before于后续对这个volatile变量的读操作。</em></strong></p></li><li><p><strong><em>传递性：如果操作A happens-before操作B，而操作B happens-before操作C，则可以得出操作A happens-before操作C。</em></strong></p></li><li><p>start()规则：Thread对象的start()方法happens-before此线程的每个一个动作</p></li><li><p>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p></li></ol><p><img src="/media/article/happens-before-design.png" alt="happens-before-design"><br>JMM设计图，图片来自<a href="#2-4-happens-before">Java并发编程艺术</a></p><h2 id="3-JMM的可见性保证"><a href="#3-JMM的可见性保证" class="headerlink" title="3. JMM的可见性保证"></a>3. JMM的可见性保证</h2><ul><li>单线程程序。<strong><em>单线程程序不会出现内存可见性问题。</em></strong>编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li>正确<strong><em>同步</em></strong>的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。JMM通过根据happens-before原则限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li><li>未同步/未正确同步的多线程程序。JMM为他们提供最小的安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么时默认值（0、null、false）。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.importnew.com/24082.html" target="_blank" rel="noopener">你真的了解volatile关键字吗？</a></p><p><a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">Java中Volatile关键字详解</a></p><p><a href="">Java并发编程艺术</a></p><p><a href="">深入理解Java虚拟机-JVM高级特性与最佳实践</a></p><p><a href="">Java并发编程实践</a></p><p><a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2" target="_blank" rel="noopener">每个程序员都应该了解的 CPU 高速缓存</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库事务</title>
      <link href="/transaction/2018-02-28-Transaction/"/>
      <url>/transaction/2018-02-28-Transaction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。</p></blockquote><h2 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h2><p>事务是程序中一系列严密的操作，所有操作执行必须成功完成，否则在每个操作所做的更改将会被撤销，这也是事务的原子性（要么成功，要么失败）。</p><h2 id="事务特性："><a href="#事务特性：" class="headerlink" title="事务特性："></a>事务特性：</h2><p>事务特性分为四个：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）简称ACID。</p><ul><li><p>原子性（Atomicity）:事务是数据库逻辑工作单元，事务中包含的操作要么都执行成功，要么都执行失败。</p></li><li><p>一致性（Consistency）：事务执行的结果必须是使数据库数据从一个一致性状态变到另外一种一致性状态。当事务执行成功后就说数据库处于一致性状态。如果在执行过程中发生错误，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这是数据库就处于不一致状态。</p></li><li><p>隔离性（Isolation）：一个事务的执行过程中不能影响到其他事务的执行，即一个事务内部的操作及使用的数据对其他事务是隔离的，并发执行各个事务之间无不干扰。</p></li><li><p>持续性（Durability）：即一个事务执一旦提交，它对数据库数据的改变是永久性的。之后的其它操作不应该对其执行结果有任何影响。</p></li></ul><h2 id="事务的隔离级别："><a href="#事务的隔离级别：" class="headerlink" title="事务的隔离级别："></a>事务的隔离级别：</h2><p>事务的隔离级别也分为四种，由低到高依次分别为：read uncommited（未提交读）、read commited（提交读）、read repeatable（重复读）、serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><ul><li><p>read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。</p></li><li><p>read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</p></li><li><p>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。</p></li><li><p>serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。</p></li></ul><p>脏读、不可重复读、幻象读概念说明：</p><ul><li>脏读：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。</li></ul><ul><li>不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。</li></ul><ul><li>幻象读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/zhangqian1031/p/6542037.html" target="_blank" rel="noopener">PittBlogger-什么是事务、事务特性、事务隔离级别、spring事务传播特性-博客园</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
